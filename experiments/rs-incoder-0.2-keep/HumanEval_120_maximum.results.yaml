name: HumanEval_120_maximum
language: rust
results:
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![]; k];\n    for i in 0..k {\n        max_arr[i] = vec![];\n\
    \    }\n    for i in 0..arr.len() {\n        let mut max_i = i;\n        for j\
    \ in 0..k {\n            if arr[i] > max_arr[j][max_i] {\n                max_i\
    \ = j;\n            }\n        }\n        max_arr[k - 1 - i].push(arr[i]);\n \
    \   }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw1gyxsma.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpw1gyxsma.rs:19:9\n   |\n19 |         max_arr[i]\
    \ = vec![];\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[Vec<_>]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmpw1gyxsma.rs:24:25\n   |\n24 |             if arr[i] >\
    \ max_arr[j][max_i] {\n   |                         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw1gyxsma.rs:25:25\n\
    \   |\n22 |         let mut max_i = i;\n   |                         - expected\
    \ due to this value\n...\n25 |                 max_i = j;\n   |              \
    \           ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw1gyxsma.rs:28:25\n   |\n28 |         max_arr[k - 1 - i].push(arr[i]);\n\
    \   |                         ^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot subtract `usize` from `isize`\n  --> /tmp/tmpw1gyxsma.rs:28:23\n   |\n\
    28 |         max_arr[k - 1 - i].push(arr[i]);\n   |                       ^ no\
    \ implementation for `isize - usize`\n   |\n   = help: the trait `Sub<usize>`\
    \ is not implement"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[i]\
    \ > max_arr[j] {\n                max_arr[i] = max_arr[j];\n            }\n  \
    \      }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpljprqt83.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpljprqt83.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpljprqt83.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpljprqt83.rs:23:16\n   |\n23 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpljprqt83.rs:23:29\n   |\n23 |             if max_arr[i] > max_arr[j]\
    \ {\n   |                             ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut max_value = arr[0];\n    let mut max_index\
    \ = arr.iter().position(|&x| x > max_value);\n    while max_index != k {\n   \
    \     result.push(max_value);\n        max_value = arr[max_index];\n        max_index\
    \ = arr.iter().position(|&x| x > max_value);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpot9emqoh.rs:20:24\n   |\n\
    20 |     while max_index != k {\n   |                        ^ expected enum `Option`,\
    \ found `isize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by\
    \ `Option<usize>`\n  --> /tmp/tmpot9emqoh.rs:22:21\n   |\n22 |         max_value\
    \ = arr[max_index];\n   |                     ^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `Option<usize>`\n   = note: required because of the requirements\
    \ on the impl of `Index<Option<usize>>` for `Vec<isize>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![0; k];\n    let mut max_element = arr[0];\n    for i in 1..k\
    \ {\n        if arr[i] > max_element {\n            max_element = arr[i];\n  \
    \      }\n    }\n    for i in 0..k {\n        result[i] = max_element;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvz_h1ozp.rs:17:30\n   |\n\
    17 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpvz_h1ozp.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_element {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpvz_h1ozp.rs:21:27\n   |\n21 |            \
    \ max_element = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpvz_h1ozp.rs:25:9\n   |\n25 |         result[i]\
    \ = max_element;\n   |         ^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0; k]; arr.len()];\n    for i in 0..arr.len() {\n  \
    \      let mut max_i = i;\n        for j in 0..k {\n            if arr[i] > max_arr[j][max_i]\
    \ {\n                max_i = j;\n            }\n        }\n        max_arr[i][max_i]\
    \ = arr[i];\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps127k1w4.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k]; arr.len()];\n   |                \
    \                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k.try_into().unwrap()]; arr.len()];\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmps127k1w4.rs:21:25\n\
    \   |\n21 |             if arr[i] > max_arr[j][max_i] {\n   |                \
    \         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps127k1w4.rs:22:25\n\
    \   |\n19 |         let mut max_i = i;\n   |                         - expected\
    \ due to this value\n...\n22 |                 max_i = j;\n   |              \
    \           ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps127k1w4.rs:27:5\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n27 |     max_arr\n   |     ^^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Vec<isize>>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[j]\
    \ < max_arr[i] {\n                max_arr[i] = max_arr[j];\n            }\n  \
    \      }\n    }\n    for i in 0..k {\n        arr[i] = max_arr[i];\n    }\n  \
    \  arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkg_k6jvc.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpkg_k6jvc.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpkg_k6jvc.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpkg_k6jvc.rs:23:16\n   |\n23 |  \
    \           if max_arr[j] < max_arr[i] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpkg_k6jvc.rs:23:29\n   |\n23 |             if max_arr[j] < max_arr[i]\
    \ {\n   |                             ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let mut j = i;\n        while j <\
    \ arr.len() {\n            if arr[j] > max_arr[j][0] {\n                max_arr[j]\
    \ = [arr[j], max_arr[j][0]];\n                max_k = max_k - 1;\n           \
    \ }\n            j += 1\n        }\n        i += 1;\n    }\n    max_arr.sort_by_key(|&x|\
    \ x.0);\n    max_arr.take(max_k).collect()\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkh8k5jg8.rs:24:30\n   |\n\
    24 |                 max_arr[j] = [arr[j], max_arr[j][0]];\n   |             \
    \    ----------   ^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_vec()`\n   |                 |            |\n   |                 |   \
    \         expected struct `Vec`, found array `[isize; 2]`\n   |              \
    \   expected due to the type of this binding\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n               found array `[isize; 2]`\n\nerror[E0609]: no field\
    \ `0` on type `Vec<isize>`\n  --> /tmp/tmpkh8k5jg8.rs:31:32\n   |\n31 |     max_arr.sort_by_key(|&x|\
    \ x.0);\n   |                                ^ unknown field\n\nerror[E0599]:\
    \ `Vec<Vec<isize>>` is not an iterator\n   --> /tmp/tmpkh8k5jg8.rs:32:13\n   \
    \ |\n32  |       max_arr.take(max_k).collect()\n    |               ^^^^ `Vec<Vec<isize>>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<Vec<isize>>: Iterator`\n            which is required by `&mut\
    \ Vec<Vec<isize>>: Iterator`\n            `[Vec<isize>]: Iterator`\n         \
    \   which is required by `&mut [Vec<isize>]: Iterator`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0609.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![arr[i], -1000, 1000];\n    }\n    for i in 0..k {\n        max_arr[i].sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect();\n \
    \   }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpefj3atmj.rs:19:9\n   |\n19 |         max_arr[i] = vec![arr[i],\
    \ -1000, 1000];\n   |         ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpefj3atmj.rs:19:27\n   |\n19 |  \
    \       max_arr[i] = vec![arr[i], -1000, 1000];\n   |                        \
    \   ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   =\
    \ help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpefj3atmj.rs:22:9\n   |\n22 |         max_arr[i].sort_unstable();\n \
    \  |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpefj3atmj.rs:25:9\n   |\n25 |         max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpefj3atmj.rs:24:5\n\
    \   |\n16 |   fn maxim"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_k = k;\n    let mut max_i = arr.len();\n\
    \    while max_i < max_k {\n        let mut max_value = arr[0];\n        for i\
    \ in 1..arr.len() {\n            if arr[i] > max_value {\n                max_value\
    \ = arr[i];\n            }\n        }\n        max_arr.push(max_value);\n    \
    \    max_i -= 1;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7v93ybcl.rs:20:19\n   |\n\
    20 |     while max_i < max_k {\n   |                   ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n    }\n    for i in 0..k {\n        max_arr[i].push(arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr[i].sort();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i].iter().take(k).cloned().collect()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpok_dpmff.rs:19:9\n   |\n19 |         max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpok_dpmff.rs:19:22\n   |\n19 |         max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n   |                      ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpok_dpmff.rs:22:9\n   |\n22 |         max_arr[i].push(arr[i]);\n   |\
    \         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpok_dpmff.rs:22:25\n   |\n22 |         max_arr[i].push(arr[i]);\n\
    \   |                         ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed\
    \ by `isize`\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_idx = vec![];\n    for i in 0..k {\n\
    \        max_arr[i] = arr[i];\n        max_idx[i] = i;\n    }\n    for i in 0..k\
    \ {\n        for j in 0..k {\n            if max_arr[j] > max_arr[i] {\n     \
    \           max_arr[i] = max_arr[j];\n                max_idx[i] = max_idx[j];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        arr[i] = max_arr[i];\n\
    \    }\n    return arr;\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpy_ynydbs.rs:20:9\n\
    \   |\n20 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpy_ynydbs.rs:20:22\n   |\n20 |         max_arr[i] =\
    \ arr[i];\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpy_ynydbs.rs:21:9\n   |\n21 |         max_idx[i] =\
    \ i;\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpy_ynydbs.rs:25:16\n\
    \   |\n25 |             if max_arr[j] > max_arr[i] {\n   |                ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpy_ynydbs.rs:25:29\n\
    \   |\n25 |             if max_arr[j] > max_arr[i] {\n   |                   \
    \          ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = h"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].max();\n    }\n \
    \   for i in 0..k {\n        arr[i] = max_arr[i];\n    }\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwam68xl4.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpwam68xl4.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpwam68xl4.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpwam68xl4.rs:22:9\n   |\n22 |   \
    \      max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpwam68xl4.rs:22:22\n   |\n22 |  \
    \       max_arr[i] = max_arr[i].max();\n   |                      ^^^^^^^^^^ slice\
    \ indic"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![0; k];\n    let mut max_idx = k;\n    for &i in arr {\n \
    \       if i >= 0 {\n            if max_idx < i {\n                max_idx = i;\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        max_arr[i] = max_idx;\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9ctdbjv9.rs:17:31\n   |\n\
    17 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9ctdbjv9.rs:19:9\n   |\n19 | \
    \    for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp9ctdbjv9.rs:27:9\n   |\n27 |   \
    \      max_arr[i] = max_idx;\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![0; k];\n    let mut max_element = arr[0];\n    let mut max_index\
    \ = 0;\n    for i in 0..arr.len() {\n        if arr[i] > max_element {\n     \
    \       max_element = arr[i];\n            max_index = i;\n        }\n    }\n\
    \    for i in 0..k {\n        result[i] = max_element;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphb7up87v.rs:17:30\n   |\n\
    17 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmphb7up87v.rs:27:9\n\
    \   |\n27 |         result[i] = max_element;\n   |         ^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_k = k;\n    let mut i = 0;\n    while\
    \ i < arr.len() {\n        if arr[i] > max_arr[k] {\n            max_arr[k] =\
    \ arr[i];\n            max_k--;\n        }\n        i += 1;\n    }\n    max_arr.truncate(max_k);\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp9gtehf89.rs:23:20\n\
    \   |\n23 |             max_k--;\n   |                    ^ expected expression\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp9gtehf89.rs:21:21\n\
    \   |\n21 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp9gtehf89.rs:22:13\n\
    \   |\n22 |             max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9gtehf89.rs:27:22\n   |\n27 |     max_arr.truncate(max_k);\n  \
    \ |                      ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n27 |     max_arr.truncate(max_k.try_into().unwrap());\n   |     \
    \                      ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_num = arr[0];\n    for i in 1..k {\n\
    \        if max_num < arr[i] {\n            max_num = arr[i];\n        }\n   \
    \ }\n    max_arr.push(max_num);\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpv14t3c9a.rs:20:22\n\
    \   |\n20 |         if max_num < arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpv14t3c9a.rs:21:23\n   |\n21 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpv14t3c9a.rs:26:12\n   |\n26 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpv14t3c9a.rs:27:26\n   |\n27 |             max_arr.push(arr[i]);\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![arr[i]];\n    }\n    for i in 0..k {\n        for j in 0..k {\n     \
    \       if max_arr[i][j] > max_arr[i][j+1] {\n                max_arr[i][j] =\
    \ max_arr[i][j+1];\n            }\n        }\n    }\n    for i in 0..k {\n   \
    \     for j in 0..k {\n            if max_arr[i][j] > max_arr[i+1][j] {\n    \
    \            max_arr[i+1][j] = max_arr[i][j];\n            }\n        }\n    }\n\
    \    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j] >\
    \ max_arr[i][j-1] {\n                max_arr[i][j] = max_arr[i][j-1];\n      \
    \      }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n   \
    \         if max_arr[i][j] > max_arr[i-1][j] {\n                max_arr[i-1][j]\
    \ = max_arr[i][j];\n            }\n        }\n    }\n    for i in 0..k {\n   \
    \     for j in 0..k {\n            if max_arr[i][j] > max_arr[i+1][j+1] {\n  \
    \              max_arr[i+1][j+1] = max_arr[i][j];\n            }\n        }\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > max_arr[i-1][j-1] {\n                max_arr[i-1][j-1] = max_arr[i][j];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > max_arr[i-1][j+1] {\n                max_arr[i-1][j+1]\
    \ = max_arr[i][j];\n            }\n        }\n    }\n    for i in 0..k {\n   \
    \     for j in 0..k {\n            if max_arr[i][j] > max_arr[i+1][j-1] {\n  \
    \              max_arr[i+1][j-1] = max_arr[i][j];\n            }\n        }\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > max_arr[i+1][j+1] {\n                max_arr[i+1][j+1] = max_arr[i][j];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > max_arr[i+1][j-1] {\n                max_arr[i+1][j-1]\
    \ = max_arr[i][j];\n            }\n        }\n    }\n    for i in 0..k {\n   \
    \     for j in 0..k {\n            if max_arr[i][j] > max_arr[i-1][j-1] {\n  \
    \              max_arr[i-1][j-1] = max_arr[i][j];\n            }\n        }\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > max_arr[i-1][j+1] {\n                max_arr[i-1]\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmphwfz0kbv.rs:117:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    98  |     for i in 0..k {\n    |                   - unclosed delimiter\n99  |\
    \         for j in 0..k {\n    |                       - unclosed delimiter\n\
    100 |             if max_arr[i][j] > max_arr[i-1][j+1] {\n    |              \
    \                                    - this delimiter might not be properly closed...\n\
    101 |                 max_arr[i-1]\n102 | }\n    | - ...as it matches this but\
    \ it has different indentation\n...\n117 | }\n    |   ^\n\nerror[E0277]: the type\
    \ `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmphwfz0kbv.rs:19:9\n\
    \   |\n19 |         max_arr[i] = vec![arr[i]];\n   |         ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmphwfz0kbv.rs:19:27\n\
    \   |\n19 |         max_arr[i] = vec![arr[i]];\n   |                         \
    \  ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmphwfz0kbv.rs:23:16\n\
    \   |\n23 |             if max_arr[i][j] > max_arr[i][j+1] {\n   |           \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ require"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_k = k;\n    let mut i = 0;\n    while\
    \ i < arr.len() {\n        if max_k == 0 {\n            break;\n        }\n  \
    \      if arr[i] > max_arr[0] {\n            max_arr.push(arr[i]);\n         \
    \   max_k -= 1;\n        } else {\n            max_k -= 1;\n        }\n      \
    \  i += 1;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpedmtdrto.rs:24:21\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![0; k];\n    let mut max_idx = k;\n    let mut max_val = arr[0];\n\
    \    for i in 0..arr.len() {\n        if arr[i] > max_val {\n            max_val\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    for i in 0..k {\n\
    \        result[i] = arr[max_idx];\n        max_idx--;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpzgc_5p89.rs:28:18\n\
    \   |\n28 |         max_idx--;\n   |                  ^ expected expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpzgc_5p89.rs:17:30\n   |\n17 |  \
    \   let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzgc_5p89.rs:23:23\n   |\n18 |\
    \     let mut max_idx = k;\n   |                       - expected due to this\
    \ value\n...\n23 |             max_idx = i;\n   |                       ^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpzgc_5p89.rs:27:9\n   |\n27 |         result[i] = arr[max_idx];\n\
    \   |         ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzgc_5p89.rs:27:21\n\
    \   |\n27 |         result[i] = arr[max_idx];\n   |                     ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_so_far = vec![];\n    let mut max_k =\
    \ k;\n    let mut i = 0;\n    while i < arr.len() {\n        if max_k == 0 {\n\
    \            break;\n        }\n        if max_k == 1 {\n            max_arr.push(arr[i]);\n\
    \            max_so_far.push(arr[i]);\n            i += 1;\n            continue;\n\
    \        }\n        let mut j = i;\n        while j < arr.len() {\n          \
    \  if arr[j] > max_so_far[max_k - 1] {\n                max_arr.push(arr[j]);\n\
    \                max_so_far.push(arr[j]);\n                j += 1;\n         \
    \   } else {\n                break;\n            }\n        }\n        max_k\
    \ -= 1;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpf5hkhtxg.rs:33:25\n\
    \   |\n33 |             if arr[j] > max_so_far[max_k - 1] {\n   |            \
    \             ^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    for i in 0..k {\n        max_arr.push(arr[i]);\n\
    \    }\n    for i in 0..arr.len() {\n        let mut max_i = i;\n        for j\
    \ in 0..k {\n            if arr[i] > max_arr[j] {\n                max_i = j;\n\
    \            }\n        }\n        max_arr.swap(i, max_i);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmprvs_jx9s.rs:19:22\n\
    \   |\n19 |         max_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmprvs_jx9s.rs:24:25\n   |\n24 |  \
    \           if arr[i] > max_arr[j] {\n   |                         ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprvs_jx9s.rs:25:25\n   |\n22 |         let mut\
    \ max_i = i;\n   |                         - expected due to this value\n...\n\
    25 |                 max_i = j;\n   |                         ^ expected `usize`,\
    \ found `isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![];\n    }\n    for i in 0..arr.len() {\n        max_arr[k - i].push(arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr[i].sort_unstable();\n    }\n    for\
    \ i in 0..k {\n        max_arr[i].iter().cloned().collect();\n    }\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpr0az4sgt.rs:19:9\n   |\n19 |         max_arr[i] = vec![];\n   |\
    \         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr0az4sgt.rs:22:21\n\
    \   |\n22 |         max_arr[k - i].push(arr[i]);\n   |                     ^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot subtract `usize` from `isize`\n\
    \  --> /tmp/tmpr0az4sgt.rs:22:19\n   |\n22 |         max_arr[k - i].push(arr[i]);\n\
    \   |                   ^ no implementation for `isize - usize`\n   |\n   = help:\
    \ the trait `Sub<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]: the type\
    \ `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpr0az4sgt.rs:22:9\n\
    \   |\n22 |         max_arr[k - i].push(arr[i]);\n   |         ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpr0az4sgt.rs:25:9\n   |\n25 |         max_arr[i].sort_unstable();\n \
    \  |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![]; k];\n    for i in 0..k {\n        max_arr[i] = arr\n\
    \            .iter()\n            .take_while(|&x| x < 0)\n            .take_while(|&x|\
    \ x < 0)\n            .max().unwrap();\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuya5_jf2.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpuya5_jf2.rs:19:9\n   |\n19 |         max_arr[i]\
    \ = arr\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuya5_jf2.rs:21:34\n\
    \   |\n21 |             .take_while(|&x| x < 0)\n   |                        \
    \          ^\n   |                                  |\n   |                  \
    \                expected `&isize`, found integer\n   |                      \
    \            help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpuya5_jf2.rs:22:34\n   |\n22 |             .take_while(|&x| x <\
    \ 0)\n   |                                  ^\n   |                          \
    \        |\n   |                                  expected `&isize`, found integer\n\
    \   |                                  help: consider borrowing here: `&0`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpuya5_jf2.rs:25:5\n   |\n16 | fn\
    \ maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |                   \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n25 |     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Vec<_>>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![]; k];\n    for i in 0..k {\n        max_arr[i] = vec![];\n\
    \    }\n    for i in 0..arr.len() {\n        let mut max_i = i;\n        for j\
    \ in 0..k {\n            if arr[i] > max_arr[j][max_i] {\n                max_i\
    \ = j;\n            }\n        }\n        max_arr[k - 1 - i].push(arr[i]);\n \
    \   }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_49iih9l.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp_49iih9l.rs:19:9\n   |\n19 |         max_arr[i]\
    \ = vec![];\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[Vec<_>]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmp_49iih9l.rs:24:25\n   |\n24 |             if arr[i] >\
    \ max_arr[j][max_i] {\n   |                         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_49iih9l.rs:25:25\n\
    \   |\n22 |         let mut max_i = i;\n   |                         - expected\
    \ due to this value\n...\n25 |                 max_i = j;\n   |              \
    \           ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_49iih9l.rs:28:25\n   |\n28 |         max_arr[k - 1 - i].push(arr[i]);\n\
    \   |                         ^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot subtract `usize` from `isize`\n  --> /tmp/tmp_49iih9l.rs:28:23\n   |\n\
    28 |         max_arr[k - 1 - i].push(arr[i]);\n   |                       ^ no\
    \ implementation for `isize - usize`\n   |\n   = help: the trait `Sub<usize>`\
    \ is not implement"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        let mut max_i = i;\n        for j in 0..k\
    \ {\n            if max_arr[j] < max_arr[j] {\n                max_i = j;\n  \
    \          }\n        }\n        max_arr[i] = max_arr[i].max(max_arr[max_i]);\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].max();\n    }\n \
    \   for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpai21cf7u.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpai21cf7u.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpai21cf7u.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpai21cf7u.rs:24:16\n   |\n24 |  \
    \           if max_arr[j] < max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpai21cf7u.rs:24:29\n   |\n24 |             if max_arr[j] < max_arr[j]\
    \ {\n   |                             ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ max_idx = 0;\n    for i in 0..arr.len() {\n        let mut max_val = arr[i];\n\
    \        let mut max_idx = i;\n        for j in 0..k {\n            if arr[j]\
    \ > max_val {\n                max_val = arr[j];\n                max_idx = j;\n\
    \            }\n        }\n        max_arr[k - 1 - i].push(max_val);\n       \
    \ max_arr[k - 1 - i].push(max_idx);\n    }\n    for i in 0..k {\n        max_arr[i].sort();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].sort();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i].sort();\n    }\n    for i in 0..k {\n        max_arr[i].sort();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].sort();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i].sort();\n    }\n    for i in 0..k {\n        max_arr[i].sort();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].sort();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i].sort();\n    }\n    for i in 0..k {\n        max_arr[i].sort();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].sort();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i].sort();\n    }\n    for i in 0..k {\n        max_arr[i].sort();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].sort();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i].sort();\n    }\n    for i in 0..k {\n        max_arr[i].sort();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].sort();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i].sort();\n    }\n    for i in 0..k {\n        max_arr[i].sort();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].sort();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i].sort();\n    }\n    for i in 0..k {\n        max_arr[i].sort();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].sort();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i].sort();\n    }\n    for i in 0..k {\n        max_arr[i].sort();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].sort();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i].sort();\n    }\n    for i in 0..k {\n        max_arr[i].sort();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].sort();\n    }\n\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmppc7e11nf.rs:24:16\n\
    \   |\n24 |             if arr[j] > max_val {\n   |                ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmppc7e11nf.rs:25:27\n   |\n25 |  \
    \               max_val = arr[j];\n   |                           ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppc7e11nf.rs:26:27\n   |\n22 |         let mut max_idx = i;\n  \
    \ |                           - expected due to this value\n...\n26 |        \
    \         max_idx = j;\n   |                           ^ expected `usize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppc7e11nf.rs:29:25\n\
    \   |\n29 |         max_arr[k - 1 - i].push(max_val);\n   |                  \
    \       ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot subtract `usize`\
    \ from `isize`\n  --> /tmp/tmppc7e11nf.rs:29:23\n   |\n29 |         max_arr[k\
    \ - 1 - i].push(max_val);\n   |                       ^ no implementation for\
    \ `isize - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0277]: the type "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![-1000, 1000];\n    }\n    for i in 0..arr.len() {\n        let mut max_val\
    \ = -1000isize;\n        let mut max_idx = -1;\n        for j in 0..k {\n    \
    \        if arr[i] > max_arr[j][0] {\n                max_val = arr[i];\n    \
    \            max_idx = j;\n            }\n        }\n        max_arr[k - 1 - max_idx].push(max_val);\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpl3daiunk.rs:19:9\n   |\n19 |         max_arr[i] = vec![-1000, 1000];\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpl3daiunk.rs:25:25\n   |\n25 |         \
    \    if arr[i] > max_arr[j][0] {\n   |                         ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpl3daiunk.rs:30:9\n   |\n30 |         max_arr[k - 1 - max_idx].push(max_val);\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl3daiunk.rs:32:5\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n32 |     max_arr\n   |     ^^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Vec<{integer}>>`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rus"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..arr.len() {\n\
    \        max_arr[i][arr.len() - 1 - i] = max_arr[i][arr.len() - 1 - i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i][arr.len() - 1 - i] = max_arr[i][arr.len()\
    \ - 1 - i].iter().cloned().collect();\n    }\n    for i in 0..k {\n        max_arr[i][arr.len()\
    \ - 1 - i] = max_arr[i][arr.len() - 1 - i].iter().cloned().collect();\n    }\n\
    \    for i in 0..k {\n        max_arr[i][arr.len() - 1 - i] = max_arr[i][arr.len()\
    \ - 1 - i].iter().cloned().collect();\n    }\n    for i in 0..k {\n        max_arr[i][arr.len()\
    \ - 1 - i] = max_arr[i][arr.len() - 1 - i].iter().cloned().collect();\n    }\n\
    \    for i in 0..k {\n        max_arr[i][arr.len() - 1 - i] = max_arr[i][arr.len()\
    \ - 1 - i].iter().cloned().collect();\n    }\n    for i in 0..k {\n        max_arr[i][arr.len()\
    \ - 1 - i] = max_arr[i][arr.len() - 1 - i].iter().cloned().collect();\n    }\n\
    \    for i in 0..k {\n        max_arr[i][arr.len() - 1 - i] = max_arr[i][arr.len()\
    \ - 1 - i].iter().cloned().collect();\n    }\n    for i in 0..k {\n        max_arr[i][arr.len()\
    \ - 1 - i] = max_arr[i][arr.len() - 1 - i].iter().cloned().collect();\n    }\n\
    \    for i in 0..k {\n        max_arr[i][arr.len() - 1 - i] = max_arr[i][arr.len()\
    \ - 1 - i].iter().cloned().collect();\n    }\n    for i in 0..k {\n        max_arr[i][arr.len()\
    \ - 1 - i] = max_arr[i][arr.len() - 1 - i].iter().cloned().collect();\n    }\n\
    \    for i in 0..k {\n        max_arr[i][arr.len() - 1 - i] = max_arr[i][arr.len()\
    \ - 1 - i].iter().cloned().collect();\n    }\n    for i in 0..k {\n        max_arr[i][arr.len()\
    \ - 1 - i] = max_arr[i][arr.len() - 1 - i].iter().cloned().collect();\n    }\n\
    \    for i in 0..k {\n        max_arr[i][arr.len() - 1 - i] = max_arr[i][arr.len()\
    \ - 1 - i].iter().cloned().collect();\n    }\n    for i in 0..k {\n        max_arr[i][arr.len()\
    \ - \n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp995yon8t.rs:80:3\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                               - unclosed delimiter\n...\n63\
    \ |     for i in 0..k {\n   |                   - this delimiter might not be\
    \ properly closed...\n64 |         max_arr[i][arr.len() - \n65 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n80 | }\n   |   ^\n\n\
    error: expected expression, found `]`\n  --> /tmp/tmp995yon8t.rs:65:1\n   |\n\
    65 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n\
    \  --> /tmp/tmp995yon8t.rs:64:19\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                                                     -\
    \ closing delimiter possibly meant for this\n...\n64 |         max_arr[i][arr.len()\
    \ - \n   |                   ^ unclosed delimiter\n65 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmp995yon8t.rs:19:9\n   |\n19 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp995yon8t.rs:19:22\n   |\n19 |         max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0599]: no method named `iter` found for type `{integer}` in the current\
    \ scope\n  --> "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[i]\
    \ > max_arr[j] {\n                max_arr[i] = max_arr[j];\n            }\n  \
    \      }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9z8bc5m6.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp9z8bc5m6.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp9z8bc5m6.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp9z8bc5m6.rs:23:16\n   |\n23 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp9z8bc5m6.rs:23:29\n   |\n23 |             if max_arr[i] > max_arr[j]\
    \ {\n   |                             ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000]; k];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![arr[i]; 1];\n    }\n    for i in 0..k {\n        for j in 0..k {\n  \
    \          if max_arr[i][j] > max_arr[i][j + 1] {\n                max_arr[i][j]\
    \ = max_arr[i][j + 1];\n            }\n        }\n    }\n    for i in 0..k {\n\
    \        for j in 0..k {\n            if max_arr[i][j] > arr[i] {\n          \
    \      max_arr[i][j] = arr[i];\n            }\n        }\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbp3fmr6x.rs:17:41\n   |\n\
    17 |     let mut max_arr = vec![vec![-1000]; k];\n   |                       \
    \                  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max_arr = vec![vec![-1000]; k.try_into().unwrap()];\n   |   \
    \                                       ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpbp3fmr6x.rs:19:9\n\
    \   |\n19 |         max_arr[i] = vec![arr[i]; 1];\n   |         ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbp3fmr6x.rs:19:27\n\
    \   |\n19 |         max_arr[i] = vec![arr[i]; 1];\n   |                      \
    \     ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n  \
    \ = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   =\
    \ help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpbp3fmr6x.rs:23:16\n   |\n23 |             if max_arr[i][j] > max_arr[i][j\
    \ + 1] {\n   |                ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbp3fmr6x.rs:23:32\n   |\n23 |  \
    \           if max_arr[i][j]"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![0; k];\n    let mut max_idx = k;\n    for i in 0..arr.len()\
    \ {\n        if arr[i] > max_arr[k] {\n            max_arr[k] = arr[i];\n    \
    \        max_idx += 1;\n        }\n    }\n    max_arr.truncate(max_idx);\n   \
    \ max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3p95raka.rs:17:31\n   |\n\
    17 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp3p95raka.rs:20:21\n\
    \   |\n20 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp3p95raka.rs:21:13\n\
    \   |\n21 |             max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3p95raka.rs:25:22\n   |\n25 |     max_arr.truncate(max_idx);\n\
    \   |                      ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |     max_arr.truncate(max_idx.try_into().unwrap());\n   |   \
    \                          ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ max_idx = 0;\n    for ele in arr {\n        if ele > max_arr[0][0] { \n    \
    \        max_arr[0][0] = ele;\n            max_arr[0][1] = ele;\n        }\n \
    \       if ele > max_arr[1][0] { \n            max_arr[1][0] = ele;\n        \
    \    max_arr[1][1] = ele;\n        }\n        if ele > max_arr[2][0] { \n    \
    \        max_arr[2][0] = ele;\n            max_arr[2][1] = ele;\n        }\n \
    \       if ele > max_arr[3][0] { \n            max_arr[3][0] = ele;\n        \
    \    max_arr[3][1] = ele;\n        }\n        if ele > max_arr[4][0] { \n    \
    \        max_arr[4][0] = ele;\n            max_arr[4][1] = ele;\n        }\n \
    \       if ele > max_arr[5][0] { \n            max_arr[5][0] = ele;\n        \
    \    max_arr[5][1] = ele;\n        }\n        if ele > max_arr[6][0] { \n    \
    \        max_arr[6][0] = ele;\n            max_arr[6][1] = ele;\n        }\n \
    \       if ele > max_arr[7][0] { \n            max_arr[7][0] = ele;\n        \
    \    max_arr[7][1] = ele;\n        }\n        if ele > max_arr[8][0] { \n    \
    \        max_arr[8][0] = ele;\n            max_arr[8][1] = ele;\n        }\n \
    \       if ele > max_arr[9][0] { \n            max_arr[9][0] = ele;\n        \
    \    max_arr[9][1] = ele;\n        }\n        if ele > max_arr[10][0] { \n   \
    \         max_arr[10][0]= ele;\n            max_arr[10][1]= ele;\n        }\n\
    \        if ele > max_arr[11][0] { \n            max_arr[11][0]= ele;\n      \
    \      max_arr[11][1]= ele;\n        }\n        if ele > max_arr[12][0] { \n \
    \           max_arr[12][0]= ele;\n            max_arr[12][1]= ele;\n        }\n\
    \        if ele > max_arr[13][0] { \n            max_arr[13][0]= ele;\n      \
    \      max_arr[13][1]= ele;\n        }\n        if ele > max_arr[14][0] { \n \
    \           max_arr[14][0]= ele;\n            max_arr[14][1]= ele;\n        }\n\
    \        if ele > max_arr[15][0] { \n            max_arr[15][0]= ele;\n      \
    \      max_arr[15][1]= ele;\n        }\n        if ele > max_arr[16][0] { \n \
    \           max_arr[16][0]= ele\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp2rl19iff.rs:102:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     for ele in arr {\n    |                    - unclosed delimiter\n...\n\
    85  |         if ele > max_arr[16][0] { \n    |                              \
    \   - this delimiter might not be properly closed...\n86  |             max_arr[16][0]=\
    \ ele\n87  | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n102 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmp2rl19iff.rs:20:5\n\
    \    |\n16  |   fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    | \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n20  | /     for ele in arr {\n21  | |         if ele >\
    \ max_arr[0][0] { \n22  | |             max_arr[0][0] = ele;\n23  | |        \
    \     max_arr[0][1] = ele;\n...   |\n101 | |     assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n102 | | }\n    | |__^ expected\
    \ struct `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n\
    \            found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![];\n    }\n    for i in 0..arr.len() {\n        let mut max_num = arr[i];\n\
    \        let mut max_pos = i;\n        for j in 0..k {\n            if max_arr[j].len()\
    \ > 0 && max_arr[j][0] == max_num {\n                max_num = max_arr[j][0];\n\
    \                max_pos = j;\n            }\n        }\n        max_arr[max_pos].push(max_num);\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp_asbs55q.rs:19:9\n   |\n19 |         max_arr[i] = vec![];\n   |\
    \         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp_asbs55q.rs:25:16\n   |\n25 |         \
    \    if max_arr[j].len() > 0 && max_arr[j][0] == max_num {\n   |             \
    \   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp_asbs55q.rs:25:40\n   |\n25 |             if max_arr[j].len() > 0 &&\
    \ max_arr[j][0] == max_num {\n   |                                        ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp_asbs55q.rs:26:27\n   |\n26 |                 max_num = max_arr[j][0];\n\
    \   |                           ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![]; k];\n    for i in 0..k {\n        max_arr[i] = vec![];\n\
    \    }\n    for i in 0..arr.len() {\n        max_arr[k - 1 - i].push(arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyyyvvzg7.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpyyyvvzg7.rs:19:9\n   |\n19 |         max_arr[i]\
    \ = vec![];\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyyyvvzg7.rs:22:25\n\
    \   |\n22 |         max_arr[k - 1 - i].push(arr[i]);\n   |                   \
    \      ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot subtract `usize`\
    \ from `isize`\n  --> /tmp/tmpyyyvvzg7.rs:22:23\n   |\n22 |         max_arr[k\
    \ - 1 - i].push(arr[i]);\n   |                       ^ no implementation for `isize\
    \ - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]:\
    \ the type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmpyyyvvzg7.rs:22:9\n\
    \   |\n22 |         max_arr[k - 1 - i].push(arr[i]);\n   |         ^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<_>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is i"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_num = arr[0];\n    for i in 1..k {\n\
    \        if arr[i] > max_num {\n            max_num = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(max_num);\n\
    \        }\n        max_arr.push(arr[i]);\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpiy07vbqp.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpiy07vbqp.rs:21:23\n   |\n21 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpiy07vbqp.rs:25:12\n   |\n25 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpiy07vbqp.rs:28:22\n   |\n28 |         max_arr.push(arr[i]);\n \
    \  |                      ^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_num = arr[0];\n    for i in 1..k {\n\
    \        if arr[i] > max_num {\n            max_num = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(max_num);\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp9yx8v37l.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp9yx8v37l.rs:21:23\n   |\n21 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp9yx8v37l.rs:25:12\n   |\n25 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp9yx8v37l.rs:30:12\n   |\n30 |         if arr[i] > max_num {\n \
    \  |            ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp9yx8v37l.rs:31:26\n\
    \   |\n31 |             max_arr.push(arr[i]);\n   |                          ^^^^^^\
    \ slice indices are of type `usize` or ranges of `us"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].max();\n    }\n \
    \   for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for\
    \ i in 0..k {\n        arr[i] = max_arr[i];\n    }\n    arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpig4cz6z4.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpig4cz6z4.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpig4cz6z4.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpig4cz6z4.rs:22:9\n   |\n22 |   \
    \      max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpig4cz6z4.rs:22:22\n   |\n22 |  \
    \       max_arr[i] = max_arr[i].max();\n   |                      ^^^^^^^^^^ slice\
    \ indic"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ max_i = -1;\n    let mut max_j = -1;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    while i < arr.len() && j < max_k {\n        if arr[i] > max_arr[j][0] {\n\
    \            max_arr[j] = vec![arr[i], arr[i]];\n            max_k = j;\n    \
    \        max_i = i;\n        }\n        if arr[i] < max_arr[j][0] {\n        \
    \    if arr[i] > max_arr[j][0] {\n                max_arr[j] = vec![arr[i], arr[i]];\n\
    \                max_k = j;\n                max_i = i;\n            }\n     \
    \   }\n        i += 1;\n        j += 1;\n    }\n    if max_k == max_k {\n    \
    \    max_arr[j] = vec![arr[i], arr[i]];\n    }\n    if max_k > max_k {\n     \
    \   max_arr[j] = vec![arr[i], arr[i]];\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpe5an4b_i.rs:24:21\n   |\n24 |         if arr[i] > max_arr[j][0]\
    \ {\n   |                     ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpe5an4b_i.rs:25:13\n   |\n25 |  \
    \           max_arr[j] = vec![arr[i], arr[i]];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpe5an4b_i.rs:19:21\n\
    \   |\n19 |     let mut max_i = -1;\n   |                     ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpe5an4b_i.rs:29:21\n   |\n29 |  \
    \       if arr[i] < max_arr[j][0] {\n   |                     ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpe5an4b_i.rs:30:25\n   |\n30 "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[j]\
    \ < max_arr[i] {\n                max_arr[j] = max_arr[i];\n            }\n  \
    \      }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if\
    \ max_arr[j] == max_arr[i] {\n                max_arr[j] = max_arr[i];\n     \
    \       }\n        }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[j]\
    \ == max_arr[i] {\n                max_arr[j] = max_arr[i];\n            }\n \
    \       }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[j]\
    \ == max_arr[i] {\n                max_arr[j] = max_arr[i];\n            }\n \
    \       }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if\
    \ max_arr[j] == max_arr[i] {\n                max_arr[j] = max_arr[i];\n     \
    \       }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n  \
    \          if max_arr[j] == max_arr[i] {\n                max_arr[j] = max_arr[i];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[j] == max_arr[i] {\n                max_arr[j] = max_arr[i];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[j] == max_arr[i] {\n                max_arr[j] = max_arr[i];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[j] == max_arr[i] {\n                max_arr[j] = max_arr[i];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[j] == max_arr[i] {\n                max_arr[j] = max_arr[i];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[j] == max_arr[i] {\n                max_arr[j] = max_arr[i];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[j] == max_arr[i] {\n                max_arr[j] = max_arr[i];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpgcrv9osj.rs:128:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    111 |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n112 |         for j in 0..\n113 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n128 | }\n    |   ^\n\nerror:\
    \ expected `{`, found `}`\n   --> /tmp/tmpgcrv9osj.rs:113:1\n    |\n113 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgcrv9osj.rs:17:36\n\
    \   |\n17 |     let mut max_arr = vec![vec![]; k];\n   |                     \
    \               ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |        \
    \                             ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpgcrv9osj.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpgcrv9osj.rs:19:22\n   |\n19 |         max_arr[i]\
    \ = arr[i];\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpgcrv9osj.rs:23:16\n   |\n23 |         \
    \    if max_arr[j] < max_arr[i] {\n   |                ^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[0][i] {\n   \
    \         max_arr[0][i] = arr[i];\n            max_arr[1][i] = arr[i];\n     \
    \   } else {\n            max_arr[0][i] = max_arr[0][i] * max_k;\n           \
    \ max_arr[1][i] = max_arr[1][i] * max_k;\n        }\n        i += 1;\n    }\n\
    \    max_arr[0].sort();\n    max_arr[1].sort();\n    max_arr[0].iter().take(max_k).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpik74svrn.rs:32:28\n   |\n\
    32 |     max_arr[0].iter().take(max_k).cloned().collect()\n   |              \
    \              ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    32 |     max_arr[0].iter().take(max_k.try_into().unwrap()).cloned().collect()\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ max_idx = 0;\n    for idx in 0..arr.len() {\n        if max_k == 0 {\n     \
    \       break;\n        }\n        if max_arr[idx][0] > arr[idx] {\n         \
    \   max_arr[idx] = [arr[idx], max_arr[idx][1]];\n            max_k -= 1;\n   \
    \     } else {\n            max_arr[idx] = [max_arr[idx][0] - arr[idx], max_arr[idx][1]];\n\
    \        }\n    }\n    if max_k == 0 {\n        return max_arr;\n    }\n    for\
    \ idx in 0..arr.len() {\n        if max_arr[idx][0] > arr[idx] {\n           \
    \ max_arr[idx] = [arr[idx], max_arr[idx][1]];\n            max_k -= 1;\n     \
    \   } else {\n            max_arr[idx] = [max_arr[idx][0] - arr[idx], max_arr[idx][1]];\n\
    \        }\n    }\n    if max_k == 0 {\n        return max_arr;\n    }\n    for\
    \ idx in 0..arr.len() {\n        if max_arr[idx][0] > arr[idx] {\n           \
    \ max_arr[idx] = [arr[idx], max_arr[idx][1]];\n            max_k -= 1;\n     \
    \   } else {\n            max_arr[idx] = [max_arr[idx][0] - arr[idx], max_arr[idx][1]];\n\
    \        }\n    }\n    if max_k == 0 {\n        return max_arr;\n    }\n    for\
    \ idx in 0..arr.len() {\n        if max_arr[idx][0] > arr[idx] {\n           \
    \ max_arr[idx] = [arr[idx], max_arr[idx][1]];\n            max_k -= 1;\n     \
    \   } else {\n            max_arr[idx] = [max_arr[idx][0] - arr[idx], max_arr[idx][1]];\n\
    \        }\n    }\n    if max_k == 0 {\n        return max_arr;\n    }\n    for\
    \ idx in 0..arr.len() {\n        if max_arr[idx][0] > arr[idx] {\n           \
    \ max_arr[idx] = [arr[idx], max_arr[idx][1]];\n            max_k -= 1;\n     \
    \   } else {\n            max_arr[idx] = [max_arr[idx][0] - arr[idx], max_arr[idx][1]];\n\
    \        }\n    }\n    if max_k == 0 {\n        return max_arr;\n    }\n    for\
    \ idx in 0..arr.len() {\n        if max_arr[idx][0] > arr[idx] {\n           \
    \ max_arr[idx] = [arr[idx], max_arr[idx][1]];\n            max_k -= 1;\n     \
    \   } else {\n            max_arr[idx] = [max_arr[idx][0] - arr[idx], max_arr[idx][1]];\n\
    \        }\n    }\n    if max_k == 0 {\n        return max_arr;\n    }\n    for\
    \ idx in 0..arr.len() {\n        if max_arr[idx][0] > arr[idx] {\n           \
    \ max_arr[idx] = [arr[idx], max_arr[idx][1]];\n            max_k -= 1;\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpkkbonw7x.rs:108:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    89  |     for idx in 0..arr.len() {\n    |                             - unclosed\
    \ delimiter\n90  |         if max_arr[idx][0] > arr[idx] {\n    |            \
    \                           - this delimiter might not be properly closed...\n\
    ...\n93  | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n108 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkkbonw7x.rs:25:28\n\
    \   |\n25 |             max_arr[idx] = [arr[idx], max_arr[idx][1]];\n   |    \
    \         ------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_vec()`\n   |             |              |\n   |             | \
    \             expected struct `Vec`, found array `[isize; 2]`\n   |          \
    \   expected due to the type of this binding\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n               found array `[isize; 2]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkkbonw7x.rs:28:28\n   |\n28 |             max_arr[idx]\
    \ = [max_arr[idx][0] - arr[idx], max_arr[idx][1]];\n   |             ------------\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_vec()`\n   |             |              |\n   |             | \
    \             expected struct `Vec`, found array `[isize; 2]`\n   |          \
    \   expected due to the type of this binding\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n               found array `[isize; 2]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkkbonw7x.rs:32:16\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n32 |         return max_arr;\n\
    \   |                ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Vec<isize>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        let mut\
    \ max_val = -1000.0;\n        let mut max_idx = -1;\n        for j in 0..arr.len()\
    \ {\n            if arr[j] > max_val {\n                max_val = arr[j];\n  \
    \              max_idx = j;\n            }\n        }\n        max_arr.push(vec![max_idx,\
    \ max_val]);\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfqwewgvi.rs:22:25\n   |\n\
    22 |             if arr[j] > max_val {\n   |                         ^^^^^^^ expected\
    \ `isize`, found floating-point number\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfqwewgvi.rs:23:27\n   |\n19 |         let mut max_val = -1000.0;\n \
    \  |                           ------- expected due to this value\n...\n23 | \
    \                max_val = arr[j];\n   |                           ^^^^^^ expected\
    \ floating-point number, found `isize`\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmpfqwewgvi.rs:20:27\n   |\n20 |         let\
    \ mut max_idx = -1;\n   |                           ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmpfqwewgvi.rs:17:33\n   |\n17 |     let mut\
    \ max_arr = vec![vec![-1000, 1000]];\n   |                                 ^^^^^\
    \ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfqwewgvi.rs:27:36\n   |\n27 |         max_arr.push(vec![max_idx,\
    \ max_val]);\n   |                                    ^^^^^^^ expected `usize`,\
    \ found floating-point number\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfqwewgvi.rs:29:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n29 |     max_arr\n   |     ^^^^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<Vec<usize>>`\n\nerror: aborting due to "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![arr[i]; 2];\n    }\n    for i in 0..k {\n        for j in 0..k {\n  \
    \          if max_arr[i][j] > max_arr[i][j+1] {\n                max_arr[i][j]\
    \ = max_arr[i][j+1];\n            }\n        }\n    }\n    for i in 0..k {\n \
    \       for j in 0..k {\n            if max_arr[i][j] > arr[i] {\n           \
    \     max_arr[i][j] = arr[i];\n            }\n        }\n    }\n    for i in 0..k\
    \ {\n        for j in 0..k {\n            if max_arr[i][j] > arr[j] {\n      \
    \          max_arr[i][j] = arr[j];\n            }\n        }\n    }\n    for i\
    \ in 0..k {\n        for j in 0..k {\n            if max_arr[i][j] > max_arr[i+1][j]\
    \ {\n                max_arr[i][j] = max_arr[i+1][j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > max_arr[i][j-1] {\n                max_arr[i][j] = max_arr[i][j-1];\n    \
    \        }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n \
    \           if max_arr[i][j] > max_arr[i+1][j+1] {\n                max_arr[i][j]\
    \ = max_arr[i+1][j+1];\n            }\n        }\n    }\n    for i in 0..k {\n\
    \        for j in 0..k {\n            if max_arr[i][j] > max_arr[i-1][j] {\n \
    \               max_arr[i][j] = max_arr[i-1][j];\n            }\n        }\n \
    \   }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > max_arr[i-1][j-1] {\n                max_arr[i][j] = max_arr[i-1][j-1];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > max_arr[i+1][j-1] {\n                max_arr[i][j]\
    \ = max_arr[i+1][j-1];\n            }\n        }\n    }\n    for i in 0..k {\n\
    \        for j in 0..k {\n            if max_arr[i][j] > max_arr[i-1][j+1] {\n\
    \                max_arr[i][j] = max_arr[i-1][j+1];\n            }\n        }\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > max_arr[i+1][j+1] {\n                max_arr[i][j] = max_arr[i+1][j+1];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > max_arr[i+1][j] {\n                max_arr[i][j]\
    \ = max_arr[i+1][j];\n            }\n        }\n\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmptsp5y_we.rs:120:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    98  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n...\n105 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n120 | }\n    |   ^\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmptsp5y_we.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = vec![arr[i]; 2];\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmptsp5y_we.rs:19:27\n   |\n19 |  \
    \       max_arr[i] = vec![arr[i]; 2];\n   |                           ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmptsp5y_we.rs:23:16\n   |\n23 |  \
    \           if max_arr[i][j] > max_arr[i][j+1] {\n   |                ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmptsp5y_we.rs:23:32\n   |\n23 |             if max_arr[i][j] > max_ar"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    for i in 0..k {\n        max_arr.push(arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmprtjub32s.rs:19:22\n\
    \   |\n19 |         max_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmprtjub32s.rs:22:22\n   |\n22 |  \
    \       max_arr.push(max_arr[i]);\n   |                      ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<_>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n  \
    \  }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpzzkgw2wt.rs:101:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    84  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n85  |         max_arr[i] = max_arr[i].iter().\n86  |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n101\
    \ | }\n    |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpzzkgw2wt.rs:86:1\n\
    \   |\n86 | }\n   | ^\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpzzkgw2wt.rs:19:9\n   |\n19 |         max_arr[i] =\
    \ max_arr[i].iter().max().unwrap();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpzzkgw2wt.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = max_arr[i].iter().max().unwrap();\n   |                 \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpzzkgw2wt.rs:22:9\n   |\n22 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<i"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        let mut max_i = i;\n        for j in 0..k\
    \ {\n            if max_arr[j] < max_arr[j] && max_arr[j] < max_arr[max_i] {\n\
    \                max_i = j;\n            }\n        }\n        max_arr[max_i]\
    \ = max_arr[i];\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqt3m7_tb.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpqt3m7_tb.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpqt3m7_tb.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpqt3m7_tb.rs:24:16\n   |\n24 |  \
    \           if max_arr[j] < max_arr[j] && max_arr[j] < max_arr[max_i] {\n   |\
    \                ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpqt3m7_tb.rs:24:29\n   |\n24 |         \
    \    if max_arr[j] < max_arr[j] && max_"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![]; k];\n    for i in 0..k {\n        max_arr[i] = vec![arr[i];\
    \ 1];\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > max_arr[i][j+1] {\n                max_arr[i][j] = max_arr[i][j+1];\n    \
    \        }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n \
    \           if max_arr[i][j] > arr[j] {\n                max_arr[i][j] = arr[j];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        max_arr[i].sort();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpryli3q7y.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpryli3q7y.rs:19:9\n   |\n19 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |         ^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpryli3q7y.rs:19:27\n   |\n19 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpryli3q7y.rs:23:16\n   |\n23 |         \
    \    if max_arr[i][j] > max_arr[i][j+1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<_>]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]:\
    \ the type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmpryli3q7y.rs:23:32\n\
    \   |\n23 |             if max_arr[i][j] > max_arr[i][j+1] {\n   |           \
    \                     ^^^^^^^^^^ slice indi"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0; k]; arr.len()];\n    for i in 0..arr.len() {\n  \
    \      let mut max_i = i;\n        let mut max_j = i;\n        for j in 0..k {\n\
    \            if arr[j] > arr[max_j] {\n                max_j = j;\n          \
    \  }\n        }\n        max_arr[i] = arr[max_i..max_j];\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8zfm5bu8.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k]; arr.len()];\n   |                \
    \                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k.try_into().unwrap()]; arr.len()];\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8zfm5bu8.rs:22:16\n\
    \   |\n22 |             if arr[j] > arr[max_j] {\n   |                ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8zfm5bu8.rs:23:25\n   |\n20 |         let mut max_j = i;\n   |\
    \                         - expected due to this value\n...\n23 |            \
    \     max_j = j;\n   |                         ^ expected `usize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8zfm5bu8.rs:26:22\n   |\n26 |\
    \         max_arr[i] = arr[max_i..max_j];\n   |         ----------   ^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_vec()`\n   |         |           \
    \ |\n   |         |            expected struct `Vec`, found slice `[isize]`\n\
    \   |         expected due to the type of this binding\n   |\n   = note: expected\
    \ struct `Vec<{integer}>`\n               found slice `[isize]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8zfm5bu8.rs:28:5\n   |\n16 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n28 |\
    \     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected struct `Vec<isize>`\n              found struct `Vec<Vec<{integer}>>`\n\
    \nerror: aborting due to 5 previous errors\n\nS"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut max_element = arr[0];\n    for i in 1..k {\n\
    \        if arr[i] > max_element {\n            max_element = arr[i];\n      \
    \  }\n    }\n    for i in 0..k {\n        if arr[i] > max_element {\n        \
    \    result.push(max_element);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmptz294g_7.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_element {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmptz294g_7.rs:21:27\n   |\n21 |            \
    \ max_element = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmptz294g_7.rs:25:12\n   |\n25 |         if arr[i]\
    \ > max_element {\n   |            ^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..arr.len() {\n        max_arr[i]\
    \ = if arr[i] > max_arr[i].iter().max().unwrap() {\n            max_arr[i].iter().max().unwrap()\n\
    \        } else {\n            max_arr[i].iter().max().unwrap()\n        };\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkeqfi6qc.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkeqfi6qc.rs:19:34\n   |\n19 |         max_arr[i] = if arr[i] >\
    \ max_arr[i].iter().max().unwrap() {\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&{integer}`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n19 |         max_arr[i] = if arr[i] > *max_arr[i].iter().max().unwrap()\
    \ {\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkeqfi6qc.rs:20:13\n   |\n20 |             max_arr[i].iter().max().unwrap()\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ `&{integer}`\n   |\n   = note: expected struct `Vec<{integer}>`\n          \
    \ found reference `&{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkeqfi6qc.rs:22:13\n\
    \   |\n22 |             max_arr[i].iter().max().unwrap()\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `&{integer}`\n   |\n   = note: expected struct\
    \ `Vec<{integer}>`\n           found reference `&{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkeqfi6qc.rs:25:5\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n25 |     max_arr\n   |  \
    \   ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<Vec<{integer}>>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![0; k];\n    let mut max_val = arr[0];\n    for i in 1..k {\n\
    \        if arr[i] > max_val {\n            max_val = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        result[i] = max_val;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfk4_j0yb.rs:17:30\n   |\n\
    17 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfk4_j0yb.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpfk4_j0yb.rs:21:23\n   |\n21 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpfk4_j0yb.rs:25:9\n   |\n25 |         result[i]\
    \ = max_val;\n   |         ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..arr.len() {\n\
    \        max_arr[i][arr.len() - 1 - i].push(*arr[i]);\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n  \
    \  }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8ndt6d2k.rs:101:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    84  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n85  |         max_arr[i] = max_arr[i].\n86  | }\n   \
    \ | - ...as it matches this but it has different indentation\n...\n101 | }\n \
    \   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmp8ndt6d2k.rs:86:1\n  \
    \ |\n86 | }\n   | ^\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp8ndt6d2k.rs:19:9\n   |\n19 |         max_arr[i] =\
    \ max_arr[i].iter().cloned().collect();\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp8ndt6d2k.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = max_arr[i].iter().cloned().collect();\n   |             \
    \         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0599]: no method named `push` found for\
    \ type `{integer}` in the current scope\n  --> /tmp/tmp8ndt6d2k.rs:22:39\n   |\n\
    22 |         max_arr[i][arr.len() - 1 - i].push(*arr[i]);\n   |              \
    \                         ^^^^ method not found in `{integer}`\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp8ndt6d2k.rs:22:44\n   |\n\
    22 |         max_arr[i][arr.len() - 1 - i].push(*arr[i]);\n   |              \
    \                              ^^^^^^^\n\nerror[E0277"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![]; k];\n    for i in 0..k {\n        max_arr[i] = arr\n\
    \            .iter()\n            .enumerate()\n            .filter(|(_, v)| v\
    \ > arr[i])\n            .map(|(_, v)| v)\n            .collect::<Vec<_>>();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd57qcldo.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpd57qcldo.rs:19:9\n   |\n19 |         max_arr[i]\
    \ = arr\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpd57qcldo.rs:22:34\n   |\n22 |             .filter(|(_, v)| v >\
    \ arr[i])\n   |                                  ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd57qcldo.rs:26:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     max_arr\n   |     ^^^^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<Vec<_>>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        let mut max_num = max_arr[i].unwrap();\n\
    \        for j in (i + 1)..k {\n            if max_arr[j] > max_num {\n      \
    \          max_num = max_arr[j].unwrap();\n            }\n        }\n        max_arr[i]\
    \ = max_num;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy1x7g_v0.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpy1x7g_v0.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpy1x7g_v0.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpy1x7g_v0.rs:22:27\n   |\n22 |  \
    \       let mut max_num = max_arr[i].unwrap();\n   |                         \
    \  ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n \
    \  = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpy1x7g_v0.rs:24:16\n   |\n24 |             if max_arr[j] > max_num {\n\
    \   |                ^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![0; k];\n    let mut max_idx = k;\n    let mut max_val = arr[0];\n\
    \    for &x in arr {\n        if x > max_val {\n            max_val = x;\n   \
    \         max_idx = k;\n        }\n        if x == max_val {\n            max_arr[k\
    \ - 1] = x;\n        }\n        if k == max_idx {\n            max_arr[k - 1]\
    \ = max_val;\n        }\n        k -= 1;\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp31wghqh7.rs:17:31\n   |\n\
    17 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp31wghqh7.rs:20:9\n   |\n20 | \
    \    for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp31wghqh7.rs:26:13\n   |\n26 |  \
    \           max_arr[k - 1] = x;\n   |             ^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp31wghqh7.rs:29:13\n   |\n29 |  \
    \           max_arr[k - 1] = max_val;\n   |             ^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![]; k];\n    for i in 0..k {\n        max_arr[i] = vec![arr[i];\
    \ 1];\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > max_arr[i][j + 1] {\n                max_arr[i][j] = max_arr[i][j + 1];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] == max_arr[i][j] {\n                max_arr[i][j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq5b__vra.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpq5b__vra.rs:19:9\n   |\n19 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |         ^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpq5b__vra.rs:19:27\n   |\n19 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpq5b__vra.rs:23:16\n   |\n23 |         \
    \    if max_arr[i][j] > max_arr[i][j + 1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<_>]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]:\
    \ the type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmpq5b__vra.rs:23:32\n\
    \   |\n23 |             if max_arr[i][j] > max_arr[i][j + 1] {\n   |         \
    \                       ^^^^^^^^^^ slice "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    for i in 0..k {\n        max_arr.push(arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    for\
    \ i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    for i in 0..k {\n\
    \        max_arr.push(max_arr[i]);\n    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    for\
    \ i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    for i in 0..k {\n\
    \        max_arr.push(max_arr[i]);\n    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    for\
    \ i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    for i in 0..k {\n\
    \        max_arr.push(max_arr[i]);\n    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    for\
    \ i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    for i in 0..k {\n\
    \        max_arr.push(max_arr[i]);\n    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    for\
    \ i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    for i in 0..k {\n\
    \        max_arr.push(max_arr[i]);\n    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    for\
    \ i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    for i in 0..k {\n\
    \        max_arr.push(max_arr[i]);\n    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    for\
    \ i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    for i in 0..k {\n\
    \        max_arr.push(max_arr[i]);\n    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    for\
    \ i in 0..k {\n        max_arr.push(max_arr[i]);\n    }\n    for i in 0..k {\n\
    \        max_arr.push(max_arr[i]);\n    }\n    for i in 0..k {\n        max_arr.push(max_arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr.push(\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpsf4a7a34.rs:134:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    117 |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n118 |         max_arr.push(\n119 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n134 | }\n    |   ^\n\nerror:\
    \ mismatched closing delimiter: `}`\n   --> /tmp/tmpsf4a7a34.rs:118:21\n    |\n\
    16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |           \
    \                                          - closing delimiter possibly meant\
    \ for this\n...\n118 |         max_arr.push(\n    |                     ^ unclosed\
    \ delimiter\n119 | }\n    | ^ mismatched closing delimiter\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpsf4a7a34.rs:19:22\n\
    \   |\n19 |         max_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpsf4a7a34.rs:22:22\n   |\n22 |  \
    \       max_arr.push(max_arr[i]);\n   |                      ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpsf4a7a34.rs:25:22\n   |\n25 |         max_arr.push(max_arr[i]);\n\
    \   |                      ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `isize`\n   = h"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let mut j = i;\n        while j <\
    \ arr.len() {\n            if arr[j] < max_arr[j][0] {\n                max_arr[j][0]\
    \ = arr[j];\n            }\n            if arr[j] > max_arr[j][1] {\n        \
    \        max_arr[j][1] = arr[j];\n            }\n            j += 1\n        }\n\
    \        if max_k == i {\n            max_arr[i] = vec![max_arr[i][0], max_arr[i][1]];\n\
    \        } else {\n            max_arr[i] = vec![max_arr[i][0], max_arr[i][1]];\n\
    \            max_k -= 1;\n        }\n        i += 1;\n    }\n    max_arr\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt7gubiwf.rs:31:21\n   |\n\
    31 |         if max_k == i {\n   |                     ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n31 |         if max_k == i.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt7gubiwf.rs:39:5\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n39 |     max_arr\n   |  \
    \   ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<Vec<isize>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_k = k;\n    let mut max_element = arr[0];\n\
    \    for element in arr.iter() {\n        if element > max_element {\n       \
    \     max_element = element;\n        }\n    }\n    while max_k > 0 && max_k >\
    \ max_arr.len() {\n        max_arr.push(max_element);\n        max_k -= 1;\n \
    \       for element in arr.iter() {\n            if element > max_element {\n\
    \                max_element = element;\n            }\n        }\n    }\n   \
    \ max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvf0nres_.rs:21:22\n   |\n\
    21 |         if element > max_element {\n   |                      ^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ `isize`\n   |                      help: consider borrowing here: `&max_element`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvf0nres_.rs:22:27\n   |\n19 |\
    \     let mut max_element = arr[0];\n   |                           ------ expected\
    \ due to this value\n...\n22 |             max_element = element;\n   |      \
    \                     ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |             max_element = *element;\n \
    \  |                           +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvf0nres_.rs:25:32\n\
    \   |\n25 |     while max_k > 0 && max_k > max_arr.len() {\n   |             \
    \                   ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |     while max_k > 0 && max_k > max_arr.len().try_into().unwrap()\
    \ {\n   |                                             ++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpvf0nres_.rs:29:26\n   |\n29 |  \
    \           if element > max_element {\n   |                          ^^^^^^^^^^^\n\
    \   |                          |\n   |                          expected `&isize`,\
    \ found `isize`\n   |                          help: consider borrowing here:\
    \ `&max_element`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvf0nres_.rs:30:31\n\
    \   |\n19 |     let mut max_element = arr[0];\n   |                          \
    \ ------ expected due to this value\n...\n30 |                 max_element = element;\n\
    \   |                               ^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n30 |                 max_element\
    \ = *element;\n   |                               +\n\nerror: aborting due to\
    \ 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![]; k];\n    for i in 0..k {\n        max_arr[i] = arr\n\
    \            .iter()\n            .enumerate()\n            .filter(|(_, elem)|\
    \ elem > 0)\n            .map(|(_, elem)| elem)\n            .collect::<Vec<_>>();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2lfwfhn9.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp2lfwfhn9.rs:19:9\n   |\n19 |         max_arr[i]\
    \ = arr\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2lfwfhn9.rs:22:40\n\
    \   |\n22 |             .filter(|(_, elem)| elem > 0)\n   |                  \
    \                      ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2lfwfhn9.rs:26:5\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n26 |     max_arr\n   |  \
    \   ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<Vec<_>>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        let mut\
    \ max_val = -1000isize;\n        for j in 0..arr.len() {\n            if arr[j]\
    \ > max_val {\n                max_val = arr[j];\n            }\n        }\n \
    \       max_arr.push(vec![max_val]);\n    }\n    max_arr.push(vec![-1000, 1000]);\n\
    \    max_arr.sort_by_key(|x| x.0);\n    max_arr.iter().cloned().collect()\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0609]: no field `0` on type `&Vec<isize>`\n  --> /tmp/tmp3csa2bd5.rs:28:31\n\
    \   |\n28 |     max_arr.sort_by_key(|x| x.0);\n   |                          \
    \     ^ unknown field\n\nerror[E0277]: a value of type `Vec<isize>` cannot be\
    \ built from an iterator over elements of type `Vec<isize>`\n    --> /tmp/tmp3csa2bd5.rs:29:29\n\
    \     |\n29   |     max_arr.iter().cloned().collect()\n     |                \
    \             ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=Vec<isize>>`\n\
    \     |\n     = help: the trait `FromIterator<Vec<isize>>` is not implemented\
    \ for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0609.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![-1000, 1000];\n    }\n    for i in 0..arr.len() {\n        let mut max_i\
    \ = i;\n        let mut max_val = arr[i];\n        for j in 0..k {\n         \
    \   if max_arr[j][0] > max_val {\n                max_i = j;\n               \
    \ max_val = max_arr[j][1];\n            }\n        }\n        max_arr[i][2] =\
    \ max_val;\n    }\n    max_arr.iter().map(|x| x.reverse()).collect()\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpsg91is1i.rs:19:9\n   |\n19 |         max_arr[i] = vec![-1000, 1000];\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpsg91is1i.rs:25:16\n   |\n25 |         \
    \    if max_arr[j][0] > max_val {\n   |                ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsg91is1i.rs:26:25\n   |\n22 |         let mut max_i = i;\n   |\
    \                         - expected due to this value\n...\n26 |            \
    \     max_i = j;\n   |                         ^ expected `usize`, found `isize`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpsg91is1i.rs:27:27\n   |\n27 |                 max_val = max_arr[j][1];\n\
    \   |                           ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `()`\n    --> /tmp/tmpsg91is1i.rs:32:41\n\
    \     |\n32   |     max_arr.iter().map(|x| x.reverse()).collect()\n     |    \
    \                                     ^^^^^^^ value of type `Vec<isize>` cannot\
    \ b"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n  \
    \  }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmphemhd23f.rs:101:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    84  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n85  |         max_arr[i] = max_arr[i].iter().\n86  |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n101\
    \ | }\n    |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmphemhd23f.rs:86:1\n\
    \   |\n86 | }\n   | ^\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmphemhd23f.rs:19:9\n   |\n19 |         max_arr[i] =\
    \ max_arr[i].iter().max().unwrap();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmphemhd23f.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = max_arr[i].iter().max().unwrap();\n   |                 \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmphemhd23f.rs:22:9\n   |\n22 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<i"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000]; k];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![arr[i]; 1];\n    }\n    for i in 0..k {\n        max_arr[i].sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_unstable();\n\
    \    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmprhyguwu9.rs:89:3\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                               - unclosed delimiter\n...\n72\
    \ |     for i in 0..k {\n   |                   - this delimiter might not be\
    \ properly closed...\n73 |         max_arr[i].iter().cloned().\n74 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n89 | }\n   |  \
    \ ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmprhyguwu9.rs:74:1\n   |\n74\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprhyguwu9.rs:17:41\n\
    \   |\n17 |     let mut max_arr = vec![vec![-1000]; k];\n   |                \
    \                         ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n17 |     let mut max_arr = vec![vec![-1000]; k.try_into().unwrap()];\n\
    \   |                                          ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmprhyguwu9.rs:19:9\n\
    \   |\n19 |         max_arr[i] = vec![arr[i]; 1];\n   |         ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmprhyguwu9.rs:19:27\n\
    \   |\n19 |         max_arr[i] = vec![arr[i]; 1];\n   |                      \
    \     ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n  \
    \ = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   =\
    \ help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmprhyguwu9.rs:22:9\n   |\n22 |      "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in (i + 1)..k {\n            if max_arr[j]\
    \ > max_arr[i] {\n                max_arr[j] = max_arr[i];\n            }\n  \
    \      }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz9oknyfe.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpz9oknyfe.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpz9oknyfe.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpz9oknyfe.rs:23:16\n   |\n23 |  \
    \           if max_arr[j] > max_arr[i] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpz9oknyfe.rs:23:29\n   |\n23 |             if max_arr[j] > max_arr[i]\
    \ {\n   |                             ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..arr.len() {\n\
    \        max_arr[k][i] = if arr[i] > max_arr[k][i].iter().max().unwrap() {\n \
    \           max_arr[k][i]\n        } else {\n            arr[i]\n        };\n\
    \    }\n    max_arr[k].iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpz1pqhlb9.rs:19:9\n   |\n19 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpz1pqhlb9.rs:19:22\n   |\n19 |         max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpz1pqhlb9.rs:22:9\n   |\n22 |         max_arr[k][i] = if arr[i] > max_arr[k][i].iter().max().unwrap()\
    \ {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpz1pqhlb9.rs:22:37\n   |\n22 |         max_arr[k][i]\
    \ = if arr[i] > max_arr[k][i].iter().max().unwrap() {\n   |                  \
    \                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requireme"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in (i + 1)..k {\n            if max_arr[i]\
    \ > max_arr[j] {\n                max_arr[i] = max_arr[j];\n            }\n  \
    \      }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzk61n0m2.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpzk61n0m2.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpzk61n0m2.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpzk61n0m2.rs:23:16\n   |\n23 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpzk61n0m2.rs:23:29\n   |\n23 |             if max_arr[i] > max_arr[j]\
    \ {\n   |                             ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = max_arr[i].max(arr[i]);\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqgl37byr.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpqgl37byr.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = max_arr[i].max(arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpqgl37byr.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = max_arr[i].max(arr[i]);\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqgl37byr.rs:19:37\n\
    \   |\n19 |         max_arr[i] = max_arr[i].max(arr[i]);\n   |               \
    \                      ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqgl37byr.rs:21:5\n   |\n16 | fn\
    \ maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![]; k];\n    for i in 0..k {\n        max_arr[i] = vec![arr[i];\
    \ 1];\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > max_arr[i][j + 1] {\n                max_arr[i][j] = max_arr[i][j + 1];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > arr[i] {\n                max_arr[i][j] = arr[i];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > arr[j] {\n                max_arr[i][j] = arr[j];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > arr[j] {\n                max_arr[i][j] = arr[j];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > arr[j] {\n                max_arr[i][j] = arr[j];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > arr[j] {\n                max_arr[i][j] = arr[j];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > arr[j] {\n                max_arr[i][j] = arr[j];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > arr[j] {\n                max_arr[i][j] = arr[j];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > arr[j] {\n                max_arr[i][j] = arr[j];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > arr[j] {\n                max_arr[i][j] = arr[j];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > arr[j] {\n                max_arr[i][j] = arr[j];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > arr[j] {\n                max_arr[i][j] = arr[j];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > arr[j] {\n                max_arr[i][j] = arr[j];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0.\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpan8r_0o8.rs:129:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n113 |         for j in 0.\n114 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n129 | }\n    |   ^\n\nerror:\
    \ expected `{`, found `}`\n   --> /tmp/tmpan8r_0o8.rs:114:1\n    |\n114 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpan8r_0o8.rs:17:36\n\
    \   |\n17 |     let mut max_arr = vec![vec![]; k];\n   |                     \
    \               ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |        \
    \                             ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpan8r_0o8.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = vec![arr[i]; 1];\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpan8r_0o8.rs:19:27\n   |\n19 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpan8r_0o8.rs:23:16\n   |\n23 |         \
    \    if max_arr[i][j] > max_arr[i"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0; k]; arr.len()];\n    for i in 0..arr.len() {\n  \
    \      max_arr[i][arr[i]] = 1;\n    }\n    for i in 0..k {\n        max_arr[i][arr[i]]\
    \ = 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..k {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..k {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..k {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..k {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..k {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..k {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..k {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..k {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..k {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..k {\n        max_arr[i][arr[i]] = max_arr[i][arr[i]]\
    \ + 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][arr[i]] = \n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpkttvkjyx.rs:101:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    84  |     for i in 0..arr.len() {\n    |                           - this delimiter\
    \ might not be properly closed...\n85  |         max_arr[i][arr[i]] = \n86  |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n101\
    \ | }\n    |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpkttvkjyx.rs:86:1\n\
    \   |\n86 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkttvkjyx.rs:17:36\n   |\n17 |     let mut max_arr = vec![vec![0;\
    \ k]; arr.len()];\n   |                                    ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     let mut max_arr = vec![vec![0;\
    \ k.try_into().unwrap()]; arr.len()];\n   |                                  \
    \   ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpkttvkjyx.rs:19:9\n   |\n19 |         max_arr[i][arr[i]]\
    \ = 1;\n   |         ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpkttvkjyx.rs:22:9\n   |\n22 |         max_arr[i][arr[i]]\
    \ = 1;\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..arr.len() {\n\
    \        max_arr[i][arr[i]] = arr[i];\n    }\n    max_arr.iter().cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpbq288wba.rs:19:9\n   |\n19 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpbq288wba.rs:19:22\n   |\n19 |         max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpbq288wba.rs:22:9\n\
    \   |\n22 |         max_arr[i][arr[i]] = arr[i];\n   |         ^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbq288wba.rs:24:5\n   |\n16 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n24 |\
    \     max_arr.iter().cloned().collect::<Vec<_>>()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Vec<{integer}>>`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detaile"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = max_arr[i].max(arr[i]);\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdjblikli.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpdjblikli.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = max_arr[i].max(arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpdjblikli.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = max_arr[i].max(arr[i]);\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpdjblikli.rs:19:37\n\
    \   |\n19 |         max_arr[i] = max_arr[i].max(arr[i]);\n   |               \
    \                      ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdjblikli.rs:21:5\n   |\n16 | fn\
    \ maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = max_arr[i].max(arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx82p6ada.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpx82p6ada.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = max_arr[i].max(arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpx82p6ada.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = max_arr[i].max(arr[i]);\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpx82p6ada.rs:19:37\n\
    \   |\n19 |         max_arr[i] = max_arr[i].max(arr[i]);\n   |               \
    \                      ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpx82p6ada.rs:22:9\n   |\n22 |         max_arr[i] = "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_k = k;\n    let mut max_i = arr.len();\n\
    \    while max_i < max_k {\n        let mut max_val = arr[0];\n        let mut\
    \ max_pos = 0;\n        for i in 1..max_i {\n            if arr[i] > max_val {\n\
    \                max_val = arr[i];\n                max_pos = i;\n           \
    \ }\n        }\n        max_arr.push(max_val);\n        max_i = max_pos;\n   \
    \ }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1rx0h_5h.rs:20:19\n   |\n\
    20 |     while max_i < max_k {\n   |                   ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        let mut\
    \ max_val = -1000isize;\n        for j in 0..arr.len() {\n            if arr[j]\
    \ > max_val {\n                max_val = arr[j];\n            }\n        }\n \
    \       max_arr[i] = vec![max_val];\n    }\n    max_arr\n}\n\nfn main() {\n  \
    \  let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpd2ef1t5e.rs:25:9\n   |\n25 |         max_arr[i] = vec![max_val];\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd2ef1t5e.rs:27:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n27 |     max_arr\n   |     ^^^^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<Vec<{integer}>>`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    let mut max_idx = k;\n    for &i in arr\
    \ {\n        if i >= 0 {\n            max_arr[k - 1].push(i);\n            if\
    \ k == 1 {\n                max_idx = 1;\n            }\n            k -= 1;\n\
    \        }\n    }\n    for i in 0..max_idx {\n        max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3_3a3og2.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3_3a3og2.rs:19:9\n   |\n19 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp3_3a3og2.rs:21:13\n   |\n21 |  \
    \           max_arr[k - 1].push(i);\n   |             ^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp3_3a3og2.rs:29:9\n   |\n29 |   \
    \      max_arr[i] = max_arr[i].iter().max().unwrap();\n   |         ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp3_3a3og2.rs:29:22\n   |\n29 |         max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \   |                      ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = h"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![vec![0]; k];\n    let mut max_val = arr[0];\n    let mut max_idx\
    \ = 1;\n    for i in 1..k {\n        if arr[i] > max_val {\n            max_val\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    for i in 0..k {\n\
    \        result[max_idx].push(arr[i]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcz8xob7k.rs:17:36\n   |\n\
    17 |     let mut result = vec![vec![0]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut result = vec![vec![0]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpcz8xob7k.rs:21:12\n   |\n21 |         if\
    \ arr[i] > max_val {\n   |            ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpcz8xob7k.rs:22:23\n   |\n22 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpcz8xob7k.rs:27:9\n   |\n27 |   \
    \      result[max_idx].push(arr[i]);\n   |         ^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpcz8xob7k.rs:27:30\n   |\n27 |  \
    \       result[max_idx].push(arr[i]);\n   |                              ^^^^^^\
    \ slice indices are of type `usize` or rang"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..k {\n      \
    \  arr[i] = max_arr[i].iter().max().unwrap();\n    }\n    for i in 0..k {\n  \
    \      arr[i] = arr[i].iter().cloned().collect();\n    }\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpehljpjtt.rs:19:9\n   |\n19 |         max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpehljpjtt.rs:19:22\n   |\n19 |         max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n   |                      ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpehljpjtt.rs:22:9\n   |\n22 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpehljpjtt.rs:22:22\n   |\n22 |         max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integ"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0; k]; arr.len()];\n    for i in 0..arr.len() {\n  \
    \      max_arr[i][arr[i]] = 1;\n    }\n    for i in 0..k {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ += 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ -= 1;\n    }\n    for i in 0..k {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ += 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ -= 1;\n    }\n    for i in 0..k {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ += 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ -= 1;\n    }\n    for i in 0..k {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ += 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ -= 1;\n    }\n    for i in 0..k {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ += 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ -= 1;\n    }\n    for i in 0..k {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ += 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ -= 1;\n    }\n    for i in 0..k {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ += 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ -= 1;\n    }\n    for i in 0..k {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ += 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ -= 1;\n    }\n    for i in 0..k {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ += 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ -= 1;\n    }\n    for i in 0..k {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ += 1;\n    }\n    for i in 0..arr.len() {\n        max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ -= 1;\n    }\n    for i in 0..k {\n        max_arr[i][\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpg64dpfey.rs:98:3\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                               - unclosed delimiter\n...\n81\
    \ |     for i in 0..k {\n   |                   - this delimiter might not be\
    \ properly closed...\n82 |         max_arr[i][\n83 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n98 | }\n   |   ^\n\nerror: expected\
    \ expression, found `]`\n  --> /tmp/tmpg64dpfey.rs:83:1\n   |\n83 | }\n   | ^\
    \ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpg64dpfey.rs:82:19\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                               - closing delimiter possibly meant\
    \ for this\n...\n82 |         max_arr[i][\n   |                   ^ unclosed delimiter\n\
    83 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpg64dpfey.rs:17:36\n   |\n17 |     let mut max_arr = vec![vec![0;\
    \ k]; arr.len()];\n   |                                    ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     let mut max_arr = vec![vec![0;\
    \ k.try_into().unwrap()]; arr.len()];\n   |                                  \
    \   ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpg64dpfey.rs:19:9\n   |\n19 |         max_arr[i][arr[i]]\
    \ = 1;\n   |         ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpg64dpfey.rs:22:9\n   |\n22 |         max_arr[i][max_arr[i].iter().max().unwrap()]\
    \ += 1;\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ra"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![0; k];\n    let mut max_idx = k;\n    for &i in arr {\n \
    \       if i > max_arr[k] {\n            max_arr[k] = i;\n            max_idx\
    \ += 1;\n        }\n    }\n    max_arr.sort_unstable();\n    max_arr.truncate(max_idx);\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0k0hv8sq.rs:17:31\n   |\n\
    17 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0k0hv8sq.rs:19:9\n   |\n19 | \
    \    for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp0k0hv8sq.rs:20:16\n   |\n20 |  \
    \       if i > max_arr[k] {\n   |                ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp0k0hv8sq.rs:21:13\n   |\n21 |  \
    \           max_arr[k] = i;\n   |             ^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0k0hv8sq.rs:26:22\n   |\n26 |     max_arr.truncate(max_idx);\n   | \
    \                     ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n26 |     max_arr.truncate(max_idx.try_into().unwrap());\n   |   \
    \                      "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_num = arr[0];\n    for i in 0..k {\n\
    \        if max_num < arr[i] {\n            max_num = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if max_num < arr[i] {\n            max_arr.push(max_num);\n\
    \        }\n    }\n    for i in 0..k {\n        if max_num < arr[i] {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpl70egjos.rs:20:22\n\
    \   |\n20 |         if max_num < arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpl70egjos.rs:21:23\n   |\n21 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpl70egjos.rs:25:22\n   |\n25 |         if max_num\
    \ < arr[i] {\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpl70egjos.rs:30:22\n   |\n30 |         if max_num\
    \ < arr[i] {\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpl70egjos.rs:31:26\n   |\n31 |            \
    \ max_arr.push(arr[i]);\n   |                          ^^^^^^ slice indices are\
    \ of"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0; k]; arr.len()];\n    for i in 0..arr.len() {\n  \
    \      for j in 0..k {\n            if arr[i] > max_arr[j][k] {\n            \
    \    max_arr[j][k] = arr[i];\n            }\n        }\n    }\n    for i in 0..k\
    \ {\n        for j in 0..arr.len() {\n            if max_arr[i][j] == 0 {\n  \
    \              max_arr[i][j] = max_arr[j][i];\n            }\n        }\n    }\n\
    \    for i in 0..k {\n        for j in 0..arr.len() {\n            if max_arr[i][j]\
    \ > max_arr[j][i] {\n                max_arr[j][i] = max_arr[i][j];\n        \
    \    }\n        }\n    }\n    for i in 0..k {\n        for j in 0..arr.len() {\n\
    \            if max_arr[i][j] > max_arr[j][i] {\n                max_arr[j][i]\
    \ = max_arr[i][j];\n            }\n        }\n    }\n    for i in 0..k {\n   \
    \     for j in 0..arr.len() {\n            if max_arr[i][j] > max_arr[j][i] {\n\
    \                max_arr[j][i] = max_arr[i][j];\n            }\n        }\n  \
    \  }\n    for i in 0..k {\n        for j in 0..arr.len() {\n            if max_arr[i][j]\
    \ > max_arr[j][i] {\n                max_arr[j][i] = max_arr[i][j];\n        \
    \    }\n        }\n    }\n    for i in 0..k {\n        for j in 0..arr.len() {\n\
    \            if max_arr[i][j] > max_arr[j][i] {\n                max_arr[j][i]\
    \ = max_arr[i][j];\n            }\n        }\n    }\n    for i in 0..k {\n   \
    \     for j in 0..arr.len() {\n            if max_arr[i][j] > max_arr[j][i] {\n\
    \                max_arr[j][i] = max_arr[i][j];\n            }\n        }\n  \
    \  }\n    for i in 0..k {\n        for j in 0..arr.len() {\n            if max_arr[i][j]\
    \ > max_arr[j][i] {\n                max_arr[j][i] = max_arr[i][j];\n        \
    \    }\n        }\n    }\n    for i in 0..k {\n        for j in 0..arr.len() {\n\
    \            if max_arr[i][j] > max_arr[j][i] {\n                max_arr[j][i]\
    \ = max_arr[i][j];\n            }\n        }\n    }\n    for i in 0..k {\n   \
    \     for j in 0..arr.len() {\n            if max_arr[i][j] > max_arr[j][i] {\n\
    \                max_arr[j][i] = max_arr[i][j];\n            }\n        }\n  \
    \  }\n    for i in 0..k {\n        for j in 0..arr.len() {\n            if max_arr[i][j]\
    \ > max_arr[j][i] {\n                max_arr[j][i] = max_arr[i][j];\n        \
    \    }\n        }\n    }\n    for i in 0..k {\n        for j in 0..arr.len() {\n\
    \            if max_arr[i][j] > max_\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpodb6r1vq.rs:120:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    102 |     for i in 0..k {\n    |                   - unclosed delimiter\n103 |\
    \         for j in 0..arr.len() {\n    |                               - this\
    \ delimiter might not be properly closed...\n104 |             if max_arr[i][j]\
    \ > max_\n105 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n120 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpodb6r1vq.rs:105:1\n\
    \    |\n104 |             if max_arr[i][j] > max_\n    |             -- this `if`\
    \ expression has a condition, but no block\n105 | }\n    | ^ expected `{`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpodb6r1vq.rs:17:36\n   |\n17 |  \
    \   let mut max_arr = vec![vec![0; k]; arr.len()];\n   |                     \
    \               ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k.try_into().unwrap()]; arr.len()];\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpodb6r1vq.rs:20:25\n\
    \   |\n20 |             if arr[i] > max_arr[j][k] {\n   |                    \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpodb6r1vq.rs:21:17\n   |\n21 |                 max_arr[j][k] = arr[i];\n\
    \   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![0; k];\n    for i in 0..arr.len() {\n        if arr[i] >\
    \ max_arr[k] {\n            max_arr[k] = arr[i];\n        }\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3yoy37np.rs:17:31\n   |\n\
    17 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp3yoy37np.rs:19:21\n\
    \   |\n19 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp3yoy37np.rs:20:13\n\
    \   |\n20 |             max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![0; k];\n    let mut max_so_far = arr[0];\n    for i in 1..k\
    \ {\n        if arr[i] > max_so_far {\n            max_so_far = arr[i];\n    \
    \    }\n    }\n    for i in 0..k {\n        result[i] = max_so_far;\n        max_so_far\
    \ = max_so_far - arr[i];\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpegxa5bdh.rs:17:30\n   |\n\
    17 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpegxa5bdh.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_so_far {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpegxa5bdh.rs:21:26\n   |\n21 |            \
    \ max_so_far = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpegxa5bdh.rs:25:9\n   |\n25 |         result[i]\
    \ = max_so_far;\n   |         ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmpegxa5bdh.rs:26:35\n   |\n26 |         max_so_far = max_so_far\
    \ - arr[i];\n   |                                   ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_so_far = vec![vec![0]; k];\n    let mut max_so_far_iter = max_so_far.iter();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&v| v + 1).collect::<Vec<_>>();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&v| v - 1).collect::<Vec<_>>();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&v| v + 1).collect::<Vec<_>>();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&v| v - 1).collect::<Vec<_>>();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&v| v + 1).collect::<Vec<_>>();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&v| v - 1).collect::<Vec<_>>();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&v| v + 1).collect::<Vec<_>>();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&v| v - 1).collect::<Vec<_>>();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&v| v + 1).collect::<Vec<_>>();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&v| v - 1).collect::<Vec<_>>();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&v| v + 1).collect::<Vec<_>>();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&v| v - 1).collect::<Vec<_>>();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&v| v + 1).collect::<Vec<_>>();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&v| v - 1).collect::<Vec<_>>();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&v| v + 1).collect::<Vec<_>>();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&v| v - 1).collect::<Vec<_>>();\n\
    \    let mut max_so_far_iter = max_so_far_iter.map(|&\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpcrbkx9y8.rs:35:50\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                               - closing delimiter possibly meant\
    \ for this\n...\n35 |     let mut max_so_far_iter = max_so_far_iter.map(|&\n \
    \  |                                                  ^ unclosed delimiter\n36\
    \ | }\n   | ^ mismatched closing delimiter\n\nerror: expected parameter name,\
    \ found `)`\n  --> /tmp/tmpcrbkx9y8.rs:36:1\n   |\n36 | }\n   | ^ expected parameter\
    \ name\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcrbkx9y8.rs:17:40\n  \
    \ |\n17 |     let mut max_so_far = vec![vec![0]; k];\n   |                   \
    \                     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max_so_far = vec![vec![0]; k.try_into().unwrap()];\n   |    \
    \                                     ++++++++++++++++++++\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Vec<{integer}>`\n  --> /tmp/tmpcrbkx9y8.rs:19:58\n   |\n\
    19 |     let mut max_so_far_iter = max_so_far_iter.map(|&v| v + 1).collect::<Vec<_>>();\n\
    \   |                                                        - ^ - {integer}\n\
    \   |                                                        |\n   |         \
    \                                               Vec<{integer}>\n\nerror[E0599]:\
    \ `Vec<_>` is not an iterator\n   --> /tmp/tmpcrbkx9y8.rs:20:47\n    |\n20  |\
    \       let mut max_so_far_iter = max_so_far_iter.map(|&v| v - 1).collect::<Vec<_>>();\n\
    \    |                                                 ^^^ `Vec<_>` is not an\
    \ iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<_>: Iterator`\n            which is required by `&mut Vec<_>:\
    \ Iterator`\n            `[_]: Iterator`\n            which is required by `&mut\
    \ [_]: Iterator`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0369, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_num = arr[0];\n    for i in 1..k {\n\
    \        if max_num < arr[i] {\n            max_num = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if max_num < arr[i] {\n            max_arr.push(max_num);\n\
    \        }\n        max_arr.push(arr[i]);\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4bsq4cuc.rs:20:22\n\
    \   |\n20 |         if max_num < arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4bsq4cuc.rs:21:23\n   |\n21 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp4bsq4cuc.rs:25:22\n   |\n25 |         if max_num\
    \ < arr[i] {\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp4bsq4cuc.rs:28:22\n   |\n28 |         max_arr.push(arr[i]);\n\
    \   |                      ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_num = arr[0];\n    for i in 1..k {\n\
    \        if arr[i] > max_num {\n            max_num = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(max_num);\n\
    \            max_num = arr[i];\n        }\n    }\n    max_arr.push(max_num);\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpahlsu08c.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpahlsu08c.rs:21:23\n   |\n21 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpahlsu08c.rs:25:12\n   |\n25 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpahlsu08c.rs:27:23\n   |\n27 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[j]\
    \ < max_arr[i] {\n                max_arr[i] = max_arr[j];\n            }\n  \
    \      }\n    }\n    for i in 0..k {\n        arr[i] = max_arr[i];\n    }\n  \
    \  arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0hjtgcr8.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp0hjtgcr8.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp0hjtgcr8.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp0hjtgcr8.rs:23:16\n   |\n23 |  \
    \           if max_arr[j] < max_arr[i] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp0hjtgcr8.rs:23:29\n   |\n23 |             if max_arr[j] < max_arr[i]\
    \ {\n   |                             ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n  \
    \  }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjh_xyck5.rs:101:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    84  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n85  |         max_arr[i] = max_arr[i].iter().\n86  |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n101\
    \ | }\n    |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpjh_xyck5.rs:86:1\n\
    \   |\n86 | }\n   | ^\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpjh_xyck5.rs:19:9\n   |\n19 |         max_arr[i] =\
    \ max_arr[i].iter().max().unwrap();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpjh_xyck5.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = max_arr[i].iter().max().unwrap();\n   |                 \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpjh_xyck5.rs:22:9\n   |\n22 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<i"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ max_idx = 0;\n    let mut min_idx = 0;\n    let mut min_val = arr[0];\n    let\
    \ mut max_val = arr[0];\n    let mut min_idx = 0;\n    let mut max_idx = 0;\n\
    \    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    for &i in arr\
    \ {\n        if i < min_val {\n            min_val = i;\n            min_idx =\
    \ i;\n        }\n        if i > max_val {\n            max_val = i;\n        \
    \    max_idx = i;\n        }\n    }\n    while max_k > 0 {\n        if max_k ==\
    \ 1 {\n            max_arr.push(max_val);\n            break;\n        }\n   \
    \     if min_idx < max_idx {\n            max_arr.push(max_val);\n           \
    \ max_k -= 1;\n        } else {\n            min_idx += 1;\n            max_arr.push(min_val);\n\
    \            max_k -= 1;\n        }\n    }\n    max_arr\n}\n\nfn main() {\n  \
    \  let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzdg6f9no.rs:27:9\n   |\n\
    27 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzdg6f9no.rs:39:26\n   |\n39 |             max_arr.push(max_val);\n\
    \   |                          ^^^^^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<{integer}>`\n                found type\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzdg6f9no.rs:43:26\n\
    \   |\n43 |             max_arr.push(max_val);\n   |                         \
    \ ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct\
    \ `Vec<{integer}>`\n                found type `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzdg6f9no.rs:47:26\n   |\n47 |             max_arr.push(min_val);\n\
    \   |                          ^^^^^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<{integer}>`\n                found type\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzdg6f9no.rs:51:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n51 |     max_arr\n   |     ^^^^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<Vec<{integer}>>`\n\nerror: aborting due to 5 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..arr.len() {\n\
    \        let mut max_i = i;\n        for j in 0..k {\n            if arr[i] >\
    \ max_arr[j][max_i] {\n                max_i = j;\n            }\n        }\n\
    \        max_arr[k][max_i] = arr[i];\n    }\n    max_arr[k].iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpzsh1qm5e.rs:19:9\n   |\n19 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpzsh1qm5e.rs:19:22\n   |\n19 |         max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpzsh1qm5e.rs:24:25\n   |\n24 |             if arr[i] > max_arr[j][max_i]\
    \ {\n   |                         ^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzsh1qm5e.rs:25:25\n   |\n22 |         let mut max_i = i;\n   |\
    \                         - expected due to this value\n...\n25 |            \
    \     max_i = j;\n   |                         ^ expected `usize`, found `isize`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpzsh1qm5e.rs:28:9\n   |\n28 |         max_arr[k][max_i] = arr[i];\n \
    \  |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ max_pos = 0;\n    let mut max_val = -1000isize;\n    for ele in arr {\n    \
    \    if ele > max_val {\n            max_val = ele;\n            max_pos = 0;\n\
    \        }\n        if ele > max_arr[max_pos][max_k] {\n            max_arr[max_pos][max_k]\
    \ = ele;\n            max_k -= 1;\n        }\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpv3kgc8wn.rs:26:18\n   |\n26 |         if ele > max_arr[max_pos][max_k]\
    \ {\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpv3kgc8wn.rs:27:13\n   |\n27 |  \
    \           max_arr[max_pos][max_k] = ele;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv3kgc8wn.rs:31:5\n   |\n16 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n31 |\
    \     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected struct `Vec<isize>`\n              found struct `Vec<Vec<{integer}>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[j]\
    \ > max_arr[j + 1] {\n                max_arr[j] = max_arr[j + 1];\n         \
    \   }\n        }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz68r8irp.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpz68r8irp.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpz68r8irp.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpz68r8irp.rs:23:16\n   |\n23 |  \
    \           if max_arr[j] > max_arr[j + 1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpz68r8irp.rs:23:29\n   |\n23 |             if max_arr[j] > max_arr[j\
    \ + 1] {\n   |                        "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..k {\n      \
    \  max_arr[i].sort_unstable_by(|a, b| a.cmp(b));\n    }\n    for i in 0..k {\n\
    \        max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n    for i\
    \ in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpcwdmtr_6.rs:101:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    84  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n85  |         max_arr[i] = max_arr[i].\n86  | }\n   \
    \ | - ...as it matches this but it has different indentation\n...\n101 | }\n \
    \   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpcwdmtr_6.rs:86:1\n  \
    \ |\n86 | }\n   | ^\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpcwdmtr_6.rs:19:9\n   |\n19 |         max_arr[i] =\
    \ max_arr[i].iter().cloned().collect();\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpcwdmtr_6.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = max_arr[i].iter().cloned().collect();\n   |             \
    \         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpcwdmtr_6.rs:22:9\n   |\n22 |         max_arr[i].sort_unstable_by(|a,\
    \ b| a.cmp(b));\n   |         ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_so_far = arr[0];\n    let mut max_so_far_index = 0;\n    let mut max_so_far_max\
    \ = max_so_far;\n    for &x in arr.iter() {\n        if x > max_so_far {\n   \
    \         max_so_far = x;\n            max_so_far_index = x;\n            max_so_far_max\
    \ = x;\n        }\n        if x == max_so_far {\n            if x > max_so_far_max\
    \ {\n                max_so_far_max = x;\n            }\n        }\n    }\n  \
    \  arr.iter().take(k).cloned().collect::<Vec<_>>()\n        .iter()\n        .enumerate()\n\
    \        .map(|(i, x)| (i, x))\n        .sort_by(|a, b| b.1.cmp(&a.1))\n     \
    \   .map(|(i, x)| x.1)\n        .collect::<Vec<_>>()\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb9a28tlm.rs:32:21\n   |\n\
    32 |     arr.iter().take(k).cloned().collect::<Vec<_>>()\n   |               \
    \      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n32 |     arr.iter().take(k.try_into().unwrap()).cloned().collect::<Vec<_>>()\n\
    \   |                      ++++++++++++++++++++\n\nerror[E0599]: no method named\
    \ `sort_by` found for struct `Map` in the current scope\n  --> /tmp/tmpb9a28tlm.rs:36:10\n\
    \   |\n36 |         .sort_by(|a, b| b.1.cmp(&a.1))\n   |          ^^^^^^^ method\
    \ not found in `Map<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpb9a28tlm.rs:35:14:\
    \ 35:29]>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n  \
    \  }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpg0vr16cs.rs:101:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    84  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n85  |         max_arr[i] = max_arr[i].iter().\n86  |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n101\
    \ | }\n    |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpg0vr16cs.rs:86:1\n\
    \   |\n86 | }\n   | ^\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpg0vr16cs.rs:19:9\n   |\n19 |         max_arr[i] =\
    \ max_arr[i].iter().max().unwrap();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpg0vr16cs.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = max_arr[i].iter().max().unwrap();\n   |                 \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpg0vr16cs.rs:22:9\n   |\n22 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<i"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![vec![0]; k];\n    for i in 0..k {\n        result[i] = arr\n\
    \            .iter()\n            .max_by_key(|x| x.clone())\n            .unwrap()\n\
    \            .cloned()\n            .unwrap();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0p2r5dy9.rs:17:36\n   |\n\
    17 |     let mut result = vec![vec![0]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut result = vec![vec![0]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp0p2r5dy9.rs:19:9\n   |\n19 |   \
    \      result[i] = arr\n   |         ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0599]: `&isize` is not an\
    \ iterator\n  --> /tmp/tmp0p2r5dy9.rs:23:14\n   |\n23 |             .cloned()\n\
    \   |              ^^^^^^ `&isize` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `&isize: Iterator`\n          \
    \ which is required by `&mut &isize: Iterator`\n           `isize: Iterator`\n\
    \           which is required by `&mut isize: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0p2r5dy9.rs:26:5\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n26 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<Vec<{integer}>>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[j]\
    \ > max_arr[j + i] {\n                max_arr[j] = max_arr[j + i];\n         \
    \   }\n        }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpik99os52.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpik99os52.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpik99os52.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpik99os52.rs:23:16\n   |\n23 |  \
    \           if max_arr[j] > max_arr[j + i] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpik99os52.rs:23:29\n   |\n23 |             if max_arr[j] > max_arr[j\
    \ + i] {\n   |                        "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let mut j = i;\n        while j <\
    \ arr.len() && arr[j] > max_arr[j].0 {\n            max_arr[j].0 = max_arr[j].1;\n\
    \            j += 1\n        }\n        if j - i > max_k {\n            max_k\
    \ = j - i;\n        }\n        i += 1;\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `0` on type `Vec<{integer}>`\n  --> /tmp/tmpv372xct9.rs:22:52\n\
    \   |\n22 |         while j < arr.len() && arr[j] > max_arr[j].0 {\n   |     \
    \                                               ^ unknown field\n\nerror[E0609]:\
    \ no field `0` on type `Vec<{integer}>`\n  --> /tmp/tmpv372xct9.rs:23:24\n   |\n\
    23 |             max_arr[j].0 = max_arr[j].1;\n   |                        ^ unknown\
    \ field\n\nerror[E0609]: no field `1` on type `Vec<{integer}>`\n  --> /tmp/tmpv372xct9.rs:23:39\n\
    \   |\n23 |             max_arr[j].0 = max_arr[j].1;\n   |                   \
    \                    ^ unknown field\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpv372xct9.rs:26:20\n   |\n26 |         if j - i > max_k {\n   |     \
    \               ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    26 |         if j - i > max_k.try_into().unwrap() {\n   |                    \
    \     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv372xct9.rs:27:21\n\
    \   |\n18 |     let mut max_k = k;\n   |                     - expected due to\
    \ this value\n...\n27 |             max_k = j - i;\n   |                     ^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv372xct9.rs:31:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n31 |     max_arr\n   |     ^^^^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<Vec<{integer}>>`\n\nerror: aborting due to 6 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0609.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0; k]; arr.len()];\n    for i in 0..arr.len() {\n  \
    \      let mut max_num = arr[i];\n        for j in 0..k {\n            if max_num\
    \ < max_arr[i][j] {\n                max_num = max_arr[i][j];\n            }\n\
    \        }\n        max_arr[i][k - 1] = max_num;\n    }\n    max_arr\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo6su6it_.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k]; arr.len()];\n   |                \
    \                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k.try_into().unwrap()]; arr.len()];\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpo6su6it_.rs:21:26\n\
    \   |\n21 |             if max_num < max_arr[i][j] {\n   |                   \
    \       ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpo6su6it_.rs:22:27\n\
    \   |\n22 |                 max_num = max_arr[i][j];\n   |                   \
    \        ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpo6su6it_.rs:25:9\n\
    \   |\n25 |         max_arr[i][k - 1] = max_num;\n   |         ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo6su6it_.rs:27:5\n   |\n16 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |      "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_so_far = arr[0];\n    let mut max_so_far_pos = 0;\n    let mut max_so_far_neg\
    \ = 0;\n    let mut max_so_far_neg_ind = -1;\n    let mut max_so_far_neg_ind_pos\
    \ = -1;\n    let mut max_so_far_neg_ind_neg = -1;\n    for i in 0..arr.len() {\n\
    \        if arr[i] > max_so_far {\n            max_so_far = arr[i];\n        \
    \    max_so_far_pos = i;\n        }\n        if arr[i] < -max_so_far {\n     \
    \       max_so_far_neg = arr[i];\n            max_so_far_neg_ind = i;\n      \
    \  }\n        if arr[i] < -max_so_far {\n            max_so_far_neg_ind_neg =\
    \ i;\n        }\n        if arr[i] > -max_so_far {\n            max_so_far_neg_ind_pos\
    \ = i;\n        }\n    }\n    let mut max_so_far_neg_ind_neg = max_so_far_neg_ind_neg;\n\
    \    let mut max_so_far_neg_ind_pos = max_so_far_neg_ind_pos;\n    let mut max_so_far_pos\
    \ = max_so_far_pos;\n    let mut max_so_far_neg = max_so_far_neg;\n    let mut\
    \ max_so_far = max_so_far;\n    let mut max_so_far_neg_ind = max_so_far_neg_ind;\n\
    \    let mut max_so_far_neg_ind_neg = max_so_far_neg_ind_neg;\n    let mut max_so_far_neg_ind_pos\
    \ = max_so_far_neg_ind_pos;\n    let mut max_so_far_pos = max_so_far_pos;\n  \
    \  let mut max_so_far_neg = max_so_far_neg;\n    let mut max_so_far = max_so_far;\n\
    \    let mut max_so_far_neg_ind = max_so_far_neg_ind;\n    let mut max_so_far_neg_ind_neg\
    \ = max_so_far_neg_ind_neg;\n    let mut max_so_far_neg_ind_pos = max_so_far_neg_ind_pos;\n\
    \    let mut max_so_far_pos = max_so_far_pos;\n    let mut max_so_far_neg = max_so_far_neg;\n\
    \    let mut max_so_far = max_so_far;\n    let mut max_so_far_neg_ind = max_so_far_neg_ind;\n\
    \    let mut max_so_far_neg_ind_neg = max_so_far_neg_ind_neg\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4dz3isfh.rs:57:60\n   |\n\
    57 |     let mut max_so_far_neg_ind_neg = max_so_far_neg_ind_neg\n   |       \
    \                                                     ^ help: add `;` here\n58\
    \ | }\n   | - unexpected token\n\nerror[E0277]: the trait bound `usize: Neg` is\
    \ not satisfied\n  --> /tmp/tmp4dz3isfh.rs:20:34\n   |\n20 |     let mut max_so_far_neg_ind\
    \ = -1;\n   |                                  ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmp4dz3isfh.rs:22:38\n   |\n22 |     let mut max_so_far_neg_ind_neg\
    \ = -1;\n   |                                      ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmp4dz3isfh.rs:21:38\n   |\n21 |     let mut max_so_far_neg_ind_pos\
    \ = -1;\n   |                                      ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4dz3isfh.rs:16:42\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |    -------\
    \                               ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: a"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].max();\n    }\n \
    \   for i in 0..k {\n        arr[i] = max_arr[i];\n    }\n    return arr;\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgp4wrnd1.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpgp4wrnd1.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpgp4wrnd1.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpgp4wrnd1.rs:22:9\n   |\n22 |   \
    \      max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpgp4wrnd1.rs:22:22\n   |\n22 |  \
    \       max_arr[i] = max_arr[i].max();\n   |                      ^^^^^^^^^^ slice\
    \ indic"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000]; k];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![arr[i]; 1];\n    }\n    for i in 0..k {\n        for j in 0..k {\n  \
    \          if max_arr[i][j] > max_arr[i][j+1] {\n                max_arr[i][j]\
    \ = max_arr[i][j+1];\n            }\n        }\n    }\n    for i in 0..k {\n \
    \       for j in 0..k {\n            if max_arr[i][j] > arr[j] {\n           \
    \     max_arr[i][j] = arr[j];\n            }\n        }\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n  \
    \  }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpquf5a0x8.rs:106:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    89  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n90  | \n91  | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n106 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpquf5a0x8.rs:17:41\n   |\n17 |     let mut max_arr = vec![vec![-1000];\
    \ k];\n   |                                         ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     let mut max_arr = vec![vec![-1000];\
    \ k.try_into().unwrap()];\n   |                                          ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpquf5a0x8.rs:19:9\n   |\n19 |         max_arr[i] = vec![arr[i]; 1];\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpquf5a0x8.rs:19:27\n   |\n19 |         max_arr[i] =\
    \ vec![arr[i]; 1];\n   |                           ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpquf5a0x8.rs:23:16\n   |\n23 |  \
    \           if max_arr[i][j] > max_arr[i][j+1] {\n   |                ^^^^^^^^^^\
    \ slice indices are of type `"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_so_far = vec![];\n    for i in 0..k {\n\
    \        max_so_far.push(arr[i]);\n    }\n    for i in 0..arr.len() {\n      \
    \  let mut max_element = max_so_far[0];\n        for j in 0..k {\n           \
    \ if arr[i] > max_element {\n                max_element = arr[i];\n         \
    \   }\n        }\n        max_arr.push(max_element);\n    }\n    max_arr\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpv62r83ht.rs:20:25\n\
    \   |\n20 |         max_so_far.push(arr[i]);\n   |                         ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[j]\
    \ > max_arr[j + 1] {\n                max_arr[j] = max_arr[j + 1];\n         \
    \   }\n        }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp00gfaom0.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp00gfaom0.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp00gfaom0.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp00gfaom0.rs:23:16\n   |\n23 |  \
    \           if max_arr[j] > max_arr[j + 1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp00gfaom0.rs:23:29\n   |\n23 |             if max_arr[j] > max_arr[j\
    \ + 1] {\n   |                        "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ max_i = 1;\n    let mut max_j = 1;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    while i < arr.len() && j < max_k {\n        if arr[i] > arr[j] {\n      \
    \      max_arr[j] = arr[i];\n            max_k = max_k - 1;\n        } else {\n\
    \            max_arr[j] = arr[j];\n            max_k = max_k - 1;\n        }\n\
    \        i += 1;\n        j += 1;\n    }\n    while i < arr.len() {\n        max_arr[j]\
    \ = arr[i];\n        j += 1;\n        i += 1;\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp5uzi6huj.rs:24:21\n\
    \   |\n24 |         if arr[i] > arr[j] {\n   |                     ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp5uzi6huj.rs:25:13\n   |\n25 |  \
    \           max_arr[j] = arr[i];\n   |             ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp5uzi6huj.rs:28:13\n   |\n28 |  \
    \           max_arr[j] = arr[j];\n   |             ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp5uzi6huj.rs:28:26\n   |\n28 |  \
    \           max_arr[j] = arr[j];\n   |                          ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp5uzi6huj.rs:35:9\n   |\n35 |   \
    \      max_arr[j] = arr[i];\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0; k]; arr.len()];\n    for i in 0..arr.len() {\n  \
    \      for j in 0..k {\n            if arr[i] > max_arr[j][k] {\n            \
    \    max_arr[j][k] = arr[i];\n            }\n        }\n    }\n    max_arr\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprzmmrgo2.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k]; arr.len()];\n   |                \
    \                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k.try_into().unwrap()]; arr.len()];\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmprzmmrgo2.rs:20:25\n\
    \   |\n20 |             if arr[i] > max_arr[j][k] {\n   |                    \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmprzmmrgo2.rs:21:17\n   |\n21 |                 max_arr[j][k] = arr[i];\n\
    \   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprzmmrgo2.rs:25:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     max_arr\n   |     ^^^^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<Vec<{integer}>>`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[j]\
    \ > max_arr[j + 1] {\n                max_arr[j] = max_arr[j + 1];\n         \
    \   }\n        }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvxs4_nvh.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpvxs4_nvh.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpvxs4_nvh.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpvxs4_nvh.rs:23:16\n   |\n23 |  \
    \           if max_arr[j] > max_arr[j + 1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpvxs4_nvh.rs:23:29\n   |\n23 |             if max_arr[j] > max_arr[j\
    \ + 1] {\n   |                        "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0; k]; arr.len()];\n    for i in 0..arr.len() {\n  \
    \      for j in 0..k {\n            if arr[i] > max_arr[j][k] {\n            \
    \    max_arr[j][k] = arr[i];\n            }\n        }\n    }\n    max_arr\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0rzs3fd3.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k]; arr.len()];\n   |                \
    \                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k.try_into().unwrap()]; arr.len()];\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmp0rzs3fd3.rs:20:25\n\
    \   |\n20 |             if arr[i] > max_arr[j][k] {\n   |                    \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp0rzs3fd3.rs:21:17\n   |\n21 |                 max_arr[j][k] = arr[i];\n\
    \   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0rzs3fd3.rs:25:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     max_arr\n   |     ^^^^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<Vec<{integer}>>`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_val = arr[0];\n    for i in 0..k {\n\
    \        if arr[i] > max_val {\n            max_val = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if arr[i] > max_val {\n            max_arr.push(max_val);\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] < max_val {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpebgrqopd.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpebgrqopd.rs:21:23\n   |\n21 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpebgrqopd.rs:25:12\n   |\n25 |         if arr[i]\
    \ > max_val {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpebgrqopd.rs:30:12\n   |\n30 |         if arr[i] < max_val {\n \
    \  |            ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpebgrqopd.rs:31:26\n\
    \   |\n31 |             max_arr.push(arr[i]);\n   |                          ^^^^^^\
    \ slice indices are of type `usize` or ranges of `us"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..arr.len() {\n\
    \        max_arr[i][arr.len() - 1 - i].cloned().push(arr[i]);\n    }\n    max_arr.iter().cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmptm0p9i8f.rs:19:9\n   |\n19 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmptm0p9i8f.rs:19:22\n   |\n19 |         max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0689]: can't call method `cloned` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmptm0p9i8f.rs:22:39\n   |\n22 |         max_arr[i][arr.len() - 1\
    \ - i].cloned().push(arr[i]);\n   |                                       ^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptm0p9i8f.rs:24:5\n   |\n16 | fn\
    \ maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |                   \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n24 |     max_arr.iter().cloned().collect::<Vec<_>>()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Vec<{integer}>>`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0689.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![0; k];\n    let mut max_idx = k;\n    for &x in arr {\n \
    \       if x > max_arr[k] {\n            max_arr[k] = x;\n            max_idx\
    \ += 1;\n        }\n    }\n    max_arr.sort_unstable();\n    max_arr.truncate(max_idx);\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpte09qt9h.rs:17:31\n   |\n\
    17 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpte09qt9h.rs:19:9\n   |\n19 | \
    \    for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpte09qt9h.rs:20:16\n   |\n20 |  \
    \       if x > max_arr[k] {\n   |                ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpte09qt9h.rs:21:13\n   |\n21 |  \
    \           max_arr[k] = x;\n   |             ^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpte09qt9h.rs:26:22\n   |\n26 |     max_arr.truncate(max_idx);\n   | \
    \                     ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n26 |     max_arr.truncate(max_idx.try_into().unwrap());\n   |   \
    \                      "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ max_idx = vec![];\n    for i in 0..arr.len() {\n        if max_k == 0 {\n  \
    \          break;\n        }\n        if arr[i] > max_arr[0][i] {\n          \
    \  max_arr[0] = vec![arr[i]];\n            max_k -= 1;\n            max_idx =\
    \ vec![];\n        }\n        if arr[i] > max_arr[1][i] {\n            max_arr[1]\
    \ = vec![arr[i]];\n            max_k -= 1;\n            max_idx = vec![];\n  \
    \      }\n        if arr[i] > max_arr[2][i] {\n            max_arr[2] = vec![arr[i]];\n\
    \            max_k -= 1;\n            max_idx = vec![];\n        }\n        if\
    \ arr[i] > max_arr[3][i] {\n            max_arr[3] = vec![arr[i]];\n         \
    \   max_k -= 1;\n            max_idx = vec![];\n        }\n        if arr[i] >\
    \ max_arr[4][i] {\n            max_arr[4] = vec![arr[i]];\n            max_k -=\
    \ 1;\n            max_idx = vec![];\n        }\n        if arr[i] > max_arr[5][i]\
    \ {\n            max_arr[5] = vec![arr[i]];\n            max_k -= 1;\n       \
    \     max_idx = vec![];\n        }\n        if arr[i] > max_arr[6][i] {\n    \
    \        max_arr[6] = vec![arr[i]];\n            max_k -= 1;\n            max_idx\
    \ = vec![];\n        }\n        if arr[i] > max_arr[7][i] {\n            max_arr[7]\
    \ = vec![arr[i]];\n            max_k -= 1;\n            max_idx = vec![];\n  \
    \      }\n        if arr[i] > max_arr[8][i] {\n            max_arr[8] = vec![arr[i]];\n\
    \            max_k -= 1;\n            max_idx = vec![];\n        }\n        if\
    \ arr[i] > max_arr[9][i] {\n            max_arr[9] = vec![arr[i]];\n         \
    \   max_k -= 1;\n            max_idx = vec![];\n        }\n        if arr[i] >\
    \ max_arr[10][i] {\n            max_arr[10] = vec![arr[i]];\n            max_k\
    \ -= 1;\n            max_idx = vec![];\n        }\n        if arr[i] > max_arr[11][i]\
    \ {\n            max_arr[11] = vec![arr[i]];\n            max_k -= 1;\n      \
    \      max_idx = vec![];\n        }\n        if arr[i] > max_arr[12][i] {\n  \
    \          max_arr[12] = vec![arr[i]];\n            max_k -= 1;\n            max_idx\
    \ = vec![];\n        }\n        if arr[i] > max_arr[13][i] {\n            max_arr[13]\
    \ = vec![arr[i]];\n            max_k -= 1;\n            max_idx = \n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmporoq0fe_.rs:108:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     for i in 0..arr.len() {\n    |                           - unclosed\
    \ delimiter\n...\n89  |         if arr[i] > max_arr[13][i] {\n    |          \
    \                          - this delimiter might not be properly closed...\n\
    ...\n93  | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n108 | }\n    |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmporoq0fe_.rs:93:1\n\
    \   |\n93 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \   --> /tmp/tmporoq0fe_.rs:20:5\n    |\n16  |   fn maximum(arr: Vec<isize>, k:\
    \ isize) -> Vec<isize> {\n    |                                            ----------\
    \ expected `Vec<isize>` because of return type\n...\n20  | /     for i in 0..arr.len()\
    \ {\n21  | |         if max_k == 0 {\n22  | |             break;\n23  | |    \
    \     }\n...   |\n107 | |     assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400,\
    \ 0], 0), Vec::<isize>::new());\n108 | | }\n    | |__^ expected struct `Vec`,\
    \ found `()`\n    |\n    = note: expected struct `Vec<isize>`\n            found\
    \ unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_k = k;\n    let mut min_arr = vec![];\n\
    \    let mut min_k = k;\n    let mut max_val = arr[0];\n    let mut min_val =\
    \ arr[0];\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos\
    \ = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos\
    \ = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos\
    \ = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos\
    \ = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos\
    \ = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos\
    \ = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos\
    \ = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos\
    \ = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos\
    \ = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos\
    \ = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos\
    \ = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpafae9sjp.rs:89:11\n   |\n\
    89 |     let mu\n   |           ^ help: add `;` here\n90 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpafae9sjp.rs:16:42\n \
    \  |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |    -------\
    \                               ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[i]\
    \ > max_arr[j] {\n                max_arr[i] = max_arr[j];\n            }\n  \
    \      }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpku5wh2pa.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpku5wh2pa.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpku5wh2pa.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpku5wh2pa.rs:23:16\n   |\n23 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpku5wh2pa.rs:23:29\n   |\n23 |             if max_arr[i] > max_arr[j]\
    \ {\n   |                             ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_len = k;\n    for ele in arr {\n    \
    \    if max_len < ele {\n            max_len = ele;\n        }\n    }\n    for\
    \ i in 0..max_len {\n        max_arr.push(arr[i]);\n    }\n    max_arr\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp5ru_6mo0.rs:25:22\n\
    \   |\n25 |         max_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_idx = vec![];\n    for i in 0..k {\n\
    \        max_arr[i] = arr[i];\n        max_idx[i] = i;\n    }\n    for i in 1..arr.len()\
    \ {\n        let mut max_val = max_arr[max_idx[i - 1]];\n        let mut max_idx\
    \ = max_idx[i - 1];\n        for j in 0..i {\n            if arr[j] > max_val\
    \ {\n                max_val = arr[j];\n                max_idx = j;\n       \
    \     }\n        }\n        max_arr[max_idx] = arr[i];\n        max_idx[max_idx]\
    \ = i;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n \
    \   assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp6lsunnbo.rs:20:9\n\
    \   |\n20 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp6lsunnbo.rs:20:22\n   |\n20 |         max_arr[i] =\
    \ arr[i];\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp6lsunnbo.rs:21:9\n   |\n21 |         max_idx[i] =\
    \ i;\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\
    \nerror[E0608]: cannot index into a value of type `usize`\n  --> /tmp/tmp6lsunnbo.rs:33:9\n\
    \   |\n33 |         max_idx[max_idx] = i;\n   |         ^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0608.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![0; k];\n    let mut max_idx = k;\n    for &i in arr {\n \
    \       if i >= 0 {\n            if i > max_arr[k] {\n                max_arr[k]\
    \ = i;\n                max_idx += 1;\n            }\n        }\n    }\n    max_arr.sort_unstable();\n\
    \    max_arr.truncate(max_idx);\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe9g4v3ql.rs:17:31\n   |\n\
    17 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe9g4v3ql.rs:19:9\n   |\n19 | \
    \    for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpe9g4v3ql.rs:21:20\n   |\n21 |  \
    \           if i > max_arr[k] {\n   |                    ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpe9g4v3ql.rs:22:17\n   |\n22 |  \
    \               max_arr[k] = i;\n   |                 ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpe9g4v3ql.rs:28:22\n   |\n28 |     max_arr.truncate(max_idx);\n   | \
    \                     ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n28 |     max_arr.truncate(max_idx.try_into().unwrap());\n   |   \
    \      "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![0; k];\n    let mut max_idx = k;\n    for i in 0..arr.len()\
    \ {\n        if arr[i] > max_arr[k] {\n            max_arr[k] = arr[i];\n    \
    \        max_idx = k;\n        }\n        if max_idx > k {\n            break;\n\
    \        }\n        max_idx--;\n    }\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp3nmfqf6r.rs:27:18\n\
    \   |\n27 |         max_idx--;\n   |                  ^ expected expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp3nmfqf6r.rs:17:31\n   |\n17 |  \
    \   let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp3nmfqf6r.rs:20:21\n\
    \   |\n20 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp3nmfqf6r.rs:21:13\n\
    \   |\n21 |             max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ max_idx = -1;\n    for i in 0..arr.len() {\n        let mut cur_max = arr[i];\n\
    \        let mut cur_idx = i;\n        while cur_idx > 0 && cur_max > max_arr[cur_idx\
    \ - 1] {\n            max_arr[cur_idx - 1] = max_arr[cur_idx];\n            cur_idx\
    \ -= 1;\n        }\n        max_arr[cur_idx - 1] = cur_max;\n        if cur_idx\
    \ > max_k {\n            max_k = cur_idx;\n            max_idx = i;\n        }\n\
    \    }\n    max_arr.sort_by_key(|&x| x);\n    max_arr.to_owned()[0..max_k].to_vec()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp2duurjl.rs:23:40\n   |\n\
    23 |         while cur_idx > 0 && cur_max > max_arr[cur_idx - 1] {\n   |     \
    \                                   ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct\
    \ `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp2duurjl.rs:27:32\n\
    \   |\n27 |         max_arr[cur_idx - 1] = cur_max;\n   |         --------------------\
    \   ^^^^^^^ expected struct `Vec`, found `isize`\n   |         |\n   |       \
    \  expected due to the type of this binding\n   |\n   = note: expected struct\
    \ `Vec<{integer}>`\n                found type `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp2duurjl.rs:28:22\n   |\n28 |         if cur_idx > max_k\
    \ {\n   |                      ^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n28 |         if cur_idx > max_k.try_into().unwrap() {\n   |     \
    \                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp2duurjl.rs:29:21\n   |\n18 |     let mut max_k = k;\n   |    \
    \                 - expected due to this value\n...\n29 |             max_k =\
    \ cur_idx;\n   |                     ^^^^^^^ expected `isize`, found `usize`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpp2duurjl.rs:19:23\n\
    \   |\n19 |     let mut max_idx = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `std::ops::Range<isize>`\n  --> /tmp/tmpp2duurjl.rs:34:5\n\
    \   |\n34 |     max_arr.to_owned()[0..max_k].to_vec()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integ"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        let mut max_num = max_arr[i];\n        for\
    \ j in 0..k {\n            if max_arr[j] > max_num {\n                max_num\
    \ = max_arr[j];\n            }\n        }\n        max_arr[i] = max_num;\n   \
    \ }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpntymqgri.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpntymqgri.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpntymqgri.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpntymqgri.rs:22:27\n   |\n22 |  \
    \       let mut max_num = max_arr[i];\n   |                           ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpntymqgri.rs:24:16\n   |\n24 |             if max_arr[j] > max_num {\n\
    \   |                ^^^^^^^^^^ "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![arr[i]; 2];\n    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0]\
    \ > max_arr[i][1] ? max_arr[i][0] : max_arr[i][1];\n    }\n    for i in 0..k {\n\
    \        max_arr[i][0] = max_arr[i][0] > max_arr[i][1] ? max_arr[i][1] : max_arr[i][0];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] > max_arr[i][1]\
    \ ? max_arr[i][0] : max_arr[i][1];\n    }\n    for i in 0..k {\n        max_arr[i][0]\
    \ = max_arr[i][0] > max_arr[i][1] ? max_arr[i][1] : max_arr[i][0];\n    }\n  \
    \  for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] > max_arr[i][1] ? max_arr[i][0]\
    \ : max_arr[i][1];\n    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0]\
    \ > max_arr[i][1] ? max_arr[i][1] : max_arr[i][0];\n    }\n    for i in 0..k {\n\
    \        max_arr[i][0] = max_arr[i][0] > max_arr[i][1] ? max_arr[i][1] : max_arr[i][0];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] > max_arr[i][1]\
    \ ? max_arr[i][1] : max_arr[i][0];\n    }\n    for i in 0..k {\n        max_arr[i][0]\
    \ = max_arr[i][0] > max_arr[i][1] ? max_arr[i][1] : max_arr[i][0];\n    }\n  \
    \  for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] > max_arr[i][1] ? max_arr[i][1]\
    \ : max_arr[i][0];\n    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0]\
    \ > max_arr[i][1] ? max_arr[i][1] : max_arr[i][0];\n    }\n    for i in 0..k {\n\
    \        max_arr[i][0] = max_arr[i][0] > max_arr[i][1] ? max_arr[i][1] : max_arr[i][0];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] > max_arr[i][1]\
    \ ? max_arr[i][1] : max_arr[i][0];\n    }\n    for i in 0..k {\n        max_arr[i][0]\
    \ = max_arr[i][0] > max_arr[i][1] ? max_arr[i][1] : max_arr[i][0];\n    }\n  \
    \  for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] > max_arr[i][1] ? max_arr[i][1]\
    \ : max_arr[i][0];\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n  \
    \  assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `max_arr`\n\
    \  --> /tmp/tmpdxtz3852.rs:22:57\n   |\n22 |         max_arr[i][0] = max_arr[i][0]\
    \ > max_arr[i][1] ? max_arr[i][0] : max_arr[i][1];\n   |                     \
    \                                    ^^^^^^^ expected one of `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator,\
    \ found `max_arr`\n  --> /tmp/tmpdxtz3852.rs:25:57\n   |\n25 |         max_arr[i][0]\
    \ = max_arr[i][0] > max_arr[i][1] ? max_arr[i][1] : max_arr[i][0];\n   |     \
    \                                                    ^^^^^^^ expected one of `.`,\
    \ `;`, `?`, `}`, or an operator\n\nerror: expected one of `.`, `;`, `?`, `}`,\
    \ or an operator, found `max_arr`\n  --> /tmp/tmpdxtz3852.rs:28:57\n   |\n28 |\
    \         max_arr[i][0] = max_arr[i][0] > max_arr[i][1] ? max_arr[i][0] : max_arr[i][1];\n\
    \   |                                                         ^^^^^^^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n\nerror: expected one of `.`, `;`,\
    \ `?`, `}`, or an operator, found `max_arr`\n  --> /tmp/tmpdxtz3852.rs:31:57\n\
    \   |\n31 |         max_arr[i][0] = max_arr[i][0] > max_arr[i][1] ? max_arr[i][1]\
    \ : max_arr[i][0];\n   |                                                     \
    \    ^^^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: expected\
    \ one of `.`, `;`, `?`, `}`, or an operator, found `max_arr`\n  --> /tmp/tmpdxtz3852.rs:34:57\n\
    \   |\n34 |         max_arr[i][0] = max_arr[i][0] > max_arr[i][1] ? max_arr[i][0]\
    \ : max_arr[i][1];\n   |                                                     \
    \    ^^^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: expected\
    \ one of `.`, `;`, `?`, `}`, or an operator, found `max_arr`\n  --> /tmp/tmpdxtz3852.rs:37:57\n\
    \   |\n37 |         max_arr[i][0] = max_arr[i][0] > max_arr[i][1] ? max_arr[i][1]\
    \ : max_arr[i][0];\n   |                                                     \
    \    ^^^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: expected\
    \ one of `.`, `;`, `?`, `}`, or an operator, found `max_arr`\n  --> /tmp/tmpdxtz3852."
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![0; k];\n    let mut max_so_far = arr[0];\n    for i in 1..k\
    \ {\n        if arr[i] > max_so_far {\n            max_so_far = arr[i];\n    \
    \    }\n    }\n    for i in 0..k {\n        result[i] = max_so_far;\n        max_so_far\
    \ = max_so_far.max(arr[i]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaonyi1ha.rs:17:30\n   |\n\
    17 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpaonyi1ha.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_so_far {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpaonyi1ha.rs:21:26\n   |\n21 |            \
    \ max_so_far = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpaonyi1ha.rs:25:9\n   |\n25 |         result[i]\
    \ = max_so_far;\n   |         ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmpaonyi1ha.rs:26:37\n   |\n26 |         max_so_far = max_so_far.max(arr[i]);\n\
    \   |                                     ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![0; k];\n    let mut max_idx = k;\n    let mut max_val = arr[0];\n\
    \    for &i in arr {\n        if i > max_val {\n            max_val = i;\n   \
    \         max_idx = k;\n        }\n        if i == max_val {\n            max_idx\
    \ += 1;\n        }\n        max_arr[k] = max_val;\n        max_arr[k] = i;\n \
    \   }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbp8co_8c.rs:17:31\n   |\n\
    17 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbp8co_8c.rs:20:9\n   |\n20 | \
    \    for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbp8co_8c.rs:28:9\n   |\n28 |   \
    \      max_arr[k] = max_val;\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbp8co_8c.rs:29:9\n   |\n29 |   \
    \      max_arr[k] = i;\n   |         ^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..k {\n      \
    \  arr[i] = arr[i].iter().cloned().collect();\n    }\n    for i in 0..k {\n  \
    \      max_arr[i] = max_arr[i].iter().max().unwrap();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n    for\
    \ i in 0..k {\n        arr[i] = arr[i].iter().cloned().collect();\n    }\n   \
    \ for i in 0..k {\n        max_arr[i] = max_arr[i].iter().max().unwrap();\n  \
    \  }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        arr[i] = arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        arr[i] = arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        arr[i] = arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        arr[i] = arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        arr[i] = arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp3ncgxhoc.rs:104:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    87  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n88  | \n89  | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n104 | }\n    |   ^\n\nerror[E0277]: the type\
    \ `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmp3ncgxhoc.rs:19:9\n\
    \   |\n19 |         max_arr[i] = max_arr[i].iter().max().unwrap();\n   |     \
    \    ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp3ncgxhoc.rs:19:22\n   |\n19 |         max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \   |                      ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp3ncgxhoc.rs:22:9\n   |\n22 |   \
    \      max_arr[i] = max_arr[i].iter().cloned().collect();\n   |         ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_k = k;\n    let mut max_i = 0;\n    let\
    \ mut max_j = 0;\n    let mut max_val = arr[0];\n    let mut max_pos = 0;\n  \
    \  let mut max_pos = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i <\
    \ arr.len() && j < arr.len() {\n        if arr[i] > arr[j] {\n            max_val\
    \ = arr[i];\n            max_pos = i;\n        } else {\n            max_val =\
    \ arr[j];\n            max_pos = j;\n        }\n        if max_val > max_arr[0]\
    \ {\n            max_arr.push(max_val);\n            max_k += 1;\n        }\n\
    \        i += 1;\n        j += 1;\n    }\n    if max_k > max_arr.len() {\n   \
    \     max_k = max_arr.len();\n    }\n    while max_k > 0 {\n        max_arr[max_k\
    \ - 1] = max_arr[max_k - 1] - 1;\n        max_k -= 1;\n    }\n    while max_pos\
    \ > 0 {\n        max_arr[max_pos] = max_arr[max_pos] - 1;\n        max_pos -=\
    \ 1;\n    }\n    while max_arr.len() > k {\n        max_arr.pop();\n        max_k\
    \ -= 1;\n    }\n    while max_arr.len() > 0 {\n        max_arr.pop();\n    }\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9c6hl4hm.rs:41:16\n   |\n\
    41 |     if max_k > max_arr.len() {\n   |                ^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n41 |     if max_k > max_arr.len().try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9c6hl4hm.rs:42:17\n   |\n18 |     let mut max_k = k;\n\
    \   |                     - expected due to this value\n...\n42 |         max_k\
    \ = max_arr.len();\n   |                 ^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n \
    \ --> /tmp/tmp9c6hl4hm.rs:45:9\n   |\n45 |         max_arr[max_k - 1] = max_arr[max_k\
    \ - 1] - 1;\n   |         ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp9c6hl4hm.rs:45:30\n   |\n45 |         max_arr[max_k\
    \ - 1] = max_arr[max_k - 1] - 1;\n   |                              ^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9c6hl4hm.rs:52:27\n   |\n52 |     while max_arr.len()\
    \ > k {\n   |                           ^ expected `usize`, found `isize`\n  \
    \ |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n52 |     while max_arr.len() > k.try_into().unwrap()\
    \ {\n   |                            ++++++++++++++++++++\n\nerror: aborting due\
    \ to 5 previous errors"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ max_i = -1;\n    let mut max_j = -1;\n    for i in 0..arr.len() {\n        if\
    \ max_arr[0][0] <= arr[i] {\n            max_arr[0][0] = arr[i];\n           \
    \ max_arr[0][1] = i;\n        }\n        if max_arr[1][0] > arr[i] {\n       \
    \     max_arr[1][0] = arr[i];\n            max_arr[1][1] = i;\n        }\n   \
    \     if max_k == 0 {\n            break;\n        }\n        if max_k == 1 {\n\
    \            max_k = max_arr[1][1] - max_arr[1][0] + 1;\n            max_i = max_arr[1][1];\n\
    \            max_j = max_arr[1][0];\n        }\n        if max_arr[1][0] > max_arr[0][0]\
    \ {\n            max_k = max_k - 1;\n        }\n        if max_arr[1][1] < max_arr[0][0]\
    \ {\n            max_k = max_k + 1;\n        }\n    }\n    if max_k == 0 {\n \
    \       return vec![];\n    }\n    let mut max_arr = max_arr[0];\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i + 1];\n    }\n    max_arr[k\
    \ - 1]\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoe4gwc8k.rs:24:29\n   |\n\
    24 |             max_arr[0][1] = i;\n   |             -------------   ^ expected\
    \ `isize`, found `usize`\n   |             |\n   |             expected due to\
    \ the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoe4gwc8k.rs:28:29\n\
    \   |\n28 |             max_arr[1][1] = i;\n   |             -------------   ^\
    \ expected `isize`, found `usize`\n   |             |\n   |             expected\
    \ due to the type of this binding\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpoe4gwc8k.rs:50:9\n   |\n50 |         max_arr[i]\
    \ = max_arr[i] + max_arr[i + 1];\n   |         ^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpoe4gwc8k.rs:50:22\n   |\n50 |         max_arr[i]\
    \ = max_arr[i] + max_arr[i + 1];\n   |                      ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpoe4gwc8k.rs:50:35\n   |\n50 |         max_arr[i]\
    \ = max_arr[i] + max_arr[i + 1];\n   |                                   ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpoe4gwc8k.r"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_num = arr[0];\n    for i in 1..k {\n\
    \        if arr[i] > max_num {\n            max_num = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(max_num);\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_num {\n            max_arr.push(arr[i]);\n        }\n    }\n  \
    \  for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_num {\n            max_arr.push(arr[i]);\n        }\n    }\n  \
    \  for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_num {\n            max_arr.push(arr[i]);\n        }\n    }\n  \
    \  for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_num {\n            max_arr.push(arr[i]);\n        }\n    }\n  \
    \  for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_num {\n            max_arr.push(arr[i]);\n        }\n    }\n  \
    \  for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_num {\n            max_arr.push(arr[i]);\n        }\n    }\n  \
    \  for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp1zqcjy1s.rs:137:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for i in 0..k {\n    |                   - unclosed delimiter\n120 |\
    \         if arr[i] > max_num {\n    |                             - this delimiter\
    \ might not be properly closed...\n121 |             max_\n122 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n137 | }\n    |   ^\n\n\
    error[E0425]: cannot find value `max_` in this scope\n   --> /tmp/tmp1zqcjy1s.rs:121:13\n\
    \    |\n121 |             max_\n    |             ^^^^ not found in this scope\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1zqcjy1s.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1zqcjy1s.rs:21:23\n   |\n21 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1zqcjy1s.rs:25:12\n   |\n25 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isi"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_so_far = arr[0];\n    let mut max_so_far_pos = 0;\n    let mut max_so_far_neg\
    \ = 0;\n    let mut max_so_far_neg_inner = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] > max_so_far {\n            max_so_far = arr[i];\n    \
    \        max_so_far_pos = i;\n        }\n        if arr[i] < max_so_far {\n  \
    \          max_so_far_neg = i;\n        }\n        if arr[i] > max_so_far_neg_inner\
    \ {\n            max_so_far_neg_inner = arr[i];\n        }\n    }\n    let mut\
    \ max_so_far_neg_inner_pos = 0;\n    let mut max_so_far_neg_inner_neg = 0;\n \
    \   let mut max_so_far_neg_inner_neg_inner = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] > max_so_far_neg_inner {\n            max_so_far_neg_inner\
    \ = arr[i];\n        }\n        if arr[i] < max_so_far_neg_inner {\n         \
    \   max_so_far_neg_inner_neg = i;\n        }\n        if arr[i] > max_so_far_neg_inner_neg_inner\
    \ {\n            max_so_far_neg_inner_neg_inner = arr[i];\n        }\n    }\n\
    \    let mut max_so_far_neg_inner_pos = 0;\n    let mut max_so_far_neg_inner_neg\
    \ = 0;\n    let mut max_so_far_neg_inner_neg_inner = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] > max_so_far_neg_inner_neg_inner {\n            max_so_far_neg_inner_neg_inner\
    \ = arr[i];\n        }\n        if arr[i] < max_so_far_neg_inner_neg_inner {\n\
    \            max_so_far_neg_inner_pos = i;\n        }\n        if arr[i] > max_so_far_neg_inner_neg\
    \ {\n            max_so_far_neg_inner_neg = i;\n        }\n    }\n    let mut\
    \ max_so_far_pos = 0;\n    let mut max_so_far_neg = 0;\n    let mut max_so_far_neg_inner\
    \ = arr[0];\n    for i in 1..arr.len() {\n        if arr[i] > max_so_far_neg_inner\
    \ {\n            max_so_far_neg_inner = arr[i];\n        }\n        if arr[i]\
    \ < max_so_far_neg_inner {\n            max_so_far_neg = i;\n        }\n     \
    \   if arr[i] > max_so_far_neg {\n            max_so_far_neg = i;\n        }\n\
    \        if arr[i] > max_so_far_pos {\n            max_so_far_pos = i;\n     \
    \   }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp0xxh5889.rs:92:3\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                               - unclosed delimiter\n...\n64\
    \ |     for i in 1..arr.len() {\n   |                           - this delimiter\
    \ might not be properly closed...\n...\n77 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n92 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0xxh5889.rs:58:40\n   |\n48 |     let mut max_so_far_neg_inner_neg\
    \ = 0;\n   |                                        - expected due to this value\n\
    ...\n58 |             max_so_far_neg_inner_neg = i;\n   |                    \
    \                    ^ expected `isize`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0xxh5889.rs:71:21\n   |\n71 |         if arr[i] > max_so_far_neg\
    \ {\n   |                     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n71 |         if arr[i] > max_so_far_neg.try_into().unwrap()\
    \ {\n   |                                   ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0xxh5889.rs:75:30\n   |\n61 |     let mut max_so_far_pos\
    \ = 0;\n   |                              - expected due to this value\n...\n\
    75 |             max_so_far_pos = i;\n   |                              ^ expected\
    \ `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0xxh5889.rs:16:42\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |    -------\
    \                               ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![0; k];\n    let mut max_val = arr[0];\n    for i in 0..k {\n\
    \        if arr[i] > max_val {\n            max_val = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        result[i] = max_val;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbv4x08uo.rs:17:30\n   |\n\
    17 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbv4x08uo.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpbv4x08uo.rs:21:23\n   |\n21 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpbv4x08uo.rs:25:9\n   |\n25 |         result[i]\
    \ = max_val;\n   |         ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..arr.len() {\n\
    \        max_arr[k - 1 - i].push(arr[i]);\n    }\n    max_arr.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpeq5ibroz.rs:19:9\n   |\n19 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpeq5ibroz.rs:19:22\n   |\n19 |         max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpeq5ibroz.rs:22:25\n   |\n22 |\
    \         max_arr[k - 1 - i].push(arr[i]);\n   |                         ^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot subtract `usize` from `isize`\n\
    \  --> /tmp/tmpeq5ibroz.rs:22:23\n   |\n22 |         max_arr[k - 1 - i].push(arr[i]);\n\
    \   |                       ^ no implementation for `isize - usize`\n   |\n  \
    \ = help: the trait `Sub<usize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as\
    \ Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n\
    \             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n    \
    \         <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n          \
    \   <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]: the type\
    \ `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpeq5ibroz.rs:22:9\n\
    \   |\n22 |         max_arr[k - 1 - i].push(arr[i]);\n   |         ^^^^^^^^^^^^^^^^^^\
    \ slice i"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    for i in 0..k {\n        max_arr.push(arr[i]);\n\
    \    }\n    max_arr.sort();\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpo9ywkzsc.rs:19:22\n\
    \   |\n19 |         max_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![arr[i]; 2];\n    }\n    for i in 0..k {\n        for j in 0..k {\n  \
    \          if max_arr[i][j] > max_arr[i][j+1] {\n                max_arr[i][j]\
    \ = max_arr[i][j+1];\n            }\n        }\n    }\n    for i in 0..k {\n \
    \       for j in 0..k {\n            if max_arr[i][j] > arr[j] {\n           \
    \     max_arr[i][j] = arr[j];\n            }\n        }\n    }\n    for i in 0..k\
    \ {\n        max_arr[i][0] = max_arr[i][0];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i][1] = max_arr[i][1];\n    }\n    for i in 0..k {\n        for j\
    \ in 0..k {\n            if max_arr[i][j] > arr[j] {\n                max_arr[i][j]\
    \ = arr[j];\n            }\n        }\n    }\n    for i in 0..k {\n        max_arr[i][0]\
    \ = max_arr[i][0];\n    }\n    for i in 0..k {\n        max_arr[i][1] = max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0];\n    }\n\
    \    for i in 0..k {\n        max_arr[i][1] = max_arr[i][1];\n    }\n    for i\
    \ in 0..k {\n        for j in 0..k {\n            if max_arr[i][j] > arr[j] {\n\
    \                max_arr[i][j] = arr[j];\n            }\n        }\n    }\n  \
    \  for i in 0..k {\n        max_arr[i][0] = max_arr[i][0];\n    }\n    for i in\
    \ 0..k {\n        max_arr[i][1] = max_arr[i][1];\n    }\n    for i in 0..k {\n\
    \        for j in 0..k {\n            if max_arr[i][j] > arr[j] {\n          \
    \      max_arr[i][j] = arr[j];\n            }\n        }\n    }\n    for i in\
    \ 0..k {\n        max_arr[i][0] = max_arr[i][0];\n    }\n    for i in 0..k {\n\
    \        max_arr[i][1] = max_arr[i][1];\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if max_arr[i][j] > arr[j] {\n                max_arr[i][j]\
    \ = arr[j];\n            }\n        }\n    }\n    for i in 0..k {\n        max_arr[i][0]\
    \ = max_arr[i][0];\n    }\n    for i in 0..k {\n        max_arr[i][1] = max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpo8ql5mq0.rs:124:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    106 |     for i in 0..k {\n    |                   - unclosed delimiter\n107 |\
    \         for j in 0..k {\n    |                       - this delimiter might\
    \ not be properly closed...\n108 |             if max_arr[i][j] > arr\n109 | }\n\
    \    | - ...as it matches this but it has different indentation\n...\n124 | }\n\
    \    |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpo8ql5mq0.rs:109:1\n\
    \    |\n108 |             if max_arr[i][j] > arr\n    |             -- this `if`\
    \ expression has a condition, but no block\n109 | }\n    | ^ expected `{`\n\n\
    error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpo8ql5mq0.rs:19:9\n   |\n19 |         max_arr[i] = vec![arr[i]; 2];\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpo8ql5mq0.rs:19:27\n   |\n19 |         max_arr[i] =\
    \ vec![arr[i]; 2];\n   |                           ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpo8ql5mq0.rs:23:16\n   |\n23 |  \
    \           if max_arr[i][j] > max_arr[i][j+1] {\n   |                ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..arr.len() {\n\
    \        max_arr[i][arr[i]] = arr[i];\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpewgl_k27.rs:19:9\n   |\n19 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpewgl_k27.rs:19:22\n   |\n19 |         max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpewgl_k27.rs:22:9\n\
    \   |\n22 |         max_arr[i][arr[i]] = arr[i];\n   |         ^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpewgl_k27.rs:25:9\n\
    \   |\n25 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n   | \
    \        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for\
    \ `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Ve"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in (i + 1)..k {\n            if max_arr[i]\
    \ > max_arr[j] {\n                max_arr[i] = max_arr[j];\n            }\n  \
    \      }\n    }\n    for i in 0..k {\n        arr[i] = max_arr[i];\n    }\n  \
    \  arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp33jw49d3.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp33jw49d3.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp33jw49d3.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp33jw49d3.rs:23:16\n   |\n23 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp33jw49d3.rs:23:29\n   |\n23 |             if max_arr[i] > max_arr[j]\
    \ {\n   |                             ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![arr[i], -1000, 1000];\n    }\n    for i in 0..k {\n        let mut max_num\
    \ = -1000.0;\n        for j in 0..k {\n            if max_arr[j][0] > max_num\
    \ {\n                max_num = max_arr[j][0];\n            }\n        }\n    \
    \    max_arr[i][1] = max_num;\n    }\n    for i in 0..k {\n        for j in 0..k\
    \ {\n            if max_arr[j][1] < max_arr[i][1] {\n                max_arr[j][1]\
    \ = max_arr[i][1];\n            }\n        }\n    }\n    for i in 0..k {\n   \
    \     for j in 0..k {\n            if max_arr[j][1] > max_arr[i][1] {\n      \
    \          max_arr[j][1] = max_arr[i][1];\n            }\n        }\n    }\n \
    \   for i in 0..k {\n        for j in 0..k {\n            if max_arr[j][1] < max_arr[i][1]\
    \ {\n                max_arr[j][1] = max_arr[i][1];\n            }\n        }\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[j][1]\
    \ > max_arr[i][1] {\n                max_arr[j][1] = max_arr[i][1];\n        \
    \    }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n     \
    \       if max_arr[j][1] < max_arr[i][1] {\n                max_arr[j][1] = max_arr[i][1];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[j][1] > max_arr[i][1] {\n                max_arr[j][1]\
    \ = max_arr[i][1];\n            }\n        }\n    }\n    for i in 0..k {\n   \
    \     for j in 0..k {\n            if max_arr[j][1] < max_arr[i][1] {\n      \
    \          max_arr[j][1] = max_arr[i][1];\n            }\n        }\n    }\n \
    \   for i in 0..k {\n        for j in 0..k {\n            if max_arr[j][1] > max_arr[i][1]\
    \ {\n                max_arr[j][1] = max_arr[i][1];\n            }\n        }\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[j][1]\
    \ < max_arr[i][1] {\n                max_arr[j][1] = max_arr[i][1];\n        \
    \    }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n     \
    \       if max_arr[j][1] > max_arr[i][1] {\n                max_arr[j][1] = max_arr[i][1];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[j][1] < max_arr[i][1]\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpo7bt4v6_.rs:118:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    100 |     for i in 0..k {\n    |                   - unclosed delimiter\n101 |\
    \         for j in 0..k {\n    |                       - this delimiter might\
    \ not be properly closed...\n102 |             if max_arr[j][1] < max_arr[i][1]\n\
    103 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    118 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpo7bt4v6_.rs:103:1\n\
    \    |\n102 |             if max_arr[j][1] < max_arr[i][1]\n    |            \
    \ -- this `if` expression has a condition, but no block\n103 | }\n    | ^ expected\
    \ `{`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpo7bt4v6_.rs:19:9\n   |\n19 |         max_arr[i] = vec![arr[i],\
    \ -1000, 1000];\n   |         ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpo7bt4v6_.rs:19:27\n   |\n19 |  \
    \       max_arr[i] = vec![arr[i], -1000, 1000];\n   |                        \
    \   ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   =\
    \ help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpo7bt4v6_.rs:24:16\n   |\n24 |             if max_arr[j][0] > max_num\
    \ {\n   |                ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{inte"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_num = arr[0];\n    for i in 1..k {\n\
    \        if arr[i] > max_num {\n            max_num = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(max_num);\n\
    \        }\n        max_arr.push(arr[i]);\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpxh30u1lj.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpxh30u1lj.rs:21:23\n   |\n21 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpxh30u1lj.rs:25:12\n   |\n25 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpxh30u1lj.rs:28:22\n   |\n28 |         max_arr.push(arr[i]);\n \
    \  |                      ^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_num = arr[0];\n    for i in 0..k {\n\
    \        if max_num < arr[i] {\n            max_num = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if max_num < arr[i] {\n            max_arr.push(max_num);\n\
    \        }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp61d8vse4.rs:20:22\n\
    \   |\n20 |         if max_num < arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp61d8vse4.rs:21:23\n   |\n21 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp61d8vse4.rs:25:22\n   |\n25 |         if max_num\
    \ < arr[i] {\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![vec![0; k]; arr.len()];\n    let mut max_idx = vec![0; k];\n\
    \    let mut max_val = vec![0; k];\n    for i in 0..arr.len() {\n        let mut\
    \ max_idx = 0;\n        let mut max_val = 0;\n        for j in 0..k {\n      \
    \      if arr[i] > max_val[j] {\n                max_val = max_val[j];\n     \
    \           max_idx = j;\n            }\n        }\n        result[max_idx][max_idx]\
    \ = arr[max_idx];\n        max_idx[max_idx] = i;\n        max_val[max_idx] = arr[i];\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpswvca82u.rs:17:35\n   |\n\
    17 |     let mut result = vec![vec![0; k]; arr.len()];\n   |                 \
    \                  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut result = vec![vec![0; k.try_into().unwrap()]; arr.len()];\n \
    \  |                                    ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpswvca82u.rs:18:31\n   |\n18 |     let mut max_idx\
    \ = vec![0; k];\n   |                               ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |     let mut max_idx = vec![0; k.try_into().unwrap()];\n\
    \   |                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpswvca82u.rs:19:31\n   |\n19 |     let mut max_val = vec![0;\
    \ k];\n   |                               ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |     let mut max_val = vec![0; k.try_into().unwrap()];\n\
    \   |                                ++++++++++++++++++++\n\nerror[E0608]: cannot\
    \ index into a value of type `{integer}`\n  --> /tmp/tmpswvca82u.rs:24:25\n  \
    \ |\n24 |             if arr[i] > max_val[j] {\n   |                         ^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `{integer}`\n  --> /tmp/tmpswvca82u.rs:25:27\n\
    \   |\n25 |                 max_val = max_val[j];\n   |                      \
    \     ^^^^^^^^^^\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpswvca82u.rs:29:9\n   |\n29 |         result[max_idx][max_idx]\
    \ = arr[max_idx];\n   |         ^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n    }\n    for i in 0..k {\n        max_arr[i].push(arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr[i].sort();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i].iter().cloned().collect();\n    }\n    max_arr\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp7w3t6jy8.rs:19:9\n   |\n19 |         max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp7w3t6jy8.rs:19:22\n   |\n19 |         max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n   |                      ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp7w3t6jy8.rs:22:9\n   |\n22 |         max_arr[i].push(arr[i]);\n   |\
    \         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp7w3t6jy8.rs:22:25\n   |\n22 |         max_arr[i].push(arr[i]);\n\
    \   |                         ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed\
    \ by `isize`\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_len = k;\n    let mut i = 0;\n    while\
    \ i < arr.len() {\n        if max_len < arr.len() {\n            max_len = arr.len();\n\
    \        }\n        if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[1] {\n            max_arr[1] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[2] {\n            max_arr[2] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[3] {\n            max_arr[3] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[4] {\n            max_arr[4] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[5] {\n            max_arr[5] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[6] {\n            max_arr[6] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[7] {\n            max_arr[7] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[8] {\n            max_arr[8] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[9] {\n            max_arr[9] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[10] {\n            max_arr[10] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[11] {\n            max_arr[11] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[12] {\n            max_arr[12] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[13] {\n            max_arr[13] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[14] {\n            max_arr[14] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[15] {\n            max_arr[15] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[16] {\n            max_arr[16] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[17] {\n            max_arr[17] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[18] {\n            max_arr[18] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[19] {\n            max_arr[19] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[20] {\n            max_arr[20] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[21] {\n            max_arr[21] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[22] {\n            max_arr[22] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[23] {\n            max_arr[23] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[24] {\n            max_arr[24] = arr[i];\n\
    \        }\n        if arr[i] > max_arr[25] {\n            max_arr[25] = arr[i];\n\
    \        }\n        if arr[i] > max_\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmphylt8a2b.rs:118:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while i < arr.len() {\n    |                         - this delimiter\
    \ might not be properly closed...\n...\n103 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n118 | }\n    |   ^\n\nerror: expected\
    \ `{`, found `}`\n   --> /tmp/tmphylt8a2b.rs:103:1\n    |\n102 |         if arr[i]\
    \ > max_\n    |         -- this `if` expression has a condition, but no block\n\
    103 | }\n    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphylt8a2b.rs:21:22\n\
    \   |\n21 |         if max_len < arr.len() {\n   |                      ^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n21 |         if\
    \ max_len < arr.len().try_into().unwrap() {\n   |                            \
    \   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphylt8a2b.rs:22:23\n\
    \   |\n18 |     let mut max_len = k;\n   |                       - expected due\
    \ to this value\n...\n22 |             max_len = arr.len();\n   |            \
    \           ^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphylt8a2b.rs:16:42\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |    -------                               ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![0; k];\n    let mut max_value = arr[0];\n    let mut max_pos\
    \ = 0;\n    for &x in arr.iter() {\n        if x > max_value {\n            max_value\
    \ = x;\n            max_pos = 0;\n        }\n        if x == max_value {\n   \
    \         result[max_pos] = x;\n            max_pos++;\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp5f4gscli.rs:27:20\n\
    \   |\n27 |             max_pos++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n27 |             { let tmp =\
    \ max_pos; max_pos += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    27 -             max_pos++;\n27 +             max_pos += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5f4gscli.rs:17:30\n   |\n17 |     let mut result\
    \ = vec![0; k];\n   |                              ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     let mut result = vec![0; k.try_into().unwrap()];\n\
    \   |                               ++++++++++++++++++++\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0; k]; arr.len()];\n    for i in 0..arr.len() {\n  \
    \      let mut max_val = arr[i];\n        for j in 0..k {\n            if max_val\
    \ < arr[j] {\n                max_val = arr[j];\n            }\n        }\n  \
    \      max_arr[i] = vec![max_val; k];\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpulwi_u5n.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k]; arr.len()];\n   |                \
    \                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k.try_into().unwrap()]; arr.len()];\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpulwi_u5n.rs:21:26\n\
    \   |\n21 |             if max_val < arr[j] {\n   |                          ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpulwi_u5n.rs:22:27\n\
    \   |\n22 |                 max_val = arr[j];\n   |                          \
    \ ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpulwi_u5n.rs:25:36\n   |\n25 |         max_arr[i]\
    \ = vec![max_val; k];\n   |                                    ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         max_arr[i] = vec![max_val;\
    \ k.try_into().unwrap()];\n   |                                     ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpulwi_u5n.rs:27:5\n   |\n16 | fn\
    \ maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |                   \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n27 |     max_arr\n   |"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_so_far = vec![0; k];\n    let mut max_so_far_len = k;\n    let mut max_so_far_pos\
    \ = 0;\n    let mut max_so_far_neg = 0;\n    let mut max_so_far_zero = 0;\n  \
    \  let mut max_so_far_neg_inv = vec![0; k];\n    let mut max_so_far_neg_inv_len\
    \ = k;\n    let mut max_so_far_neg_inv_pos = 0;\n    let mut max_so_far_neg_inv_zero\
    \ = 0;\n    let mut max_so_far_neg_inv_neg = 0;\n    let mut max_so_far_neg_inv_zero_inv\
    \ = vec![0; k];\n    let mut max_so_far_neg_inv_zero_inv_len = k;\n    let mut\
    \ max_so_far_neg_inv_zero_inv_pos = 0;\n    let mut max_so_far_neg_inv_zero_inv_neg\
    \ = 0;\n    let mut max_so_far_neg_inv_zero_inv_neg_inv = vec![0; k];\n    let\
    \ mut max_so_far_neg_inv_zero_inv_neg_inv_len = k;\n    let mut max_so_far_neg_inv_zero_inv_neg_inv_pos\
    \ = 0;\n    let mut max_so_far_neg_inv_zero_inv_neg_inv_neg = 0;\n    let mut\
    \ max_so_far_neg_inv_zero_inv_neg_inv_neg_inv = vec![0; k];\n    let mut max_so_far_neg_inv_zero_inv_neg_inv_neg_inv_len\
    \ = k;\n    let mut max_so_far_neg_inv_zero_inv_neg_inv_neg_inv_pos = 0;\n   \
    \ let mut max_so_far_neg_inv_zero_inv_neg_inv_neg_inv_neg = 0;\n    let mut max_so_far_neg_inv_zero_inv_neg_inv_neg_inv_neg_inv\
    \ = vec![0; k];\n    let mut max_so_far_neg_inv_zero_inv_neg_inv_neg_inv_len =\
    \ k;\n    let mut max_so_far_neg_inv_zero_inv_neg_inv_neg_inv_pos = 0;\n    let\
    \ mut max_so_far_neg_inv_zero_inv_neg_inv_neg_inv_neg_inv = vec![0; k];\n    let\
    \ mut max_so_far_neg_inv_zero_inv_neg_inv_neg_inv_neg_inv_len = k;\n    let mut\
    \ max_so_far_neg_inv_zero_inv_neg_inv_neg_inv_neg_inv_pos = 0;\n    let mut \n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp0fqjvcyl.rs:46:1\n\
    \   |\n46 | }\n   | ^ expected identifier\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0fqjvcyl.rs:17:34\n   |\n17 |     let mut max_so_far = vec![0;\
    \ k];\n   |                                  ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     let mut max_so_far = vec![0; k.try_into().unwrap()];\n\
    \   |                                   ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0fqjvcyl.rs:22:42\n   |\n22 |     let mut max_so_far_neg_inv\
    \ = vec![0; k];\n   |                                          ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n22 |     let mut max_so_far_neg_inv\
    \ = vec![0; k.try_into().unwrap()];\n   |                                    \
    \       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0fqjvcyl.rs:27:51\n\
    \   |\n27 |     let mut max_so_far_neg_inv_zero_inv = vec![0; k];\n   |      \
    \                                             ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n27 |     let mut max_so_far_neg_inv_zero_inv = vec![0;\
    \ k.try_into().unwrap()];\n   |                                              \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0fqjvcyl.rs:31:59\n\
    \   |\n31 |     let mut max_so_far_neg_inv_zero_inv_neg_inv = vec![0; k];\n  \
    \ |                                                           ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n31 |     let mut max_so_far_neg_inv_zero_inv_neg_inv\
    \ = vec![0; k.try_into().unwrap()];\n   |                                    \
    \                        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0fqjvcyl.rs:35:67\n   |\n35 |     let mut max_so_far_neg_inv_zero_inv_ne"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        let mut max_val = max_arr[i].unwrap();\n\
    \        for j in 0..k {\n            if max_arr[j] > max_val {\n            \
    \    max_val = max_arr[j].unwrap();\n            }\n        }\n        max_arr[i]\
    \ = max_val;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmrh1og98.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpmrh1og98.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpmrh1og98.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpmrh1og98.rs:22:27\n   |\n22 |  \
    \       let mut max_val = max_arr[i].unwrap();\n   |                         \
    \  ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n \
    \  = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpmrh1og98.rs:24:16\n   |\n24 |             if max_arr[j] > max_val {\n\
    \   |                ^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![]; k];\n    for i in 0..k {\n        max_arr[i] = arr\n\
    \            .iter()\n            .take_while(|&x| x < 0)\n            .take_while(|&x|\
    \ x < 0)\n            .take_while(|&x| x < 0)\n            .max();\n    }\n  \
    \  max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdmyxwtgn.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpdmyxwtgn.rs:19:9\n   |\n19 |         max_arr[i]\
    \ = arr\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdmyxwtgn.rs:21:34\n\
    \   |\n21 |             .take_while(|&x| x < 0)\n   |                        \
    \          ^\n   |                                  |\n   |                  \
    \                expected `&isize`, found integer\n   |                      \
    \            help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdmyxwtgn.rs:22:34\n   |\n22 |             .take_while(|&x| x <\
    \ 0)\n   |                                  ^\n   |                          \
    \        |\n   |                                  expected `&isize`, found integer\n\
    \   |                                  help: consider borrowing here: `&0`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpdmyxwtgn.rs:23:34\n   |\n23 |  \
    \           .take_while(|&x| x < 0)\n   |                                  ^\n\
    \   |                                  |\n   |                               \
    \   expected `&isize`, found integer\n   |                                  help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdmyxwtgn.rs:26:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ------"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![0; k];\n    let mut max_idx = k;\n    for &i in arr {\n \
    \       if i > max_arr[k] {\n            max_arr[k] = i;\n            max_idx\
    \ += 1;\n        }\n    }\n    max_arr.sort_unstable();\n    max_arr.truncate(max_idx);\n\
    \    return max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpif75xvxh.rs:17:31\n   |\n\
    17 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpif75xvxh.rs:19:9\n   |\n19 | \
    \    for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpif75xvxh.rs:20:16\n   |\n20 |  \
    \       if i > max_arr[k] {\n   |                ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpif75xvxh.rs:21:13\n   |\n21 |  \
    \           max_arr[k] = i;\n   |             ^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpif75xvxh.rs:26:22\n   |\n26 |     max_arr.truncate(max_idx);\n   | \
    \                     ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n26 |     max_arr.truncate(max_idx.try_into().unwrap());\n   |   \
    \                      "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_so_far = vec![];\n    for i in 0..k {\n\
    \        max_arr.push(arr[i]);\n        max_so_far.push(arr[i]);\n    }\n    for\
    \ i in 1..arr.len() {\n        if max_arr[i] > max_so_far[i] {\n            max_arr.swap(i,\
    \ max_arr.len() - 1);\n            max_so_far.swap(i, max_so_far.len() - 1);\n\
    \        }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7washokx.rs:20:22\n\
    \   |\n20 |         max_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp7washokx.rs:21:25\n   |\n21 |  \
    \       max_so_far.push(arr[i]);\n   |                         ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![arr[i]; 2];\n    }\n    for i in 0..k {\n        for j in 0..k {\n  \
    \          if max_arr[i][j] > max_arr[i][j + 1] {\n                max_arr[i][j]\
    \ = max_arr[i][j + 1];\n            }\n        }\n    }\n    for i in 0..k {\n\
    \        for j in 0..k {\n            if max_arr[i][j] > arr[i] {\n          \
    \      max_arr[i][j] = arr[i];\n            }\n        }\n    }\n    for i in\
    \ 0..k {\n        for j in 0..k {\n            if max_arr[i][j] > arr[j] {\n \
    \               max_arr[i][j] = arr[j];\n            }\n        }\n    }\n   \
    \ for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j] > max_arr[i][j\
    \ + 1] {\n                max_arr[i][j] = max_arr[i][j + 1];\n            }\n\
    \        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if\
    \ max_arr[i][j] > max_arr[i + 1][j] {\n                max_arr[i][j] = max_arr[i\
    \ + 1][j];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if max_arr[i][j] > max_arr[i][j + 1] {\n          \
    \      max_arr[i][j] = max_arr[i][j + 1];\n            }\n        }\n    }\n \
    \   for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j] > max_arr[i\
    \ + 1][j] {\n                max_arr[i][j] = max_arr[i + 1][j];\n            }\n\
    \        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if\
    \ max_arr[i][j] > max_arr[i + 1][j] {\n                max_arr[i][j] = max_arr[i\
    \ + 1][j];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if max_arr[i][j] > max_arr[i + 1][j] {\n          \
    \      max_arr[i][j] = max_arr[i + 1][j];\n            }\n        }\n    }\n \
    \   for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j] > max_arr[i\
    \ + 1][j] {\n                max_arr[i][j] = max_arr[i + 1][j];\n            }\n\
    \        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if\
    \ max_arr[i][j] > max_arr[i + 1][j] {\n                max_arr[i][j] = max_arr[i\
    \ + 1][j];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if max_arr[i][j] > max_arr[i + 1][j] {\n          \
    \      max_arr[i][j] = max_arr[i + 1][j];\n            }\n        }\n    }\n \
    \   for i in 0..k {\n        for j in \n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpax4yelfu.rs:122:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    105 |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n106 |         for j in \n107 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n122 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpax4yelfu.rs:107:1\n    |\n107 | }\n  \
    \  | ^ expected expression\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpax4yelfu.rs:19:9\n   |\n19 |         max_arr[i]\
    \ = vec![arr[i]; 2];\n   |         ^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpax4yelfu.rs:19:27\n   |\n19 |  \
    \       max_arr[i] = vec![arr[i]; 2];\n   |                           ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpax4yelfu.rs:23:16\n   |\n23 |  \
    \           if max_arr[i][j] > max_arr[i][j + 1] {\n   |                ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_num = arr[0];\n    for i in 1..k {\n\
    \        if arr[i] > max_num {\n            max_num = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(max_num);\n\
    \            max_num = arr[i];\n        }\n    }\n    max_arr.push(max_num);\n\
    \    return max_arr;\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpc_t13uci.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpc_t13uci.rs:21:23\n   |\n21 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpc_t13uci.rs:25:12\n   |\n25 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpc_t13uci.rs:27:23\n   |\n27 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![arr[i], -1000, 1000];\n    }\n    for i in 0..k {\n        for j in 0..k\
    \ {\n            if max_arr[i][j] > max_arr[i][j+1] {\n                max_arr[i][j]\
    \ = max_arr[i][j+1];\n            }\n        }\n    }\n    for i in 0..k {\n \
    \       for j in 0..k {\n            if max_arr[i][j] < max_arr[i+1][j] {\n  \
    \              max_arr[i][j] = max_arr[i+1][j];\n            }\n        }\n  \
    \  }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > max_arr[i][j+1] {\n                max_arr[i][j] = max_arr[i][j+1];\n    \
    \        }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n \
    \           if max_arr[i][j] < max_arr[i+1][j] {\n                max_arr[i][j]\
    \ = max_arr[i+1][j];\n            }\n        }\n    }\n    for i in 0..k {\n \
    \       for j in 0..k {\n            if max_arr[i][j] > max_arr[i][j+1] {\n  \
    \              max_arr[i][j] = max_arr[i][j+1];\n            }\n        }\n  \
    \  }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ < max_arr[i+1][j] {\n                max_arr[i][j] = max_arr[i+1][j];\n    \
    \        }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n \
    \           if max_arr[i][j] > max_arr[i][j+1] {\n                max_arr[i][j]\
    \ = max_arr[i][j+1];\n            }\n        }\n    }\n    for i in 0..k {\n \
    \       for j in 0..k {\n            if max_arr[i][j] < max_arr[i+1][j] {\n  \
    \              max_arr[i][j] = max_arr[i+1][j];\n            }\n        }\n  \
    \  }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > max_arr[i][j+1] {\n                max_arr[i][j] = max_arr[i][j+1];\n    \
    \        }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n \
    \           if max_arr[i][j] < max_arr[i+1][j] {\n                max_arr[i][j]\
    \ = max_arr[i+1][j];\n            }\n        }\n    }\n    for i in 0..k {\n \
    \       for j in 0..k {\n            if max_arr[i][j] > max_arr[i][j+1] {\n  \
    \              max_arr[i][j] = max_arr[i][j+1];\n            }\n        }\n  \
    \  }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ < max_arr[i+1][j] {\n                max_arr[i][j] = max_arr[i+1][j];\n    \
    \        }\n\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt49ye9a7.rs:119:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    98  |     for i in 0..k {\n    |                   - unclosed delimiter\n99  |\
    \         for j in 0..k {\n    |                       - this delimiter might\
    \ not be properly closed...\n...\n104 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n119 | }\n    |   ^\n\nerror[E0277]: the type\
    \ `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpt49ye9a7.rs:19:9\n\
    \   |\n19 |         max_arr[i] = vec![arr[i], -1000, 1000];\n   |         ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpt49ye9a7.rs:19:27\n\
    \   |\n19 |         max_arr[i] = vec![arr[i], -1000, 1000];\n   |            \
    \               ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpt49ye9a7.rs:23:16\n   |\n23 |             if max_arr[i][j] > max_arr[i][j+1]\
    \ {\n   |                ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_num = arr[0];\n    for i in 1..k {\n\
    \        if arr[i] > max_num {\n            max_num = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(max_num);\n\
    \        }\n    }\n    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpb7iujppc.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpb7iujppc.rs:21:23\n   |\n21 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpb7iujppc.rs:25:12\n   |\n25 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = max_arr[i].max(arr[i]);\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4h27ts36.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4h27ts36.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = max_arr[i].max(arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4h27ts36.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = max_arr[i].max(arr[i]);\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4h27ts36.rs:19:37\n\
    \   |\n19 |         max_arr[i] = max_arr[i].max(arr[i]);\n   |               \
    \                      ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4h27ts36.rs:21:5\n   |\n16 | fn\
    \ maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[j]\
    \ > max_arr[j + 1] {\n                max_arr[j] = max_arr[j + 1];\n         \
    \   }\n        }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpue5isi5c.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpue5isi5c.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpue5isi5c.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpue5isi5c.rs:23:16\n   |\n23 |  \
    \           if max_arr[j] > max_arr[j + 1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpue5isi5c.rs:23:29\n   |\n23 |             if max_arr[j] > max_arr[j\
    \ + 1] {\n   |                        "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000]; k];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![];\n    }\n    for i in 0..arr.len() {\n        max_arr[k - 1 - i].push(arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr[i].sort_unstable();\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp6c3lrlo.rs:17:41\n   |\n\
    17 |     let mut max_arr = vec![vec![-1000]; k];\n   |                       \
    \                  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max_arr = vec![vec![-1000]; k.try_into().unwrap()];\n   |   \
    \                                       ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpp6c3lrlo.rs:19:9\n\
    \   |\n19 |         max_arr[i] = vec![];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp6c3lrlo.rs:22:25\n   |\n22 |         max_arr[k - 1 - i].push(arr[i]);\n\
    \   |                         ^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot subtract `usize` from `isize`\n  --> /tmp/tmpp6c3lrlo.rs:22:23\n   |\n\
    22 |         max_arr[k - 1 - i].push(arr[i]);\n   |                       ^ no\
    \ implementation for `isize - usize`\n   |\n   = help: the trait `Sub<usize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpp6c3lrlo.rs:22:9\n   |\n22 |         max_arr[k\
    \ - 1 - i].push(arr[i]);\n   |         ^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[j] {\n                max_arr[j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[j] {\n                max_arr[j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[j] {\n                max_arr[j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[j] {\n                max_arr[j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[j] {\n                max_arr[j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[j] {\n                max_arr[j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[j] {\n                max_arr[j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[j] {\n                max_arr[j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[j] {\n                max_arr[j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[j] {\n                max_arr[j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[j] {\n                max_arr[j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[j] {\n                max_arr[j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[j] {\n                max_arr[j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[j] {\n                max_arr[j]\
    \ = arr[i];\n            }\n        }\n    }\n\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpfs8k5yma.rs:19:9\n   |\n19 |         max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpfs8k5yma.rs:19:22\n   |\n19 |         max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n   |                      ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfs8k5yma.rs:23:16\n\
    \   |\n23 |             if arr[i] > max_arr[j] {\n   |                ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfs8k5yma.rs:23:25\n   |\n23 |  \
    \           if arr[i] > max_arr[j] {\n   |                         ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be inde"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[j]\
    \ > max_arr[i] {\n                max_arr[i] = max_arr[j];\n            }\n  \
    \      }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp13930l6e.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp13930l6e.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp13930l6e.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp13930l6e.rs:23:16\n   |\n23 |  \
    \           if max_arr[j] > max_arr[i] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp13930l6e.rs:23:29\n   |\n23 |             if max_arr[j] > max_arr[i]\
    \ {\n   |                             ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    let mut max_idx = k;\n    for i in 0..arr.len()\
    \ {\n        if max_idx < k {\n            max_arr[k] = arr[i];\n            max_idx\
    \ += 1;\n        } else {\n            if arr[i] > max_arr[k] {\n            \
    \    max_arr[k] = arr[i];\n            }\n        }\n    }\n    max_arr\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgfsbjdcs.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpgfsbjdcs.rs:21:13\n   |\n21 |  \
    \           max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpgfsbjdcs.rs:24:25\n   |\n24 |  \
    \           if arr[i] > max_arr[k] {\n   |                         ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpgfsbjdcs.rs:25:17\n   |\n25 |                 max_arr[k] = arr[i];\n\
    \   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgfsbjdcs.rs:29:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \      "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        let mut max_i = i;\n        for j in i..k\
    \ {\n            if max_arr[j] > max_arr[j+1] {\n                max_i = j;\n\
    \            }\n        }\n        max_arr[i] = max_arr[i];\n        max_arr[i]\
    \ = max_arr[i] + max_arr[i] - max_arr[max_i];\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8qgk40qx.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp8qgk40qx.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp8qgk40qx.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp8qgk40qx.rs:24:16\n   |\n24 |  \
    \           if max_arr[j] > max_arr[j+1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp8qgk40qx.rs:24:29\n   |\n24 |             if max_arr[j] > max_arr[j+1]\
    \ {\n   |                            "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0; k]; arr.len()];\n    for i in 0..arr.len() {\n  \
    \      let mut max_val = arr[i];\n        for j in 0..k {\n            if max_val\
    \ < arr[j] {\n                max_val = arr[j];\n            }\n        }\n  \
    \      max_arr[i] = max_val;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzu7bpsuk.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k]; arr.len()];\n   |                \
    \                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k.try_into().unwrap()]; arr.len()];\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzu7bpsuk.rs:21:26\n\
    \   |\n21 |             if max_val < arr[j] {\n   |                          ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzu7bpsuk.rs:22:27\n\
    \   |\n22 |                 max_val = arr[j];\n   |                          \
    \ ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzu7bpsuk.rs:25:22\n   |\n25 |         max_arr[i]\
    \ = max_val;\n   |         ----------   ^^^^^^^ expected struct `Vec`, found `isize`\n\
    \   |         |\n   |         expected due to the type of this binding\n   |\n\
    \   = note: expected struct `Vec<{integer}>`\n                found type `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzu7bpsuk.rs:27:5\n   |\n16 | fn\
    \ maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |                   \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n27 |     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_k = k;\n    let mut i = 0;\n    while\
    \ i < arr.len() {\n        if arr[i] > max_arr[0] {\n            max_arr[0] =\
    \ arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[1] {\n\
    \            max_arr[1] = arr[i];\n            max_k = 1;\n        }\n       \
    \ if arr[i] > max_arr[2] {\n            max_arr[2] = arr[i];\n            max_k\
    \ = 2;\n        }\n        i += 1;\n    }\n    max_arr.drain(..max_k);\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `RangeTo<isize>: RangeBounds<usize>` is not\
    \ satisfied\n    --> /tmp/tmp0ujd084_.rs:35:19\n     |\n35   |     max_arr.drain(..max_k);\n\
    \     |             ----- ^^^^^^^ the trait `RangeBounds<usize>` is not implemented\
    \ for `RangeTo<isize>`\n     |             |\n     |             required by a\
    \ bound introduced by this call\n     |\n     = help: the following other types\
    \ implement trait `RangeBounds<T>`:\n               RangeTo<&T>\n            \
    \   RangeTo<T>\nnote: required by a bound in `Vec::<T, A>::drain`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![vec![0]; k];\n    for i in 0..k {\n        result[i] = vec![arr[i];\
    \ 1];\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if result[i][j]\
    \ > result[i][j+1] {\n                result[i][j] = result[i][j];\n         \
    \   }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n      \
    \      if result[i][j] > result[i+1][j] {\n                result[i+1][j] = result[i][j];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if result[i][j] > result[i+1][j+1] {\n                result[i+1][j+1]\
    \ = result[i][j];\n            }\n        }\n    }\n    for i in 0..k {\n    \
    \    result[i].pop();\n    }\n    for i in 0..k {\n        result[i].sort();\n\
    \    }\n    for i in 0..k {\n        result[i].push(arr[i]);\n    }\n    for i\
    \ in 0..k {\n        result[i].sort();\n    }\n    for i in 0..k {\n        result[i].push(arr[i]);\n\
    \    }\n    for i in 0..k {\n        result[i].sort();\n    }\n    for i in 0..k\
    \ {\n        result[i].push(arr[i]);\n    }\n    for i in 0..k {\n        result[i].sort();\n\
    \    }\n    for i in 0..k {\n        result[i].push(arr[i]);\n    }\n    for i\
    \ in 0..k {\n        result[i].sort();\n    }\n    for i in 0..k {\n        result[i].push(arr[i]);\n\
    \    }\n    for i in 0..k {\n        result[i].sort();\n    }\n    for i in 0..k\
    \ {\n        result[i].push(arr[i]);\n    }\n    for i in 0..k {\n        result[i].sort();\n\
    \    }\n    for i in 0..k {\n        result[i].push(arr[i]);\n    }\n    for i\
    \ in 0..k {\n        result[i].sort();\n    }\n    for i in 0..k {\n        result[i].push(arr[i]);\n\
    \    }\n    for i in 0..k {\n        result[i].sort();\n    }\n    for i in 0..k\
    \ {\n        result[i].push(arr[i]);\n    }\n    for i in 0..k {\n        result[i].sort();\n\
    \    }\n    for i in 0..k {\n        result[i].push(arr[i]);\n    }\n    for i\
    \ in 0..k {\n        result[i].sort();\n    }\n    for i in 0..k {\n        result[i].push(arr[i]);\n\
    \    }\n    for i in 0..k {\n        result[i].sort();\n    }\n    for i in 0..k\
    \ {\n        result[i].push(arr[i]);\n    }\n    for i in 0..k {\n        result[i].sort();\n\
    \    }\n    for i in 0..k {\n        result[i].push(arr[i]);\n    }\n    for i\
    \ in 0..k {\n        result[i].sort();\n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp87dahopv.rs:140:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    123 |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n124 |         result[i].sort();\n125 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n140 | }\n    |   ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp87dahopv.rs:17:36\n   |\n17 |  \
    \   let mut result = vec![vec![0]; k];\n   |                                 \
    \   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut result = vec![vec![0]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp87dahopv.rs:19:9\n   |\n19 |   \
    \      result[i] = vec![arr[i]; 1];\n   |         ^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp87dahopv.rs:19:26\n   |\n19 |  \
    \       result[i] = vec![arr[i]; 1];\n   |                          ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp87dahopv.rs:23:16\n   |\n23 |  \
    \           if result[i][j] > result[i][j+1] {\n   |                ^^^^^^^^^\
    \ slice indices are of type `us"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![vec![0; k]; arr.len()];\n    for i in 0..arr.len() {\n   \
    \     let mut max = 0;\n        for j in 0..k {\n            if arr[i] > arr[j]\
    \ {\n                max = arr[i];\n            } else {\n                max\
    \ = arr[j];\n            }\n        }\n        result[i] = vec![max; k];\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptkpry48q.rs:17:35\n   |\n\
    17 |     let mut result = vec![vec![0; k]; arr.len()];\n   |                 \
    \                  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut result = vec![vec![0; k.try_into().unwrap()]; arr.len()];\n \
    \  |                                    ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmptkpry48q.rs:21:25\n\
    \   |\n21 |             if arr[i] > arr[j] {\n   |                         ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmptkpry48q.rs:24:23\n\
    \   |\n24 |                 max = arr[j];\n   |                       ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptkpry48q.rs:27:31\n   |\n27 |         result[i] = vec![max; k];\n\
    \   |                               ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n27 |         result[i] = vec![max; k.try_into().unwrap()];\n\
    \   |                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptkpry48q.rs:29:5\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n29 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ max_idx = 1;\n    let mut min_idx = 1;\n    let mut min_val = arr[0];\n    let\
    \ mut max_val = arr[0];\n    for &i in arr {\n        if i > max_val {\n     \
    \       max_val = i;\n            max_idx = max_idx + 1;\n        }\n        if\
    \ i < min_val {\n            min_val = i;\n            min_idx = min_idx + 1;\n\
    \        }\n        if max_idx > max_k {\n            max_arr = max_arr.push(vec![max_val]);\n\
    \            max_idx = 1;\n        }\n        if min_idx > max_k {\n         \
    \   max_arr = max_arr.push(vec![min_val]);\n            min_idx = 1;\n       \
    \ }\n        if max_idx < min_k {\n            max_arr = max_arr.push(vec![min_val]);\n\
    \            min_idx = 1;\n        }\n        if max_idx < min_k {\n         \
    \   max_arr = max_arr.push(vec![max_val]);\n            min_idx = 1;\n       \
    \ }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `min_k` in this scope\n  --> /tmp/tmpnsxwkns3.rs:40:22\n\
    \   |\n40 |         if max_idx < min_k {\n   |                      ^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `min_k` in this scope\n\
    \  --> /tmp/tmpnsxwkns3.rs:44:22\n   |\n44 |         if max_idx < min_k {\n  \
    \ |                      ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnsxwkns3.rs:23:9\n   |\n23 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `Option<isize>`\n   |         |\n\
    \   |         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsxwkns3.rs:33:23\n\
    \   |\n17 |     let mut max_arr = vec![vec![-1000, 1000]];\n   |             \
    \          ----------------------- expected due to this value\n...\n33 |     \
    \        max_arr = max_arr.push(vec![max_val]);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n\
    \           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsxwkns3.rs:37:23\n\
    \   |\n17 |     let mut max_arr = vec![vec![-1000, 1000]];\n   |             \
    \          ----------------------- expected due to this value\n...\n37 |     \
    \        max_arr = max_arr.push(vec![min_val]);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n\
    \           found unit type `()`\nnote: method `push` modifies its receiver in-place\n\
    \  --> /tmp/tmpnsxwkns3.rs:37:31\n   |\n37 |             max_arr = max_arr.push(vec![min_val]);\n\
    \   |                       ------- ^^^^ this call modifies `max_arr` in-place\n\
    \   |                       |\n   |                       you probably want to\
    \ use this value after calling the method...\n   = note: ...instead of the `()`\
    \ output of method `push`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsxwkns3.rs:41:23\n\
    \  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![]; k];\n    for i in 0..k {\n        max_arr[i] = vec![arr[i];\
    \ 1];\n    }\n    for i in 0..k {\n        max_arr[i].sort_unstable();\n    }\n\
    \    for i in 0..k {\n        max_arr[i].iter().cloned().collect();\n    }\n \
    \   max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc8ssmwae.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpc8ssmwae.rs:19:9\n   |\n19 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |         ^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpc8ssmwae.rs:19:27\n   |\n19 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpc8ssmwae.rs:22:9\n   |\n22 |         max_arr[i].sort_unstable();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<_>>`\n\
    \nerror[E0277]: the type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmpc8ssmwae.rs:25:9\n\
    \   |\n25 |         max_arr[i].iter().cloned().collect();\n   |         ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0; k]; arr.len()];\n    for i in 0..arr.len() {\n  \
    \      for j in 0..k {\n            if arr[i] > max_arr[j][k] {\n            \
    \    max_arr[j][k] = arr[i];\n            }\n        }\n    }\n    max_arr\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjdmf3dr1.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k]; arr.len()];\n   |                \
    \                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max_arr = vec![vec![0; k.try_into().unwrap()]; arr.len()];\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpjdmf3dr1.rs:20:25\n\
    \   |\n20 |             if arr[i] > max_arr[j][k] {\n   |                    \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpjdmf3dr1.rs:21:17\n   |\n21 |                 max_arr[j][k] = arr[i];\n\
    \   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjdmf3dr1.rs:25:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     max_arr\n   |     ^^^^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<Vec<{integer}>>`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    let mut max_idx = k;\n    for i in 0..arr.len()\
    \ {\n        if max_idx > 0 && arr[i] > max_arr[0][k] {\n            max_arr[0]\
    \ = vec![arr[i]; max_idx];\n            max_idx = 0;\n        }\n        if max_idx\
    \ > 0 && arr[i] > max_arr[0][k] {\n            max_arr[0][k] = arr[i];\n     \
    \   }\n        if max_idx > 0 && arr[i] > max_arr[0][k] {\n            max_arr[0][k]\
    \ = arr[i];\n        }\n        if max_idx > 0 && arr[i] > max_arr[0][k] {\n \
    \           max_arr[0][k] = arr[i];\n        }\n        if max_idx > 0 && arr[i]\
    \ > max_arr[0][k] {\n            max_arr[0][k] = arr[i];\n        }\n        if\
    \ max_idx > 0 && arr[i] > max_arr[0][k] {\n            max_arr[0][k] = arr[i];\n\
    \        }\n        if max_idx > 0 && arr[i] > max_arr[0][k] {\n            max_arr[0][k]\
    \ = arr[i];\n        }\n        if max_idx > 0 && arr[i] > max_arr[0][k] {\n \
    \           max_arr[0][k] = arr[i];\n        }\n        if max_idx > 0 && arr[i]\
    \ > max_arr[0][k] {\n            max_arr[0][k] = arr[i];\n        }\n        if\
    \ max_idx > 0 && arr[i] > max_arr[0][k] {\n            max_arr[0][k] = arr[i];\n\
    \        }\n        if max_idx > 0 && arr[i] > max_arr[0][k] {\n            max_arr[0][k]\
    \ = arr[i];\n        }\n        if max_idx > 0 && arr[i] > max_arr[0][k] {\n \
    \           max_arr[0][k] = arr[i];\n        }\n        if max_idx > 0 && arr[i]\
    \ > max_arr[0][k] {\n            max_arr[0][k] = arr[i];\n        }\n        if\
    \ max_idx > 0 && arr[i] > max_arr[0][k] {\n            max_arr[0][k] = arr[i];\n\
    \        }\n        if max_idx > 0 && arr[i] > max_arr[0][k] {\n            max_arr[0][k]\
    \ = arr[i];\n        }\n        if max_idx > 0 && arr[i] > max_arr[0][k] {\n \
    \           max_arr[0][k] = arr[i];\n        }\n        if max_idx > 0 && arr[i]\
    \ > max_arr[0][k] {\n            max_arr[0][k] = arr[i];\n        }\n        if\
    \ max_idx > 0 && arr[i] > max_arr[0][k] {\n            max_arr[0][k] = arr[i];\n\
    \        }\n        if max_idx > 0 && arr[i] > max_arr[0][k] {\n            max_arr[0][k]\
    \ = arr[i];\n        }\n        if max_idx > 0 && arr[i] > max_arr[0][k] {\n \
    \           max_arr[0][k] = arr[i];\n        }\n        if max_idx > 0 && arr[i]\
    \ > max_arr[0][k] {\n            max_\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1ajmoubh.rs:98:3\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                               - unclosed delimiter\n...\n19\
    \ |     for i in 0..arr.len() {\n   |                           - unclosed delimiter\n\
    ...\n81 |         if max_idx > 0 && arr[i] > max_arr[0][k] {\n   |           \
    \                                       - this delimiter might not be properly\
    \ closed...\n82 |             max_\n83 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n98 | }\n   |   ^\n\nerror[E0425]: cannot find\
    \ value `max_` in this scope\n  --> /tmp/tmp1ajmoubh.rs:82:13\n   |\n82 |    \
    \         max_\n   |             ^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1ajmoubh.rs:17:37\n   |\n17 |     let mut max_arr\
    \ = vec![vec![0]; k];\n   |                                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     let mut max_arr = vec![vec![0];\
    \ k.try_into().unwrap()];\n   |                                      ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp1ajmoubh.rs:20:36\n\
    \   |\n20 |         if max_idx > 0 && arr[i] > max_arr[0][k] {\n   |         \
    \                           ^^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp1ajmoubh.rs:21:39\n   |\n21 |             max_arr[0] = vec![arr[i];\
    \ max_idx];\n   |                                       ^^^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |             max_arr[0] = vec![arr[i];\
    \ max_idx.try_into().un"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_>>();\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_>>();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_>>();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_>>();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_>>();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_>>();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_>>();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_>>();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_>>();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_>>();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_>>();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_>>();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_>>();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_>>();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_>>();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_>>();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpgzvoyvtd.rs:89:3\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                               - unclosed delimiter\n...\n72\
    \ |     for i in 0..k {\n   |                   - this delimiter might not be\
    \ properly closed...\n73 |         max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_\n\
    74 | }\n   | - ...as it matches this but it has different indentation\n...\n89\
    \ | }\n   |   ^\n\nerror: expected one of `,`, `:`, `=`, or `>`, found `}`\n \
    \ --> /tmp/tmpgzvoyvtd.rs:74:1\n   |\n73 |         max_arr[i] = max_arr[i].iter().cloned().collect::<Vec<_\n\
    \   |                                                                - expected\
    \ one of `,`, `:`, `=`, or `>`\n74 | }\n   | ^ unexpected token\n   |\nhelp: you\
    \ might have meant to end the type parameters here\n   |\n73 |         max_arr[i]\
    \ = max_arr[i].iter().cloned().collect::<Vec<_>\n   |                        \
    \                                        +\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpgzvoyvtd.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = max_arr[i].iter().max().unwrap();\n   |         ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpgzvoyvtd.rs:19:22\n   |\n19 |         max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \   |                      ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{int"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].max();\n    }\n \
    \   for i in 0..k {\n        arr[i] = max_arr[i];\n    }\n    return arr;\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfbrlv8g3.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfbrlv8g3.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfbrlv8g3.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfbrlv8g3.rs:22:9\n   |\n22 |   \
    \      max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfbrlv8g3.rs:22:22\n   |\n22 |  \
    \       max_arr[i] = max_arr[i].max();\n   |                      ^^^^^^^^^^ slice\
    \ indic"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000]; k];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![-1000];\n    }\n    for i in 0..arr.len() {\n        max_arr[k - 1 -\
    \ i].push(arr[i]);\n    }\n    for i in 0..k {\n        max_arr[i].sort();\n \
    \   }\n    for i in 0..k {\n        max_arr[i].push(max_arr[i].iter().max().unwrap());\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k\n}\n\nfn main() {\n    let candidate = maximum;\n  \
    \  assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpl3kjco1g.rs:88:1\n   |\n\
    88 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl3kjco1g.rs:17:41\n\
    \   |\n17 |     let mut max_arr = vec![vec![-1000]; k];\n   |                \
    \                         ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n17 |     let mut max_arr = vec![vec![-1000]; k.try_into().unwrap()];\n\
    \   |                                          ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpl3kjco1g.rs:19:9\n\
    \   |\n19 |         max_arr[i] = vec![-1000];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl3kjco1g.rs:22:25\n   |\n22 |         max_arr[k - 1 - i].push(arr[i]);\n\
    \   |                         ^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot subtract `usize` from `isize`\n  --> /tmp/tmpl3kjco1g.rs:22:23\n   |\n\
    22 |         max_arr[k - 1 - i].push(arr[i]);\n   |                       ^ no\
    \ implementation for `isize - usize`\n   |\n   = help: the trait `Sub<usize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpl3kjco1g.rs:22:9\n   |\n22 |         max_arr[k\
    \ - 1 - i].push(arr[i]);\n   |         ^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[i]\
    \ > max_arr[j] {\n                max_arr[i] = max_arr[j];\n            }\n  \
    \      }\n    }\n    for i in 0..k {\n        if max_arr[i] != arr[i] {\n    \
    \        max_arr[i] = arr[i];\n        }\n    }\n    for i in 0..k {\n       \
    \ max_arr[i] = max_arr[i].unwrap();\n    }\n    max_arr\n}\n\nfn main() {\n  \
    \  let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqhs8zj1d.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpqhs8zj1d.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpqhs8zj1d.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpqhs8zj1d.rs:23:16\n   |\n23 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpqhs8zj1d.rs:23:29\n   |\n23 |             if max_arr[i] > max_arr[j]\
    \ {\n   |                             ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![]; k];\n    for i in 0..k {\n        max_arr[i] = arr\n\
    \            .iter()\n            .max_by(|a, b| a.partial_cmp(&b).unwrap())\n\
    \            .unwrap();\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpps2iinam.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpps2iinam.rs:19:9\n   |\n19 |         max_arr[i]\
    \ = arr\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpps2iinam.rs:24:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n24 |     max_arr\n   |     ^^^^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<Vec<_>>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![]; k];\n    for i in 0..k {\n        max_arr[i] = vec![arr[i];\
    \ 1];\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > max_arr[i][j + 1] {\n                max_arr[i][j] = max_arr[i][j + 1];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] == max_arr[i][j] {\n                max_arr[i][j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc3su3m49.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpc3su3m49.rs:19:9\n   |\n19 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |         ^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpc3su3m49.rs:19:27\n   |\n19 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpc3su3m49.rs:23:16\n   |\n23 |         \
    \    if max_arr[i][j] > max_arr[i][j + 1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<_>]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]:\
    \ the type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmpc3su3m49.rs:23:32\n\
    \   |\n23 |             if max_arr[i][j] > max_arr[i][j + 1] {\n   |         \
    \                       ^^^^^^^^^^ slice "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if max_arr[0].0 > arr[i] {\n    \
    \        max_arr[0] = vec![arr[i], -1000, 1000];\n            max_k = 1;\n   \
    \     } else {\n            if max_arr[0].1 > arr[i] {\n                max_arr[1]\
    \ = vec![arr[i], -1000, 1000];\n                max_k = 2;\n            } else\
    \ {\n                max_arr[2] = vec![arr[i], -1000, 1000];\n               \
    \ max_k = 3;\n            }\n        }\n        i += 1;\n    }\n    max_arr.sort_unstable_by_key(|&x|\
    \ x.0);\n    if max_k == 1 {\n        max_arr.iter().cloned().take(max_k).collect()\n\
    \    } else if max_k == 2 {\n        max_arr.iter().cloned().take(max_k).collect::<Vec<_>>()\n\
    \    } else {\n        max_arr.iter().cloned().take(max_k).collect::<Vec<_>>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0609]: no field `0` on type `Vec<{integer}>`\n  --> /tmp/tmpjiwzexb0.rs:21:23\n\
    \   |\n21 |         if max_arr[0].0 > arr[i] {\n   |                       ^ unknown\
    \ field\n\nerror[E0609]: no field `1` on type `Vec<isize>`\n  --> /tmp/tmpjiwzexb0.rs:25:27\n\
    \   |\n25 |             if max_arr[0].1 > arr[i] {\n   |                     \
    \      ^ unknown field\n\nerror[E0609]: no field `0` on type `Vec<isize>`\n  -->\
    \ /tmp/tmpjiwzexb0.rs:35:41\n   |\n35 |     max_arr.sort_unstable_by_key(|&x|\
    \ x.0);\n   |                                         ^ unknown field\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjiwzexb0.rs:37:38\n   |\n37 |         max_arr.iter().cloned().take(max_k).collect()\n\
    \   |                                      ^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n37 |         max_arr.iter().cloned().take(max_k.try_into().unwrap()).collect()\n\
    \   |                                           ++++++++++++++++++++\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built from an iterator over elements\
    \ of type `Vec<isize>`\n    --> /tmp/tmpjiwzexb0.rs:37:45\n     |\n37   |    \
    \     max_arr.iter().cloned().take(max_k).collect()\n     |                  \
    \                           ^^^^^^^ value of type `Vec<isize>` cannot be built\
    \ from `std::iter::Iterator<Item=Vec<isize>>`\n     |\n     = help: the trait\
    \ `FromIterator<Vec<isize>>` is not implemented for `Vec<isize>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjiwzexb0.rs:39:38\n\
    \   |\n39 |         max_arr.iter().cloned().take(max_k).collect::<Vec<_>>()\n\
    \   |                                      ^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n39 |         max_arr.iter().cloned().take(max_k.try_into().unwrap()).collect::<Vec<_>>()\n\
    \   |                                           ++++++++++++++++++++\n\nerror[E03"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[j]\
    \ > max_arr[j + 1] {\n                max_arr[j] = max_arr[j + 1];\n         \
    \   }\n        }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp72mji3r8.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp72mji3r8.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp72mji3r8.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp72mji3r8.rs:23:16\n   |\n23 |  \
    \           if max_arr[j] > max_arr[j + 1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp72mji3r8.rs:23:29\n   |\n23 |             if max_arr[j] > max_arr[j\
    \ + 1] {\n   |                        "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[j]\
    \ > max_arr[j + 1] {\n                max_arr[j] = max_arr[j + 1];\n         \
    \   }\n        }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpewe5q9yq.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpewe5q9yq.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpewe5q9yq.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpewe5q9yq.rs:23:16\n   |\n23 |  \
    \           if max_arr[j] > max_arr[j + 1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpewe5q9yq.rs:23:29\n   |\n23 |             if max_arr[j] > max_arr[j\
    \ + 1] {\n   |                        "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n  \
    \  }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpa_1fakbh.rs:101:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    84  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n85  |         max_arr[i] = max_arr[i].iter().\n86  |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n101\
    \ | }\n    |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpa_1fakbh.rs:86:1\n\
    \   |\n86 | }\n   | ^\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpa_1fakbh.rs:19:9\n   |\n19 |         max_arr[i] =\
    \ max_arr[i].iter().max().unwrap();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpa_1fakbh.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = max_arr[i].iter().max().unwrap();\n   |                 \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpa_1fakbh.rs:22:9\n   |\n22 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<i"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = max_arr[i].max(arr[i]);\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa5r6btst.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpa5r6btst.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = max_arr[i].max(arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpa5r6btst.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = max_arr[i].max(arr[i]);\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpa5r6btst.rs:19:37\n\
    \   |\n19 |         max_arr[i] = max_arr[i].max(arr[i]);\n   |               \
    \                      ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpa5r6btst.rs:21:5\n   |\n16 | fn\
    \ maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let mut j = i;\n        while j <\
    \ arr.len() && arr[j] < max_arr[0][j] {\n            j += 1\n        }\n     \
    \   max_arr[i] = arr[j..j + max_k].iter().cloned().collect();\n        i += 1;\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7k9y352m.rs:25:33\n   |\n\
    25 |         max_arr[i] = arr[j..j + max_k].iter().cloned().collect();\n   | \
    \                                ^^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add `isize` to `usize`\n  --> /tmp/tmp7k9y352m.rs:25:31\n   |\n25 | \
    \        max_arr[i] = arr[j..j + max_k].iter().cloned().collect();\n   |     \
    \                          ^ no implementation for `usize + isize`\n   |\n   =\
    \ help: the trait `Add<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `Add<Rhs>`:\n             <&'a f32 as\
    \ Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n\
    \             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n    \
    \         <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n          \
    \   <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7k9y352m.rs:28:5\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n28 |     max_arr\n   |  \
    \   ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<Vec<isize>>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![0; k];\n    let mut max_element = arr[0];\n    for i in 1..k\
    \ {\n        if arr[i] > max_element {\n            max_element = arr[i];\n  \
    \      }\n    }\n    for i in 0..k {\n        result[i] = max_element;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphevpfzf6.rs:17:30\n   |\n\
    17 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmphevpfzf6.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_element {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmphevpfzf6.rs:21:27\n   |\n21 |            \
    \ max_element = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmphevpfzf6.rs:25:9\n   |\n25 |         result[i]\
    \ = max_element;\n   |         ^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_so_far = arr[0];\n    let mut max_so_far_index = arr.len();\n    for\
    \ i in 1..k {\n        if arr[i] > max_so_far {\n            max_so_far = arr[i];\n\
    \            max_so_far_index = i;\n        }\n    }\n    arr.iter().take(max_so_far_index).collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpvnifx_5h.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_so_far {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpvnifx_5h.rs:21:26\n   |\n21 |            \
    \ max_so_far = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvnifx_5h.rs:22:32\n\
    \   |\n18 |     let mut max_so_far_index = arr.len();\n   |                  \
    \              --------- expected due to this value\n...\n22 |             max_so_far_index\
    \ = i;\n   |                                ^ expected `usize`, found `isize`\n\
    \nerror[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmpvnifx_5h.rs:25:39\n     |\n\
    25   |     arr.iter().take(max_so_far_index).collect()\n     |               \
    \                        ^^^^^^^ value of type `Vec<isize>` cannot be built from\
    \ `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait `FromIterator<&isize>`\
    \ is not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..arr.len() {\n\
    \        max_arr[k][i] = max(arr[i], max_arr[k][i]);\n    }\n    max_arr.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpedfezd9x.rs:22:25\n\
    \   |\n22 |         max_arr[k][i] = max(arr[i], max_arr[k][i]);\n   |        \
    \                 ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0277]: the type\
    \ `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpedfezd9x.rs:19:9\n\
    \   |\n19 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n   | \
    \        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for\
    \ `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpedfezd9x.rs:19:22\n   |\n19 |         max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpedfezd9x.rs:22:9\n   |\n22 |         max_arr[k][i] = max(arr[i], max_arr[k][i]);\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpedfezd9x.rs:22:37\n   |\n22 |         max_arr[k][i]\
    \ = max(arr[i], max_arr[k][i]);\n   |                                     ^^^^^^^^^^\
    \ slice indice"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n    }\n    for i in 0..k {\n        max_arr[i].push(arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr[i].sort();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i].iter().cloned().collect();\n    }\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp9c2i0n0g.rs:19:9\n   |\n19 |         max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp9c2i0n0g.rs:19:22\n   |\n19 |         max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n   |                      ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp9c2i0n0g.rs:22:9\n   |\n22 |         max_arr[i].push(arr[i]);\n   |\
    \         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp9c2i0n0g.rs:22:25\n   |\n22 |         max_arr[i].push(arr[i]);\n\
    \   |                         ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed\
    \ by `isize`\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![0; k];\n    let mut max_val = arr[0];\n    for i in 0..k {\n\
    \        if arr[i] > max_val {\n            max_val = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        result[i] = max_val;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2cjzemdn.rs:17:30\n   |\n\
    17 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp2cjzemdn.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp2cjzemdn.rs:21:23\n   |\n21 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp2cjzemdn.rs:25:9\n   |\n25 |         result[i]\
    \ = max_val;\n   |         ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![]; k];\n    for i in 0..k {\n        max_arr[i] = vec![arr[i];\
    \ 1];\n    }\n    for i in 0..k {\n        max_arr[i].sort_by_key(|&x| x);\n \
    \   }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_by_key(|&x|\
    \ x).collect();\n    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_by_key(|&x|\
    \ x).collect();\n    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_by_key(|&x|\
    \ x).collect();\n    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_by_key(|&x|\
    \ x).collect();\n    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_by_key(|&x|\
    \ x).collect();\n    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_by_key(|&x|\
    \ x).collect();\n    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_by_key(|&x|\
    \ x).collect();\n    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_by_key(|&x|\
    \ x).collect();\n    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_by_key(|&x|\
    \ x).collect();\n    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_by_key(|&x|\
    \ x).collect();\n    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_by_key(|&x|\
    \ x).collect();\n    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_by_key(|&x|\
    \ x).collect();\n    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec<_>>().sort_by_key(|&x|\
    \ x).collect();\n    }\n    for i in 0..k {\n        max_arr[i].iter().cloned().collect::<Vec\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpm5fjqvmk.rs:80:3\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                               - unclosed delimiter\n...\n63\
    \ |     for i in 0..k {\n   |                   - this delimiter might not be\
    \ properly closed...\n64 |         max_arr[i].iter().cloned().collect::<Vec\n\
    65 | }\n   | - ...as it matches this but it has different indentation\n...\n80\
    \ | }\n   |   ^\n\nerror: expected one of `!`, `(`, `+`, `,`, `::`, `:`, `<`,\
    \ `=`, or `>`, found `}`\n  --> /tmp/tmpm5fjqvmk.rs:65:1\n   |\n64 |         max_arr[i].iter().cloned().collect::<Vec\n\
    \   |                                                 - expected one of 9 possible\
    \ tokens\n65 | }\n   | ^ unexpected token\n   |\nhelp: you might have meant to\
    \ end the type parameters here\n   |\n64 |         max_arr[i].iter().cloned().collect::<Vec>\n\
    \   |                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm5fjqvmk.rs:17:36\n   |\n17 |     let mut max_arr = vec![vec![];\
    \ k];\n   |                                    ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     let mut max_arr = vec![vec![]; k.try_into().unwrap()];\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmpm5fjqvmk.rs:19:9\n\
    \   |\n19 |         max_arr[i] = vec![arr[i]; 1];\n   |         ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<_>]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpm5fjqvmk.rs:19:27\n\
    \   |\n19 |         max_arr[i] = vec![arr[i]; 1];\n   |                      \
    \     ^^^^^^ slice indices are of type `usize` or ranges of `usiz"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ max_i = -1;\n    for i in 0..arr.len() {\n        let mut cur_max = -1000 +\
    \ 1000;\n        let mut cur_max_i = -1;\n        for j in 0..k {\n          \
    \  if arr[i] > cur_max {\n                cur_max = arr[i];\n                cur_max_i\
    \ = j;\n            }\n        }\n        max_arr[i] = vec![cur_max, cur_max_i];\n\
    \        if cur_max_i == k {\n            max_k = cur_max_i;\n        }\n    }\n\
    \    max_arr.sort_by_key(|x| x.0);\n    max_arr.iter().take(max_k).collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0609]: no field `0` on type `&Vec<isize>`\n  --> /tmp/tmp2mho63es.rs:34:31\n\
    \   |\n34 |     max_arr.sort_by_key(|x| x.0);\n   |                          \
    \     ^ unknown field\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2mho63es.rs:35:25\n\
    \   |\n35 |     max_arr.iter().take(max_k).collect()\n   |                   \
    \      ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n35 |     max_arr.iter().take(max_k.try_into().unwrap()).collect()\n\
    \   |                              ++++++++++++++++++++\n\nerror[E0277]: a value\
    \ of type `Vec<isize>` cannot be built from an iterator over elements of type\
    \ `&Vec<isize>`\n    --> /tmp/tmp2mho63es.rs:35:32\n     |\n35   |     max_arr.iter().take(max_k).collect()\n\
    \     |                                ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=&Vec<isize>>`\n     |\n     = help:\
    \ the trait `FromIterator<&Vec<isize>>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let mut j = i;\n        while j <\
    \ arr.len() && arr[j] < max_arr[0][j] {\n            j += 1\n        }\n     \
    \   if j - i > max_k {\n            max_k = j - i;\n            max_arr[0] = max_arr[0].clone();\n\
    \            max_arr[1] = max_arr[1].clone();\n        }\n        max_arr[0][i]\
    \ = arr[i];\n        max_arr[1][i] = arr[j];\n        i += 1;\n    }\n    max_arr[0].swap(0,\
    \ max_k);\n    max_arr[1].swap(0, max_k);\n    max_arr\n}\n\nfn main() {\n   \
    \ let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpld726he2.rs:25:20\n   |\n\
    25 |         if j - i > max_k {\n   |                    ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i > max_k.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpld726he2.rs:26:21\n   |\n18 |     let mut max_k = k;\n\
    \   |                     - expected due to this value\n...\n26 |            \
    \ max_k = j - i;\n   |                     ^^^^^ expected `isize`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpld726he2.rs:34:24\n   |\n34 |\
    \     max_arr[0].swap(0, max_k);\n   |                        ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n34 |     max_arr[0].swap(0, max_k.try_into().unwrap());\n\
    \   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpld726he2.rs:35:24\n   |\n35 |     max_arr[1].swap(0, max_k);\n\
    \   |                        ^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n35 |     max_arr[1].swap(0, max_k.try_into().unwrap());\n   |   \
    \                          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpld726he2.rs:36:5\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n36 |     max_arr\n   |     ^^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Vec<isize>>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![0; k];\n    let mut max_idx = k;\n    let mut max_value =\
    \ arr[0];\n    for &i in arr {\n        if i > max_value {\n            max_value\
    \ = i;\n        }\n        if i == max_value {\n            max_arr[k - 1] = i;\n\
    \        }\n        if max_idx > k - 1 {\n            break;\n        }\n    \
    \    max_arr[k - 1] = i;\n        max_idx -= 1;\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0zh531mq.rs:17:31\n   |\n\
    17 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0zh531mq.rs:20:9\n   |\n20 | \
    \    for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp0zh531mq.rs:25:13\n   |\n25 |  \
    \           max_arr[k - 1] = i;\n   |             ^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp0zh531mq.rs:30:9\n   |\n30 |   \
    \      max_arr[k - 1] = i;\n   |         ^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![arr[i], arr[i]];\n    }\n    for i in 0..k {\n        let mut max_num\
    \ = max_arr[i][0];\n        let mut max_pos = 0;\n        for j in 0..k {\n  \
    \          if max_arr[j][0] > max_num {\n                max_num = max_arr[j][0];\n\
    \                max_pos = j;\n            }\n        }\n        max_arr[i][2]\
    \ = max_pos;\n    }\n    for i in 0..k {\n        let mut max_num = max_arr[i][0];\n\
    \        let mut max_pos = 0;\n        for j in 0..k {\n            if max_arr[j][0]\
    \ > max_num {\n                max_num = max_arr[j][0];\n                max_pos\
    \ = j;\n            }\n        }\n        max_arr[i][2] = max_pos;\n    }\n  \
    \  for i in 0..k {\n        let mut max_num = max_arr[i][0];\n        let mut\
    \ max_pos = 0;\n        for j in 0..k {\n            if max_arr[j][0] > max_num\
    \ {\n                max_num = max_arr[j][0];\n                max_pos = j;\n\
    \            }\n        }\n        max_arr[i][2] = max_pos;\n    }\n    for i\
    \ in 0..k {\n        let mut max_num = max_arr[i][0];\n        let mut max_pos\
    \ = 0;\n        for j in 0..k {\n            if max_arr[j][0] > max_num {\n  \
    \              max_num = max_arr[j][0];\n                max_pos = j;\n      \
    \      }\n        }\n        max_arr[i][2] = max_pos;\n    }\n    for i in 0..k\
    \ {\n        let mut max_num = max_arr[i][0];\n        let mut max_pos = 0;\n\
    \        for j in 0..k {\n            if max_arr[j][0] > max_num {\n         \
    \       max_num = max_arr[j][0];\n                max_pos = j;\n            }\n\
    \        }\n        max_arr[i][2] = max_pos;\n    }\n    for i in 0..k {\n   \
    \     let mut max_num = max_arr[i][0];\n        let mut max_pos = 0;\n       \
    \ for j in 0..k {\n            if max_arr[j][0] > max_num {\n                max_num\
    \ = max_arr[j][0];\n                max_pos = j;\n            }\n        }\n \
    \       max_arr[i][2] = max_pos;\n    }\n    for i in 0..k {\n        let mut\
    \ max_num = max_arr[i][0];\n        let mut max_pos = 0;\n        for j in 0..k\
    \ {\n            if max_arr[j][0] > max_num {\n                max_num = max_arr[j][0];\n\
    \                max_pos = j;\n            }\n        }\n        max_arr[i][2]\
    \ = max_pos;\n    }\n    for i in 0..k {\n        let mut max_num = max_arr[i][0];\n\
    \n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpkx0jbuel.rs:116:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    98  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n...\n101 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n116 | }\n    |   ^\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpkx0jbuel.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = vec![arr[i], arr[i]];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpkx0jbuel.rs:19:27\n   |\n19 |  \
    \       max_arr[i] = vec![arr[i], arr[i]];\n   |                           ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkx0jbuel.rs:19:35\n\
    \   |\n19 |         max_arr[i] = vec![arr[i], arr[i]];\n   |                 \
    \                  ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpkx0jbuel.rs:22:27\n   |\n22 |         let mut max_num = max_arr[i][0];\n\
    \   |"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[j] > max_arr[i][j] {\n                max_arr[i][j]\
    \ = arr[j];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[i][j] {\n                max_arr[i][j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[i][j] {\n                max_arr[i][j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[j] > max_arr[i][j] {\n                max_arr[i][j]\
    \ = arr[j];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[i][j] {\n                max_arr[i][j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[j] > max_arr[i][j] {\n                max_arr[i][j]\
    \ = arr[j];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[i][j] {\n                max_arr[i][j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[j] > max_arr[i][j] {\n                max_arr[i][j]\
    \ = arr[j];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[i][j] {\n                max_arr[i][j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[j] > max_arr[i][j] {\n                max_arr[i][j]\
    \ = arr[j];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[i][j] {\n                max_arr[i][j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[j] > max_arr[i][j] {\n                max_arr[i][j]\
    \ = arr[j];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr[i] > max_arr[i][j] {\n                max_arr[i][j]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n        for\
    \ j in 0..k {\n            if arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp23o3vhtm.rs:130:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for i in 0..k {\n    |                   - unclosed delimiter\n113 |\
    \         for j in 0..k {\n    |                       - this delimiter might\
    \ not be properly closed...\n114 |             if arr\n115 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n130 | }\n    |   ^\n\n\
    error: expected `{`, found `}`\n   --> /tmp/tmp23o3vhtm.rs:115:1\n    |\n114 |\
    \             if arr\n    |             -- this `if` expression has a condition,\
    \ but no block\n115 | }\n    | ^ expected `{`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp23o3vhtm.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = max_arr[i].iter().max().unwrap();\n   |         ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp23o3vhtm.rs:19:22\n   |\n19 |         max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \   |                      ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp23o3vhtm.rs:23:16\n   |\n23 |  \
    \           if arr[j] > max_arr[i][j] {\n   |                ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `is"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[i]\
    \ > max_arr[j] {\n                max_arr[i] = max_arr[j];\n            }\n  \
    \      }\n    }\n    for i in 0..k {\n        if max_arr[i] != arr[i] {\n    \
    \        max_arr[i] = arr[i];\n        }\n    }\n    for i in 0..k {\n       \
    \ if max_arr[i] == arr[i] {\n            max_arr[i] = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if max_arr[i] != arr[i] {\n            max_arr[i]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if max_arr[i] != arr[i]\
    \ {\n            max_arr[i] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if max_arr[i] != arr[i] {\n            max_arr[i] = arr[i];\n       \
    \ }\n    }\n    for i in 0..k {\n        if max_arr[i] != arr[i] {\n         \
    \   max_arr[i] = arr[i];\n        }\n    }\n    for i in 0..k {\n        if max_arr[i]\
    \ != arr[i] {\n            max_arr[i] = arr[i];\n        }\n    }\n    for i in\
    \ 0..k {\n        if max_arr[i] != arr[i] {\n            max_arr[i] = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if max_arr[i] != arr[i] {\n  \
    \          max_arr[i] = arr[i];\n        }\n    }\n    for i in 0..k {\n     \
    \   if max_arr[i] != arr[i] {\n            max_arr[i] = arr[i];\n        }\n \
    \   }\n    for i in 0..k {\n        if max_arr[i] != arr[i] {\n            max_arr[i]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if max_arr[i] != arr[i]\
    \ {\n            max_arr[i] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if max_arr[i] != arr[i] {\n            max_arr[i] = arr[i];\n       \
    \ }\n    }\n    for i in 0..k {\n        if max_arr[i] != arr[i] {\n         \
    \   max_arr[i] = arr[i];\n        }\n    }\n    for i in 0..k {\n        if max_arr[i]\
    \ != arr[i] {\n            max_arr[i] = arr[i];\n        }\n    }\n    for i in\
    \ 0..k {\n        if max_arr[i] != arr[i] {\n            max_arr[i] = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if max_arr[i] != arr[i] {\n  \
    \          max_arr[i] = arr[i];\n        }\n    }\n    for i in 0..k {\n     \
    \   if max_arr[i] != arr[i] {\n            max_arr[i] = arr[i];\n        }\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpkph1v7hc.rs:132:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    113 |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n...\n117 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n132 | }\n    |   ^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkph1v7hc.rs:17:37\n   |\n17 |     let mut max_arr = vec![vec![0];\
    \ k];\n   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpkph1v7hc.rs:19:9\n\
    \   |\n19 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpkph1v7hc.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpkph1v7hc.rs:23:16\n   |\n23 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the tr"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[0][0] || (arr[i]\
    \ > max_arr[0][1] &&\n            arr[i] > max_arr[1][0]) {\n            max_arr[0]\
    \ = vec![arr[i], max_arr[0]];\n            max_k = 1;\n        } else if arr[i]\
    \ > max_arr[1][0] || (arr[i] > max_arr[1][1] &&\n            arr[i] > max_arr[2][0])\
    \ {\n            max_arr[1] = vec![arr[i], max_arr[1]];\n            max_k = 2;\n\
    \        } else {\n            max_arr[2] = vec![arr[i], max_arr[2]];\n      \
    \  }\n        i += 1;\n    }\n    max_arr.sort_by_key(|x| x.0);\n    vec![max_arr[0][0..max_k]]\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4xc811dp.rs:23:39\n   |\n\
    23 |             max_arr[0] = vec![arr[i], max_arr[0]];\n   |                \
    \                       ^^^^^^^^^^ expected `isize`, found struct `Vec`\n   |\n\
    \   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4xc811dp.rs:27:39\n   |\n27 |             max_arr[1]\
    \ = vec![arr[i], max_arr[1]];\n   |                                       ^^^^^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n\
    \            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4xc811dp.rs:30:39\n   |\n30 |             max_arr[2] = vec![arr[i],\
    \ max_arr[2]];\n   |                                       ^^^^^^^^^^ expected\
    \ `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n      \
    \      found struct `Vec<isize>`\n\nerror[E0609]: no field `0` on type `&Vec<isize>`\n\
    \  --> /tmp/tmp4xc811dp.rs:34:31\n   |\n34 |     max_arr.sort_by_key(|x| x.0);\n\
    \   |                               ^ unknown field\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `std::ops::Range<isize>`\n  --> /tmp/tmp4xc811dp.rs:35:10\n\
    \   |\n35 |     vec![max_arr[0][0..max_k]]\n   |          ^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `std::ops::Range<isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <std::ops::Range<usize> as SliceIndex<[T]>>\n             <std::ops::Range<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<std::ops::Range<isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0609.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[i]\
    \ > max_arr[j] {\n                max_arr[i] = max_arr[j];\n            }\n  \
    \      }\n    }\n    for i in 0..k {\n        arr[i] = max_arr[i];\n    }\n  \
    \  arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfm3gjy4c.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfm3gjy4c.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfm3gjy4c.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfm3gjy4c.rs:23:16\n   |\n23 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpfm3gjy4c.rs:23:29\n   |\n23 |             if max_arr[i] > max_arr[j]\
    \ {\n   |                             ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n    let mut\
    \ max_idx = -1;\n    for i in 0..arr.len() {\n        if max_k == 0 {\n      \
    \      break;\n        }\n        if arr[i] > max_arr[0][k] {\n            max_arr[0]\
    \ = vec![arr[i]];\n            max_k--;\n        } else {\n            max_arr[0].push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if max_k == 0 {\n            break;\n\
    \        }\n        if max_arr[0][i] > max_arr[1][k] {\n            max_arr[1]\
    \ = vec![max_arr[0][i]];\n            max_k--;\n        } else {\n           \
    \ max_arr[1].push(max_arr[0][i]);\n        }\n    }\n    for i in 0..k {\n   \
    \     if max_k == 0 {\n            break;\n        }\n        if max_arr[0][i]\
    \ > max_arr[1][k] {\n            max_arr[1] = vec![max_arr[0][i]];\n         \
    \   max_k--;\n        } else {\n            max_arr[1].push(max_arr[0][i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if max_k == 0 {\n            break;\n\
    \        }\n        if max_arr[0][i] > max_arr[1][k] {\n            max_arr[1]\
    \ = vec![max_arr[0][i]];\n            max_k--;\n        } else {\n           \
    \ max_arr[1].push(max_arr[0][i]);\n        }\n    }\n    for i in 0..k {\n   \
    \     if max_k == 0 {\n            break;\n        }\n        if max_arr[0][i]\
    \ > max_arr[1][k] {\n            max_arr[1] = vec![max_arr[0][i]];\n         \
    \   max_k--;\n        } else {\n            max_arr[1].push(max_arr[0][i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if max_k == 0 {\n            break;\n\
    \        }\n        if max_arr[0][i] > max_arr[1][k] {\n            max_arr[1]\
    \ = vec![max_arr[0][i]];\n            max_k--;\n        } else {\n           \
    \ max_arr[1].push(max_arr[0][i]);\n        }\n    }\n    for i in 0..k {\n   \
    \     if max_k == 0 {\n            break;\n        }\n        if max_arr[0][i]\
    \ > max_arr[1][k] {\n            max_arr[1] = vec![max_arr[0][i]];\n         \
    \   max_k--;\n        } else {\n            max_arr[1].push(max_arr[0][i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if max_k == 0 {\n            break;\n\
    \        }\n        if max_arr[0][i] > max_arr[1][k] {\n            max_arr[1]\
    \ = vec![max_arr[0][i]];\n            max_k--;\n        } else {\n           \
    \ max_arr[1].push(max_arr[0][i]);\n        }\n    }\n    for i in 0..k {\n   \
    \     if max_k == 0 {\n            break;\n        }\n        if max_arr[0][i]\
    \ > max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpvkm0iez4.rs:128:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    108 |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n...\n113 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n128 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpvkm0iez4.rs:113:1\n    |\n112 |         if max_arr[0][i]\
    \ > max_arr\n    |         -- this `if` expression has a condition, but no block\n\
    113 | }\n    | ^ expected `{`\n\nerror[E0277]: the type `[{integer}]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpvkm0iez4.rs:24:21\n   |\n24 |         if arr[i]\
    \ > max_arr[0][k] {\n   |                     ^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpvkm0iez4.rs:26:13\n   |\n24 |  /         if arr[i] > max_arr[0][k] {\n\
    25 |  |             max_arr[0] = vec![arr[i]];\n26 |  |             max_k--;\n\
    \   |  |_____________^\n27 | ||         } else {\n   | ||_________^ expected `()`,\
    \ found `isize`\n28 |  |             max_arr[0].push(arr[i]);\n29 |  |       \
    \  }\n   |  |         -- help: consider using a semicolon here\n   |  |_________|\n\
    \   |            expected this to be `()`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpvkm0iez4.rs:35:12\n   |\n35 |  \
    \       if max_arr[0][i] > max_arr[1][k] {\n   |            ^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[i]\
    \ > max_arr[j] {\n                max_arr[i] = max_arr[j];\n            }\n  \
    \      }\n    }\n    for i in 0..k {\n        arr[i] = max_arr[i];\n    }\n  \
    \  arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp54c11ai8.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp54c11ai8.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp54c11ai8.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp54c11ai8.rs:23:16\n   |\n23 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp54c11ai8.rs:23:29\n   |\n23 |             if max_arr[i] > max_arr[j]\
    \ {\n   |                             ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![]; k];\n    for i in 0..k {\n        max_arr[i] = vec![];\n\
    \    }\n    for i in 0..arr.len() {\n        let mut max_i = i;\n        for j\
    \ in 0..k {\n            if arr[i] > max_arr[j][max_i] {\n                max_i\
    \ = j;\n            }\n        }\n        max_arr[k - 1].push(arr[i]);\n    }\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzc5_zbjg.rs:17:36\n   |\n\
    17 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpzc5_zbjg.rs:19:9\n   |\n19 |         max_arr[i]\
    \ = vec![];\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[Vec<_>]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmpzc5_zbjg.rs:24:25\n   |\n24 |             if arr[i] >\
    \ max_arr[j][max_i] {\n   |                         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzc5_zbjg.rs:25:25\n\
    \   |\n22 |         let mut max_i = i;\n   |                         - expected\
    \ due to this value\n...\n25 |                 max_i = j;\n   |              \
    \           ^ expected `usize`, found `isize`\n\nerror[E0277]: the type `[Vec<_>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpzc5_zbjg.rs:28:9\n   |\n28 |   \
    \      max_arr[k - 1].push(arr[i]);\n   |         ^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k]\n    for i in 0..k {\n        max_arr[i] = arr[i]\n\
    \    }\n    for i in 0..k {\n        let mut max_val = max_arr[i]\n        let\
    \ mut max_pos = i\n        for j in i+1..k {\n            if max_arr[j] > max_val\
    \ {\n                max_val = max_arr[j]\n                max_pos = j\n     \
    \       }\n        }\n        max_arr[i] = max_val\n        max_arr[i] = max_pos\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpngm97j0e.rs:17:39\n\
    \   |\n17 |     let mut max_arr = vec![vec![0]; k]\n   |                     \
    \                  ^ help: add `;` here\n18 |     for i in 0..k {\n   |     ---\
    \ unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpngm97j0e.rs:22:37\n\
    \   |\n22 |         let mut max_val = max_arr[i]\n   |                       \
    \              ^ help: add `;` here\n23 |         let mut max_pos = i\n   |  \
    \       --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  -->\
    \ /tmp/tmpngm97j0e.rs:23:28\n   |\n23 |         let mut max_pos = i\n   |    \
    \                        ^ help: add `;` here\n24 |         for j in i+1..k {\n\
    \   |         --- unexpected token\n\nerror: expected `;`, found `max_pos`\n \
    \ --> /tmp/tmpngm97j0e.rs:26:37\n   |\n26 |                 max_val = max_arr[j]\n\
    \   |                                     ^ help: add `;` here\n27 |         \
    \        max_pos = j\n   |                 ------- unexpected token\n\nerror:\
    \ expected `;`, found `max_arr`\n  --> /tmp/tmpngm97j0e.rs:30:29\n   |\n30 | \
    \        max_arr[i] = max_val\n   |                             ^ help: add `;`\
    \ here\n31 |         max_arr[i] = max_pos\n   |         ------- unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpngm97j0e.rs:17:37\n   |\n17 |\
    \     let mut max_arr = vec![vec![0]; k]\n   |                               \
    \      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()]\n   |                   \
    \                   ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpngm97j0e.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i]\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requireme"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().max().unwrap();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n  \
    \  }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpfi8bcvxd.rs:101:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    84  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n85  |         max_arr[i] = max_arr[i].iter().\n86  |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n101\
    \ | }\n    |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpfi8bcvxd.rs:86:1\n\
    \   |\n86 | }\n   | ^\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpfi8bcvxd.rs:19:9\n   |\n19 |         max_arr[i] =\
    \ max_arr[i].iter().max().unwrap();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfi8bcvxd.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = max_arr[i].iter().max().unwrap();\n   |                 \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpfi8bcvxd.rs:22:9\n   |\n22 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<i"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        max_arr[i]\
    \ = vec![];\n    }\n    for i in 0..arr.len() {\n        let mut max_i = i;\n\
    \        for j in 0..k {\n            if max_arr[j].len() > 0 && arr[i] > max_arr[j][0]\
    \ {\n                max_i = j;\n            }\n        }\n        max_arr[i].push(arr[i]);\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpw2xje1_m.rs:19:9\n   |\n19 |         max_arr[i] = vec![];\n   |\
    \         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpw2xje1_m.rs:24:16\n   |\n24 |         \
    \    if max_arr[j].len() > 0 && arr[i] > max_arr[j][0] {\n   |               \
    \ ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n  \
    \ = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpw2xje1_m.rs:24:49\n   |\n24 |             if max_arr[j].len() > 0 &&\
    \ arr[i] > max_arr[j][0] {\n   |                                             \
    \    ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw2xje1_m.rs:25:25\n   |\n22 |\
    \         let mut max_i = i;\n   |                         - expected due to this\
    \ value\n...\n25 |                 max_i = j;\n   |                         ^\
    \ expected `usize`, found `isize`\n\nerror[E0277]: the type `[Vec<isize>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpw2xje1_m.rs:31:9\n   |\n31 |         max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[i]\
    \ > max_arr[j] {\n                max_arr[i] = max_arr[j];\n            }\n  \
    \      }\n    }\n    for i in 0..k {\n        if max_arr[i] != 0 {\n         \
    \   max_arr[i] = max_arr[i] * -1;\n        }\n    }\n    for i in 0..k {\n   \
    \     if max_arr[i] != 0 {\n            max_arr[i] = max_arr[i] + arr[i];\n  \
    \      }\n    }\n    for i in 0..k {\n        if max_arr[i] != 0 {\n         \
    \   max_arr[i] = max_arr[i] + arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if max_arr[i] != 0 {\n            max_arr[i] = max_arr[i] + arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if max_arr[i] != 0 {\n       \
    \     max_arr[i] = max_arr[i] + arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if max_arr[i] != 0 {\n            max_arr[i] = max_arr[i] + arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if max_arr[i] != 0 {\n       \
    \     max_arr[i] = max_arr[i] + arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if max_arr[i] != 0 {\n            max_arr[i] = max_arr[i] + arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if max_arr[i] != 0 {\n       \
    \     max_arr[i] = max_arr[i] + arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if max_arr[i] != 0 {\n            max_arr[i] = max_arr[i] + arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if max_arr[i] != 0 {\n       \
    \     max_arr[i] = max_arr[i] + arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if max_arr[i] != 0 {\n            max_arr[i] = max_arr[i] + arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if max_arr[i] != 0 {\n       \
    \     max_arr[i] = max_arr[i] + arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if max_arr[i] != 0 {\n            max_arr[i] = max_arr[i] + arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if max_arr[i] != 0 {\n       \
    \     max_arr[i] = max_arr[i] + arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if max_arr[i] != 0 {\n            max_arr[i] = max_arr[i] + arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if max_arr[i] != 0 {\n       \
    \     max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpfo69kja7.rs:126:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    108 |     for i in 0..k {\n    |                   - unclosed delimiter\n109 |\
    \         if max_arr[i] != 0 {\n    |                            - this delimiter\
    \ might not be properly closed...\n110 |             max_arr\n111 | }\n    | -\
    \ ...as it matches this but it has different indentation\n...\n126 | }\n    |\
    \   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfo69kja7.rs:17:37\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfo69kja7.rs:19:9\n   |\n19 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfo69kja7.rs:19:22\n   |\n19 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfo69kja7.rs:23:16\n   |\n23 |  \
    \           if max_arr[i] > max_arr[j]"
  exit_code: 1
  status: SyntaxError
