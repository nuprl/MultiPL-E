name: HumanEval_99_closest_integer
language: rust
results:
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpozlkdt5e.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   if value < 4 {\n        value = 1;\n    }\n    if value < 6 {\n        value\
    \ = 2;\n    }\n    if value < 8 {\n        value = 3;\n    }\n    if value < 10\
    \ {\n        value = 4;\n    }\n    if value < 12 {\n        value = 5;\n    }\n\
    \    if value < 14 {\n        value = 6;\n    }\n    if value < 16 {\n       \
    \ value = 7;\n    }\n    if value < 18 {\n        value = 8;\n    }\n    if value\
    \ < 20 {\n        value = 9;\n    }\n    if value < 22 {\n        value = 10;\n\
    \    }\n    if value < 24 {\n        value = 11;\n    }\n    if value < 26 {\n\
    \        value = 12;\n    }\n    if value < 28 {\n        value = 13;\n    }\n\
    \    if value < 30 {\n        value = 14;\n    }\n    if value < 32 {\n      \
    \  value = 15;\n    }\n    if value < 34 {\n        value = 16;\n    }\n    if\
    \ value < 36 {\n        value = 17;\n    }\n    if value < 38 {\n        value\
    \ = 18;\n    }\n    if value < 40 {\n        value = 19;\n    }\n    if value\
    \ < 42 {\n        value = 20;\n    }\n    if value < 44 {\n        value = 21;\n\
    \    }\n    if value < 46 {\n        value = 22;\n    }\n    if value < 48 {\n\
    \        value = 23;\n    }\n    if value < 50 {\n        value = 24;\n    }\n\
    \    if value < 52 {\n        value = 25;\n    }\n    if value < 54 {\n      \
    \  value = 26;\n    }\n    if value < 56 {\n        value = 27;\n    }\n    if\
    \ value < 58 {\n        value = 28;\n    }\n    if value < 60 {\n        value\
    \ = 29;\n    }\n    if value < 62 {\n        value = 30;\n    }\n    if value\
    \ < 64 {\n        value = 31;\n    }\n    if value < 66 {\n        value = 32;\n\
    \    }\n    if value < 68 {\n        value = 33;\n    }\n    if value < 70 {\n\
    \        value = 34;\n    }\n    if value < 72 {\n        value = 35;\n    }\n\
    \    if value < 74 {\n        value = 36;\n    }\n    if value < 76 {\n      \
    \  value = 37;\n    }\n    if value < 78 {\n        value = 38;\n    }\n    if\
    \ value < 80 {\n        value = 39;\n    }\n    if value < 82 {\n        value\
    \ = 40;\n    }\n    if value < 84 {\n        value = 41;\n    }\n    if value\
    \ < 86 {\n        value = 42;\n    }\n    if value < 88 {\n        value = 43;\n\
    \    }\n    if value < 90 {\n        value = 44;\n    }\n    if value < 92 {\n\
    \        value = 45;\n    }\n    if \n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmp4ahjm33z.rs:158:1\n\
    \    |\n158 | }\n    | ^ expected expression\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut prev_value = value;\n    while prev_value != value {\n\
    \        closest_integer = prev_value;\n        prev_value = value;\n        value\
    \ = value.parse::<isize>().unwrap();\n    }\n    closest_integer\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `parse` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpaqpdgduq.rs:21:23\n   |\n21 |         value = value.parse::<isize>().unwrap();\n\
    \   |                       ^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest: isize = 0;\n    let mut closest_distance\
    \ = std::i32::MAX;\n    for &d in &[10, 5, 2.5, 1] {\n        let mut d = d.parse::<isize>().unwrap();\n\
    \        if d < 0 {\n            d = -d;\n        }\n        let distance = value\
    \ - d;\n        if distance < closest_distance {\n            closest = d;\n \
    \           closest_distance = distance;\n        }\n    }\n    closest\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgthh4bwv.rs:21:24\n   |\n\
    21 |     for &d in &[10, 5, 2.5, 1] {\n   |                        ^^^ expected\
    \ integer, found floating-point number\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpgthh4bwv.rs:27:23\n   |\n27 |         if distance < closest_distance\
    \ {\n   |                       ^^^^^^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n27 |         if distance < closest_distance.try_into().unwrap()\
    \ {\n   |                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgthh4bwv.rs:29:32\n   |\n20 |     let mut closest_distance\
    \ = std::i32::MAX;\n   |                                ------------- expected\
    \ due to this value\n...\n29 |             closest_distance = distance;\n   |\
    \                                ^^^^^^^^ expected `i32`, found `isize`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmprgnpqpbd.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut closest_integer_diff = 0;\n\n    while value >= closest_integer\
    \ {\n        closest_integer = closest_integer + 1;\n        closest_integer_diff\
    \ = closest_integer_diff + 1;\n    }\n\n    while closest_integer > 0 {\n    \
    \    closest_integer = closest_integer - 1;\n        closest_integer_diff = closest_integer_diff\
    \ - 1;\n    }\n\n    closest_integer\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `10`', /tmp/tmp2dy27fi8.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_integer = value;\n    let mut prev_value = value;\n    while\
    \ prev_value != 0 {\n        prev_value = closest_integer;\n        closest_integer\
    \ = closest_integer / 10;\n    }\n    closest_integer\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `10`', /tmp/tmpohxn26z6.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp44ncycmv.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest: isize\
    \ = 0;\n    let mut closest_diff = std::i32::MAX;\n    let mut closest_index =\
    \ -1;\n    let mut closest_value = value;\n    let mut closest_value_diff = std::i32::MAX;\n\
    \    let mut closest_index = -1;\n    let mut closest_value = value;\n    let\
    \ mut closest_value_diff = std::i32::MAX;\n    let mut closest_index = -1;\n \
    \   let mut closest_value = value;\n    let mut closest_value_diff = std::i32::MAX;\n\
    \    let mut closest_index = -1;\n    let mut closest_value = value;\n    let\
    \ mut closest_value_diff = std::i32::MAX;\n    let mut closest_index = -1;\n \
    \   let mut closest_value = value;\n    let mut closest_value_diff = std::i32::MAX;\n\
    \    let mut closest_index = -1;\n    let mut closest_value = value;\n    let\
    \ mut closest_value_diff = std::i32::MAX;\n    let mut closest_index = -1;\n \
    \   let mut closest_value = value;\n    let mut closest_value_diff = std::i32::MAX;\n\
    \    let mut closest_index = -1;\n    let mut closest_value = value;\n    let\
    \ mut closest_value_diff = std::i32::MAX;\n    let mut closest_index = -1;\n \
    \   let mut closest_value = value;\n    let mut closest_value_diff = std::i32::MAX;\n\
    \    let mut closest_index = -1;\n    let mut closest_value = value;\n    let\
    \ mut closest_value_diff = std::i32::MAX;\n    let mut closest_index = -1;\n \
    \   let mut closest_value = value;\n    let mut closest_value_diff = std::i32::MAX;\n\
    \    let mut closest_index = -1;\n    let mut closest_value = value;\n    let\
    \ mut closest_value_diff = std::i32::MAX;\n    let mut closest_index = -1;\n \
    \   let mut closest_value = value;\n    let mut closest_value_diff = std::i32::MAX;\n\
    \    let mut closest_index = -1;\n    let mut closest_value = value;\n    let\
    \ mut closest_value_diff = std::i32::MAX;\n    let mut closest_index = -1;\n \
    \   let mut closest_value = value;\n    let mut closest_value_diff = std::i32::MAX;\n\
    \    let mut closest_index = -1;\n    let mut closest_value = value;\n    let\
    \ mut closest_value_diff = std::i32::MAX;\n    let mut closest_index = -1;\n \
    \   let mut closest_value = value;\n    let mut closest_value_diff = std::i32::MAX;\n\
    \    let mut closest_index = -1;\n    let mut closest_value = value;\n    let\
    \ mut closest_value_diff = std::i32::MAX;\n    let mut closest_index = -1;\n \
    \   let mu\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprt9wswtc.rs:73:11\n   |\n\
    73 |     let mu\n   |           ^ help: add `;` here\n74 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprt9wswtc.rs:14:38\n \
    \  |\n14 | fn closest_integer(value: String) -> isize {\n   |    ---------------\
    \                   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut prev_value = value;\n    while prev_value > 0 {\n    \
    \    prev_value = value;\n        value = value / 10;\n        closest_integer\
    \ = closest_integer.saturating_add((value - prev_value).abs());\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `20`,\n right: `10`', /tmp/tmp94w3cuo8.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest_integer = value;\n    let mut\
    \ closest_integer = if value % 2 == 0 {\n        closest_integer / 2\n    } else\
    \ {\n        closest_integer * 3 + 1\n    };\n    if closest_integer < 0 {\n \
    \       closest_integer = -closest_integer;\n    }\n    closest_integer\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpl56avo4w.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_value = value;\n    let mut closest_index = 0;\n    let mut\
    \ closest_distance = std::f32::MAX;\n    for index in 0..value.len() {\n     \
    \   let distance = value.len() - index;\n        let distance_to_closest_value\
    \ = distance - closest_value;\n        if distance_to_closest_value < closest_distance\
    \ {\n            closest_value = value;\n            closest_distance = distance_to_closest_value;\n\
    \            closest_index = index;\n        }\n    }\n    closest_value\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpj475e_2p.rs:25:27\n   |\n25 |     for index in 0..value.len()\
    \ {\n   |                           ^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `len` found for type `isize` in the current scope\n  --> /tmp/tmpj475e_2p.rs:26:30\n\
    \   |\n26 |         let distance = value.len() - index;\n   |                \
    \              ^^^ method not found in `isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_integer = value;\n    let mut closest_integer_diff = value.abs()\
    \ as isize;\n    let mut current_diff = 0;\n    while current_diff < closest_integer_diff\
    \ {\n        let mut current_integer = closest_integer;\n        let mut current_integer_diff\
    \ = closest_integer_diff;\n        while current_integer_diff < current_diff {\n\
    \            current_integer += 1;\n            current_integer_diff += 1;\n \
    \       }\n        if current_integer == closest_integer {\n            return\
    \ current_integer;\n        }\n        current_diff = current_integer_diff;\n\
    \        closest_integer = current_integer;\n    }\n    closest_integer\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp342oj4d_.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_integer = value;\n    let mut closest_integer_diff = value.abs()\
    \ - 1;\n    while closest_integer_diff > 0 {\n        if closest_integer % 2 ==\
    \ 0 {\n            closest_integer /= 2;\n        } else {\n            closest_integer\
    \ = (closest_integer - 1) / 2;\n        }\n        closest_integer_diff -= 1;\n\
    \    }\n    closest_integer\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `10`', /tmp/tmpo520_oy0.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest: isize = 0;\n    let mut closest2 = value;\n    let mut closest3\
    \ = value;\n    let mut closest4 = value;\n    let mut closest5 = value;\n   \
    \ let mut closest6 = value;\n    let mut closest7 = value;\n    let mut closest8\
    \ = value;\n    let mut closest9 = value;\n    let mut closest10 = value;\n  \
    \  let mut closest11 = value;\n    let mut closest12 = value;\n    let mut closest13\
    \ = value;\n    let mut closest14 = value;\n    let mut closest15 = value;\n \
    \   let mut closest16 = value;\n    let mut closest17 = value;\n    let mut closest18\
    \ = value;\n    let mut closest19 = value;\n    let mut closest20 = value;\n \
    \   let mut closest21 = value;\n    let mut closest22 = value;\n    let mut closest23\
    \ = value;\n    let mut closest24 = value;\n    let mut closest25 = value;\n \
    \   let mut closest26 = value;\n    let mut closest27 = value;\n    let mut closest28\
    \ = value;\n    let mut closest29 = value;\n    let mut closest30 = value;\n \
    \   let mut closest31 = value;\n    let mut closest32 = value;\n    let mut closest33\
    \ = value;\n    let mut closest34 = value;\n    let mut closest35 = value;\n \
    \   let mut closest36 = value;\n    let mut closest37 = value;\n    let mut closest38\
    \ = value;\n    let mut closest39 = value;\n    let mut closest40 = value;\n \
    \   let mut closest41 = value;\n    let mut closest42 = value;\n    let mut closest43\
    \ = value;\n    let mut closest44 = value;\n    let mut closest45 = value;\n \
    \   let mut closest46 = value;\n    let mut closest47 = value;\n    let mut closest48\
    \ = value;\n    let mut closest49 = value;\n    let mut closest50 = value;\n \
    \   let mut closest51 = value;\n    let mut closest52 = value;\n    let mut closest53\
    \ = value;\n    let mut closest54 = value;\n    let mut closest55 = value;\n \
    \   let mut closest56 = value;\n    let mut closest57 = value;\n    let mut closest58\
    \ = value;\n    let mut closest59 = value;\n    let mut closest60 = value;\n \
    \   let mut closest61 = value;\n\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy2x7sv5s.rs:14:38\n   |\n\
    14 | fn closest_integer(value: String) -> isize {\n   |    ---------------   \
    \                ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        return value;\n    }\n\
    \    if value < 10 {\n        return 2;\n    }\n    if value < 20 {\n        return\
    \ 3;\n    }\n    if value < 100 {\n        return 4;\n    }\n    if value < 1000\
    \ {\n        return 5;\n    }\n    if value < 10000 {\n        return 6;\n   \
    \ }\n    if value < 100000 {\n        return 7;\n    }\n    if value < 1000000\
    \ {\n        return 8;\n    }\n    if value < 10000000 {\n        return 9;\n\
    \    }\n    if value < 100000000 {\n        return 10;\n    }\n    if value <\
    \ 1000000000 {\n        return 11;\n    }\n    if value < 10000000000 {\n    \
    \    return 12;\n    }\n    if value < 100000000000 {\n        return 13;\n  \
    \  }\n    if value < 1000000000000 {\n        return 14;\n    }\n    if value\
    \ < 10000000000000 {\n        return 15;\n    }\n    if value < 100000000000000\
    \ {\n        return 16;\n    }\n    if value < 1000000000000000 {\n        return\
    \ 17;\n    }\n    if value < 10000000000000000 {\n        return 18;\n    }\n\
    \    if value < 100000000000000000 {\n        return 19;\n    }\n    if value\
    \ < 1000000000000000000 {\n        return 20;\n    }\n    if value < 10000000000000000000\
    \ {\n        return 21;\n    }\n    if value < 100000000000000000000 {\n     \
    \   return 22;\n    }\n    if value < 1000000000000000000000 {\n        return\
    \ 23;\n    }\n    if value < 10000000000000000000000 {\n        return 24;\n \
    \   }\n    if value < 100000000000000000000000 {\n        return 25;\n    }\n\
    \    if value < 1000000000000000000000000 {\n        return 26;\n    }\n    if\
    \ value < 10000000000000000000000000 {\n        return 27;\n    }\n    if value\
    \ < 100000000000000000000000000 {\n        return 28;\n    }\n    if value < 1000000000000000000000000000\
    \ {\n        return 29;\n    }\n    if value < 10000000000000000000000000000 {\n\
    \        return 30;\n    }\n    if value < 100000000000000000000000000000 {\n\
    \        return 31;\n    }\n    if value < 1000000000000000000000000000000 {\n\
    \        return 32;\n    }\n    if value < 10000000000000000000000000000000 {\n\
    \        return 33;\n    }\n    if value < 100000000000000000000000000000000 {\n\
    \        return 34;\n    }\n    if value < 1000000000000000000000000000000000\
    \ {\n        return 35;\n    }\n    if value < 10000000000000000000000000000000000\
    \ {\n        return 36;\n    }\n    if value < 100000000000000000000000000000000000\
    \ {\n        return 37;\n    }\n    if value < 1000000000000000000000000000000000000\
    \ {\n        return 38;\n    }\n    if value < 10000000000000000000000000000000000000\
    \ {\n        return 39;\n    }\n    if value < 100000000000000000000000000000000000000\
    \ {\n        return 40;\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpo7j_h38v.rs:147:3\n\
    \    |\n14  | fn closest_integer(value: String) -> isize {\n    |            \
    \                                - unclosed delimiter\n...\n136 |     if value\
    \ < 100000000000000000000000000000000000000 {\n    |                         \
    \                               - this delimiter might not be properly closed...\n\
    137 |         return 40;\n138 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n147 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpo7j_h38v.rs:14:38\n   |\n14 | fn closest_integer(value: String) -> isize\
    \ {\n   |    ---------------                   ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmptfe4l875.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpkr4l2gpb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest: isize = 0;\n    let mut closest2 = value;\n    let mut closest3\
    \ = value;\n    let mut closest4 = value;\n    let mut closest5 = value;\n   \
    \ let mut closest6 = value;\n    let mut closest7 = value;\n    let mut closest8\
    \ = value;\n    let mut closest9 = value;\n    let mut closest10 = value;\n  \
    \  let mut closest11 = value;\n    let mut closest12 = value;\n    let mut closest13\
    \ = value;\n    let mut closest14 = value;\n    let mut closest15 = value;\n \
    \   let mut closest16 = value;\n    let mut closest17 = value;\n    let mut closest18\
    \ = value;\n    let mut closest19 = value;\n    let mut closest20 = value;\n \
    \   let mut closest21 = value;\n    let mut closest22 = value;\n    let mut closest23\
    \ = value;\n    let mut closest24 = value;\n    let mut closest25 = value;\n \
    \   let mut closest26 = value;\n    let mut closest27 = value;\n    let mut closest28\
    \ = value;\n    let mut closest29 = value;\n    let mut closest30 = value;\n \
    \   let mut closest31 = value;\n    let mut closest32 = value;\n    let mut closest33\
    \ = value;\n    let mut closest34 = value;\n    let mut closest35 = value;\n \
    \   let mut closest36 = value;\n    let mut closest37 = value;\n    let mut closest38\
    \ = value;\n    let mut closest39 = value;\n    let mut closest40 = value;\n \
    \   let mut closest41 = value;\n    let mut closest42 = value;\n    let mut closest43\
    \ = value;\n    let mut closest44 = value;\n    let mut closest45 = value;\n \
    \   let mut closest46 = value;\n    let mut closest47 = value;\n    let mut closest48\
    \ = value;\n    let mut closest49 = value;\n    let mut closest50 = value;\n \
    \   let mut closest51 = value;\n    let mut closest52 = value;\n    let mut closest53\
    \ = value;\n    let mut closest54 = value;\n    let mut closest55 = value;\n \
    \   let mut closest56 = value;\n    let mut closest57 = value;\n    let mut closest58\
    \ = value;\n    let mut closest59 = value;\n    let mut closest60 = value;\n \
    \   let mut closest61 = value;\n\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpscmieuc1.rs:14:38\n   |\n\
    14 | fn closest_integer(value: String) -> isize {\n   |    ---------------   \
    \                ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp6xrlo7he.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        value = 0;\n    }\n\
    \    value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp7hce4zct.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpsed1tdck.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmppzyehlfg.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut closest_integer_distance = value.abs() as isize;\n   \
    \ let mut closest_integer_distance = value.abs() as isize;\n    let mut closest_integer_distance\
    \ = value.abs() as isize;\n    let mut closest_integer_distance = value.abs()\
    \ as isize;\n    let mut closest_integer_distance = value.abs() as isize;\n  \
    \  let mut closest_integer_distance = value.abs() as isize;\n    let mut closest_integer_distance\
    \ = value.abs() as isize;\n    let mut closest_integer_distance = value.abs()\
    \ as isize;\n    let mut closest_integer_distance = value.abs() as isize;\n  \
    \  let mut closest_integer_distance = value.abs() as isize;\n    let mut closest_integer_distance\
    \ = value.abs() as isize;\n    let mut closest_integer_distance = value.abs()\
    \ as isize;\n    let mut closest_integer_distance = value.abs() as isize;\n  \
    \  let mut closest_integer_distance = value.abs() as isize;\n    let mut closest_integer_distance\
    \ = value.abs() as isize;\n    let mut closest_integer_distance = value.abs()\
    \ as isize;\n    let mut closest_integer_distance = value.abs() as isize;\n  \
    \  let mut closest_integer_distance = value.abs() as isize;\n    let mut closest_integer_distance\
    \ = value.abs() as isize;\n    let mut closest_integer_distance = value.abs()\
    \ as isize;\n    let mut closest_integer_distance = value.abs() as isize;\n  \
    \  let mut closest_integer_distance = value.abs() as isize;\n    let mut closest_integer_distance\
    \ = value.abs() as isize;\n    let mut closest_integer_distance = value.abs()\
    \ as isize;\n    let mut closest_integer_distance = value.abs() as isize;\n  \
    \  let mut closest_integer_distance = value.abs() as isize;\n    let mut closest_integer_distance\
    \ = value.abs() as isize;\n    let mut closest_integer_distance = value.abs()\
    \ as isize;\n    let mut closest_integer_distance = value.abs() as isize;\n  \
    \  let mut closest_integer_distance = value.abs() as isize;\n    let mut closest_integer_distance\
    \ = value.abs() as isize;\n    let mut closest_integer_distance = value.abs()\
    \ as isize;\n    let mut closest_integer_distance = value.abs() as isize;\n  \
    \  let mut closest_integer_distance = value.abs() as isize;\n    let mut closest_integer_distance\
    \ = value.abs() as isize;\n    let mut closest_integer_distance = value.abs()\
    \ as isize;\n    let mut closest_integer_distance = value.abs() as isize;\n  \
    \  let mut closest_integer_distance = value.abs() as isize;\n    let mut closest_integer_distance\
    \ = value.abs() as isize;\n    let mut closest_integer_distance = value.abs()\
    \ as isize;\n    let mut closest_integer_distance = value.abs() as \n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected type, found `}`\n  --> /tmp/tmplw9_xgug.rs:58:1\n   |\n\
    58 | }\n   | ^ expected type\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpyzcl7dy2.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n   \
    \ assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpae0_ohcp.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpomi_xfyp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut current = value;\n    let mut previous = value;\n    while current\
    \ > 0 {\n        previous = current;\n        current -= 1;\n    }\n    previous\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `10`', /tmp/tmp6xx381qf.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest: isize = 0;\n    let mut closest2\
    \ = closest;\n    let mut closest3 = closest;\n    let mut closest4 = closest;\n\
    \    let mut closest5 = closest;\n    let mut closest6 = closest;\n    let mut\
    \ closest7 = closest;\n    let mut closest8 = closest;\n    let mut closest9 =\
    \ closest;\n    let mut closest10 = closest;\n    let mut closest11 = closest;\n\
    \    let mut closest12 = closest;\n    let mut closest13 = closest;\n    let mut\
    \ closest14 = closest;\n    let mut closest15 = closest;\n    let mut closest16\
    \ = closest;\n    let mut closest17 = closest;\n    let mut closest18 = closest;\n\
    \    let mut closest19 = closest;\n    let mut closest20 = closest;\n    let mut\
    \ closest21 = closest;\n    let mut closest22 = closest;\n    let mut closest23\
    \ = closest;\n    let mut closest24 = closest;\n    let mut closest25 = closest;\n\
    \    let mut closest26 = closest;\n    let mut closest27 = closest;\n    let mut\
    \ closest28 = closest;\n    let mut closest29 = closest;\n    let mut closest30\
    \ = closest;\n    let mut closest31 = closest;\n    let mut closest32 = closest;\n\
    \    let mut closest33 = closest;\n    let mut closest34 = closest;\n    let mut\
    \ closest35 = closest;\n    let mut closest36 = closest;\n    let mut closest37\
    \ = closest;\n    let mut closest38 = closest;\n    let mut closest39 = closest;\n\
    \    let mut closest40 = closest;\n    let mut closest41 = closest;\n    let mut\
    \ closest42 = closest;\n    let mut closest43 = closest;\n    let mut closest44\
    \ = closest;\n    let mut closest45 = closest;\n    let mut closest46 = closest;\n\
    \    let mut closest47 = closest;\n    let mut closest48 = closest;\n    let mut\
    \ closest49 = closest;\n    let mut closest50 = closest;\n    let mut closest51\
    \ = closest;\n    let mut closest52 = closest;\n    let mut closest53 = closest;\n\
    \    let mut closest54 = closest;\n    let mut closest55 = closest;\n    let mut\
    \ \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpqnwaclj9.rs:75:1\n\
    \   |\n75 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n   \
    \ assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpt89oagea.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpekifhbjn.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut prev_value = value;\n    while prev_value != value {\n\
    \        closest_integer = prev_value;\n        prev_value = value;\n        value\
    \ += 1;\n    }\n    closest_integer\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp4ufzyuh4.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest: isize = 0;\n    let mut closest2 = value;\n    while closest2\
    \ < closest {\n        closest2 = closest2 * 2;\n        closest += 1;\n    }\n\
    \    closest\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `10`', /tmp/tmpjy_3_dwp.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut prev_value = value;\n    while prev_value != value {\n\
    \        closest_integer = prev_value;\n        prev_value = value;\n        value\
    \ = closest_integer.checked_add(1, |x| x.checked_sub(1, |y| y.checked_mul(-1,\
    \ |z| z.checked_div(2)))).unwrap();\n    }\n    closest_integer\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpmvx1e2mh.rs:21:49\n\
    \   |\n21 |         value = closest_integer.checked_add(1, |x| x.checked_sub(1,\
    \ |y| y.checked_mul(-1, |z| z.checked_div(2)))).unwrap();\n   |              \
    \                                   ^ consider giving this closure parameter a\
    \ type\n   |\n   = note: type must be known at this point\n\nerror[E0061]: this\
    \ function takes 1 argument but 2 arguments were supplied\n   --> /tmp/tmpmvx1e2mh.rs:21:33\n\
    \    |\n21  |         value = closest_integer.checked_add(1, |x| x.checked_sub(1,\
    \ |y| y.checked_mul(-1, |z| z.checked_div(2)))).unwrap();\n    |             \
    \                    ^^^^^^^^^^^ -  -----------------------------------------------------------------\
    \ supplied 2 arguments\n    |                                 |\n    |       \
    \                          expected 1 argument\n    |\nnote: associated function\
    \ defined here\n    = note: this error originates in the macro `int_impl` (in\
    \ Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0282.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut low = value;\n    let mut high = value;\n    let mut mid = 0;\n  \
    \  while low < high {\n        mid = (low + high) / 2;\n        if mid * mid >\
    \ value {\n            high = mid;\n        } else {\n            low = mid;\n\
    \        }\n    }\n    low\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpufplxiir.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 10 {\n        return value;\n    }\n\
    \    if value < 100 {\n        return 10 + value;\n    }\n    if value < 1000\
    \ {\n        return 100 + value;\n    }\n    if value < 10000 {\n        return\
    \ 1000 + value;\n    }\n    if value < 100000 {\n        return 10000 + value;\n\
    \    }\n    if value < 1000000 {\n        return 100000 + value;\n    }\n    if\
    \ value < 10000000 {\n        return 1000000 + value;\n    }\n    if value < 100000000\
    \ {\n        return 10000000 + value;\n    }\n    if value < 1000000000 {\n  \
    \      return 100000000 + value;\n    }\n    if value < 10000000000 {\n      \
    \  return 1000000000 + value;\n    }\n    if value < 100000000000 {\n        return\
    \ 10000000000 + value;\n    }\n    if value < 1000000000000 {\n        return\
    \ 100000000000 + value;\n    }\n    if value < 10000000000000 {\n        return\
    \ 1000000000000 + value;\n    }\n    if value < 100000000000000 {\n        return\
    \ 10000000000000 + value;\n    }\n    if value < 1000000000000000 {\n        return\
    \ 100000000000000 + value;\n    }\n    if value < 10000000000000000 {\n      \
    \  return 1000000000000000 + value;\n    }\n    if value < 100000000000000000\
    \ {\n        return 10000000000000000 + value;\n    }\n    if value < 1000000000000000000\
    \ {\n        return 100000000000000000 + value;\n    }\n    if value < 10000000000000000000\
    \ {\n        return 1000000000000000000 + value;\n    }\n    if value < 100000000000000000000\
    \ {\n        return 10000000000000000000 + value;\n    }\n    if value < 1000000000000000000000\
    \ {\n        return 100000000000000000000 + value;\n    }\n    if value < 10000000000000000000000\
    \ {\n        return 1000000000000000000000 + value;\n    }\n    if value < 100000000000000000000000\
    \ {\n        return 10000000000000000000000 + value;\n    }\n    if value < 1000000000000000000000000\
    \ {\n        return 100000000000000000000000 + value;\n    }\n    if value < 10000000000000000000000000\
    \ {\n        return 1000000000000000000000000 + value;\n    }\n    if value <\
    \ 100000000000000000000000000 {\n        return 10000000000000000000000000 + value;\n\
    \    }\n    if value < 1000000000000000000000000000 {\n        return 100000000000000000000000000\
    \ + value;\n    }\n    if value < 10000000000000000000000000000 {\n        return\
    \ 1000000000000000000000000000 + value;\n    }\n    if value < 100000000000000000000000000000\
    \ {\n        return 10000000000000000000000000000 + value;\n    }\n    if value\
    \ < 1000000000000000000000000000000 {\n        return 100000000000000000000000000000\
    \ + value;\n    }\n    if value < 10000000000000000000000000000000 {\n       \
    \ return 1000000000000000000000000000000 + value;\n    }\n    if value < 100000000000000000000000000000000\
    \ {\n        return 10000000000000000000000000000000 + value;\n    }\n    if value\
    \ < 1000000000000000000000000000000000 {\n        return \n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpcmb2515z.rs:126:3\n\
    \    |\n14  | fn closest_integer(value: String) -> isize {\n    |            \
    \                                - unclosed delimiter\n...\n115 |     if value\
    \ < 1000000000000000000000000000000000 {\n    |                              \
    \                     - this delimiter might not be properly closed...\n116 |\
    \         return \n117 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n126 | }\n    |   ^\n\nerror[E0069]: `return;` in a function\
    \ whose return type is not `()`\n   --> /tmp/tmpcmb2515z.rs:116:9\n    |\n14 \
    \ | fn closest_integer(value: String) -> isize {\n    |                      \
    \                ----- expected `isize` because of this return type\n...\n116\
    \ |         return \n    |         ^^^^^^ return type is not `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcmb2515z.rs:14:38\n   |\n14 | fn closest_integer(value:\
    \ String) -> isize {\n   |    ---------------                   ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0069, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0069`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest: isize = 0;\n    let mut closest_dist: isize = 0;\n    let\
    \ mut closest_dist2: isize = 0;\n    let mut closest_dist3: isize = 0;\n    let\
    \ mut closest_dist4: isize = 0;\n    let mut closest_dist5: isize = 0;\n    let\
    \ mut closest_dist6: isize = 0;\n    let mut closest_dist7: isize = 0;\n    let\
    \ mut closest_dist8: isize = 0;\n    let mut closest_dist9: isize = 0;\n    let\
    \ mut closest_dist10: isize = 0;\n    let mut closest_dist11: isize = 0;\n   \
    \ let mut closest_dist12: isize = 0;\n    let mut closest_dist13: isize = 0;\n\
    \    let mut closest_dist14: isize = 0;\n    let mut closest_dist15: isize = 0;\n\
    \    let mut closest_dist16: isize = 0;\n    let mut closest_dist17: isize = 0;\n\
    \    let mut closest_dist18: isize = 0;\n    let mut closest_dist19: isize = 0;\n\
    \    let mut closest_dist20: isize = 0;\n    let mut closest_dist21: isize = 0;\n\
    \    let mut closest_dist22: isize = 0;\n    let mut closest_dist23: isize = 0;\n\
    \    let mut closest_dist24: isize = 0;\n    let mut closest_dist25: isize = 0;\n\
    \    let mut closest_dist26: isize = 0;\n    let mut closest_dist27: isize = 0;\n\
    \    let mut closest_dist28: isize = 0;\n    let mut closest_dist29: isize = 0;\n\
    \    let mut closest_dist30: isize = 0;\n    let mut closest_dist31: isize = 0;\n\
    \    let mut closest_dist32: isize = 0;\n    let mut closest_dist33: isize = 0;\n\
    \    let mut closest_dist34: isize = 0;\n    let mut closest_dist35: isize = 0;\n\
    \    let mut closest_dist36: isize = 0;\n    let mut closest_dist37: isize = 0;\n\
    \    let mut closest_dist38: isize = 0;\n    let mut closest_dist39: isize = 0;\n\
    \    let mut closest_dist40: isize = 0;\n    let mut closest_dist41: isize = 0;\n\
    \    let mut closest_dist42: isize = 0;\n    let mut closest_dist43: isize = 0;\n\
    \    let \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpduo8qt6s.rs:67:1\n  \
    \ |\n67 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_value\
    \ = value;\n    let mut closest_distance = 0;\n    while value >= closest_value\
    \ {\n        closest_value = closest_value + 1;\n        closest_distance = closest_distance\
    \ + 1;\n    }\n    closest_value\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `10`', /tmp/tmp7nrtg91g.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut closest_integer = if value < 0 {\n        closest_integer\
    \ - 1;\n    } else {\n        closest_integer + 1;\n    };\n    while closest_integer\
    \ % 2 == 0 {\n        closest_integer = closest_integer / 2;\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `()` by `{integer}`\n  --> /tmp/tmpo3wif2og.rs:22:27\n\
    \   |\n22 |     while closest_integer % 2 == 0 {\n   |           ---------------\
    \ ^ - {integer}\n   |           |\n   |           ()\n\nerror[E0369]: cannot divide\
    \ `()` by `{integer}`\n  --> /tmp/tmpo3wif2og.rs:23:43\n   |\n23 |         closest_integer\
    \ = closest_integer / 2;\n   |                           --------------- ^ - {integer}\n\
    \   |                           |\n   |                           ()\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo3wif2og.rs:25:5\n   |\n14 | fn closest_integer(value:\
    \ String) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n25 |     closest_integer\n   |     ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `()`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpelkmen9h.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest_integer = value;\n    let mut\
    \ closest_integer = if value < closest_integer {\n        closest_integer\n  \
    \  } else {\n        closest_integer\n    };\n    let mut closest_integer = if\
    \ closest_integer < 0 {\n        closest_integer\n    } else {\n        closest_integer\n\
    \    };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\n\
    \    } else {\n        closest_integer\n    };\n    let mut closest_integer =\
    \ if closest_integer < 0 {\n        closest_integer\n    } else {\n        closest_integer\n\
    \    };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\n\
    \    } else {\n        closest_integer\n    };\n    let mut closest_integer =\
    \ if closest_integer < 0 {\n        closest_integer\n    } else {\n        closest_integer\n\
    \    };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\n\
    \    } else {\n        closest_integer\n    };\n    let mut closest_integer =\
    \ if closest_integer < 0 {\n        closest_integer\n    } else {\n        closest_integer\n\
    \    };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\n\
    \    } else {\n        closest_integer\n    };\n    let mut closest_integer =\
    \ if closest_integer < 0 {\n        closest_integer\n    } else {\n        closest_integer\n\
    \    };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\n\
    \    } else {\n        closest_integer\n    };\n    let mut closest_integer =\
    \ if closest_integer < 0 {\n        closest_integer\n    } else {\n        closest_integer\n\
    \    };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\n\
    \    } else {\n        closest_integer\n    };\n    let mut closest_integer =\
    \ if closest_integer < 0 {\n        closest_integer\n    } else {\n        closest_integer\n\
    \    };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\n\
    \    } else {\n        closest_integer\n    };\n    let mut closest_integer =\
    \ if closest_integer < 0 {\n        closest_integer\n    } else {\n        closest_integer\n\
    \    };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\n\
    \    } else {\n        closest_integer\n    };\n    let mut closest_integer =\
    \ if closest_integer < 0 {\n        closest_integer\n    } else {\n        closest_integer\n\
    \    };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\n\
    \    } else {\n        closest_integer\n    };\n    let mut closest_integer =\
    \ if closest_integer < 0 {\n        closest_integer\n    } else {\n        closest_integer\n\
    \    };\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwe_6uddn.rs:14:38\n   |\n\
    14 | fn closest_integer(value: String) -> isize {\n   |    ---------------   \
    \                ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n   \
    \ assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp7e8izgno.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_integer = value;\n    let mut closest_integer = if closest_integer\
    \ < 0 {\n        closest_integer = -closest_integer;\n    };\n    let mut closest_integer\
    \ = if closest_integer < 0 {\n        closest_integer = -closest_integer;\n  \
    \  };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ = -closest_integer;\n    };\n    let mut closest_integer = if closest_integer\
    \ < 0 {\n        closest_integer = -closest_integer;\n    };\n    let mut closest_integer\
    \ = if closest_integer < 0 {\n        closest_integer = -closest_integer;\n  \
    \  };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ = -closest_integer;\n    };\n    let mut closest_integer = if closest_integer\
    \ < 0 {\n        closest_integer = -closest_integer;\n    };\n    let mut closest_integer\
    \ = if closest_integer < 0 {\n        closest_integer = -closest_integer;\n  \
    \  };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ = -closest_integer;\n    };\n    let mut closest_integer = if closest_integer\
    \ < 0 {\n        closest_integer = -closest_integer;\n    };\n    let mut closest_integer\
    \ = if closest_integer < 0 {\n        closest_integer = -closest_integer;\n  \
    \  };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ = -closest_integer;\n    };\n    let mut closest_integer = if closest_integer\
    \ < 0 {\n        closest_integer = -closest_integer;\n    };\n    let mut closest_integer\
    \ = if closest_integer < 0 {\n        closest_integer = -closest_integer;\n  \
    \  };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ = -closest_integer;\n    };\n    let mut closest_integer = if closest_integer\
    \ < 0 {\n        closest_integer = -closest_integer;\n    };\n    let mut closest_integer\
    \ = if closest_integer < 0 {\n        closest_integer = -closest_integer;\n  \
    \  };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ = -closest_integer;\n    };\n    let mut closest_integer = if closest_integer\
    \ < 0 {\n        closest_integer = -closest_integer;\n    };\n    let mut closest_integer\
    \ = if closest_integer < 0 {\n        closest_integer = -closest_integer;\n  \
    \  };\n    let mut closest_integer = if closest_integer < \n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp02kz7b_a.rs:84:1\n\
    \   |\n84 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp02kz7b_a.rs:26:52\n   |\n26 |     let mut closest_integer = if\
    \ closest_integer < 0 {\n   |                                                \
    \    ^ expected `()`, found integer\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `()`\n  --> /tmp/tmp02kz7b_a.rs:27:27\n   |\n27 |         closest_integer\
    \ = -closest_integer;\n   |                           ^^^^^^^^^^^^^^^^ cannot\
    \ apply unary operator `-`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0600.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_value = value;\n    let mut closest_index = 0;\n    let mut\
    \ current_index = 0;\n    while current_index < value.len() {\n        let mut\
    \ current_value = value.chars().nth(current_index).unwrap();\n        if current_value\
    \ == 0 {\n            current_index += 1;\n            continue;\n        }\n\
    \        let mut current_distance = current_value - closest_value;\n        if\
    \ current_distance < 0 {\n            current_distance *= -1;\n        }\n   \
    \     if current_distance < closest_distance {\n            closest_value = current_value;\n\
    \            closest_index = current_index;\n        }\n        current_index\
    \ += 1;\n    }\n    closest_index\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `closest_distance` in this scope\n  -->\
    \ /tmp/tmp97kl8tv0.rs:35:31\n   |\n35 |         if current_distance < closest_distance\
    \ {\n   |                               ^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `current_distance`\n\nerror[E0599]: no method named\
    \ `len` found for type `isize` in the current scope\n  --> /tmp/tmp97kl8tv0.rs:25:33\n\
    \   |\n25 |     while current_index < value.len() {\n   |                    \
    \             ^^^ method not found in `isize`\n\nerror[E0599]: no method named\
    \ `chars` found for type `isize` in the current scope\n  --> /tmp/tmp97kl8tv0.rs:26:39\n\
    \   |\n26 |         let mut current_value = value.chars().nth(current_index).unwrap();\n\
    \   |                                       ^^^^^ method not found in `isize`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest: isize = 0;\n    let mut current\
    \ = value;\n    while current > closest {\n        current -= 1;\n        closest\
    \ += 1;\n    }\n    closest\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpq9yr9c5y.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut closest_integer = if value < 0 {\n        closest_integer\
    \ - 1;\n    } else {\n        closest_integer;\n    };\n    while closest_integer\
    \ % 2 == 0 {\n        closest_integer /= 2;\n    }\n    while closest_integer\
    \ % 3 == 0 {\n        closest_integer /= 3;\n    }\n    while closest_integer\
    \ % 5 == 0 {\n        closest_integer /= 5;\n    }\n    while closest_integer\
    \ % 7 == 0 {\n        closest_integer /= 7;\n    }\n    while closest_integer\
    \ % 11 == 0 {\n        closest_integer /= 11;\n    }\n    while closest_integer\
    \ % 13 == 0 {\n        closest_integer /= 13;\n    }\n    while closest_integer\
    \ % 17 == 0 {\n        closest_integer /= 17;\n    }\n    while closest_integer\
    \ % 19 == 0 {\n        closest_integer /= 19;\n    }\n    while closest_integer\
    \ % 23 == 0 {\n        closest_integer /= 23;\n    }\n    while closest_integer\
    \ % 29 == 0 {\n        closest_integer /= 29;\n    }\n    while closest_integer\
    \ % 37 == 0 {\n        closest_integer /= 37;\n    }\n    while closest_integer\
    \ % 47 == 0 {\n        closest_integer /= 47;\n    }\n    while closest_integer\
    \ % 59 == 0 {\n        closest_integer /= 59;\n    }\n    while closest_integer\
    \ % 73 == 0 {\n        closest_integer /= 73;\n    }\n    while closest_integer\
    \ % 89 == 0 {\n        closest_integer /= 89;\n    }\n    while closest_integer\
    \ % 97 == 0 {\n        closest_integer /= 97;\n    }\n    while closest_integer\
    \ % 123 == 0 {\n        closest_integer /= 123;\n    }\n    while closest_integer\
    \ % 131 == 0 {\n        closest_integer /= 131;\n    }\n    while closest_integer\
    \ % 159 == 0 {\n        closest_integer /= 159;\n    }\n    while closest_integer\
    \ % 181 == 0 {\n        closest_integer /= 181;\n    }\n    while closest_integer\
    \ % 197 == 0 {\n        closest_integer /= 197;\n    }\n    while closest_integer\
    \ % 229 == 0 {\n        closest_integer /= 229;\n    }\n    while closest_integer\
    \ % 279 == 0 {\n        closest_integer /= 279;\n    }\n    while closest_integer\
    \ % 337 == 0 {\n        closest_integer /= 337;\n    }\n    while closest_integer\
    \ % 359 == 0 {\n        closest_integer /= 359;\n    }\n    while closest_integer\
    \ % 385 == 0 {\n        closest_integer /= 385;\n    }\n    while closest_integer\
    \ % 415 == 0 {\n        closest_integer /= 415;\n    }\n    while closest_integer\
    \ % 447 == 0 {\n        closest_integer /= \n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpabf894rn.rs:114:3\n\
    \    |\n14  | fn closest_integer(value: String) -> isize {\n    |            \
    \                                - unclosed delimiter\n...\n103 |     while closest_integer\
    \ % 447 == 0 {\n    |                                      - this delimiter might\
    \ not be properly closed...\n104 |         closest_integer /= \n105 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n114 | }\n   \
    \ |   ^\n\nerror: expected expression, found `}`\n   --> /tmp/tmpabf894rn.rs:105:1\n\
    \    |\n105 | }\n    | ^ expected expression\n\nerror[E0434]: can't capture dynamic\
    \ environment in a fn item\n   --> /tmp/tmpabf894rn.rs:108:21\n    |\n108 |  \
    \   let candidate = closest_integer;\n    |                     ^^^^^^^^^^^^^^^\n\
    \    |\n    = help: use the `|| { ... }` closure form instead\n\nerror[E0369]:\
    \ cannot mod `()` by `{integer}`\n  --> /tmp/tmpabf894rn.rs:22:27\n   |\n22 |\
    \     while closest_integer % 2 == 0 {\n   |           --------------- ^ - {integer}\n\
    \   |           |\n   |           ()\n\nerror[E0368]: binary assignment operation\
    \ `/=` cannot be applied to type `()`\n  --> /tmp/tmpabf894rn.rs:23:9\n   |\n\
    23 |         closest_integer /= 2;\n   |         ---------------^^^^^\n   |  \
    \       |\n   |         cannot use `/=` on type `()`\n\nerror[E0369]: cannot mod\
    \ `()` by `{integer}`\n  --> /tmp/tmpabf894rn.rs:25:27\n   |\n25 |     while closest_integer\
    \ % 3 == 0 {\n   |           --------------- ^ - {integer}\n   |           |\n\
    \   |           ()\n\nerror[E0368]: binary assignment operation `/=` cannot be\
    \ applied to type `()`\n  --> /tmp/tmpabf894rn.rs:26:9\n   |\n26 |         closest_integer\
    \ /= 3;\n   |         ---------------^^^^^\n   |         |\n   |         cannot\
    \ use `/=` on type `()`\n\nerror[E0369]: cannot mod `()` by `{integer}`\n  -->\
    \ /tmp/tmpabf894rn.rs:28:27\n   |\n28 |     while closest_integer % 5 == 0 {\n\
    \   |           --------------- ^ - {integer}\n   |           |\n   |        \
    \   ()\n\nerror[E0368]: binary assignment operation `/=` cannot be applied to\
    \ type `()`\n  --> /tmp/tmpabf894rn.rs:29:9\n   |"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest: isize\
    \ = 0;\n    let mut closest2 = closest;\n    let mut closest3 = closest;\n   \
    \ let mut closest4 = closest;\n    let mut closest5 = closest;\n    let mut closest6\
    \ = closest;\n    let mut closest7 = closest;\n    let mut closest8 = closest;\n\
    \    let mut closest9 = closest;\n    let mut closest10 = closest;\n    let mut\
    \ closest11 = closest;\n    let mut closest12 = closest;\n    let mut closest13\
    \ = closest;\n    let mut closest14 = closest;\n    let mut closest15 = closest;\n\
    \    let mut closest16 = closest;\n    let mut closest17 = closest;\n    let mut\
    \ closest18 = closest;\n    let mut closest19 = closest;\n    let mut closest20\
    \ = closest;\n    let mut closest21 = closest;\n    let mut closest22 = closest;\n\
    \    let mut closest23 = closest;\n    let mut closest24 = closest;\n    let mut\
    \ closest25 = closest;\n    let mut closest26 = closest;\n    let mut closest27\
    \ = closest;\n    let mut closest28 = closest;\n    let mut closest29 = closest;\n\
    \    let mut closest30 = closest;\n    let mut closest31 = closest;\n    let mut\
    \ closest32 = closest;\n    let mut closest33 = closest;\n    let mut closest34\
    \ = closest;\n    let mut closest35 = closest;\n    let mut closest36 = closest;\n\
    \    let mut closest37 = closest;\n    let mut closest38 = closest;\n    let mut\
    \ closest39 = closest;\n    let mut closest40 = closest;\n    let mut closest41\
    \ = closest;\n    let mut closest42 = closest;\n    let mut closest43 = closest;\n\
    \    let mut closest44 = closest;\n    let mut closest45 = closest;\n    let mut\
    \ closest46 = closest;\n    let mut closest47 = closest;\n    let mut closest48\
    \ = closest;\n    let mut closest49 = closest;\n    let mut closest50 = closest;\n\
    \    let mut closest51 = closest;\n    let mut closest52 = closest;\n    let mut\
    \ closest53 = closest;\n    let mut closest54 = closest;\n    let mut closest55\
    \ = closest;\n    let mut closest56 = closest;\n    let mut closest\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpu3rwpv7h.rs:72:20\n   |\n\
    72 |     let mut closest\n   |                    ^ help: add `;` here\n73 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu3rwpv7h.rs:14:38\n\
    \   |\n14 | fn closest_integer(value: String) -> isize {\n   |    ---------------\
    \                   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut min_value = value;\n\
    \    let mut max_value = value;\n    while max_value - min_value > 1 {\n     \
    \   let mut new_value = min_value + 1;\n        if new_value > max_value {\n \
    \           new_value = max_value;\n        }\n        min_value = new_value;\n\
    \        max_value = new_value;\n    }\n    min_value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpo6r0xvl7.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_value = value;\n    let mut closest_distance = 0;\n    let\
    \ mut current_distance = 0;\n    while current_distance < closest_distance {\n\
    \        let next_value = value + 1;\n        let next_distance = next_value -\
    \ closest_value;\n        if next_distance < closest_distance {\n            closest_value\
    \ = next_value;\n            closest_distance = next_distance;\n        }\n  \
    \      current_distance = next_distance;\n    }\n    closest_value\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpv_8lx904.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let mut closest_integer_value\
    \ = value;\n    let mut closest_integer_value = value;\n    let \n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpschhcxjo.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpmgc_m5v1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value % 2 == 0 {\n\
    \        value /= 2;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpoqqutn5c.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest_integer = value;\n    let mut\
    \ closest_integer = if closest_integer == 0 {\n        closest_integer\n    }\
    \ else {\n        closest_integer - 1\n    };\n    while closest_integer % 2 ==\
    \ 0 {\n        closest_integer = closest_integer / 2;\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `10`', /tmp/tmp3hwiwuyt.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest: isize = 0;\n    let mut closest_dist = std::i32::MAX;\n \
    \   let mut closest_dist2 = std::i32::MAX;\n    let mut closest_dist3 = std::i32::MAX;\n\
    \    let mut closest_dist4 = std::i32::MAX;\n    let mut closest_dist5 = std::i32::MAX;\n\
    \    let mut closest_dist6 = std::i32::MAX;\n    let mut closest_dist7 = std::i32::MAX;\n\
    \    let mut closest_dist8 = std::i32::MAX;\n    let mut closest_dist9 = std::i32::MAX;\n\
    \    let mut closest_dist10 = std::i32::MAX;\n    let mut closest_dist11 = std::i32::MAX;\n\
    \    let mut closest_dist12 = std::i32::MAX;\n    let mut closest_dist13 = std::i32::MAX;\n\
    \    let mut closest_dist14 = std::i32::MAX;\n    let mut closest_dist15 = std::i32::MAX;\n\
    \    let mut closest_dist16 = std::i32::MAX;\n    let mut closest_dist17 = std::i32::MAX;\n\
    \    let mut closest_dist18 = std::i32::MAX;\n    let mut closest_dist19 = std::i32::MAX;\n\
    \    let mut closest_dist20 = std::i32::MAX;\n    let mut closest_dist21 = std::i32::MAX;\n\
    \    let mut closest_dist22 = std::i32::MAX;\n    let mut closest_dist23 = std::i32::MAX;\n\
    \    let mut closest_dist24 = std::i32::MAX;\n    let mut closest_dist25 = std::i32::MAX;\n\
    \    let mut closest_dist26 = std::i32::MAX;\n    let mut closest_dist27 = std::i32::MAX;\n\
    \    let mut closest_dist28 = std::i32::MAX;\n    let mut closest_dist29 = std::i32::MAX;\n\
    \    let mut closest_dist30 = std::i32::MAX;\n    let mut closest_dist31 = std::i32::MAX;\n\
    \    let mut closest_dist32 = std::i32::MAX;\n    let mut closest_dist33 = std::i32::MAX;\n\
    \    let mut closest_dist34 = std::i32::MAX;\n    let mut closest_dist35 = std::i32::MAX;\n\
    \    let mut closest_dist36 = std::i32::MAX;\n    let mut closest_dist37 = std::i32::MAX;\n\
    \    let \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpc7ztnbk8.rs:61:1\n  \
    \ |\n61 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_integer = value;\n    let mut prev_value = value;\n    while\
    \ prev_value > 0 {\n        prev_value = closest_integer;\n        closest_integer\
    \ = (closest_integer + 1).wrapping_add(1);\n    }\n    closest_integer\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmprb9dtm11.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_integer = value;\n    let mut closest_integer = if closest_integer\
    \ < 0 {\n        closest_integer + isize::MAX\n    } else {\n        closest_integer\
    \ - isize::MAX\n    };\n    if closest_integer < 0 {\n        closest_integer\
    \ = -closest_integer;\n    }\n    closest_integer\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9223372036854775797`,\n right: `10`', /tmp/tmpysize3bw.rs:36:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value % 2 == 0 {\n\
    \        value /= 2;\n    }\n    if value % 3 == 0 {\n        value /= 3;\n  \
    \  }\n    value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpz1dab2tm.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut closest_integer_delta = value.abs() as isize;\n    let\
    \ mut closest_integer_delta_index = 0;\n    let mut closest_integer_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_index = 0;\n    let mut closest_integer_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta = 0;\n    let mut\
    \ closest_integer_delta_delta_delta_delta_delta = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta_delta\
    \ = 0;\n    let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsbecu1_x.rs:43:71\n   |\n\
    43 |     let mut closest_integer_delta_delta_delta_delta_delta_delta_delta_\n\
    \   |                                                                       ^\
    \ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsbecu1_x.rs:14:38\n   |\n14 | fn closest_integer(value:\
    \ String) -> isize {\n   |    ---------------                   ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        return value;\n    }\n\
    \    let mut value = value - 1;\n    while value >= 2 {\n        value = value\
    \ / 2;\n    }\n    value\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `10`', /tmp/tmp27nea5wp.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   if value < 10 {\n        value = 1;\n    }\n    if value < 100 {\n       \
    \ value = 2;\n    }\n    if value < 1000 {\n        value = 3;\n    }\n    if\
    \ value < 10000 {\n        value = 4;\n    }\n    if value < 100000 {\n      \
    \  value = 5;\n    }\n    if value < 1000000 {\n        value = 6;\n    }\n  \
    \  if value < 10000000 {\n        value = 7;\n    }\n    if value < 100000000\
    \ {\n        value = 8;\n    }\n    if value < 1000000000 {\n        value = 9;\n\
    \    }\n    if value < 10000000000 {\n        value = 10;\n    }\n    if value\
    \ < 100000000000 {\n        value = 11;\n    }\n    if value < 1000000000000 {\n\
    \        value = 12;\n    }\n    if value < 10000000000000 {\n        value =\
    \ 13;\n    }\n    if value < 100000000000000 {\n        value = 14;\n    }\n \
    \   if value < 1000000000000000 {\n        value = 15;\n    }\n    if value <\
    \ 10000000000000000 {\n        value = 16;\n    }\n    if value < 100000000000000000\
    \ {\n        value = 17;\n    }\n    if value < 1000000000000000000 {\n      \
    \  value = 18;\n    }\n    if value < 10000000000000000000 {\n        value =\
    \ 19;\n    }\n    if value < 100000000000000000000 {\n        value = 20;\n  \
    \  }\n    if value < 1000000000000000000000 {\n        value = 21;\n    }\n  \
    \  if value < 10000000000000000000000 {\n        value = 22;\n    }\n    if value\
    \ < 100000000000000000000000 {\n        value = 23;\n    }\n    if value < 1000000000000000000000000\
    \ {\n        value = 24;\n    }\n    if value < 10000000000000000000000000 {\n\
    \        value = 25;\n    }\n    if value < 100000000000000000000000000 {\n  \
    \      value = 26;\n    }\n    if value < 1000000000000000000000000000 {\n   \
    \     value = 27;\n    }\n    if value < 10000000000000000000000000000 {\n   \
    \     value = 28;\n    }\n    if value < 100000000000000000000000000000 {\n  \
    \      value = 29;\n    }\n    if value < 1000000000000000000000000000000 {\n\
    \        value = 30;\n    }\n    if value < 10000000000000000000000000000000 {\n\
    \        value = 31;\n    }\n    if value < 100000000000000000000000000000000\
    \ {\n        value = 32;\n    }\n    if value < 1000000000000000000000000000000000\
    \ {\n        value = 33;\n    }\n    if value < 10000000000000000000000000000000000\
    \ {\n        value = 34;\n    }\n    if value < 100000000000000000000000000000000000\
    \ {\n        value = 35;\n    }\n    if value < 1000000000000000000000000000000000000\
    \ {\n        value = 36;\n    }\n    if value < 10000000000000000000000000000000000000\
    \ {\n        value = 37;\n    }\n    if value < 100000000000000000000000000000000000000\
    \ {\n        value = 38;\n    }\n    if value < 100000000000000000000000000000000000000\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmp4t7_w7h0.rs:137:1\n    |\n\
    136 |     if value < 100000000000000000000000000000000000000\n    |     -- this\
    \ `if` expression has a condition, but no block\n137 | }\n    | ^ expected `{`\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut min_value = value;\n\
    \    let mut max_value = value;\n\n    while min_value <= max_value {\n      \
    \  let mut mid = min_value + (max_value - min_value) / 2;\n        if mid * mid\
    \ > value {\n            min_value = mid + 1;\n        } else {\n            max_value\
    \ = mid - 1;\n        }\n    }\n    min_value\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `10`', /tmp/tmpqng6ulkg.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest: isize\
    \ = 0;\n    let mut min_diff = std::i32::MAX;\n    let mut max_diff = std::i32::MIN;\n\
    \    let mut min_diff_index = -1;\n    let mut max_diff_index = -1;\n    let mut\
    \ min_diff_value = std::i32::MAX;\n    let mut max_diff_value = std::i32::MIN;\n\
    \    let mut min_diff_value_index = -1;\n    let mut max_diff_value_index = -1;\n\
    \    let mut min_diff_value_value = std::i32::MAX;\n    let mut max_diff_value_value\
    \ = std::i32::MIN;\n    let mut min_diff_value_value_index = -1;\n    let mut\
    \ max_diff_value_value_index = -1;\n    let mut min_diff_value_value_value = std::i32::MAX;\n\
    \    let mut max_diff_value_value_value = std::i32::MIN;\n    let mut min_diff_value_value_index\
    \ = -1;\n    let mut max_diff_value_value_index = -1;\n    let mut min_diff_value_value_value\
    \ = std::i32::MAX;\n    let mut max_diff_value_value_value = std::i32::MIN;\n\
    \    let mut min_diff_value_value_index = -1;\n    let mut max_diff_value_value_index\
    \ = -1;\n    let mut min_diff_value_value_value = std::i32::MAX;\n    let mut\
    \ max_diff_value_value_value = std::i32::MIN;\n    let mut min_diff_value_value_index\
    \ = -1;\n    let mut max_diff_value_value_index = -1;\n    let mut min_diff_value_value_value\
    \ = std::i32::MAX;\n    let mut max_diff_value_value_value = std::i32::MIN;\n\
    \    let mut min_diff_value_value_index = -1;\n    let mut max_diff_value_value_index\
    \ = -1;\n    let mut min_diff_value_value_value = std::i32::MAX;\n    let mut\
    \ max_diff_value_value_value = std::i32::MIN;\n    let mut min_diff_value_value_index\
    \ = -1;\n    let mut max_diff_value_value_index = -1;\n    let mut min_diff_value_value_value\
    \ = std::i32::MAX;\n    let mut max_diff_value_value_value = std::i32::MIN;\n\
    \    let mut min_diff_value_value_index = -1;\n    let mut max_diff_value_value_index\
    \ = -1;\n    let mut min_diff_value_value_value = std::i32::MAX;\n    let mut\
    \ max_diff_value_value_value = std::i32::MIN;\n    let mut min_diff_value_value_index\
    \ = -1;\n    let mut max_diff_value_value_index = -1;\n    let mut min_diff_value_value_value\
    \ = std::i32::MAX;\n    let mut max_diff_value_value_value = std::i32::MIN\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp39nq_3t5.rs:58:55\n   |\n\
    58 |     let mut max_diff_value_value_value = std::i32::MIN\n   |            \
    \                                           ^ help: add `;` here\n59 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp39nq_3t5.rs:14:38\n\
    \   |\n14 | fn closest_integer(value: String) -> isize {\n   |    ---------------\
    \                   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n   \
    \ assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp9oiu7r7z.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut closest_integer = if value < 0 {\n        closest_integer\
    \ - 1;\n    } else {\n        closest_integer;\n    };\n    while closest_integer\
    \ == value {\n        closest_integer += 1;\n    }\n    closest_integer\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuzghdqkk.rs:22:30\n   |\n\
    22 |     while closest_integer == value {\n   |                              ^^^^^\
    \ expected `()`, found `isize`\n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `()`\n  --> /tmp/tmpuzghdqkk.rs:23:9\n   |\n23 | \
    \        closest_integer += 1;\n   |         ---------------^^^^^\n   |      \
    \   |\n   |         cannot use `+=` on type `()`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpuzghdqkk.rs:25:5\n   |\n14 | fn closest_integer(value: String)\
    \ -> isize {\n   |                                      ----- expected `isize`\
    \ because of return type\n...\n25 |     closest_integer\n   |     ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `()`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmp_hvxf3xe.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut closest_integer = if value < 0 {\n        closest_integer\
    \ - 1;\n    } else {\n        closest_integer + 1;\n    };\n    while closest_integer\
    \ > 0 {\n        if closest_integer % 2 == 0 {\n            closest_integer /=\
    \ 2;\n        } else {\n            break;\n        }\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdo5r0jr4.rs:22:29\n   |\n\
    22 |     while closest_integer > 0 {\n   |                             ^ expected\
    \ `()`, found integer\n\nerror[E0369]: cannot mod `()` by `{integer}`\n  --> /tmp/tmpdo5r0jr4.rs:23:28\n\
    \   |\n23 |         if closest_integer % 2 == 0 {\n   |            ---------------\
    \ ^ - {integer}\n   |            |\n   |            ()\n\nerror[E0368]: binary\
    \ assignment operation `/=` cannot be applied to type `()`\n  --> /tmp/tmpdo5r0jr4.rs:24:13\n\
    \   |\n24 |             closest_integer /= 2;\n   |             ---------------^^^^^\n\
    \   |             |\n   |             cannot use `/=` on type `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdo5r0jr4.rs:29:5\n   |\n14 | fn closest_integer(value:\
    \ String) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n29 |     closest_integer\n   |     ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `()`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest_integer = value;\n    let mut\
    \ closest_integer = if closest_integer == 0 {\n        closest_integer\n    }\
    \ else {\n        closest_integer - 1\n    };\n    while closest_integer % 2 ==\
    \ 0 {\n        closest_integer = closest_integer / 2;\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `10`', /tmp/tmpx75nte_q.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpepd1ac85.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut result = value;\n    while result > 0\
    \ {\n        result -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `10`', /tmp/tmpujirvmyz.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut min_value = value;\n\
    \    let mut max_value = value;\n    while min_value + 1 != max_value {\n    \
    \    min_value += 1;\n        max_value -= 1;\n    }\n    min_value\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpc0vz83qv.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut closest_integer_diff = 0;\n\n    while value >= closest_integer\
    \ {\n        closest_integer = closest_integer + 1;\n        closest_integer_diff\
    \ = 1;\n    }\n\n    while value <= closest_integer {\n        closest_integer\
    \ = closest_integer - 1;\n        closest_integer_diff = 1;\n    }\n\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `10`', /tmp/tmpenx8b9zn.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 0 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpiikhxyoq.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest: isize = 0;\n    let mut closest_dist\
    \ = std::i32::MAX;\n    let mut closest_int: isize = 0;\n    let mut closest_int_dist\
    \ = std::i32::MAX;\n    let mut closest_int_dist2: isize = 0;\n    let mut closest_int_dist3:\
    \ isize = 0;\n    let mut closest_int_dist4: isize = 0;\n    let mut closest_int_dist5:\
    \ isize = 0;\n    let mut closest_int_dist6: isize = 0;\n    let mut closest_int_dist7:\
    \ isize = 0;\n    let mut closest_int_dist8: isize = 0;\n    let mut closest_int_dist9:\
    \ isize = 0;\n    let mut closest_int_dist10: isize = 0;\n    let mut closest_int_dist11:\
    \ isize = 0;\n    let mut closest_int_dist12: isize = 0;\n    let mut closest_int_dist13:\
    \ isize = 0;\n    let mut closest_int_dist14: isize = 0;\n    let mut closest_int_dist15:\
    \ isize = 0;\n    let mut closest_int_dist16: isize = 0;\n    let mut closest_int_dist17:\
    \ isize = 0;\n    let mut closest_int_dist18: isize = 0;\n    let mut closest_int_dist19:\
    \ isize = 0;\n    let mut closest_int_dist20: isize = 0;\n    let mut closest_int_dist21:\
    \ isize = 0;\n    let mut closest_int_dist22: isize = 0;\n    let mut closest_int_dist23:\
    \ isize = 0;\n    let mut closest_int_dist24: isize = 0;\n    let mut closest_int_dist25:\
    \ isize = 0;\n    let mut closest_int_dist26: isize = 0;\n    let mut closest_int_dist27:\
    \ isize = 0;\n    let mut closest_int_dist28: isize = 0;\n    let mut closest_int_dist29:\
    \ isize = 0;\n    let mut closest_int_dist30: isize = 0;\n    let mut closest_int_dist31:\
    \ isize = 0;\n    let mut closest_int_dist32: isize = 0;\n    let mut closest_int_dist33:\
    \ isize = 0;\n    let mut closest_int_dist34: isize = 0;\n    let mut closest_int_dist35:\
    \ isize = 0;\n    let mut closest_int_dist36: isize = 0;\n    let mut closest_int_dist37:\
    \ isize = 0;\n    let mut closest_int_dist38: isize = 0;\n    let mut closest_int_\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzjbooy76.rs:60:25\n   |\n\
    60 |     let mut closest_int_\n   |                         ^ help: add `;` here\n\
    61 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzjbooy76.rs:14:38\n\
    \   |\n14 | fn closest_integer(value: String) -> isize {\n   |    ---------------\
    \                   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_value\
    \ = value;\n    let mut closest_distance = 0;\n    let mut closest_index = 0;\n\
    \    while closest_value >= 0 {\n        closest_value = value % closest_value;\n\
    \        closest_distance = closest_distance + 1;\n        closest_index = closest_index\
    \ + 1;\n        if closest_distance > 2 {\n            break;\n        }\n   \
    \     value = closest_value;\n    }\n    closest_index\n}\n\nfn main() {\n   \
    \ let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\"\
    )), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to calculate the remainder with a divisor\
    \ of zero', /tmp/tmpfwdiionu.rs:20:25\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut prev_value = value;\n    while prev_value > 0 {\n    \
    \    closest_integer = prev_value;\n        prev_value = closest_integer % 10;\n\
    \    }\n    closest_integer\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp0ok0hkfk.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest: isize = 0;\n    let mut closest_dist = std::i32::MAX;\n \
    \   let mut closest_dist2 = std::i32::MAX;\n    let mut closest_dist3 = std::i32::MAX;\n\
    \    let mut closest_dist4 = std::i32::MAX;\n    let mut closest_dist5 = std::i32::MAX;\n\
    \    let mut closest_dist6 = std::i32::MAX;\n    let mut closest_dist7 = std::i32::MAX;\n\
    \    let mut closest_dist8 = std::i32::MAX;\n    let mut closest_dist9 = std::i32::MAX;\n\
    \    let mut closest_dist10 = std::i32::MAX;\n    let mut closest_dist11 = std::i32::MAX;\n\
    \    let mut closest_dist12 = std::i32::MAX;\n    let mut closest_dist13 = std::i32::MAX;\n\
    \    let mut closest_dist14 = std::i32::MAX;\n    let mut closest_dist15 = std::i32::MAX;\n\
    \    let mut closest_dist16 = std::i32::MAX;\n    let mut closest_dist17 = std::i32::MAX;\n\
    \    let mut closest_dist18 = std::i32::MAX;\n    let mut closest_dist19 = std::i32::MAX;\n\
    \    let mut closest_dist20 = std::i32::MAX;\n    let mut closest_dist21 = std::i32::MAX;\n\
    \    let mut closest_dist22 = std::i32::MAX;\n    let mut closest_dist23 = std::i32::MAX;\n\
    \    let mut closest_dist24 = std::i32::MAX;\n    let mut closest_dist25 = std::i32::MAX;\n\
    \    let mut closest_dist26 = std::i32::MAX;\n    let mut closest_dist27 = std::i32::MAX;\n\
    \    let mut closest_dist28 = std::i32::MAX;\n    let mut closest_dist29 = std::i32::MAX;\n\
    \    let mut closest_dist30 = std::i32::MAX;\n    let mut closest_dist31 = std::i32::MAX;\n\
    \    let mut closest_dist32 = std::i32::MAX;\n    let mut closest_dist33 = std::i32::MAX;\n\
    \    let mut closest_dist34 = std::i32::MAX;\n    let mut closest_dist35 = std::i32::MAX;\n\
    \    let mut closest_dist36 = std::i32::MAX;\n    let mut closest_dist37 = std::i32::MAX;\n\
    \    let \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpi1tapmj8.rs:61:1\n  \
    \ |\n61 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  }\n    value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpp8cb_dce.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp8fjgdm7e.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpyis_y0bx.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp2r2e5cgu.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        return value;\n    }\n\
    \    let mut min_value = value;\n    let mut max_value = value;\n    while max_value\
    \ - min_value > 1 {\n        let mut mid = min_value + max_value / 2;\n      \
    \  if mid % 2 == 0 {\n            min_value = mid;\n        } else {\n       \
    \     max_value = mid;\n        }\n    }\n    min_value\n}\n\nfn main() {\n  \
    \  let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpnweq1uty.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpag89o526.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut low = value;\n    let mut high = value;\n    while low < high {\n\
    \        let mid = low + ((high - low) / 2);\n        if mid % 2 == 0 {\n    \
    \        high = mid;\n        } else {\n            low = mid;\n        }\n  \
    \  }\n    low\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpe5gkfo89.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_integer = value;\n    let mut closest_integer_diff = value.abs()\
    \ as isize;\n    let mut closest_integer_diff_prev = value.abs() as isize;\n \
    \   while closest_integer_diff > closest_integer_diff_prev {\n        closest_integer_diff_prev\
    \ = closest_integer_diff;\n        closest_integer = closest_integer + 1;\n  \
    \      closest_integer_diff = closest_integer.abs() as isize;\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpq4e45o6y.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpm0slgegc.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpfbw6kz_0.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest: isize = 0;\n    let mut closest_distance\
    \ = std::i32::MAX;\n    let mut closest_index = -1;\n    for i in 0..value.len()\
    \ {\n        let mut distance = value.len() - i;\n        if distance < closest_distance\
    \ {\n            closest_distance = distance;\n            closest_index = i;\n\
    \        }\n    }\n    closest\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp9k2it2ly.rs:22:23\n   |\n22 |     for i in 0..value.len()\
    \ {\n   |                       ^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `len` found for type `isize` in the current scope\n  --> /tmp/tmp9k2it2ly.rs:23:34\n\
    \   |\n23 |         let mut distance = value.len() - i;\n   |                \
    \                  ^^^ method not found in `isize`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpiftx5zs1.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest: isize\
    \ = 0;\n    let mut difference = value.abs() - 1;\n    while difference > 0 {\n\
    \        closest += 1;\n        difference -= 1;\n    }\n    closest\n}\n\nfn\
    \ main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `10`', /tmp/tmpvpd8clz7.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp745d_grm.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round() as isize\n}\n\nfn main() {\n  \
    \  let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmplt86dqwr.rs:19:11\n   |\n19 |     value.round() as isize\n\
    \   |           ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp3p0cpzjp.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n   \
    \ assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpw399jj9w.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpz_x3oafw.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpscok7bx4.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmp1162qmty.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp0m5fely6.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest: isize = 0;\n    let mut closest2 = value;\n    while closest2\
    \ < closest {\n        closest2 = closest2 * 2;\n        closest += 1;\n    }\n\
    \    closest\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `10`', /tmp/tmptz55kl4x.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut closest_integer_diff = value.abs() - 1;\n    if closest_integer_diff\
    \ < 0 {\n        closest_integer_diff += 1;\n    }\n    while closest_integer_diff\
    \ > 0 {\n        closest_integer += 1;\n        closest_integer_diff -= 1;\n \
    \   }\n    closest_integer\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `19`,\n right: `10`', /tmp/tmp00xfbzq0.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest_integer = value;\n    let mut\
    \ closest_integer = if closest_integer == 0 {\n        closest_integer\n    }\
    \ else {\n        closest_integer - 1\n    };\n    while closest_integer % 2 ==\
    \ 0 {\n        closest_integer = closest_integer / 2;\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `10`', /tmp/tmp2aplyn89.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut prev_value = value;\n    while prev_value > closest_integer\
    \ {\n        closest_integer += 1;\n        prev_value -= 1;\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp_vlq9amy.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpewe33ak2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest: isize\
    \ = 0;\n    let mut closest = value;\n    while closest > 0 {\n        closest\
    \ -= 1;\n        if closest == 0 {\n            closest = 1;\n        }\n    }\n\
    \    closest\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpi5sadlg6.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut min_distance = std::i32::MAX;\n    let mut min_distance_index\
    \ = -1;\n    for index in 0..value.len() {\n        let distance = value.len()\
    \ - index;\n        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_distance_index = index;\n        }\n    }\n    if min_distance\
    \ == 0 {\n        closest_integer\n    } else {\n        closest_integer - min_distance_index\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp0esc1lwe.rs:19:27\n   |\n19 |     for index in 0..value.len()\
    \ {\n   |                           ^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `len` found for type `isize` in the current scope\n  --> /tmp/tmp0esc1lwe.rs:20:30\n\
    \   |\n20 |         let distance = value.len() - index;\n   |                \
    \              ^^^ method not found in `isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut lower = value;\n    let mut upper = value;\n    while lower > 0 &&\
    \ upper < 100 {\n        let mut mid = (lower + upper) / 2;\n        if mid %\
    \ 1 == 0 {\n            mid = mid.floor();\n        }\n        if mid == value\
    \ {\n            return mid;\n        }\n        if mid < value {\n          \
    \  lower = mid;\n        } else {\n            upper = mid;\n        }\n    }\n\
    \    if lower == 0 {\n        return 0;\n    }\n    if upper == 100 {\n      \
    \  return 100;\n    }\n    lower\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `floor` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpfuqukyy2.rs:27:23\n   |\n27 |             mid = mid.floor();\n\
    \   |                       ^^^^^ help: there is an associated function with a\
    \ similar name: `div_floor`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpa7xxfr78.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest: isize = 0;\n    let mut current = value;\n    while current\
    \ > closest {\n        current -= 1;\n        closest += 1;\n    }\n    closest\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmp4u0jx6iu.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmphk_usa97.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n   \
    \ assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp75e_i8s8.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n   \
    \ assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpgc2pibck.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpafk7fh76.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  }\n    value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpe7541tee.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_value\
    \ = value;\n    let mut closest_distance = 0;\n    while value >= closest_value\
    \ {\n        closest_value = value + closest_distance;\n        closest_distance\
    \ = closest_value - value;\n    }\n    closest_value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 0 {\n        value = -value;\n   \
    \ }\n    value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp7b1hlr16.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n   \
    \ assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmppo8kk02o.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut min_value = value;\n\
    \    let mut max_value = value;\n    while max_value - min_value > 1 {\n     \
    \   let mut mid = min_value + (max_value - min_value) / 2;\n        if mid * mid\
    \ > value {\n            min_value = mid;\n        } else {\n            max_value\
    \ = mid;\n        }\n    }\n    min_value\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpipzyftyz.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut closest_integer = if value < 0 {\n        closest_integer\
    \ - 1;\n    } else {\n        closest_integer + 1;\n    };\n    while closest_integer\
    \ % 2 == 0 {\n        closest_integer = closest_integer / 2;\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `()` by `{integer}`\n  --> /tmp/tmpc8t89o3a.rs:22:27\n\
    \   |\n22 |     while closest_integer % 2 == 0 {\n   |           ---------------\
    \ ^ - {integer}\n   |           |\n   |           ()\n\nerror[E0369]: cannot divide\
    \ `()` by `{integer}`\n  --> /tmp/tmpc8t89o3a.rs:23:43\n   |\n23 |         closest_integer\
    \ = closest_integer / 2;\n   |                           --------------- ^ - {integer}\n\
    \   |                           |\n   |                           ()\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc8t89o3a.rs:25:5\n   |\n14 | fn closest_integer(value:\
    \ String) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n25 |     closest_integer\n   |     ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `()`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut lower = value;\n    let mut upper = value;\n    let mut step = 1.0;\n\
    \    while lower < upper {\n        let mid = (lower + upper) / 2;\n        if\
    \ mid * mid > value {\n            lower = mid + 1;\n        } else {\n      \
    \      upper = mid;\n        }\n        step /= 2.0;\n    }\n    value\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpkcje8xm0.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest: isize = 0;\n    let mut current = value;\n    while current\
    \ > closest {\n        current -= 1;\n        closest += 1;\n    }\n    closest\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpdgdqv0m4.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp7ae5hnn6.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  }\n    value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmprdl93vki.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest_integer = value;\n    let mut\
    \ prev_value = value;\n    while prev_value != closest_integer {\n        closest_integer\
    \ = prev_value + 1;\n        prev_value = closest_integer;\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpm5of_cvh.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpnnx6bqmu.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_integer = value;\n    let mut closest_integer_square = value;\n\
    \    let mut square = value;\n    while square > 0 {\n        closest_integer_square\
    \ = closest_integer_square * closest_integer_square;\n        square = closest_integer_square;\n\
    \        closest_integer_square -= 1;\n    }\n    closest_integer\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp4t9uzs6c.rs:26:34\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmper4a33a8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        return value;\n    }\n\
    \    let mut lower = 2;\n    let mut upper = value;\n    while upper - lower >\
    \ 1 {\n        let mid = (upper + lower) / 2;\n        if mid * mid > value {\n\
    \            lower = mid;\n        } else {\n            upper = mid;\n      \
    \  }\n    }\n    lower\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `10`', /tmp/tmpt45zhray.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_integer = value;\n    let mut closest_integer_diff = 0;\n\
    \    let mut closest_integer_diff_prev = 0;\n    let mut closest_integer_diff_next\
    \ = 0;\n    while closest_integer != 0 {\n        let mut closest_integer_diff_next\
    \ = closest_integer_diff + closest_integer;\n        let mut closest_integer_diff_prev\
    \ = closest_integer_diff - closest_integer;\n        let mut closest_integer =\
    \ closest_integer_diff_next;\n        if closest_integer_diff_next < closest_integer_diff_prev\
    \ {\n            closest_integer = closest_integer_diff_prev;\n        }\n   \
    \     closest_integer_diff = closest_integer_diff_next;\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        return value;\n    }\n\
    \    let mut closest_value = value;\n    let mut closest_distance = 0;\n    let\
    \ mut closest_index = 0;\n    for &index in &[\n        0,\n        1,\n     \
    \   2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n\
    \        9,\n        10,\n        11,\n        12,\n        13,\n        14,\n\
    \        15,\n        16,\n        17,\n        18,\n        19,\n        20,\n\
    \        21,\n        22,\n        23,\n        24,\n        25,\n        26,\n\
    \        27,\n        28,\n        29,\n        30,\n        31,\n        32,\n\
    \        33,\n        34,\n        35,\n        36,\n        37,\n        38,\n\
    \        39,\n        40,\n        41,\n        42,\n        43,\n        44,\n\
    \        45,\n        46,\n        47,\n        48,\n        49,\n        50,\n\
    \        51,\n        52,\n        53,\n        54,\n        55,\n        56,\n\
    \        57,\n        58,\n        59,\n        60,\n        61,\n        62,\n\
    \        63,\n        64,\n        65,\n        66,\n        67,\n        68,\n\
    \        69,\n        70,\n        71,\n        72,\n        73,\n        74,\n\
    \        75,\n        76,\n        77,\n        78,\n        79,\n        80,\n\
    \        81,\n        82,\n        83,\n        84,\n        85,\n        86,\n\
    \        87,\n        88,\n        89,\n        90,\n        91,\n        92,\n\
    \        93,\n        94,\n        95,\n        96,\n        97,\n        98,\n\
    \        99,\n        100,\n        101,\n        102,\n        103,\n       \
    \ 104,\n        105,\n        106,\n        107,\n        108,\n        109,\n\
    \        110,\n        111,\n        112,\n        113,\n        114,\n      \
    \  115,\n        116,\n        117,\n        118,\n        119,\n        120,\n\
    \        121,\n        122,\n        123,\n        12\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n   --> /tmp/tmpfp0va0e9.rs:25:20\n\
    \    |\n14  | fn closest_integer(value: String) -> isize {\n    |            \
    \                                - closing delimiter possibly meant for this\n\
    ...\n25  |     for &index in &[\n    |                    ^ unclosed delimiter\n\
    ...\n151 | }\n    | ^ mismatched closing delimiter\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpfp0va0e9.rs:151:1\n    |\n151 | }\n    | ^ expected `{`\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpb_j_lf4g.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut closest_integer = if value < 0 {\n        closest_integer\
    \ - 1;\n    } else {\n        closest_integer + 1;\n    };\n    while closest_integer\
    \ != 0 {\n        if closest_integer % 2 == 0 {\n            closest_integer =\
    \ closest_integer / 2;\n        } else {\n            closest_integer = closest_integer\
    \ / 2;\n        }\n    }\n    closest_integer\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvcu7j1ab.rs:22:30\n   |\n\
    22 |     while closest_integer != 0 {\n   |                              ^ expected\
    \ `()`, found integer\n\nerror[E0369]: cannot mod `()` by `{integer}`\n  --> /tmp/tmpvcu7j1ab.rs:23:28\n\
    \   |\n23 |         if closest_integer % 2 == 0 {\n   |            ---------------\
    \ ^ - {integer}\n   |            |\n   |            ()\n\nerror[E0369]: cannot\
    \ divide `()` by `{integer}`\n  --> /tmp/tmpvcu7j1ab.rs:24:47\n   |\n24 |    \
    \         closest_integer = closest_integer / 2;\n   |                       \
    \        --------------- ^ - {integer}\n   |                               |\n\
    \   |                               ()\n\nerror[E0369]: cannot divide `()` by\
    \ `{integer}`\n  --> /tmp/tmpvcu7j1ab.rs:26:47\n   |\n26 |             closest_integer\
    \ = closest_integer / 2;\n   |                               --------------- ^\
    \ - {integer}\n   |                               |\n   |                    \
    \           ()\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvcu7j1ab.rs:29:5\n\
    \   |\n14 | fn closest_integer(value: String) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n29\
    \ |     closest_integer\n   |     ^^^^^^^^^^^^^^^ expected `isize`, found `()`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest_integer = value;\n    let mut\
    \ closest_integer_dist = std::i32::MAX;\n    let mut closest_integer_dist_sq =\
    \ std::i32::MAX;\n    let mut closest_integer_dist_sq_sq = std::i32::MAX;\n  \
    \  let mut closest_integer_dist_sq_sq_sq = std::i32::MAX;\n    let mut closest_integer_dist_sq_sq_sq_sq\
    \ = std::i32::MAX;\n    let mut closest_integer_dist_sq_sq_sq_sq_sq = std::i32::MAX;\n\
    \    let mut closest_integer_dist_sq_sq_sq_sq_sq_sq = std::i32::MAX;\n    let\
    \ mut closest_integer_dist_sq_sq_sq_sq_sq_sq_sq = std::i32::MAX;\n    let mut\
    \ closest_integer_dist_sq_sq_sq_sq_sq_sq_sq_sq_sq = std::i32::MAX;\n    let mut\
    \ closest_integer_dist_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = std::i32::MAX;\n    let\
    \ mut closest_integer_dist_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = std::i32::MAX;\n\
    \    let mut closest_integer_dist_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = std::i32::MAX;\n\
    \    let mut closest_integer_dist_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = std::i32::MAX;\n\
    \    let mut closest_integer_dist_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = std::i32::MAX;\n\
    \    let mut closest_integer_dist_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = std::i32::MAX;\n\
    \    let mut closest_integer_dist_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = std::i32::MAX;\n\
    \    let mut closest_integer_dist_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = std::i32::MAX;\n\
    \    let mut closest_integer_dist_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = std::i32::MAX;\n\
    \    let mut closest_integer_dist_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = std::i32::MAX;\n\
    \    let mut closest_integer_dist_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = std::i32::MAX;\n\
    \    let mut closest_integer_dist_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = std::i32::MAX;\n\
    \    let mut closest_integer_dist_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = std::i32::MAX;\n\
    \    let \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpz_4r74s8.rs:43:1\n  \
    \ |\n43 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_value = value;\n    let mut closest_distance = std::f64::MAX;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = value;\n\
    \    let mut closest_integer = value;\n    let mut \n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpax2xvnou.rs:82:1\n\
    \   |\n82 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpy5kmn1sy.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpfmtx2hhr.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut num: isize = 0;\n    let mut digits: Vec<isize> = value.chars().collect();\n\
    \    let mut num_digits = digits.len();\n    let mut num_digits_squared = num_digits\
    \ * num_digits;\n    let mut square_root: isize = 0;\n    let mut remainder: isize\
    \ = 0;\n    let mut quotient: isize = 0;\n    let mut remainder_squared: isize\
    \ = 0;\n    let mut quotient_squared: isize = 0;\n    while num_digits > 0 {\n\
    \        remainder = num % 10;\n        quotient = num / 10;\n        remainder_squared\
    \ = remainder * remainder;\n        quotient_squared = quotient * quotient;\n\
    \        if remainder_squared < quotient_squared {\n            num = quotient;\n\
    \            num_digits -= 1;\n        } else {\n            num = remainder;\n\
    \            num_digits -= 1;\n        }\n    }\n    square_root = num_digits_squared\
    \ + 1;\n    square_root /= 2;\n    square_root -= 1;\n    square_root * square_root\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpy5yih_0q.rs:16:48\n     |\n16\
    \   |     let mut digits: Vec<isize> = value.chars().collect();\n     |      \
    \                                          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<isize>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy5yih_0q.rs:37:19\n\
    \   |\n19 |     let mut square_root: isize = 0;\n   |                        \
    \  ----- expected due to this type\n...\n37 |     square_root = num_digits_squared\
    \ + 1;\n   |                   ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        return value;\n    }\n\
    \    let mut closest_value = value;\n    let mut closest_index = 0;\n    let mut\
    \ prev_value = value;\n    let mut prev_index = 0;\n    while closest_index !=\
    \ prev_index {\n        prev_value = closest_value;\n        prev_index = closest_index;\n\
    \        closest_value = closest_value + 1;\n        closest_index = closest_value.checked_add(isize::from(1)).ok();\n\
    \    }\n    closest_value\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpvc_9k2j2.rs:30:67\n   |\n30 |         closest_index = closest_value.checked_add(isize::from(1)).ok();\n\
    \   |                                                                   ^^ help:\
    \ there is an associated function with a similar name: `or`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpuzp_g_jq.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmphxzx6a9e.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp2begdqc5.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 10 {\n        return value;\n    }\n\
    \    if value < 100 {\n        return 10 + value;\n    }\n    if value < 1000\
    \ {\n        return 100 + value;\n    }\n    if value < 10000 {\n        return\
    \ 1000 + value;\n    }\n    if value < 100000 {\n        return 10000 + value;\n\
    \    }\n    if value < 1000000 {\n        return 100000 + value;\n    }\n    if\
    \ value < 10000000 {\n        return 1000000 + value;\n    }\n    if value < 100000000\
    \ {\n        return 10000000 + value;\n    }\n    if value < 1000000000 {\n  \
    \      return 100000000 + value;\n    }\n    if value < 10000000000 {\n      \
    \  return 1000000000 + value;\n    }\n    if value < 100000000000 {\n        return\
    \ 10000000000 + value;\n    }\n    if value < 1000000000000 {\n        return\
    \ 100000000000 + value;\n    }\n    if value < 10000000000000 {\n        return\
    \ 1000000000000 + value;\n    }\n    if value < 100000000000000 {\n        return\
    \ 10000000000000 + value;\n    }\n    if value < 1000000000000000 {\n        return\
    \ 100000000000000 + value;\n    }\n    if value < 10000000000000000 {\n      \
    \  return 1000000000000000 + value;\n    }\n    if value < 100000000000000000\
    \ {\n        return 10000000000000000 + value;\n    }\n    if value < 1000000000000000000\
    \ {\n        return 100000000000000000 + value;\n    }\n    if value < 10000000000000000000\
    \ {\n        return 1000000000000000000 + value;\n    }\n    if value < 100000000000000000000\
    \ {\n        return 10000000000000000000 + value;\n    }\n    if value < 1000000000000000000000\
    \ {\n        return 100000000000000000000 + value;\n    }\n    if value < 10000000000000000000000\
    \ {\n        return 1000000000000000000000 + value;\n    }\n    if value < 100000000000000000000000\
    \ {\n        return 10000000000000000000000 + value;\n    }\n    if value < 1000000000000000000000000\
    \ {\n        return 100000000000000000000000 + value;\n    }\n    if value < 10000000000000000000000000\
    \ {\n        return 1000000000000000000000000 + value;\n    }\n    if value <\
    \ 100000000000000000000000000 {\n        return 10000000000000000000000000 + value;\n\
    \    }\n    if value < 1000000000000000000000000000 {\n        return 100000000000000000000000000\
    \ + value;\n    }\n    if value < 10000000000000000000000000000 {\n        return\
    \ 1000000000000000000000000000 + value;\n    }\n    if value < 100000000000000000000000000000\
    \ {\n        return 10000000000000000000000000000 + value;\n    }\n    if value\
    \ < 1000000000000000000000000000000 {\n        return 100000000000000000000000000000\
    \ + value;\n    }\n    if value < 10000000000000000000000000000000 {\n       \
    \ return 1000000000000000000000000000000 + value;\n    }\n    if value < 100000000000000000000000000000000\
    \ {\n        return 10000000000000000000000000000000 + value;\n    }\n    if value\
    \ < 1000000000000000000000000000000000 {\n        return \n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0_bvr52t.rs:126:3\n\
    \    |\n14  | fn closest_integer(value: String) -> isize {\n    |            \
    \                                - unclosed delimiter\n...\n115 |     if value\
    \ < 1000000000000000000000000000000000 {\n    |                              \
    \                     - this delimiter might not be properly closed...\n116 |\
    \         return \n117 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n126 | }\n    |   ^\n\nerror[E0069]: `return;` in a function\
    \ whose return type is not `()`\n   --> /tmp/tmp0_bvr52t.rs:116:9\n    |\n14 \
    \ | fn closest_integer(value: String) -> isize {\n    |                      \
    \                ----- expected `isize` because of this return type\n...\n116\
    \ |         return \n    |         ^^^^^^ return type is not `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0_bvr52t.rs:14:38\n   |\n14 | fn closest_integer(value:\
    \ String) -> isize {\n   |    ---------------                   ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0069, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0069`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value % 2 == 0 {\n\
    \        value /= 2;\n    } else {\n        value *= 2;\n    }\n    value.round()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpecipsyk3.rs:21:11\n   |\n21 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmplrkr97hz.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_value\
    \ = value;\n    let mut closest_distance = std::cmp::max(isize::MIN, isize::MAX);\n\
    \    while closest_distance > 0 {\n        let mut new_value = value + 1;\n  \
    \      let mut new_distance = std::cmp::max(isize::MIN, isize::MAX);\n       \
    \ while new_distance > 0 {\n            let mut new_new_value = new_value + 1;\n\
    \            let mut new_new_distance = std::cmp::max(isize::MIN, isize::MAX);\n\
    \            while new_new_distance > 0 {\n                let mut new_new_new_value\
    \ = new_new_value + 1;\n                let mut new_new_new_distance = std::cmp::max(isize::MIN,\
    \ isize::MAX);\n                while new_new_new_distance > 0 {\n           \
    \         let mut new_new_new_new_value = new_new_new_value + 1;\n           \
    \         let mut new_new_new_new_distance = std::cmp::max(isize::MIN, isize::MAX);\n\
    \                    while new_new_new_new_distance > 0 {\n                  \
    \      let mut new_new_new_new_new_value = new_new_new_new_value + 1;\n      \
    \                  let mut new_new_new_new_new_distance = std::cmp::max(isize::MIN,\
    \ isize::MAX);\n                        while new_new_new_new_new_distance > 0\
    \ {\n                            let mut new_new_new_new_new_new_value = new_new_new_new_new_value\
    \ + 1;\n                            let mut new_new_new_new_new_new_distance =\
    \ std::cmp::max(isize::MIN, isize::MAX);\n                            while new_new_new_new_new_new_distance\
    \ > 0 {\n                                let mut new_new_new_new_new_new_new_value\
    \ = new_new_new_new_new_new_value + 1;\n                                let mut\
    \ new_new_new_new_new_new_new_distance = std::cmp::max(isize::MIN, isize::MAX);\n\
    \                                while new_new_new_new_new_new_new_distance >\
    \ 0 {\n                                    let mut new_new_new_new_new_new_new_new_value\
    \ = new_new_new_new_new_new_new_value + 1;\n                                 \
    \   let mut new_new_new_new_new_new_new_distance = std::cmp::max(isize::MIN, isize::MAX);\n\
    \                                    while new_new_new_new_new_new_new_new_distance\
    \ > 0 {\n                                        let mut new_new_new_new_new_new_new_new_new_value\
    \ = new_new_new_new_new_new_new_new_value + 1;\n                             \
    \           let mut new_new_new_new_new_new_new_new_distance = std::cmp::max(isize::MIN,\
    \ isize::MAX);\n                                        while new_new_new_new_new_new_new_new_new_distance\
    \ \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpskyv7_63.rs:55:3\n\
    \   |\n14 | fn closest_integer(value: String) -> isize {\n   |               \
    \                             - unclosed delimiter\n...\n18 |     while closest_distance\
    \ > 0 {\n   |                                - unclosed delimiter\n...\n21 | \
    \        while new_distance > 0 {\n   |                                - unclosed\
    \ delimiter\n...\n24 |             while new_new_distance > 0 {\n   |        \
    \                                - unclosed delimiter\n...\n27 |             \
    \    while new_new_new_distance > 0 {\n   |                                  \
    \              - unclosed delimiter\n...\n30 |                     while new_new_new_new_distance\
    \ > 0 {\n   |                                                        - unclosed\
    \ delimiter\n...\n33 |                         while new_new_new_new_new_distance\
    \ > 0 {\n   |                                                                -\
    \ unclosed delimiter\n...\n36 |                             while new_new_new_new_new_new_distance\
    \ > 0 {\n   |                                                                \
    \        - unclosed delimiter\n...\n39 |                                 while\
    \ new_new_new_new_new_new_new_distance > 0 {\n   |                           \
    \                                                     - unclosed delimiter\n...\n\
    42 |                                     while new_new_new_new_new_new_new_new_distance\
    \ > 0 {\n   |                                                                \
    \                        - this delimiter might not be properly closed...\n...\n\
    46 | }\n   | - ...as it matches this but it has different indentation\n...\n55\
    \ | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpskyv7_63.rs:46:1\n\
    \   |\n45 |                                         while new_new_new_new_new_new_new_new_new_distance\
    \ \n   |                                         ----- --------------------------------------------\
    \ this `while` condition successfully parsed\n   |                           \
    \              |\n   |                              "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut closest_integer_distance = std::i32::MAX;\n    let mut\
    \ closest_integer_distance_sign = std::i32::MAX;\n    let mut closest_integer_distance_magnitude\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals =\
    \ std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_sign\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent_sign\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent_sign\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent_sign\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent_sign\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent_sign\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent_sign\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent_sign\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent_sign\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent_sign\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent_sign\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent\
    \ = std::i32::MAX;\n    let mut closest_integer_distance_magnitude_decimals_exponent_sign\
    \ = std::i32::\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpt63la9w1.rs:44:1\n\
    \   |\n44 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        return value;\n    }\n\
    \    let mut max_diff = 0;\n    let mut closest_value = value;\n    let mut closest_index\
    \ = -1;\n    let mut closest_index = value.len();\n    for &i in value.chars().nth(closest_index)\
    \ {\n        let diff = i - closest_value;\n        if diff > max_diff {\n   \
    \         max_diff = diff;\n            closest_value = i;\n            closest_index\
    \ = i;\n        }\n    }\n    closest_value\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpkvw9pw63.rs:25:35\n   |\n25 |     let mut closest_index\
    \ = value.len();\n   |                                   ^^^ method not found\
    \ in `isize`\n\nerror[E0599]: no method named `chars` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmpkvw9pw63.rs:26:21\n   |\n26 |     for &i in\
    \ value.chars().nth(closest_index) {\n   |                     ^^^^^ method not\
    \ found in `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpg_phib3x.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut lower = value;\n    let mut upper = value;\n    let mut mid = 0;\n\
    \    while lower < upper {\n        mid = lower + (upper - lower) / 2;\n     \
    \   if mid > value {\n            upper = mid - 1;\n        } else if mid < value\
    \ {\n            lower = mid + 1;\n        } else {\n            break;\n    \
    \    }\n    }\n    mid\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `10`', /tmp/tmptxfbg93c.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest: isize\
    \ = 0;\n    let mut closest_distance = std::i32::MAX;\n\n    while value >= closest\
    \ {\n        closest_distance = std::i32::MAX;\n        closest = (value + closest)\
    \ / 2;\n        for &i in &mut [&mut closest; &mut closest] {\n            if\
    \ *i == 0 {\n                *i = 1;\n            }\n            if *i == value\
    \ {\n                *i = 1;\n            }\n            if *i == closest {\n\
    \                *i = 1;\n            }\n            if *i == value {\n      \
    \          *i = 1;\n            }\n        }\n    }\n    closest\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmp6iw7e1f8.rs:22:44\n   |\n16 |     let mut closest: isize = 0;\n   |\
    \     --------------- help: consider using `const` instead of `let`: `const closest`\n\
    ...\n22 |         for &i in &mut [&mut closest; &mut closest] {\n   |        \
    \                                    ^^^^^^^ non-constant value\n\nerror[E0277]:\
    \ the trait bound `&mut isize: Copy` is not satisfied\n  --> /tmp/tmp6iw7e1f8.rs:22:25\n\
    \   |\n22 |         for &i in &mut [&mut closest; &mut closest] {\n   |      \
    \                   -^^^^^^^^^^^\n   |                         |\n   |       \
    \                  the trait `Copy` is not implemented for `&mut isize`\n   |\
    \                         help: consider removing the leading `&`-reference\n\
    \   |\n   = note: `Copy` is implemented for `&isize`, but not for `&mut isize`\n\
    \   = note: the `Copy` trait is required because this value will be copied for\
    \ each element of the array\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0435.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpch_ojy1g.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpmgbifmei.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpd1l_n69m.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut v = value.parse::<isize>().unwrap();\n    let mut i = v;\n    if v\
    \ < 0 {\n        i = -v;\n    }\n    i as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp0qofluut.rs:15:40\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpyn509v5i.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmp83iv_15g.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value % 2 == 0 {\n\
    \        value /= 2;\n    } else {\n        value *= 2;\n    }\n    value\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpcjo8cy57.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpxv33fo2c.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round() as isize\n}\n\nfn main() {\n  \
    \  let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpg1rity8n.rs:19:11\n   |\n19 |     value.round() as isize\n\
    \   |           ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest_integer = value;\n    let mut\
    \ closest_integer = if closest_integer == 0 {\n        closest_integer + 1\n \
    \   } else {\n        closest_integer - 1\n    };\n    while closest_integer %\
    \ 2 == 0 {\n        closest_integer = closest_integer / 2;\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `10`', /tmp/tmpnth9x6wa.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpe1tihvum.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest: isize = 0;\n    let mut current = value;\n    while current\
    \ > closest {\n        current -= 1;\n        closest += 1;\n    }\n    closest\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpp8cg9jqo.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut min_value = value;\n    let mut max_value = value;\n    while max_value\
    \ - min_value > 1 {\n        let mut mid = min_value + (max_value - min_value)\
    \ / 2;\n        if mid % 2 == 0 {\n            min_value = mid;\n        } else\
    \ {\n            max_value = mid;\n        }\n    }\n    min_value\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp31ybmyr3.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 0 {\n        value = -value;\n   \
    \ }\n    value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpsekxbimq.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  }\n    value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpywj16smy.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpyh9a5pzd.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest_integer = value;\n    let mut\
    \ closest_integer = if value < closest_integer {\n        closest_integer\n  \
    \  } else {\n        closest_integer\n    };\n    while closest_integer % 2 ==\
    \ 0 {\n        closest_integer = closest_integer / 2;\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpm59h7atb.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_integer = value;\n    let mut closest_integer_distance = std::cmp::max(isize::MIN,\
    \ isize::MAX);\n    let mut closest_integer_distances = Vec::new();\n    let mut\
    \ current_distance = std::cmp::max(isize::MIN, isize::MAX);\n    let mut current_distances\
    \ = Vec::new();\n    closest_integer_distances.push(closest_integer);\n    current_distances.push(current_distance);\n\
    \    while closest_integer_distances.len() > 1 {\n        let mut closest_integer_distance\
    \ = closest_integer_distances.iter().cloned().next().unwrap();\n        let mut\
    \ current_distance = current_distances.iter().cloned().next().unwrap();\n    \
    \    if closest_integer_distance < current_distance {\n            closest_integer_distance\
    \ = current_distance;\n        }\n        if closest_integer_distance == 0 {\n\
    \            break;\n        }\n        let mut closest_integer_distances = Vec::new();\n\
    \        let mut current_distances = Vec::new();\n        closest_integer_distances.push(closest_integer_distance);\n\
    \        current_distances.push(current_distance);\n    }\n    closest_integer_distances.iter().cloned().next().unwrap()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmprexqzmfv.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut lower = value;\n    let mut upper = value;\n    while lower > 0 &&\
    \ upper < 100 {\n        if lower % 10 == 0 {\n            lower = lower / 10;\n\
    \        } else {\n            lower = lower / 10 + 1;\n        }\n        if\
    \ upper % 10 == 0 {\n            upper = upper / 10;\n        } else {\n     \
    \       upper = upper / 10 + 1;\n        }\n    }\n    if lower == 0 {\n     \
    \   lower++;\n    }\n    if upper == 100 {\n        upper--;\n    }\n    if lower\
    \ == upper {\n        return lower;\n    }\n    if lower == 0 {\n        return\
    \ 0;\n    }\n    if upper == 100 {\n        return 100;\n    }\n    if upper <\
    \ lower {\n        lower = lower * 10 + 10;\n    }\n    if upper > lower {\n \
    \       upper = upper * 10 + 10;\n    }\n    if lower > upper {\n        lower\
    \ = lower * 10 + 100;\n    }\n    if upper < lower {\n        upper = upper *\
    \ 10 + 100;\n    }\n    if lower == upper {\n        return lower;\n    }\n  \
    \  if lower == 0 {\n        return 0;\n    }\n    if upper == 100 {\n        return\
    \ 100;\n    }\n    if upper < lower {\n        lower = lower * 10 + 100;\n   \
    \ }\n    if upper > lower {\n        upper = upper * 10 + 100;\n    }\n    if\
    \ lower > upper {\n        lower = lower * 10 + 1000;\n    }\n    if upper < lower\
    \ {\n        upper = upper * 10 + 1000;\n    }\n    if lower == upper {\n    \
    \    return lower;\n    }\n    if lower == 0 {\n        return 0;\n    }\n   \
    \ if upper == 100 {\n        return 100;\n    }\n    if upper < lower {\n    \
    \    lower = lower * 10 + 1000;\n    }\n    if upper > lower {\n        upper\
    \ = upper * 10 + 1000;\n    }\n    if lower > upper {\n        lower = lower *\
    \ 10 + 10000;\n    }\n    if upper < lower {\n        upper = upper * 10 + 10000;\n\
    \    }\n    if lower == upper {\n        return lower;\n    }\n    if lower ==\
    \ 0 {\n        return 0;\n    }\n    if upper == 100 {\n        return 100;\n\
    \    }\n    if upper < lower {\n        lower = lower * 10 + 10000;\n    }\n \
    \   if upper > lower {\n        upper = upper * 10 + 10000;\n    }\n\n}\n\nfn\
    \ main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmplhr3hhvq.rs:37:14\n\
    \   |\n37 |         lower++;\n   |              ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n37 |         { let tmp = lower; lower +=\
    \ 1; tmp };\n   |         +++++++++++      ~~~~~~~~~~~~~~~~~~~\n37 -         lower++;\n\
    37 +         lower += 1;\n   | \n\nerror: expected expression, found `;`\n  -->\
    \ /tmp/tmplhr3hhvq.rs:40:16\n   |\n40 |         upper--;\n   |               \
    \ ^ expected expression\n\nerror[E0308]: mismatched types\n   --> /tmp/tmplhr3hhvq.rs:117:22\n\
    \    |\n117 |       if upper > lower {\n    |  ______________________^\n118 |\
    \ |         upper = upper * 10 + 10000;\n119 | |     }\n    | |_____^ expected\
    \ `isize`, found `()`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   if value < 4 {\n        value = 1;\n    }\n    if value < 8 {\n        value\
    \ = 2;\n    }\n    if value < 16 {\n        value = 3;\n    }\n    if value <\
    \ 32 {\n        value = 4;\n    }\n    if value < 64 {\n        value = 5;\n \
    \   }\n    if value < 128 {\n        value = 6;\n    }\n    if value < 256 {\n\
    \        value = 7;\n    }\n    if value < 512 {\n        value = 8;\n    }\n\
    \    if value < 1024 {\n        value = 9;\n    }\n    if value < 2048 {\n   \
    \     value = 10;\n    }\n    if value < 4096 {\n        value = 11;\n    }\n\
    \    if value < 8192 {\n        value = 12;\n    }\n    if value < 16384 {\n \
    \       value = 13;\n    }\n    if value < 32768 {\n        value = 14;\n    }\n\
    \    if value < 65536 {\n        value = 15;\n    }\n    if value < 131072 {\n\
    \        value = 16;\n    }\n    if value < 262144 {\n        value = 17;\n  \
    \  }\n    if value < 524288 {\n        value = 18;\n    }\n    if value < 1048576\
    \ {\n        value = 19;\n    }\n    if value < 2097152 {\n        value = 20;\n\
    \    }\n    if value < 4194304 {\n        value = 21;\n    }\n    if value < 8388608\
    \ {\n        value = 22;\n    }\n    if value < 16777216 {\n        value = 23;\n\
    \    }\n    if value < 33554432 {\n        value = 24;\n    }\n    if value <\
    \ 67108864 {\n        value = 25;\n    }\n    if value < 134217728 {\n       \
    \ value = 26;\n    }\n    if value < 268435456 {\n        value = 27;\n    }\n\
    \    if value < 536870912 {\n        value = 28;\n    }\n    if value < 1073741824\
    \ {\n        value = 29;\n    }\n    if value < 2147483648 {\n        value =\
    \ 30;\n    }\n    value\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `30`,\n right: `10`', /tmp/tmphnsb5htd.rs:117:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value % 2 == 0 {\n\
    \        value /= 2;\n    } else {\n        value *= 2;\n    }\n    value\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmp1tblqwqr.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut v = value.parse::<isize>().unwrap();\n    let mut i = v;\n    while\
    \ i > 0 {\n        if v % i == 0 {\n            return i;\n        }\n       \
    \ i /= 2;\n    }\n    v\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmppx5zqujx.rs:15:40\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpc6yre9uu.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut prev_value = value;\n    while prev_value > 0 {\n    \
    \    prev_value = value;\n        value = value / 10;\n        if value == prev_value\
    \ {\n            closest_integer = value;\n            break;\n        }\n   \
    \ }\n    closest_integer\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `10`', /tmp/tmpjvor_6nc.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest_value = value;\n    let mut closest_index\
    \ = 0;\n    let mut closest_distance = std::i32::MAX;\n    for i in 0..value.len()\
    \ {\n        let mut current_distance = value.len() - i;\n        let mut current_value\
    \ = value.clone();\n        let mut current_index = i;\n        while current_distance\
    \ > closest_distance {\n            current_value -= 1;\n            current_distance\
    \ -= 1;\n            current_index -= 1;\n        }\n        let mut current_value\
    \ = value.clone();\n        let mut current_index = i;\n        while current_distance\
    \ < closest_distance {\n            current_value += 1;\n            current_distance\
    \ += 1;\n            current_index += 1;\n        }\n        if current_value\
    \ == closest_value {\n            closest_value = current_value;\n           \
    \ closest_index = current_index;\n            closest_distance = current_distance;\n\
    \        }\n    }\n    closest_value\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp2oof6z6t.rs:22:23\n   |\n22 |     for i in 0..value.len()\
    \ {\n   |                       ^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `len` found for type `isize` in the current scope\n  --> /tmp/tmp2oof6z6t.rs:23:42\n\
    \   |\n23 |         let mut current_distance = value.len() - i;\n   |        \
    \                                  ^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpuox5j4x6.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        value = 0;\n    }\n \
    \   value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpjs7ptm9x.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_value = value;\n    let mut closest_distance = 0;\n    while\
    \ value >= closest_value {\n        closest_value = closest_value + 1;\n     \
    \   closest_distance = closest_distance + 1;\n    }\n    closest_value\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `10`', /tmp/tmpkrtksb0o.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        return value;\n    }\n\
    \    let mut closest_value = value;\n    let mut closest_diff = 0;\n    let mut\
    \ prev_diff = 0;\n    while closest_diff < prev_diff {\n        closest_value\
    \ += 1;\n        closest_diff = value.abs() - closest_value.abs();\n        prev_diff\
    \ = closest_diff;\n    }\n    closest_value\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpmx5b2k9n.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest: isize = 0;\n    let mut closest_dist = std::i32::MAX;\n \
    \   let mut closest_dist2 = std::i32::MAX;\n    let mut closest_dist3 = std::i32::MAX;\n\
    \    let mut closest_dist4 = std::i32::MAX;\n    let mut closest_dist5 = std::i32::MAX;\n\
    \    let mut closest_dist6 = std::i32::MAX;\n    let mut closest_dist7 = std::i32::MAX;\n\
    \    let mut closest_dist8 = std::i32::MAX;\n    let mut closest_dist9 = std::i32::MAX;\n\
    \    let mut closest_dist10 = std::i32::MAX;\n    let mut closest_dist11 = std::i32::MAX;\n\
    \    let mut closest_dist12 = std::i32::MAX;\n    let mut closest_dist13 = std::i32::MAX;\n\
    \    let mut closest_dist14 = std::i32::MAX;\n    let mut closest_dist15 = std::i32::MAX;\n\
    \    let mut closest_dist16 = std::i32::MAX;\n    let mut closest_dist17 = std::i32::MAX;\n\
    \    let mut closest_dist18 = std::i32::MAX;\n    let mut closest_dist19 = std::i32::MAX;\n\
    \    let mut closest_dist20 = std::i32::MAX;\n    let mut closest_dist21 = std::i32::MAX;\n\
    \    let mut closest_dist22 = std::i32::MAX;\n    let mut closest_dist23 = std::i32::MAX;\n\
    \    let mut closest_dist24 = std::i32::MAX;\n    let mut closest_dist25 = std::i32::MAX;\n\
    \    let mut closest_dist26 = std::i32::MAX;\n    let mut closest_dist27 = std::i32::MAX;\n\
    \    let mut closest_dist28 = std::i32::MAX;\n    let mut closest_dist29 = std::i32::MAX;\n\
    \    let mut closest_dist30 = std::i32::MAX;\n    let mut closest_dist31 = std::i32::MAX;\n\
    \    let mut closest_dist32 = std::i32::MAX;\n    let mut closest_dist33 = std::i32::MAX;\n\
    \    let mut closest_dist34 = std::i32::MAX;\n    let mut closest_dist35 = std::i32::MAX;\n\
    \    let mut closest_dist36 = std::i32::MAX;\n    let mut closest_dist37 = std::i32::MAX;\n\
    \    let \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpg8s4gc3t.rs:61:1\n  \
    \ |\n61 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp64gwh7ac.rs:19:11\n   |\n19 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        return value;\n    }\n\
    \    let mut closest: isize = 0;\n    let mut closest2 = 2;\n    let mut closest3\
    \ = 2;\n    let mut closest4 = 2;\n    let mut closest5 = 2;\n    let mut closest6\
    \ = 2;\n    let mut closest7 = 2;\n    let mut closest8 = 2;\n    let mut closest9\
    \ = 2;\n    let mut closest10 = 2;\n    let mut closest11 = 2;\n    let mut closest12\
    \ = 2;\n    let mut closest13 = 2;\n    let mut closest14 = 2;\n    let mut closest15\
    \ = 2;\n    let mut closest16 = 2;\n    let mut closest17 = 2;\n    let mut closest18\
    \ = 2;\n    let mut closest19 = 2;\n    let mut closest20 = 2;\n    let mut closest21\
    \ = 1;\n    let mut closest22 = 1;\n    let mut closest23 = 1;\n    let mut closest24\
    \ = 1;\n    let mut closest25 = 1;\n    let mut closest26 = 1;\n    let mut closest27\
    \ = 1;\n    let mut closest28 = 1;\n    let mut closest29 = 1;\n    let mut closest30\
    \ = 1;\n    let mut closest31 = 1;\n    let mut closest32 = 1;\n    let mut closest33\
    \ = 1;\n    let mut closest34 = 1;\n    let mut closest35 = 1;\n    let mut closest36\
    \ = 1;\n    let mut closest37 = 1;\n    let mut closest38 = 1;\n    let mut closest39\
    \ = 1;\n    let mut closest40 = 1;\n    let mut closest41 = 1;\n    let mut closest42\
    \ = 1;\n    let mut closest43 = 1;\n    let mut closest44 = 1;\n    let mut closest45\
    \ = 1;\n    let mut closest46 = 1;\n    let mut closest47 = 1;\n    let mut closest48\
    \ = 1;\n    let mut closest49 = 1;\n    let mut closest50 = 1;\n    let mut closest51\
    \ = 1;\n    let mut closest52 = 1;\n    let mut closest53 = 1;\n    let mut closest54\
    \ = 1;\n    let mut closest55 = 1;\n    let mut closest56 = 1;\n    let mut closest57\
    \ = 1;\n    let mut closest58 = 1;\n    let mut closest59 = 1;\n    let mut closest60\
    \ = 1;\n    let mut closest61 = 1;\n    let mut closest62 = 1;\n    let mut closest63\
    \ = 1;\n    let mut closest64 = 1;\n    let mut closest65 = 1;\n    let mut closest66\
    \ = 1;\n    let mut closest67 = 1;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpz_hsqt2h.rs:89:11\n   |\n\
    89 |     let mu\n   |           ^ help: add `;` here\n90 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz_hsqt2h.rs:14:38\n \
    \  |\n14 | fn closest_integer(value: String) -> isize {\n   |    ---------------\
    \                   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmppwjkozir.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        return value;\n    }\n\
    \    let mut closest_value = value;\n    let mut closest_distance = std::i32::MAX;\n\
    \    for d in &[-2, -1, 0, 1, 2] {\n        let new_value = value + d;\n     \
    \   let new_distance = std::i32::MAX;\n        if new_value < 0 {\n          \
    \  new_value = -new_value;\n        }\n        if new_value < 2 {\n          \
    \  continue;\n        }\n        for d in &[-2, -1, 0, 1, 2] {\n            let\
    \ new_value = value + d;\n            let new_distance = std::i32::MAX;\n    \
    \        if new_value < 0 {\n                new_value = -new_value;\n       \
    \     }\n            if new_distance < closest_distance {\n                closest_value\
    \ = new_value;\n                closest_distance = new_distance;\n           \
    \ }\n        }\n    }\n    closest_value\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `new_distance`\n  --> /tmp/tmpcenwcmo3.rs:26:13\n\
    \   |\n26 |         let new_distance = std::i32::MAX;\n   |             ^^^^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_new_distance`\n\
    \   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot\
    \ assign twice to immutable variable `new_value`\n  --> /tmp/tmpcenwcmo3.rs:28:13\n\
    \   |\n25 |         let new_value = value + d;\n   |             ---------\n \
    \  |             |\n   |             first assignment to `new_value`\n   |   \
    \          help: consider making this binding mutable: `mut new_value`\n...\n\
    28 |             new_value = -new_value;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice\
    \ to immutable variable `new_value`\n  --> /tmp/tmpcenwcmo3.rs:37:17\n   |\n34\
    \ |             let new_value = value + d;\n   |                 ---------\n \
    \  |                 |\n   |                 first assignment to `new_value`\n\
    \   |                 help: consider making this binding mutable: `mut new_value`\n\
    ...\n37 |                 new_value = -new_value;\n   |                 ^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_value = value;\n    let mut closest_distance = std::f64::MAX;\n\
    \    let mut closest_index = -1;\n    for (i, &v) in value.chars().enumerate()\
    \ {\n        let distance = value.len() - i;\n        if distance < closest_distance\
    \ {\n            closest_distance = distance;\n            closest_value = v;\n\
    \            closest_index = i;\n        }\n    }\n    closest_value\n}\n\nfn\
    \ main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp8gm73nsb.rs:25:26\n   |\n25 |     for (i, &v) in value.chars().enumerate()\
    \ {\n   |                          ^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `len` found for type `isize` in the current scope\n  --> /tmp/tmp8gm73nsb.rs:26:30\n\
    \   |\n26 |         let distance = value.len() - i;\n   |                    \
    \          ^^^ method not found in `isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value < 2 {\n        return value;\n    }\n\
    \    let mut closest: isize = 0;\n    let mut closest2 = value;\n    let mut closest3\
    \ = value;\n    let mut closest4 = value;\n    let mut closest5 = value;\n   \
    \ let mut closest6 = value;\n    let mut closest7 = value;\n    let mut closest8\
    \ = value;\n    let mut closest9 = value;\n    let mut closest10 = value;\n  \
    \  let mut closest11 = value;\n    let mut closest12 = value;\n    let mut closest13\
    \ = value;\n    let mut closest14 = value;\n    let mut closest15 = value;\n \
    \   let mut closest16 = value;\n    let mut closest17 = value;\n    let mut closest18\
    \ = value;\n    let mut closest19 = value;\n    let mut closest20 = value;\n \
    \   let mut closest21 = value;\n    let mut closest22 = value;\n    let mut closest23\
    \ = value;\n    let mut closest24 = value;\n    let mut closest25 = value;\n \
    \   let mut closest26 = value;\n    let mut closest27 = value;\n    let mut closest28\
    \ = value;\n    let mut closest29 = value;\n    let mut closest30 = value;\n \
    \   let mut closest31 = value;\n    let mut closest32 = value;\n    let mut closest33\
    \ = value;\n    let mut closest34 = value;\n    let mut closest35 = value;\n \
    \   let mut closest36 = value;\n    let mut closest37 = value;\n    let mut closest38\
    \ = value;\n    let mut closest39 = value;\n    let mut closest40 = value;\n \
    \   let mut closest41 = value;\n    let mut closest42 = value;\n    let mut closest43\
    \ = value;\n    let mut closest44 = value;\n    let mut closest45 = value;\n \
    \   let mut closest46 = value;\n    let mut closest47 = value;\n    let mut closest48\
    \ = value;\n    let mut closest49 = value;\n    let mut closest50 = value;\n \
    \   let mut closest51 = value;\n    let mut closest52 = value;\n    let mut closest53\
    \ = value;\n    let mut closest54 = value;\n    let mut closest55 = value;\n \
    \   let mut closest56 = value;\n    let mut closest57 = value;\n    let mut closest58\
    \ = value;\n    let mut closest59 = value;\n    let mut closest60 = value;\n \
    \   let mut closest61 = value;\n\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptbtx3v7w.rs:14:38\n   |\n\
    14 | fn closest_integer(value: String) -> isize {\n   |    ---------------   \
    \                ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut v = value.parse::<isize>().unwrap();\n    if v < 0 {\n        v = -v;\n\
    \    }\n    v.round()\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp0fz5qo0e.rs:19:7\n   |\n19 |     v.round()\n   |      \
    \ ^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_value\
    \ = value;\n    let mut closest_index = 0;\n    let mut closest_distance = std::f64::MAX;\n\
    \    while closest_value >= 0 {\n        let mut current_distance = std::f64::MAX;\n\
    \        for i in 0..closest_index {\n            let current_value = closest_value\
    \ + i;\n            let current_distance = current_distance + abs(value - current_value);\n\
    \            if current_distance < closest_distance {\n                closest_value\
    \ = current_value;\n                closest_index = i;\n                closest_distance\
    \ = current_distance;\n            }\n        }\n        value = closest_value;\n\
    \    }\n    value\n}\n\nfn main() {\n    let candidate = closest_integer;\n  \
    \  assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmphwalewx_.rs:23:55\n\
    \   |\n23 |             let current_distance = current_distance + abs(value -\
    \ current_value);\n   |                                                      \
    \ ^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest: isize = 0;\n    let mut closest2 = &mut closest;\n    let\
    \ mut closest3 = &mut closest;\n    let mut closest4 = &mut closest;\n    let\
    \ mut closest5 = &mut closest;\n    let mut closest6 = &mut closest;\n    let\
    \ mut closest7 = &mut closest;\n    let mut closest8 = &mut closest;\n    let\
    \ mut closest9 = &mut closest;\n    let mut closest10 = &mut closest;\n    let\
    \ mut closest11 = &mut closest;\n    let mut closest12 = &mut closest;\n    let\
    \ mut closest13 = &mut closest;\n    let mut closest14 = &mut closest;\n    let\
    \ mut closest15 = &mut closest;\n    let mut closest16 = &mut closest;\n    let\
    \ mut closest17 = &mut closest;\n    let mut closest18 = &mut closest;\n    let\
    \ mut closest19 = &mut closest;\n    let mut closest20 = &mut closest;\n    let\
    \ mut closest21 = &mut closest;\n    let mut closest22 = &mut closest;\n    let\
    \ mut closest23 = &mut closest;\n    let mut closest24 = &mut closest;\n    let\
    \ mut closest25 = &mut closest;\n    let mut closest26 = &mut closest;\n    let\
    \ mut closest27 = &mut closest;\n    let mut closest28 = &mut closest;\n    let\
    \ mut closest29 = &mut closest;\n    let mut closest30 = &mut closest;\n    let\
    \ mut closest31 = &mut closest;\n    let mut closest32 = &mut closest;\n    let\
    \ mut closest33 = &mut closest;\n    let mut closest34 = &mut closest;\n    let\
    \ mut closest35 = &mut closest;\n    let mut closest36 = &mut closest;\n    let\
    \ mut closest37 = &mut closest;\n    let mut closest38 = &mut closest;\n    let\
    \ mut closest39 = &mut closest;\n    let mut closest40 = &mut closest;\n    let\
    \ mut closest41 = &mut closest;\n\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps0kxejt7.rs:14:38\n   |\n\
    14 | fn closest_integer(value: String) -> isize {\n   |    ---------------   \
    \                ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n   \
    \ assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpd4nzey58.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest: isize\
    \ = 0;\n    let mut prev_closest = closest;\n    let mut prev_value = value;\n\
    \    while value > closest {\n        prev_closest = closest;\n        prev_value\
    \ = value;\n        closest = (value + closest) / 2;\n    }\n    closest\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut lower = value;\n    let mut upper = value;\n    while lower < upper\
    \ {\n        let mid = lower + (upper - lower) / 2;\n        if mid * mid > value\
    \ {\n            upper = mid;\n        } else {\n            lower = mid;\n  \
    \      }\n    }\n    lower\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpew4do5kq.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  }\n    value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpigv0pu5p.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut lower = value;\n    let mut upper = value;\n\
    \    let mut mid = 0;\n    while lower < upper {\n        mid = lower + (upper\
    \ - lower) / 2;\n        if mid * mid > value {\n            upper = mid;\n  \
    \      } else {\n            lower = mid;\n        }\n    }\n    lower\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpst7352b5.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest: isize\
    \ = 0;\n    let mut closest_distance = std::cmp::max(isize::MIN, isize::MAX);\n\
    \    let mut closest_integer = isize::MIN;\n    let mut closest_integer_distance\
    \ = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_integer = isize::MIN;\n\
    \    let mut closest_integer_distance = std::cmp::max(isize::MIN, isize::MAX);\n\
    \    let mut closest_integer = isize::MIN;\n    let mut closest_integer_distance\
    \ = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_integer = isize::MIN;\n\
    \    let mut closest_integer_distance = std::cmp::max(isize::MIN, isize::MAX);\n\
    \    let mut closest_integer = isize::MIN;\n    let mut closest_integer_distance\
    \ = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_integer = isize::MIN;\n\
    \    let mut closest_integer_distance = std::cmp::max(isize::MIN, isize::MAX);\n\
    \    let mut closest_integer = isize::MIN;\n    let mut closest_integer_distance\
    \ = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_integer = isize::MIN;\n\
    \    let mut closest_integer_distance = std::cmp::max(isize::MIN, isize::MAX);\n\
    \    let mut closest_integer = isize::MIN;\n    let mut closest_integer_distance\
    \ = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_integer = isize::MIN;\n\
    \    let mut closest_integer_distance = std::cmp::max(isize::MIN, isize::MAX);\n\
    \    let mut closest_integer = isize::MIN;\n    let mut closest_integer_distance\
    \ = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_integer = isize::MIN;\n\
    \    let mut closest_integer_distance = std::cmp::max(isize::MIN, isize::MAX);\n\
    \    let mut closest_integer = isize::MIN;\n    let mut closest_integer_distance\
    \ = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_integer = isize::MIN;\n\
    \    let mut closest_integer_distance = std::cmp::max(isize::MIN, isize::MAX);\n\
    \    let mut closest_integer = isize::MIN;\n    let mut closest_integer_distance\
    \ = std::cmp::\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp53tuairs.rs:48:1\n\
    \   |\n48 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmp8k2ok3yo.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round() as isize\n}\n\nfn main() {\n  \
    \  let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpa2kvl7sh.rs:19:11\n   |\n19 |     value.round() as isize\n\
    \   |           ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer\n    };\n    let mut closest_integer\
    \ = if closest_integer < 0 {\n        closest_integer + isize::MAX\n    } else\
    \ {\n        closest_integer\n    };\n    let mut closest_integer = if closest_integer\
    \ < 0 {\n        closest_integer + isize::MAX\n    } else {\n        closest_integer\n\
    \    };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer\n    };\n    let mut closest_integer\
    \ = if closest_integer < 0 {\n        closest_integer + isize::MAX\n    } else\
    \ {\n        closest_integer\n    };\n    let mut closest_integer = if closest_integer\
    \ < 0 {\n        closest_integer + isize::MAX\n    } else {\n        closest_integer\n\
    \    };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer\n    };\n    let mut closest_integer\
    \ = if closest_integer < 0 {\n        closest_integer + isize::MAX\n    } else\
    \ {\n        closest_integer\n    };\n    let mut closest_integer = if closest_integer\
    \ < 0 {\n        closest_integer + isize::MAX\n    } else {\n        closest_integer\n\
    \    };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer\n    };\n    let mut closest_integer\
    \ = if closest_integer < 0 {\n        closest_integer + isize::MAX\n    } else\
    \ {\n        closest_integer\n    };\n    let mut closest_integer = if closest_integer\
    \ < 0 {\n        closest_integer + isize::MAX\n    } else {\n        closest_integer\n\
    \    };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer\n    };\n    let mut closest_integer\
    \ = if closest_integer < 0 {\n        closest_integer + isize::MAX\n    } else\
    \ {\n        closest_integer\n    };\n    let mut closest_integer = if closest_integer\
    \ < 0 {\n        closest_integer + isize::MAX\n    } else {\n        closest_integer\n\
    \    };\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer\n    };\n    let mut closest_integer\
    \ = if closest_integer < 0 {\n        closest_integer + isize::MAX\n    } else\
    \ {\n        closest_\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5pvgpu05.rs:110:3\n\
    \    |\n14  | fn closest_integer(value: String) -> isize {\n    |            \
    \                                - unclosed delimiter\n...\n99  |     } else {\n\
    \    |            - this delimiter might not be properly closed...\n100 |    \
    \     closest_\n101 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n110 | }\n    |   ^\n\nerror: expected one of `.`, `;`, `?`, `else`, or an\
    \ operator, found keyword `fn`\n   --> /tmp/tmp5pvgpu05.rs:103:1\n    |\n101 |\
    \ }\n    |  - expected one of `.`, `;`, `?`, `else`, or an operator\n102 | \n\
    103 | fn main() {\n    | ^^ unexpected token\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n   \
    \ assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp31lm2g68.rs:15:44\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
