name: HumanEval_58_common
language: rust
results:
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        } else {\n            if l3[0]\
    \ == l4[0] {\n                l3.remove(0);\n                l4.remove(0);\n \
    \           } else {\n                l3.remove(0);\n                l4.push(l3.pop());\n\
    \            }\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphx8w9wje.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmphx8w9wje.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmphx8w9wje.rs:22:25\n   |\n22 |  \
    \               l4.push(l3.pop());\n   |                         ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp_58evwar.rs:24:27\n   |\n24 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmp_58evwar.rs:24:41\n\
    \   |\n24 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_58evwar.rs:34:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n34 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmplp10i4x1.rs:24:27\n   |\n24 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmplp10i4x1.rs:24:41\n\
    \   |\n24 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplp10i4x1.rs:34:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n34 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(*l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(*l1.pop());\n    \
    \    } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l1_iter = l1.iter().cloned();\n            let mut l2_iter = l2.iter().cloned();\n\
    \            if l1_iter.next().unwrap() == l2_iter.next().unwrap() {\n       \
    \         l1_iter.next();\n                l2_iter.next();\n                if\
    \ l1_iter.next().unwrap() == l2_iter.next().unwrap() {\n                    l1_iter.next();\n\
    \                    l2_iter.next();\n                    if l1_iter.next().unwrap()\
    \ == l2_iter.next().unwrap() {\n                        l1_iter.next();\n    \
    \                    l2_iter.next();\n                        if l1_iter.next().unwrap()\
    \ == l2_iter.next().unwrap() {\n                            l1_iter.next();\n\
    \                            l2_iter.next();\n                            if l1_iter.next().unwrap()\
    \ == l2_iter.next().unwrap() {\n                                l1_iter.next();\n\
    \                                l2_iter.next();\n                           \
    \     if l1_iter.next().unwrap() == l2_iter.next().unwrap() {\n              \
    \                      l1_iter.next();\n                                    l2_iter.next();\n\
    \                                    if l1_iter.next().unwrap() == l2_iter.next().unwrap()\
    \ {\n                                        l1_iter.next();\n               \
    \                         l2_iter.next();\n                                  \
    \      if l1_iter.next().unwrap() == l2_iter.next().unwrap() {\n             \
    \                               l1_iter.next();\n                            \
    \                l2_iter.next();\n                                           \
    \ if l1_iter.next().unwrap() == l2_iter.next().unwrap() {\n                  \
    \                              l1_iter.next();\n                             \
    \                   l2_iter.next();\n                                        \
    \        if l1_iter.next().unwrap() == l2_iter.next().unwrap() {\n           \
    \                                         l1_iter.next();\n                  \
    \                                  l2_iter.next();\n                         \
    \                           if l1_iter.next().unwrap() == l2_iter.next().unwrap()\
    \ {\n                                                        l1_iter.next();\n\
    \                                                        l2_iter.next();\n   \
    \                                                     if l1_iter.next().unwrap()\
    \ == l2_iter.next().unwrap() {\n                                             \
    \               l1_iter.next();\n                                            \
    \                l2_iter.next();\n                                           \
    \                 if l1_iter.next().unwrap() == l2_iter.next().unwrap() {\n  \
    \                                                              l1_iter.next();\n\
    \                                                                l2_iter.next();\n\
    \                                                                if l1_iter.next().\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpeqwfqhgo.rs:68:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() > 0 || l2.len() > 0 {\n   |                     \
    \                   - unclosed delimiter\n...\n15 |         } else {\n   |   \
    \             - unclosed delimiter\n...\n20 |             if l1_iter.next().unwrap()\
    \ == l2_iter.next().unwrap() {\n   |                                         \
    \                          - unclosed delimiter\n...\n23 |                 if\
    \ l1_iter.next().unwrap() == l2_iter.next().unwrap() {\n   |                 \
    \                                                      - unclosed delimiter\n\
    ...\n26 |                     if l1_iter.next().unwrap() == l2_iter.next().unwrap()\
    \ {\n   |                                                                    \
    \       - unclosed delimiter\n...\n29 |                         if l1_iter.next().unwrap()\
    \ == l2_iter.next().unwrap() {\n   |                                         \
    \                                      - unclosed delimiter\n...\n32 |       \
    \                      if l1_iter.next().unwrap() == l2_iter.next().unwrap() {\n\
    \   |                                                                        \
    \           - unclosed delimiter\n...\n35 |                                 if\
    \ l1_iter.next().unwrap() == l2_iter.next().unwrap() {\n   |                 \
    \                                                                      - unclosed\
    \ delimiter\n...\n38 |                                     if l1_iter.next().unwrap()\
    \ == l2_iter.next().unwrap() {\n   |                                         \
    \                                                  - unclosed delimiter\n...\n\
    41 |                                         if l1_iter.next().unwrap() == l2_iter.next().unwrap()\
    \ {\n   |                                                                    \
    \                           - unclosed delimiter\n...\n44 |                  \
    \                           if l1_it"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    for i in l1.iter().cloned()\
    \ {\n        if l2.iter().any(|&x| x == i) {\n            result.push(i);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpvtttvozn.rs:18:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != l4.len() {\n        if l3[l3.len()\
    \ - 1] < l4[l4.len() - 1] {\n            l3.pop();\n        } else {\n       \
    \     l4.pop();\n        }\n    }\n    l3.sort();\n    l4.sort();\n    l3.dedup();\n\
    \    l4.dedup();\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpdij6o09k.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            if l1[0] < l2[0] {\n   \
    \             l3.push(l1[0]);\n                l1.pop();\n            } else {\n\
    \                l3.push(l2[0]);\n                l2.pop();\n            }\n \
    \       }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpq9_cxllc.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpg6xvog97.rs:6:46\n  |\n6 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------   \
    \                                 ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit\
    \ type `()`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.dedup();\n\
    \    let mut l4 = l2.clone();\n    l4.sort();\n    l4.dedup();\n    l3.iter().zip(l4.iter()).filter(|&(a,\
    \ b)| a == b).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n    --> /tmp/tmpcn4j5639.rs:13:55\n\
    \     |\n13   |     l3.iter().zip(l4.iter()).filter(|&(a, b)| a == b).collect()\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize, &isize)>`\n\
    \     |\n     = help: the trait `FromIterator<(&isize, &isize)>` is not implemented\
    \ for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    let mut result = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n\
    \        if l1.len() == 0 {\n            result.push(l2.pop());\n        } else\
    \ if l2.len() == 0 {\n            result.push(l1.pop());\n        } else {\n \
    \           if l1.len() == l2.len() {\n                if l1.pop() == l2.pop()\
    \ {\n                    result.push(l1.pop());\n                }\n         \
    \   } else {\n                if l1.len() < l2.len() {\n                    result.push(l1.pop());\n\
    \                } else {\n                    result.push(l2.pop());\n      \
    \          }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpau93qllx.rs:29:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n29 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            let mut j = 0;\n            while l1.len() != 0\
    \ || l2.len() != 0 {\n                if l1.len() == 0 {\n                   \
    \ result.push(l2.pop());\n                    i += 1;\n                } else\
    \ if l2.len() == 0 {\n                    result.push(l1.pop());\n           \
    \         j += 1;\n                } else {\n                    if l1.len() ==\
    \ l2.len() {\n                        if l1.len() == 1 {\n                   \
    \         result.push(l1.pop());\n                            i += 1;\n      \
    \                  } else if l2.len() == 1 {\n                            result.push(l2.pop());\n\
    \                            j += 1;\n                        } else {\n     \
    \                       let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                            while l1.len() != l2.len() {\n                  \
    \              result.push(l1.pop());\n                                i += 1;\n\
    \                            }\n                            while l1.len() !=\
    \ 1 {\n                                result.push(l1.pop());\n              \
    \                  i += 1;\n                            }\n                  \
    \          while l2.len() != 1 {\n                                result.push(l2.pop());\n\
    \                                j += 1;\n                            }\n    \
    \                    }\n                    } else {\n                       \
    \ if l1.len() == 1 {\n                            result.push(l1.pop());\n   \
    \                         i += 1;\n                        } else if l2.len()\
    \ == 1 {\n                            result.push(l2.pop());\n               \
    \             j += 1;\n                        } else {\n                    \
    \        let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n              \
    \              let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n        \
    \                    while l1.len() != l2.len() {\n                          \
    \      result.push(l1.pop());\n                                i += 1;\n     \
    \                       }\n                            while l1.len() != 1 {\n\
    \                                result.push(l1.pop());\n                    \
    \            i += 1;\n                            }\n                        \
    \    while l2.len() != 1 {\n                                \n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpp5pc6oqu.rs:79:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n15 |         } else {\n   |\
    \                - unclosed delimiter\n...\n20 |             while l1.len() !=\
    \ 0 || l2.len() != 0 {\n   |                                                 \
    \ - unclosed delimiter\n...\n27 |                 } else {\n   |             \
    \           - unclosed delimiter\n...\n51 |                     } else {\n   |\
    \                            - unclosed delimiter\n...\n58 |                 \
    \        } else {\n   |                                - unclosed delimiter\n\
    ...\n69 |                             while l2.len() != 1 {\n   |            \
    \                                     - this delimiter might not be properly closed...\n\
    70 |                                 \n71 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n79 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp5pc6oqu.rs:10:5\n   |\n6  |   fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \          ---------- expected `Vec<isize>` because of return type\n...\n10 |\
    \ /     while l1.len() != 0 || l2.len() != 0 {\n11 | |         if l1.len() ==\
    \ 0 {\n12 | |             result.push(l2.pop());\n13 | |         } else if l2.len()\
    \ == 0 {\n...  |\n78 | |     assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n79 | | }\n   | |__^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    let mut l1_iter = l1.iter().cloned();\n\
    \    let mut l2_iter = l2.iter().cloned();\n    let mut l1_next = l1.iter().cloned().next();\n\
    \    let mut l2_next = l2.iter().cloned().next();\n    while l1_next && l2_next\
    \ {\n        if l1_next == l2_next {\n            result.push(l1_next.unwrap());\n\
    \            l1_next = l1.iter().cloned().next();\n            l2_next = l2.iter().cloned().next();\n\
    \        } else if l1_next.unwrap() == l2_next.unwrap() {\n            l1_next\
    \ = l1.iter().cloned().next();\n            l2_next = l2.iter().cloned().next();\n\
    \        } else {\n            let mut l1_iter = l1.iter().cloned();\n       \
    \     let mut l2_iter = l2.iter().cloned();\n            while l1_iter.next()\
    \ && l2_iter.next() {\n                if l1_iter.peek().unwrap() == l2_iter.peek().unwrap()\
    \ {\n                    l1_iter = l1.iter().cloned();\n                    l2_iter\
    \ = l2.iter().cloned();\n                } else {\n                    break;\n\
    \                }\n            }\n            if l1_iter.peek().unwrap() == l2_iter.peek().unwrap()\
    \ {\n                l1_next = l1.iter().cloned().next();\n                l2_next\
    \ = l2.iter().cloned().next();\n            } else {\n                l1_next\
    \ = l1.iter().cloned().next();\n                l2_next = l2.iter().cloned().next();\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpndxu1w3w.rs:12:11\n   |\n\
    12 |     while l1_next && l2_next {\n   |           ^^^^^^^ expected `bool`, found\
    \ enum `Option`\n   |\n   = note: expected type `bool`\n              found enum\
    \ `Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpndxu1w3w.rs:12:22\n\
    \   |\n12 |     while l1_next && l2_next {\n   |                      ^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpndxu1w3w.rs:23:19\n   |\n23 |             while l1_iter.next()\
    \ && l2_iter.next() {\n   |                   ^^^^^^^^^^^^^^ expected `bool`,\
    \ found enum `Option`\n   |\n   = note: expected type `bool`\n              found\
    \ enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpndxu1w3w.rs:23:37\n\
    \   |\n23 |             while l1_iter.next() && l2_iter.next() {\n   |       \
    \                              ^^^^^^^^^^^^^^ expected `bool`, found enum `Option`\n\
    \   |\n   = note: expected type `bool`\n              found enum `Option<isize>`\n\
    \nerror[E0599]: no method named `peek` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpndxu1w3w.rs:24:28\n   |\n24 |                 if l1_iter.peek().unwrap()\
    \ == l2_iter.peek().unwrap() {\n   |                            ^^^^ method not\
    \ found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `Cloned` in the current scope\n  --> /tmp/tmpndxu1w3w.rs:24:55\n\
    \   |\n24 |                 if l1_iter.peek().unwrap() == l2_iter.peek().unwrap()\
    \ {\n   |                                                       ^^^^ method not\
    \ found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `Cloned` in the current scope\n  --> /tmp/tmpndxu1w3w.rs:31:24\n\
    \   |\n31 |             if l1_iter.peek().unwrap() == l2_iter.peek().unwrap()\
    \ {\n   |                        ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `peek` found for struct `Cloned` in\
    \ the cu"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(0);\n            l4.push(0);\n\
    \        }\n        if l4.len() == 0 {\n            l4.push(0);\n            l3.push(0);\n\
    \        }\n        if l3[0] < l4[0] {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            l3.pop();\n            l4.pop();\n        }\n \
    \   }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmplcts_hsr.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                l3_el\
    \ = l1_el;\n                l1_el = l1.pop();\n                l2_el = l2.pop();\n\
    \            }\n            l3.push(l3_el);\n        }\n    }\n    l3\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `l3_el` in this scope\n  --> /tmp/tmp4n5s6wka.rs:19:17\n\
    \   |\n19 |                 l3_el = l1_el;\n   |                 ^^^^^ help: a\
    \ local variable with a similar name exists: `l1_el`\n\nerror[E0425]: cannot find\
    \ value `l3_el` in this scope\n  --> /tmp/tmp4n5s6wka.rs:23:21\n   |\n23 |   \
    \          l3.push(l3_el);\n   |                     ^^^^^ help: a local variable\
    \ with a similar name exists: `l1_el`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4n5s6wka.rs:26:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n26 |     l3\n   |     ^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpoju5jnxp.rs:24:27\n   |\n24 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpoju5jnxp.rs:24:41\n\
    \   |\n24 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoju5jnxp.rs:34:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n34 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > i && l2.len() > i {\n        \
    \        if l1[i] < l2[i] {\n                    result.push(l1.pop());\n    \
    \            } else {\n                    result.push(l2.pop());\n          \
    \      }\n                i += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpca1vh1c6.rs:29:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n29 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    let mut l3 = l1.clone();\n    let mut l4 = l2.clone();\n    while l3.len()\
    \ > 0 || l4.len() > 0 {\n        if l3.len() == 0 {\n            l3.push(0);\n\
    \            l4.push(0);\n        }\n        if l4.len() == 0 {\n            l3.push(0);\n\
    \            l4.push(0);\n        }\n        let mut l3_iter = l3.iter();\n  \
    \      let mut l4_iter = l4.iter();\n        if l3_iter.next().unwrap() != l4_iter.next().unwrap()\
    \ {\n            l3.push(0);\n            l4.push(0);\n        }\n        if l3_iter.next().unwrap()\
    \ == l4_iter.next().unwrap() {\n            l3.push(l3_iter.next().unwrap());\n\
    \            l4.push(l4_iter.next().unwrap());\n        }\n    }\n    l3\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2jd_b_1_.rs:27:21\n   |\n\
    27 |             l3.push(l3_iter.next().unwrap());\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n27 |             l3.push(*l3_iter.next().unwrap());\n   |             \
    \        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2jd_b_1_.rs:28:21\n\
    \   |\n28 |             l4.push(l4_iter.next().unwrap());\n   |              \
    \       ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n28 |             l4.push(*l4_iter.next().unwrap());\n\
    \   |                     +\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.len() == l2.len() {\n                        if l1.len()\
    \ == 1 {\n                            result.push(l1.pop());\n               \
    \         } else {\n                            result.push(l1.pop());\n     \
    \                       result.push(l2.pop());\n                        }\n  \
    \                  } else {\n                        if l1.len() > l2.len() {\n\
    \                            result.push(l1.pop());\n                        }\
    \ else {\n                            result.push(l2.pop());\n               \
    \         }\n                    }\n                }\n            }\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp65ocpshz.rs:42:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n42 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    }\n        if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        }\n        if l1.len() == 0 && l2.len() == 0 {\n            break;\n\
    \        }\n        if l1.len() == 1 {\n            if l2.len() == 1 {\n     \
    \           l3.pop();\n                l4.pop();\n            } else {\n     \
    \           l3.pop();\n            }\n        }\n        if l2.len() == 1 {\n\
    \            if l1.len() == 1 {\n                l3.pop();\n                l4.pop();\n\
    \            } else {\n                l3.pop();\n            }\n        }\n \
    \       if l1.len() == l2.len() {\n            let mut i = 0;\n            while\
    \ i < l1.len() {\n                if l1[i] != l2[i] {\n                    break;\n\
    \                }\n                i += 1;\n            }\n            l3.pop();\n\
    \            l4.pop();\n        }\n    }\n    l3.into_iter().collect()\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l2.pop();\n        } else if l2.len() == 0 {\n            l1.pop();\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                l1_el\
    \ = l1.pop();\n                l2_el = l2.pop();\n            }\n            result.push(l1_el);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpglfyva0o.rs:25:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.front() == l2.front() {\n               \
    \ l3.push(l1.pop());\n                l1.pop();\n            } else {\n      \
    \          l3.push(l1.pop());\n                l2.pop();\n            }\n    \
    \    }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpo6dom45n.rs:16:19\n   |\n16 |             if\
    \ l1.front() == l2.front() {\n   |                   ^^^^^ method not found in\
    \ `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpo6dom45n.rs:16:33\n   |\n16 |          \
    \   if l1.front() == l2.front() {\n   |                                 ^^^^^\
    \ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo6dom45n.rs:25:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n25 |     l3\n   |     ^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    let mut l4 =\
    \ l2.clone();\n    l4.sort();\n    let mut l5 = l3.clone();\n    l5.sort();\n\
    \    let mut l6 = l4.clone();\n    l6.sort();\n    let mut l7 = l5.clone();\n\
    \    l7.sort();\n    let mut l8 = l6.clone();\n    l8.sort();\n    let mut l9\
    \ = l7.clone();\n    l9.sort();\n    let mut l10 = l8.clone();\n    l10.sort();\n\
    \    let mut l11 = l9.clone();\n    l11.sort();\n    let mut l12 = l10.clone();\n\
    \    l12.sort();\n    let mut l13 = l11.clone();\n    l13.sort();\n    let mut\
    \ l14 = l12.clone();\n    l14.sort();\n    let mut l15 = l13.clone();\n    l15.sort();\n\
    \    let mut l16 = l14.clone();\n    l16.sort();\n    let mut l17 = l15.clone();\n\
    \    l17.sort();\n    let mut l18 = l16.clone();\n    l18.sort();\n    let mut\
    \ l19 = l17.clone();\n    l19.sort();\n    let mut l20 = l18.clone();\n    l20.sort();\n\
    \    let mut l21 = l19.clone();\n    l21.sort();\n    let mut l22 = l20.clone();\n\
    \    l22.sort();\n    let mut l23 = l21.clone();\n    l23.sort();\n    let mut\
    \ l24 = l22.clone();\n    l24.sort();\n    let mut l25 = l23.clone();\n    l25.sort();\n\
    \    let mut l26 = l24.clone();\n    l26.sort();\n    let mut l27 = l25.clone();\n\
    \    l27.sort();\n    let mut l28 = l26.clone();\n    l28.sort();\n    let mut\
    \ l29 = l27.clone();\n    l29.sort();\n    let mut l30 = l28.clone();\n    l30.sort();\n\
    \    let mut l31 = l29.clone();\n    l31.sort();\n    let mut l32 = l30.clone();\n\
    \    l32.sort();\n    let mut l33 = l31.clone();\n    l33.sort();\n    let mut\
    \ l34 = l32.clone();\n    l34.sort();\n    let mut l35 = l33.clone();\n    l35.sort();\n\
    \    let mut l36 = l34.clone();\n    l36.sort();\n    let mut l37 = l35.clone();\n\
    \    l37.sort\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `sort` on type `Vec<isize>`\n\
    \  --> /tmp/tmp6bivylle.rs:76:9\n   |\n76 |     l37.sort\n   |         ^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n76 |    \
    \ l37.sort()\n   |             ++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.ded\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `ded` on type `Vec<isize>`\n  --> /tmp/tmpx2ulou08.rs:99:8\n\
    \   |\n99 |     l3.ded\n   |        ^^^ unknown field\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0609`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(0);\n            l4.push(0);\n\
    \        }\n        if l4.len() == 0 {\n            l4.push(0);\n            l3.push(0);\n\
    \        }\n        if l3[0] == l2[0] {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            l3.pop();\n            l4.pop();\n        }\n \
    \   }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpvqrlxnzx.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    }\n        if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        }\n        if l1.len() == 0 && l2.len() == 0 {\n            break;\n\
    \        }\n        if l1.len() == 1 {\n            if l2.len() == 1 {\n     \
    \           l3.pop();\n                l4.pop();\n            } else {\n     \
    \           l3.pop();\n            }\n        } else if l2.len() == 1 {\n    \
    \        l3.pop();\n            l4.pop();\n        } else {\n            let mut\
    \ l5 = l1.clone();\n            let mut l6 = l2.clone();\n            while l5.len()\
    \ != 0 || l6.len() != 0 {\n                if l5.len() == 0 {\n              \
    \      l6.pop();\n                    l5.pop();\n                }\n         \
    \       if l6.len() == 0 {\n                    l5.pop();\n                  \
    \  l6.pop();\n                }\n                if l5.len() == 1 && l6.len()\
    \ == 1 {\n                    l3.pop();\n                    l4.pop();\n     \
    \               break;\n                }\n                if l5.len() == 1 {\n\
    \                    l6.pop();\n                } else {\n                   \
    \ l5.pop();\n                }\n            }\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        let mut found = false;\n        if l1.len()\
    \ != 0 {\n            if l2.len() != 0 {\n                if l1.pop().unwrap()\
    \ == l2.pop().unwrap() {\n                    found = true;\n                }\n\
    \            } else {\n                found = true;\n            }\n        }\n\
    \        if !found {\n            result.push(*l1.pop());\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp3xwkueke.rs:22:25\n\
    \   |\n22 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0 {\n      \
    \          if l1.len() == 0 {\n                    result.push(l2.pop());\n  \
    \              } else if l2.len() == 0 {\n                    result.push(l1.pop());\n\
    \                } else {\n                    if l1.len() == l2.len() {\n   \
    \                     if l1.len() == 1 {\n                            result.push(l1.pop());\n\
    \                        } else {\n                            result.push(l1.pop());\n\
    \                            result.push(l2.pop());\n                        }\n\
    \                    } else if l1.len() < l2.len() {\n                       \
    \ result.push(l1.pop());\n                    } else {\n                     \
    \   result.push(l2.pop());\n                    }\n                }\n       \
    \         i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmc07n34p.rs:42:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n42 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != l4.len() {\n        if l3[l3.len()\
    \ - 1] > l4[l4.len() - 1] {\n            l3.pop();\n            l4.pop();\n  \
    \      } else {\n            l3.pop();\n            l4.pop();\n        }\n   \
    \ }\n    l3.sort();\n    l4.sort();\n    l3.dedup();\n    l4.dedup();\n    l3\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpwbu0io3p.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    let mut l4 =\
    \ l2.clone();\n    l4.sort();\n    while l3.len() != l4.len() {\n        if l3[0]\
    \ != l4[0] {\n            break;\n        }\n        l3.remove(0);\n        l4.remove(0);\n\
    \    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmprgvt6q2s.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut common = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l2.pop();\n        } else if l2.len() == 0 {\n            l1.pop();\n \
    \       } else {\n            let mut l1_el = l1.pop();\n            let mut l2_el\
    \ = l2.pop();\n            while l1_el == l2_el {\n                common.push(l1_el);\n\
    \                l1_el = l1.pop();\n                l2_el = l2.pop();\n      \
    \      }\n        }\n    }\n    common\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpza3thchp.rs:25:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     common\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    let mut result = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n    \
    \    if l1.len() == 0 {\n            l2.pop();\n        } else if l2.len() ==\
    \ 0 {\n            l1.pop();\n        } else {\n            let mut i = 0;\n \
    \           let mut j = 0;\n            while i < l1.len() && j < l2.len() {\n\
    \                if l1[i] == l2[j] {\n                    i += 1;\n          \
    \          j += 1;\n                } else {\n                    break;\n   \
    \             }\n            }\n            result.push(l1[i]);\n            l1.pop();\n\
    \            l2.pop();\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpmnqqzwpe.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            if l1[0] < l2[0] {\n   \
    \             l3.push(l1[0]);\n                l1.pop();\n            } else {\n\
    \                l3.push(l2[0]);\n                l2.pop();\n            }\n \
    \       }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpomgxy3oq.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        } else {\n            if l3[0]\
    \ < l4[0] {\n                l3.push(l4.pop());\n            } else {\n      \
    \          l4.push(l3.pop());\n            }\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpewzpfpn8.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpewzpfpn8.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpewzpfpn8.rs:18:25\n   |\n18 |  \
    \               l3.push(l4.pop());\n   |                         ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpewzpfpn8.rs:20:25\n   |\n20 |                 l4.push(l3.pop());\n \
    \  |                         ^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        let mut i = 0;\n        while\
    \ l1.len() != 0 && l2.len() != 0 {\n            if l1[0] > l2[0] {\n         \
    \       result.push(l1[0]);\n                l1.remove(0);\n            } else\
    \ {\n                result.push(l2[0]);\n                l2.remove(0);\n    \
    \        }\n            i += 1;\n        }\n        if l1.len() != 0 {\n     \
    \       result.push(l1[0]);\n            l1.remove(0);\n        }\n        if\
    \ l2.len() != 0 {\n            result.push(l2[0]);\n            l2.remove(0);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 7, 1, 5, 9, 653, 121, 1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmp1q19i1vj.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    l1.sort();\n    l2.sort();\n\
    \    let mut l3 = l1.clone();\n    let mut l4 = l2.clone();\n    while l3.len()\
    \ != 0 || l4.len() != 0 {\n        if l3.len() == 0 {\n            l3.push(l4.pop());\n\
    \        } else if l4.len() == 0 {\n            l4.push(l3.pop());\n        }\n\
    \        if l3[0] == l4[0] {\n            l3.remove(0);\n            l4.remove(0);\n\
    \        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7s8n6lnz.rs:15:21\n   |\n\
    15 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7s8n6lnz.rs:17:21\n   |\n17 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut i = 0;\n    while\
    \ i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n            result.push(l1[i]);\n\
    \            i += 1;\n        } else {\n            if l1[i] > l2[i] {\n     \
    \           i += 1;\n            } else {\n                i += 1;\n         \
    \   }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmp0ivu0tbs.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        let mut i = 0;\n        let mut j = 0;\n  \
    \      while l1.len() != 0 || l2.len() != 0 {\n            if l1.len() != 0 {\n\
    \                if l2.len() != 0 {\n                    if l1[i] < l2[j] {\n\
    \                        result.push(l1[i]);\n                        l1.remove(&mut\
    \ i);\n                    } else {\n                        result.push(l2[j]);\n\
    \                        l2.remove(&mut j);\n                    }\n         \
    \       } else {\n                    result.push(l1[i]);\n                  \
    \  l1.remove(&mut i);\n                }\n            } else {\n             \
    \   if l2.len() != 0 {\n                    result.push(l2[j]);\n            \
    \        l2.remove(&mut j);\n                } else {\n                    break;\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbu9k4v0v.rs:18:35\n   |\n\
    18 |                         l1.remove(&mut i);\n   |                        \
    \           ^^^^^^ expected `usize`, found `&mut usize`\n   |\nhelp: consider\
    \ removing the borrow\n   |\n18 -                         l1.remove(&mut i);\n\
    18 +                         l1.remove(i);\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbu9k4v0v.rs:21:35\n   |\n21 |                         l2.remove(&mut\
    \ j);\n   |                                   ^^^^^^ expected `usize`, found `&mut\
    \ usize`\n   |\nhelp: consider removing the borrow\n   |\n21 -               \
    \          l2.remove(&mut j);\n21 +                         l2.remove(j);\n  \
    \ | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbu9k4v0v.rs:25:31\n   |\n\
    25 |                     l1.remove(&mut i);\n   |                            \
    \   ^^^^^^ expected `usize`, found `&mut usize`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n25 -                     l1.remove(&mut i);\n25 +        \
    \             l1.remove(i);\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbu9k4v0v.rs:30:31\n\
    \   |\n30 |                     l2.remove(&mut j);\n   |                     \
    \          ^^^^^^ expected `usize`, found `&mut usize`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n30 -                     l2.remove(&mut j);\n30 +        \
    \             l2.remove(j);\n   | \n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > i && l2.len() > i {\n        \
    \        if l1[i] < l2[i] {\n                    result.push(l1.pop());\n    \
    \            } else {\n                    result.push(l2.pop());\n          \
    \      }\n                i += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps1jbbvaq.rs:29:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n29 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpvm382yv5.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    let mut l4 =\
    \ l2.clone();\n    l4.sort();\n    while l3.len() != l4.len() {\n        if l3[0]\
    \ != l4[0] {\n            break;\n        }\n        l3.remove(0);\n        l4.remove(0);\n\
    \    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpnq2ub32d.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut common = Vec::new();\n    while l1.len()\
    \ > 0 && l2.len() > 0 {\n        if l1[0] < l2[0] {\n            common.resize(common.len()\
    \ + 1);\n            common.push(l1[0]);\n            l1.remove(0);\n        }\
    \ else {\n            common.resize(common.len() + 1);\n            common.push(l2[0]);\n\
    \            l2.remove(0);\n        }\n    }\n    common\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpuui4s4_s.rs:14:20\n     |\n14   |             common.resize(common.len()\
    \ + 1);\n     |                    ^^^^^^ ---------------- supplied 1 argument\n\
    \     |                    |\n     |                    expected 2 arguments\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 2 arguments but 1 argument was supplied\n    --> /tmp/tmpuui4s4_s.rs:18:20\n\
    \     |\n18   |             common.resize(common.len() + 1);\n     |         \
    \           ^^^^^^ ---------------- supplied 1 argument\n     |              \
    \      |\n     |                    expected 2 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            let mut j = 0;\n            while l1.len() > 0\
    \ && l2.len() > 0 {\n                if l1[0] > l2[0] {\n                    result.push(l1.pop());\n\
    \                } else {\n                    result.push(l2.pop());\n      \
    \          }\n                i += 1;\n                j += 1;\n            }\n\
    \            while l1.len() > 0 {\n                result.push(l1.pop());\n  \
    \              i += 1;\n            }\n            while l2.len() > 0 {\n    \
    \            result.push(l2.pop());\n                j += 1;\n            }\n\
    \            if i != j {\n                result.push(i);\n            }\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n  \
    \  assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe036i6b_.rs:38:29\n   |\n\
    38 |                 result.push(i);\n   |                             ^ expected\
    \ enum `Option`, found integer\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n38 |                 result.push(Some(i));\n   |                      \
    \       +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe036i6b_.rs:42:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n42 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<Option<isize>>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            if l1[0] < l2[0] {\n   \
    \             l3.push(l1[0]);\n                l1.pop();\n            } else {\n\
    \                l3.push(l2[0]);\n                l2.pop();\n            }\n \
    \       }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpe665wr5r.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    let mut l4 =\
    \ l2.clone();\n    l4.sort();\n    let mut l5 = l3.clone();\n    l5.sort();\n\
    \    let mut l6 = l4.clone();\n    l6.sort();\n    let mut l7 = l5.clone();\n\
    \    l7.sort();\n    let mut l8 = l6.clone();\n    l8.sort();\n    let mut l9\
    \ = l7.clone();\n    l9.sort();\n    let mut l10 = l8.clone();\n    l10.sort();\n\
    \    let mut l11 = l9.clone();\n    l11.sort();\n    let mut l12 = l10.clone();\n\
    \    l12.sort();\n    let mut l13 = l11.clone();\n    l13.sort();\n    let mut\
    \ l14 = l12.clone();\n    l14.sort();\n    let mut l15 = l13.clone();\n    l15.sort();\n\
    \    let mut l16 = l14.clone();\n    l16.sort();\n    let mut l17 = l15.clone();\n\
    \    l17.sort();\n    let mut l18 = l16.clone();\n    l18.sort();\n    let mut\
    \ l19 = l17.clone();\n    l19.sort();\n    let mut l20 = l18.clone();\n    l20.sort();\n\
    \    let mut l21 = l19.clone();\n    l21.sort();\n    let mut l22 = l20.clone();\n\
    \    l22.sort();\n    let mut l23 = l21.clone();\n    l23.sort();\n    let mut\
    \ l24 = l22.clone();\n    l24.sort();\n    let mut l25 = l23.clone();\n    l25.sort();\n\
    \    let mut l26 = l24.clone();\n    l26.sort();\n    let mut l27 = l25.clone();\n\
    \    l27.sort();\n    let mut l28 = l26.clone();\n    l28.sort();\n    let mut\
    \ l29 = l27.clone();\n    l29.sort();\n    let mut l30 = l28.clone();\n    l30.sort();\n\
    \    let mut l31 = l29.clone();\n    l31.sort();\n    let mut l32 = l30.clone();\n\
    \    l32.sort();\n    let mut l33 = l31.clone();\n    l33.sort();\n    let mut\
    \ l34 = l32.clone();\n    l34.sort();\n    let mut l35 = l33.clone();\n    l35.sort();\n\
    \    let mut l36 = l34.clone();\n    l36.sort();\n    let mut l37 = l35.clone();\n\
    \    l37.sort\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `sort` on type `Vec<isize>`\n\
    \  --> /tmp/tmp7v27z9dx.rs:76:9\n   |\n76 |     l37.sort\n   |         ^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n76 |    \
    \ l37.sort()\n   |             ++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    for i in l1.iter().cloned()\
    \ {\n        if l2.iter().any(|&x| x == i) {\n            result.push(i);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpv_8i7vt7.rs:18:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpxbo66lkw.rs:19:23\n   |\n19 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpxbo66lkw.rs:19:37\n   |\n19\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxbo66lkw.rs:30:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    let mut l4 =\
    \ l2.clone();\n    l4.sort();\n    let mut l5 = l3.clone();\n    l5.sort();\n\
    \    let mut l6 = l4.clone();\n    l6.sort();\n    let mut l7 = l5.clone();\n\
    \    l7.sort();\n    let mut l8 = l6.clone();\n    l8.sort();\n    let mut l9\
    \ = l7.clone();\n    l9.sort();\n    let mut l10 = l8.clone();\n    l10.sort();\n\
    \    let mut l11 = l9.clone();\n    l11.sort();\n    let mut l12 = l10.clone();\n\
    \    l12.sort();\n    let mut l13 = l11.clone();\n    l13.sort();\n    let mut\
    \ l14 = l12.clone();\n    l14.sort();\n    let mut l15 = l13.clone();\n    l15.sort();\n\
    \    let mut l16 = l14.clone();\n    l16.sort();\n    let mut l17 = l15.clone();\n\
    \    l17.sort();\n    let mut l18 = l16.clone();\n    l18.sort();\n    let mut\
    \ l19 = l17.clone();\n    l19.sort();\n    let mut l20 = l18.clone();\n    l20.sort();\n\
    \    let mut l21 = l19.clone();\n    l21.sort();\n    let mut l22 = l20.clone();\n\
    \    l22.sort();\n    let mut l23 = l21.clone();\n    l23.sort();\n    let mut\
    \ l24 = l22.clone();\n    l24.sort();\n    let mut l25 = l23.clone();\n    l25.sort();\n\
    \    let mut l26 = l24.clone();\n    l26.sort();\n    let mut l27 = l25.clone();\n\
    \    l27.sort();\n    let mut l28 = l26.clone();\n    l28.sort();\n    let mut\
    \ l29 = l27.clone();\n    l29.sort();\n    let mut l30 = l28.clone();\n    l30.sort();\n\
    \    let mut l31 = l29.clone();\n    l31.sort();\n    let mut l32 = l30.clone();\n\
    \    l32.sort();\n    let mut l33 = l31.clone();\n    l33.sort();\n    let mut\
    \ l34 = l32.clone();\n    l34.sort();\n    let mut l35 = l33.clone();\n    l35.sort();\n\
    \    let mut l36 = l34.clone();\n    l36.sort();\n    let mut l37 = l35.clone();\n\
    \    l37.sort\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `sort` on type `Vec<isize>`\n\
    \  --> /tmp/tmp9p_b6ul9.rs:76:9\n   |\n76 |     l37.sort\n   |         ^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n76 |    \
    \ l37.sort()\n   |             ++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    for i in l1.iter().cloned().chain(l2.iter().cloned())\
    \ {\n        if result.iter().any(|&x| x == i) {\n            continue;\n    \
    \    }\n        result.push(i);\n    }\n    result.sort_unstable();\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 7, 9, 34, 121, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpvvuwzzgm.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(*l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(*l1.pop());\n    \
    \    } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2\
    \ = l2.iter().cloned().collect::<Vec<_>>();\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2\
    \ = l2.iter().cloned().collect::<Vec<_>>();\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2\
    \ = l2.iter().cloned().collect::<Vec<_>>();\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2\
    \ = l2.iter().cloned().collect::<Vec<_>>();\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2\
    \ = l2.iter().cloned().collect::<Vec<_>>();\n            let mut l1 = l1.iter().cloned().collect::<Vec<_\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1bjpr81f.rs:45:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() > 0 || l2.len() > 0 {\n   |                     \
    \                   - unclosed delimiter\n...\n15 |         } else {\n   |   \
    \             - this delimiter might not be properly closed...\n...\n37 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n45 | }\n\
    \   |   ^\n\nerror: expected one of `,`, `:`, `=`, or `>`, found `}`\n  --> /tmp/tmp1bjpr81f.rs:37:1\n\
    \   |\n36 |             let mut l1 = l1.iter().cloned().collect::<Vec<_\n   |\
    \                                                            - expected one of\
    \ `,`, `:`, `=`, or `>`\n37 | }\n   | ^ unexpected token\n   |\nhelp: you might\
    \ have meant to end the type parameters here\n   |\n36 |             let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>\n   |                                \
    \                            +\n\nerror[E0614]: type `Option<isize>` cannot be\
    \ dereferenced\n  --> /tmp/tmp1bjpr81f.rs:12:25\n   |\n12 |             result.push(*l2.pop());\n\
    \   |                         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp1bjpr81f.rs:14:25\n   |\n14 |        \
    \     result.push(*l1.pop());\n   |                         ^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1bjpr81f.rs:10:5\n   |\n6  |   fn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |                          \
    \                      ---------- expected `Vec<isize>` because of return type\n\
    ...\n10 | /     while l1.len() > 0 || l2.len() > 0 {\n11 | |         if l1.len()\
    \ == 0 {\n12 | |             result.push(*l2.pop());\n13 | |         } else if\
    \ l2.len() == 0 {\n...  |\n44 | |     assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n45 | | }\n   | |__^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 5 pr"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            let mut l3_iter = l3.iter_mut();\n\
    \            let mut l3_iter2 = l3.iter_mut();\n            let mut l3_iter3 =\
    \ l3.iter_mut();\n            let mut l3_iter4 = l3.iter_mut();\n            let\
    \ mut l3_iter5 = l3.iter_mut();\n            let mut l3_iter6 = l3.iter_mut();\n\
    \            let mut l3_iter7 = l3.iter_mut();\n            let mut l3_iter8 =\
    \ l3.iter_mut();\n            let mut l3_iter9 = l3.iter_mut();\n            let\
    \ mut l3_iter10 = l3.iter_mut();\n            let mut l3_iter11 = l3.iter_mut();\n\
    \            let mut l3_iter12 = l3.iter_mut();\n            let mut l3_iter13\
    \ = l3.iter_mut();\n            let mut l3_iter14 = l3.iter_mut();\n         \
    \   let mut l3_iter15 = l3.iter_mut();\n            let mut l3_iter16 = l3.iter_mut();\n\
    \            let mut l3_iter17 = l3.iter_mut();\n            let mut l3_iter18\
    \ = l3.iter_mut();\n            let mut l3_iter19 = l3.iter_mut();\n         \
    \   let mut l3_iter20 = l3.iter_mut();\n            let mut l3_iter21 = l3.iter_mut();\n\
    \            let mut l3_iter22 = l3.iter_mut();\n            let mut l3_iter23\
    \ = l3.iter_mut();\n            let mut l3_iter24 = l3.iter_mut();\n         \
    \   let mut l3_iter25 = l3.iter_mut();\n            let mut l3_iter26 = l3.iter_mut();\n\
    \            let mut l3_iter27 = l3.iter_mut();\n            let mut l3_iter28\
    \ = l3.iter_mut();\n            let mut l3_iter29 = l3.iter\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpkry5wx7w.rs:57:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n12 |     while l1.len() > 0 || l2.len() > 0 {\n   |                     \
    \                   - unclosed delimiter\n...\n19 |         } else {\n   |   \
    \             - this delimiter might not be properly closed...\n...\n49 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n57 | }\n\
    \   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpkry5wx7w.rs:48:40\n\
    \   |\n48 |             let mut l3_iter29 = l3.iter\n   |                    \
    \                    ^ help: add `;` here\n49 | }\n   | - unexpected token\n\n\
    error[E0615]: attempted to take value of method `iter` on type `Vec<isize>`\n\
    \  --> /tmp/tmpkry5wx7w.rs:48:36\n   |\n48 |             let mut l3_iter29 = l3.iter\n\
    \   |                                    ^^^^ method, not a field\n   |\nhelp:\
    \ use parentheses to call the method\n   |\n48 |             let mut l3_iter29\
    \ = l3.iter()\n   |                                        ++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkry5wx7w.rs:12:5\n   |\n6  |   fn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |                          \
    \                      ---------- expected `Vec<isize>` because of return type\n\
    ...\n12 | /     while l1.len() > 0 || l2.len() > 0 {\n13 | |         if l1.len()\
    \ == 0 {\n14 | |             l3.push(l2[0]);\n15 | |             l2.pop();\n...\
    \  |\n56 | |     assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n57 | | }\n   | |__^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0615.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1[0] < l2[0] {\n                    result.push(l1.pop());\n    \
    \            } else {\n                    result.push(l2.pop());\n          \
    \      }\n                i += 1;\n            }\n            while l1.len() >\
    \ 0 {\n                result.push(l1.pop());\n                i += 1;\n     \
    \       }\n            while l2.len() > 0 {\n                result.push(l2.pop());\n\
    \                i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp59thm891.rs:37:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n37 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() > 0 || l4.len() > 0 {\n    \
    \    if l3.len() > 0 && l4.len() > 0 {\n            if l3[0] == l4[0] {\n    \
    \            l3.remove(0);\n                l4.remove(0);\n            }\n   \
    \     }\n        if l3.len() > 0 {\n            l3.remove(0);\n        }\n   \
    \     if l4.len() > 0 {\n            l4.remove(0);\n        }\n    }\n    l1.extend(l2);\n\
    \    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5, 5, 7, 1, 5, 9, 653, 121]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmpw2ifvvkv.rs:31:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > i && l2.len() > i {\n        \
    \        if l1[i] < l2[i] {\n                    result.push(l1.pop());\n    \
    \            } else {\n                    result.push(l2.pop());\n          \
    \      }\n                i += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpje2kln1n.rs:29:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n29 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    let mut l3 = l1.clone();\n    let mut l4 = l2.clone();\n    while l3.len()\
    \ > 0 || l4.len() > 0 {\n        if l3.len() == 0 {\n            l3.pop();\n \
    \       }\n        if l4.len() == 0 {\n            l4.pop();\n        }\n    \
    \    if l3[0] == l4[0] {\n            l3.pop();\n            l4.pop();\n     \
    \   } else {\n            l3.pop();\n            l4.pop();\n        }\n    }\n\
    \    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmp_2aanbgu.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.ded\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `ded` on type `Vec<isize>`\n  --> /tmp/tmpdrfhr0mf.rs:99:8\n\
    \   |\n99 |     l3.ded\n   |        ^^^ unknown field\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0609`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 && l1.front()\
    \ == l2.front() {\n                l1.pop();\n                l2.pop();\n    \
    \            i += 1;\n            }\n            result.push(l1.pop());\n    \
    \        result.push(l2.pop());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpz68vp6oy.rs:19:54\n   |\n19 |             while\
    \ l1.len() > 0 && l2.len() > 0 && l1.front() == l2.front() {\n   |           \
    \                                           ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpz68vp6oy.rs:19:68\n   |\n19 |             while l1.len()\
    \ > 0 && l2.len() > 0 && l1.front() == l2.front() {\n   |                    \
    \                                                ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpz68vp6oy.rs:28:5\n   |\n6  | fn\
    \ common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |               \
    \                               ---------- expected `Vec<isize>` because of return\
    \ type\n...\n28 |     result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut k = 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j]\
    \ {\n            i += 1;\n            j += 1;\n        } else {\n            if\
    \ l1[i] < l2[j] {\n                i += 1;\n            } else {\n           \
    \     j += 1;\n            }\n        }\n    }\n    l1.truncate(i);\n    l2.truncate(j);\n\
    \    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpxuqa9z5b.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    let mut l3 = l2.clone();\n\
    \    let mut l4 = l1.clone();\n    let mut l5 = l2.clone();\n    while l4.len()\
    \ != 0 || l5.len() != 0 {\n        if l4.len() == 0 {\n            l4.push(0);\n\
    \            l5.push(0);\n        }\n        if l5.len() == 0 {\n            l5.push(0);\n\
    \            l4.push(0);\n        }\n        if l4[0] == l5[0] {\n           \
    \ result.push(l4[0]);\n            l4.remove(0);\n            l5.remove(0);\n\
    \        }\n        else {\n            let mut l6 = l4.clone();\n           \
    \ let mut l7 = l5.clone();\n            while l6.len() != 0 || l7.len() != 0 {\n\
    \                if l6.len() == 0 {\n                    l6.push(0);\n       \
    \             l7.push(0);\n                }\n                if l7.len() == 0\
    \ {\n                    l7.push(0);\n                    l6.push(0);\n      \
    \          }\n                if l6[0] == l7[0] {\n                    result.push(l6[0]);\n\
    \                    l6.remove(0);\n                    l7.remove(0);\n      \
    \          }\n                else {\n                    if l6[0] < l7[0] {\n\
    \                        l6.push(0);\n                    }\n                \
    \    else {\n                        l7.push(0);\n                    }\n    \
    \            }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        let mut i = 0;\n        while l1.len() > 0 &&\
    \ l2.len() > 0 {\n            if l1[0] < l2[0] {\n                result.push(l1[0]);\n\
    \                l1.remove(0);\n            } else {\n                result.push(l2[0]);\n\
    \                l2.remove(0);\n            }\n            i += 1;\n        }\n\
    \        if l1.len() > 0 {\n            result.push(l1[0]);\n            l1.remove(0);\n\
    \        }\n        if l2.len() > 0 {\n            result.push(l2[0]);\n     \
    \       l2.remove(0);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 5, 7, 1, 5, 9, 34, 653, 121, 653, 2, 5]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmpbjjogp8v.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    let mut l3 = l2.clone();\n\
    \    while l3.len() > 0 {\n        let mut l4 = l3.clone();\n        while l4.len()\
    \ > 0 {\n            if l4[0] == l1[0] {\n                l4.remove(0);\n    \
    \            l3.remove(0);\n            } else {\n                break;\n   \
    \         }\n        }\n        if l4.len() == 0 {\n            result.remove(0);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut common: Vec<isize>\
    \ = Vec::new();\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len()\
    \ == 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n         \
    \   l1.pop();\n        } else {\n            let mut l1_el = l1.pop();\n     \
    \       let mut l2_el = l2.pop();\n            while l1_el == l2_el {\n      \
    \          common.push(l1_el);\n                l1_el = l1.pop();\n          \
    \      l2_el = l2.pop();\n            }\n        }\n    }\n    common\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjxgor5xe.rs:19:29\n   |\n\
    19 |                 common.push(l1_el);\n   |                             ^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    let mut l5 = l3.clone();\n    let mut l6 =\
    \ l4.clone();\n    let mut l7 = l5.clone();\n    let mut l8 = l6.clone();\n  \
    \  let mut l9 = l7.clone();\n    let mut l10 = l8.clone();\n    let mut l11 =\
    \ l9.clone();\n    let mut l12 = l10.clone();\n    let mut l13 = l11.clone();\n\
    \    let mut l14 = l12.clone();\n    let mut l15 = l13.clone();\n    let mut l16\
    \ = l14.clone();\n    let mut l17 = l15.clone();\n    let mut l18 = l16.clone();\n\
    \    let mut l19 = l17.clone();\n    let mut l20 = l18.clone();\n    let mut l21\
    \ = l19.clone();\n    let mut l22 = l20.clone();\n    let mut l23 = l21.clone();\n\
    \    let mut l24 = l22.clone();\n    let mut l25 = l23.clone();\n    let mut l26\
    \ = l24.clone();\n    let mut l27 = l25.clone();\n    let mut l28 = l26.clone();\n\
    \    let mut l29 = l27.clone();\n    let mut l30 = l28.clone();\n    let mut l31\
    \ = l29.clone();\n    let mut l32 = l30.clone();\n    let mut l33 = l31.clone();\n\
    \    let mut l34 = l32.clone();\n    let mut l35 = l33.clone();\n    let mut l36\
    \ = l34.clone();\n    let mut l37 = l35.clone();\n    let mut l38 = l36.clone();\n\
    \    let mut l39 = l37.clone();\n    let mut l40 = l38.clone();\n    let mut l41\
    \ = l39.clone();\n    let mut l42 = l40.clone();\n    let mut l43 = l41.clone();\n\
    \    let mut l44 = l42.clone();\n    let mut l45 = l43.clone();\n    let mut l46\
    \ = l44.clone();\n    let mut l47 = l45.clone();\n    let mut l48 = l46.clone();\n\
    \    let mut l49 = l47.clone();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpc8foksy5.rs:57:1\n\
    \   |\n57 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpfh97_zjt.rs:19:23\n   |\n19 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpfh97_zjt.rs:19:37\n   |\n19\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfh97_zjt.rs:30:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    let mut l4 =\
    \ l2.clone();\n    l4.sort();\n    let mut l5 = l3.clone();\n    l5.sort();\n\
    \    let mut l6 = l4.clone();\n    l6.sort();\n    let mut l7 = l5.clone();\n\
    \    l7.sort();\n    let mut l8 = l6.clone();\n    l8.sort();\n    let mut l9\
    \ = l7.clone();\n    l9.sort();\n    let mut l10 = l8.clone();\n    l10.sort();\n\
    \    let mut l11 = l9.clone();\n    l11.sort();\n    let mut l12 = l10.clone();\n\
    \    l12.sort();\n    let mut l13 = l11.clone();\n    l13.sort();\n    let mut\
    \ l14 = l12.clone();\n    l14.sort();\n    let mut l15 = l13.clone();\n    l15.sort();\n\
    \    let mut l16 = l14.clone();\n    l16.sort();\n    let mut l17 = l15.clone();\n\
    \    l17.sort();\n    let mut l18 = l16.clone();\n    l18.sort();\n    let mut\
    \ l19 = l17.clone();\n    l19.sort();\n    let mut l20 = l18.clone();\n    l20.sort();\n\
    \    let mut l21 = l19.clone();\n    l21.sort();\n    let mut l22 = l20.clone();\n\
    \    l22.sort();\n    let mut l23 = l21.clone();\n    l23.sort();\n    let mut\
    \ l24 = l22.clone();\n    l24.sort();\n    let mut l25 = l23.clone();\n    l25.sort();\n\
    \    let mut l26 = l24.clone();\n    l26.sort();\n    let mut l27 = l25.clone();\n\
    \    l27.sort();\n    let mut l28 = l26.clone();\n    l28.sort();\n    let mut\
    \ l29 = l27.clone();\n    l29.sort();\n    let mut l30 = l28.clone();\n    l30.sort();\n\
    \    let mut l31 = l29.clone();\n    l31.sort();\n    let mut l32 = l30.clone();\n\
    \    l32.sort();\n    let mut l33 = l31.clone();\n    l33.sort();\n    let mut\
    \ l34 = l32.clone();\n    l34.sort();\n    let mut l35 = l33.clone();\n    l35.sort();\n\
    \    let mut l36 = l34.clone();\n    l36.sort();\n    let mut l37 = l35.clone();\n\
    \    l37.sort\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `sort` on type `Vec<isize>`\n\
    \  --> /tmp/tmpdhjaa09d.rs:76:9\n   |\n76 |     l37.sort\n   |         ^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n76 |    \
    \ l37.sort()\n   |             ++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() > 0 || l4.len() > 0 {\n    \
    \    if l3.len() == 0 {\n            l3.pop();\n        }\n        if l4.len()\
    \ == 0 {\n            l4.pop();\n        }\n        if l3[0] == l4[0] {\n    \
    \        l3.pop();\n            l4.pop();\n        } else {\n            l3.pop();\n\
    \            l4.pop();\n        }\n    }\n    l1.iter().cloned().collect()\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmph43zuova.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            result.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2[0]);\n                    l2.pop();\n    \
    \            } else if l2.len() == 0 {\n                    result.push(l1[0]);\n\
    \                    l1.pop();\n                } else {\n                   \
    \ if l1[0] < l2[0] {\n                        result.push(l1[0]);\n          \
    \              l1.pop();\n                    } else {\n                     \
    \   result.push(l2[0]);\n                        l2.pop();\n                 \
    \   }\n                }\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            result.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1[0] < l2[0] {\n                    result.push(l1[0]);\n       \
    \             l1.pop();\n                } else {\n                    result.push(l2[0]);\n\
    \                    l2.pop();\n                }\n                i += 1;\n \
    \           }\n            if l1.len() > 0 {\n                result.push(l1[0]);\n\
    \                l1.pop();\n            }\n            if l2.len() > 0 {\n   \
    \             result.push(l2[0]);\n                l2.pop();\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    while i < l1.len() &&\
    \ i < l2.len() {\n        if l1[i] == l2[i] {\n            i += 1;\n        }\
    \ else {\n            l1.remove(i);\n            l2.remove(i);\n        }\n  \
    \  }\n    l1.extend(l2.iter().cloned());\n    l1\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 1, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpplh1noni.rs:26:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            if l1[0] < l2[0] {\n   \
    \             l3.push(l1[0]);\n                l1.pop();\n            } else {\n\
    \                l3.push(l2[0]);\n                l2.pop();\n            }\n \
    \       }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmptyg2g19u.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else if l1[0] < l2[0] {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            l3.push(l2[0]);\n      \
    \      l2.pop();\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmp545_01en.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    }\n        if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        }\n        if l1.len() != 0 && l2.len() != 0 {\n            if l1[l1[0]]\
    \ == l2[l2[0]] {\n                l3.pop();\n                l4.pop();\n     \
    \           l1.pop();\n                l2.pop();\n            } else {\n     \
    \           l3.pop();\n                l4.pop();\n            }\n        }\n \
    \   }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7knrj_57.rs:21:16\n\
    \   |\n21 |             if l1[l1[0]] == l2[l2[0]] {\n   |                ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7knrj_57.rs:21:29\n\
    \   |\n21 |             if l1[l1[0]] == l2[l2[0]] {\n   |                    \
    \         ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    let mut l5 = l3.clone();\n    let mut l6 =\
    \ l4.clone();\n    let mut l7 = l5.clone();\n    let mut l8 = l6.clone();\n  \
    \  let mut l9 = l7.clone();\n    let mut l10 = l8.clone();\n    let mut l11 =\
    \ l9.clone();\n    let mut l12 = l10.clone();\n    let mut l13 = l11.clone();\n\
    \    let mut l14 = l12.clone();\n    let mut l15 = l13.clone();\n    let mut l16\
    \ = l14.clone();\n    let mut l17 = l15.clone();\n    let mut l18 = l16.clone();\n\
    \    let mut l19 = l17.clone();\n    let mut l20 = l18.clone();\n    let mut l21\
    \ = l19.clone();\n    let mut l22 = l20.clone();\n    let mut l23 = l21.clone();\n\
    \    let mut l24 = l22.clone();\n    let mut l25 = l23.clone();\n    let mut l26\
    \ = l24.clone();\n    let mut l27 = l25.clone();\n    let mut l28 = l26.clone();\n\
    \    let mut l29 = l27.clone();\n    let mut l30 = l28.clone();\n    let mut l31\
    \ = l29.clone();\n    let mut l32 = l30.clone();\n    let mut l33 = l31.clone();\n\
    \    let mut l34 = l32.clone();\n    let mut l35 = l33.clone();\n    let mut l36\
    \ = l34.clone();\n    let mut l37 = l35.clone();\n    let mut l38 = l36.clone();\n\
    \    let mut l39 = l37.clone();\n    let mut l40 = l38.clone();\n    let mut l41\
    \ = l39.clone();\n    let mut l42 = l40.clone();\n    let mut l43 = l41.clone();\n\
    \    let mut l44 = l42.clone();\n    let mut l45 = l43.clone();\n    let mut l46\
    \ = l44.clone();\n    let mut l47 = l45.clone();\n    let mut l48 = l46.clone();\n\
    \    let mut l49 = l47.clone();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpkninr6bx.rs:57:1\n\
    \   |\n57 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        let mut i = 0;\n        while l1.len() > 0 &&\
    \ l2.len() > 0 {\n            if l1[0] < l2[0] {\n                result.push(l1[0]);\n\
    \                l1.remove(0);\n            } else {\n                result.push(l2[0]);\n\
    \                l2.remove(0);\n            }\n            i += 1;\n        }\n\
    \        if l1.len() > 0 {\n            result.push(l1[0]);\n            l1.remove(0);\n\
    \        }\n        if l2.len() > 0 {\n            result.push(l2[0]);\n     \
    \       l2.remove(0);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 5, 7, 1, 5, 9, 34, 653, 121, 653, 2, 5]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmp63171s06.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l1.len() == 1 {\n            if l2.len() == 1 {\n         \
    \       l3.pop();\n                l4.pop();\n            } else {\n         \
    \       l3.pop();\n                l4.pop();\n            }\n        } else if\
    \ l2.len() == 1 {\n            l3.pop();\n            l4.pop();\n        } else\
    \ {\n            let mut l5 = l1.clone();\n            let mut l6 = l2.clone();\n\
    \            while l5.len() != 0 || l6.len() != 0 {\n                if l5.len()\
    \ == 0 {\n                    l6.pop();\n                    l5.pop();\n     \
    \           } else if l6.len() == 0 {\n                    l5.pop();\n       \
    \             l6.pop();\n                } else if l5.len() == 1 {\n         \
    \           if l6.len() == 1 {\n                        l6.pop();\n          \
    \              l5.pop();\n                    } else {\n                     \
    \   l6.pop();\n                        l5.pop();\n                    }\n    \
    \            } else {\n                    let mut l7 = l5.clone();\n        \
    \            let mut l8 = l6.clone();\n                    while l7.len() != 0\
    \ || l8.len() != 0 {\n                        if l7.len() == 0 {\n           \
    \                 l8.pop();\n                            l7.pop();\n         \
    \               } else if l8.len() == 0 {\n                            l7.pop();\n\
    \                            l8.pop();\n                        } else if l7.len()\
    \ == 1 {\n                            if l8.len() == 1 {\n                   \
    \             l8.pop();\n                                l7.pop();\n         \
    \                   } else {\n                                l8.pop();\n    \
    \                            l7.pop();\n                            }\n      \
    \                  } else {\n                            let mut l9 = l7.clone();\n\
    \                            let mut l10 = l8.clone();\n                     \
    \       while l9.len() != 0 || l10.len() != 0 {\n                            \
    \    if l9.len() == 0 {\n                                    l10.pop();\n    \
    \                                l9.pop();\n                                }\
    \ else if l10.len() == 0 {\n                                    l9.pop();\n  \
    \                                  l10.pop();\n                              \
    \  } else if l9.len() == 1 {\n                                    if l10.len()\
    \ == 1 {\n                                        l10.pop();\n               \
    \                         l9.pop();\n                                    } else\
    \ {\n                                        l\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpdt7reu9j.rs:89:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n11 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n29 |         } else {\n   |\
    \                - unclosed delimiter\n...\n32 |             while l5.len() !=\
    \ 0 || l6.len() != 0 {\n   |                                                 \
    \ - unclosed delimiter\n...\n47 |                 } else {\n   |             \
    \           - unclosed delimiter\n...\n50 |                     while l7.len()\
    \ != 0 || l8.len() != 0 {\n   |                                              \
    \            - unclosed delimiter\n...\n65 |                         } else {\n\
    \   |                                - unclosed delimiter\n...\n68 |         \
    \                    while l9.len() != 0 || l10.len() != 0 {\n   |           \
    \                                                        - unclosed delimiter\n\
    ...\n75 |                                 } else if l9.len() == 1 {\n   |    \
    \                                                     - unclosed delimiter\n...\n\
    79 |                                     } else {\n   |                      \
    \                      - this delimiter might not be properly closed...\n80 |\
    \                                         l\n81 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n89 | }\n   |   ^\n\nerror[E0425]: cannot\
    \ find value `l` in this scope\n  --> /tmp/tmpdt7reu9j.rs:80:41\n   |\n80 | ...\
    \                   l\n   |                       ^ help: a local variable with\
    \ a similar name exists: `l1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdt7reu9j.rs:11:5\n\
    \   |\n6  |   fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |\
    \                                                ---------- expected `Vec<isize>`\
    \ because of return type\n...\n11 | /     while l1.len() != 0 || l2.len() != 0\
    \ {\n12 | |         if l1.len() == 0 {\n13 | |             l3.pop();\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmph1e7byun.rs:19:23\n   |\n19 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmph1e7byun.rs:19:37\n   |\n19\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph1e7byun.rs:30:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpgvvtelrk.rs:19:23\n   |\n19 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpgvvtelrk.rs:19:37\n   |\n19\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgvvtelrk.rs:30:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    let mut l3 = l2.clone();\n\
    \    while l3.len() > 0 {\n        let mut found = false;\n        for &x in l3\
    \ {\n            if result.contains(&x) {\n                found = true;\n   \
    \             break;\n            }\n        }\n        if found {\n         \
    \   break;\n        }\n        result.push(l3.pop());\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppcdfkusc.rs:11:13\n   |\n\
    11 |         for &x in l3 {\n   |             ^^    -- this expression has type\
    \ `Option<isize>`\n   |             |\n   |             expected `isize`, found\
    \ reference\n   |             help: you can probably remove the explicit borrow:\
    \ `x`\n   |\n   = note:   expected type `isize`\n           found reference `&_`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppcdfkusc.rs:20:21\n   |\n20 |\
    \         result.push(l3.pop());\n   |                     ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpjk8fy52a.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1[0] < l2[0] {\n                    result.push(l1.pop());\n    \
    \            } else {\n                    result.push(l2.pop());\n          \
    \      }\n                i += 1;\n            }\n            while l1.len() >\
    \ 0 {\n                result.push(l1.pop());\n                i += 1;\n     \
    \       }\n            while l2.len() > 0 {\n                result.push(l2.pop());\n\
    \                i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp04tpcfl0.rs:37:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n37 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    let mut l4 =\
    \ l2.clone();\n    l4.sort();\n    let mut l5 = l3.clone();\n    l5.sort();\n\
    \    let mut l6 = l4.clone();\n    l6.sort();\n    let mut l7 = l5.clone();\n\
    \    l7.sort();\n    let mut l8 = l6.clone();\n    l8.sort();\n    let mut l9\
    \ = l7.clone();\n    l9.sort();\n    let mut l10 = l8.clone();\n    l10.sort();\n\
    \    let mut l11 = l9.clone();\n    l11.sort();\n    let mut l12 = l10.clone();\n\
    \    l12.sort();\n    let mut l13 = l11.clone();\n    l13.sort();\n    let mut\
    \ l14 = l12.clone();\n    l14.sort();\n    let mut l15 = l13.clone();\n    l15.sort();\n\
    \    let mut l16 = l14.clone();\n    l16.sort();\n    let mut l17 = l15.clone();\n\
    \    l17.sort();\n    let mut l18 = l16.clone();\n    l18.sort();\n    let mut\
    \ l19 = l17.clone();\n    l19.sort();\n    let mut l20 = l18.clone();\n    l20.sort();\n\
    \    let mut l21 = l19.clone();\n    l21.sort();\n    let mut l22 = l20.clone();\n\
    \    l22.sort();\n    let mut l23 = l21.clone();\n    l23.sort();\n    let mut\
    \ l24 = l22.clone();\n    l24.sort();\n    let mut l25 = l23.clone();\n    l25.sort();\n\
    \    let mut l26 = l24.clone();\n    l26.sort();\n    let mut l27 = l25.clone();\n\
    \    l27.sort();\n    let mut l28 = l26.clone();\n    l28.sort();\n    let mut\
    \ l29 = l27.clone();\n    l29.sort();\n    let mut l30 = l28.clone();\n    l30.sort();\n\
    \    let mut l31 = l29.clone();\n    l31.sort();\n    let mut l32 = l30.clone();\n\
    \    l32.sort();\n    let mut l33 = l31.clone();\n    l33.sort();\n    let mut\
    \ l34 = l32.clone();\n    l34.sort();\n    let mut l35 = l33.clone();\n    l35.sort();\n\
    \    let mut l36 = l34.clone();\n    l36.sort();\n    let mut l37 = l35.clone();\n\
    \    l37.sort\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `sort` on type `Vec<isize>`\n\
    \  --> /tmp/tmp3govrjeg.rs:76:9\n   |\n76 |     l37.sort\n   |         ^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n76 |    \
    \ l37.sort()\n   |             ++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    for i in l1.iter().cloned()\
    \ {\n        if l2.iter().any(|&x| x == i) {\n            result.push(i);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpteey_qux.rs:18:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        let mut i = 0;\n        while l1.len() > 0 &&\
    \ l2.len() > 0 {\n            if l1[0] < l2[0] {\n                result.push(l1[0]);\n\
    \                l1.remove(0);\n            } else {\n                result.push(l2[0]);\n\
    \                l2.remove(0);\n            }\n            i += 1;\n        }\n\
    \        if l1.len() > 0 {\n            result.push(l1[0]);\n            l1.remove(0);\n\
    \        }\n        if l2.len() > 0 {\n            result.push(l2[0]);\n     \
    \       l2.remove(0);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 5, 7, 1, 5, 9, 34, 653, 121, 653, 2, 5]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmptx9f596y.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            let mut j = 0;\n            while l1.len() > 0\
    \ && l2.len() > 0 {\n                if l1[0] < l2[0] {\n                    result.push(l1.pop());\n\
    \                } else {\n                    result.push(l2.pop());\n      \
    \          }\n                i += 1;\n                j += 1;\n            }\n\
    \            while l1.len() > 0 {\n                result.push(l1.pop());\n  \
    \              i += 1;\n            }\n            while l2.len() > 0 {\n    \
    \            result.push(l2.pop());\n                j += 1;\n            }\n\
    \            while i < l1.len() {\n                result.push(l1.pop());\n  \
    \              i += 1;\n            }\n            while j < l2.len() {\n    \
    \            result.push(l2.pop());\n                j += 1;\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyrb6shv7.rs:47:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n47 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            let mut l3_iter = l3.iter().cloned();\n       \
    \     let mut l4_iter = l4.iter().cloned();\n            let mut l3_next = l3_iter.next();\n\
    \            let mut l4_next = l4_iter.next();\n            while l3_next.unwrap()\
    \ != l4_next.unwrap() {\n                let mut l3_elem = l3_next.unwrap();\n\
    \                let mut l4_elem = l4_next.unwrap();\n                while l3_elem\
    \ != l4_elem {\n                    l3_elem = l3_iter.next();\n              \
    \      l4_elem = l4_iter.next();\n                }\n                l3_next.unwrap()\
    \ = l3_elem.unwrap();\n                l4_next.unwrap() = l4_elem.unwrap();\n\
    \            }\n            l3.pop();\n            l4.pop();\n        }\n    }\n\
    \    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsusvrgnw.rs:27:31\n   |\n\
    24 |                 let mut l3_elem = l3_next.unwrap();\n   |               \
    \                    ---------------- expected due to this value\n...\n27 |  \
    \                   l3_elem = l3_iter.next();\n   |                          \
    \     ^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsusvrgnw.rs:28:31\n   |\n25 |                 let mut l4_elem\
    \ = l4_next.unwrap();\n   |                                   ----------------\
    \ expected due to this value\n...\n28 |                     l4_elem = l4_iter.next();\n\
    \   |                               ^^^^^^^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmpsusvrgnw.rs:30:34\n\
    \   |\n30 |                 l3_next.unwrap() = l3_elem.unwrap();\n   |       \
    \          ---------------- ^\n   |                 |\n   |                 cannot\
    \ assign to this expression\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmpsusvrgnw.rs:30:44\n   |\n30\
    \ |                 l3_next.unwrap() = l3_elem.unwrap();\n   |               \
    \                             ^^^^^^ method not found in `isize`\n\nerror[E0070]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpsusvrgnw.rs:31:34\n   |\n\
    31 |                 l4_next.unwrap() = l4_elem.unwrap();\n   |              \
    \   ---------------- ^\n   |                 |\n   |                 cannot assign\
    \ to this expression\n\nerror[E0599]: no method named `unwrap` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpsusvrgnw.rs:31:44\n   |\n31 |  \
    \               l4_next.unwrap() = l4_elem.unwrap();\n   |                   \
    \                         ^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0070, E0308,\
    \ E0599.\nFor more information about an e"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpytl7zeyd.rs:24:27\n   |\n24 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpytl7zeyd.rs:24:41\n\
    \   |\n24 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpytl7zeyd.rs:34:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n34 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() > 0 || l4.len() > 0 {\n    \
    \    if l3.len() == 0 {\n            l3.pop();\n            l4.pop();\n      \
    \  } else if l4.len() == 0 {\n            l3.pop();\n            l4.pop();\n \
    \       } else if l3.len() == 1 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l4.len() == 1 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l3[0] == l4[0] {\n            l3.pop();\n            l4.pop();\n\
    \            l3.pop();\n            l4.pop();\n        } else {\n            l3.pop();\n\
    \            l4.pop();\n        }\n    }\n    l1.iter().cloned().collect()\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpwakihtau.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.len() == l2.len() {\n                        let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n                        let mut\
    \ l2 = l2.iter().cloned().collect::<Vec<_>>();\n                        while\
    \ l1.len() != 0 || l2.len() != 0 {\n                            if l1.len() ==\
    \ 0 {\n                                result.push(l2.pop());\n              \
    \              } else if l2.len() == 0 {\n                                result.push(l1.pop());\n\
    \                            } else {\n                                if l1.len()\
    \ == l2.len() {\n                                    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                                    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                                }\n                            }\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9_2bo59x.rs:44:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n44 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            let mut l3_i = l3.len();\n\
    \            while l3_i > 0 && l3[l3_i - 1] == l2[0] {\n                l3_i--;\n\
    \            }\n            l3.push(l2[0]);\n            l2.pop();\n         \
    \   l3_i\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp8n145st8.rs:22:23\n\
    \   |\n22 |                 l3_i--;\n   |                       ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8n145st8.rs:26:13\n   |\n16 |\
    \           } else if l2.len() == 0 {\n   |  ________________-\n17 | |       \
    \      l3.push(l1[0]);\n18 | |             l1.pop();\n19 | |         } else {\n\
    ...  |\n26 | |             l3_i\n   | |             ^^^^ expected `()`, found\
    \ `usize`\n27 | |         }\n   | |_________- expected this to be `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            if l1[0] < l2[0] {\n   \
    \             l3.push(l1[0]);\n                l1.pop();\n            } else {\n\
    \                l3.push(l2[0]);\n                l2.pop();\n            }\n \
    \       }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpwzn4y6jv.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1o4mkqx9.rs:6:46\n  |\n6 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------   \
    \                                 ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit\
    \ type `()`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != l2.len() {\n        let mut i = l1.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut j = l2.iter().cloned().collect::<Vec<_>>();\n        while i.len()\
    \ != j.len() {\n            if i.len() == 0 {\n                i = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            }\n            if j.len() == 0 {\n                j = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            }\n            if i.len() == 0 && j.len() == 0 {\n              \
    \  break;\n            }\n            if i.len() == 1 {\n                result.push(i.front());\n\
    \                i.clear();\n            }\n            if j.len() == 1 {\n  \
    \              result.push(j.front());\n                j.clear();\n         \
    \   }\n            if i.len() == 0 && j.len() == 1 {\n                break;\n\
    \            }\n            if i.len() == 1 && j.len() == 1 {\n              \
    \  result.push(i[0]);\n                i.clear();\n                j.clear();\n\
    \            }\n            if i.len() == 1 {\n                i.next();\n   \
    \         }\n            if j.len() == 1 {\n                j.next();\n      \
    \      }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpwve4doi7.rs:24:31\n   |\n24 |             \
    \    result.push(i.front());\n   |                               ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwve4doi7.rs:28:31\n\
    \   |\n28 |                 result.push(j.front());\n   |                    \
    \           ^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method\
    \ named `next` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwve4doi7.rs:40:19\n\
    \   |\n40 |                 i.next();\n   |                   ^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `next` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpwve4doi7.rs:43:19\n   |\n43\
    \ |                 j.next();\n   |                   ^^^^ method not found in\
    \ `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    let mut l5 = l3.clone();\n    let mut l6 =\
    \ l4.clone();\n    let mut l7 = l5.clone();\n    let mut l8 = l6.clone();\n  \
    \  while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n      \
    \      l3.pop();\n            l4.pop();\n            l5.pop();\n            l6.pop();\n\
    \            l7.pop();\n            l8.pop();\n        }\n        if l2.len()\
    \ == 0 {\n            l1.pop();\n            l3.pop();\n            l4.pop();\n\
    \            l5.pop();\n            l6.pop();\n            l7.pop();\n       \
    \     l8.pop();\n        }\n        if l1.len() == 0 && l2.len() == 0 {\n    \
    \        break;\n        }\n        if l1.len() == 0 {\n            l3.pop();\n\
    \            l4.pop();\n            l5.pop();\n            l6.pop();\n       \
    \     l7.pop();\n            l8.pop();\n        }\n        if l2.len() == 0 {\n\
    \            l1.pop();\n            l3.pop();\n            l4.pop();\n       \
    \     l5.pop();\n            l6.pop();\n            l7.pop();\n            l8.pop();\n\
    \        }\n        if l1.len() == 1 && l2.len() == 1 {\n            if l1.pop()\
    \ == l2.pop() {\n                continue;\n            }\n        }\n       \
    \ if l1.len() == 1 {\n            l3.pop();\n            l4.pop();\n         \
    \   l5.pop();\n            l6.pop();\n            l7.pop();\n            l8.pop();\n\
    \        }\n        if l2.len() == 1 {\n            l1.pop();\n            l3.pop();\n\
    \            l4.pop();\n            l5.pop();\n            l6.pop();\n       \
    \     l7.pop();\n            l8.pop();\n        }\n        if l1.len() == 2 &&\
    \ l2.len() == 2 {\n            if l1.pop() == l2.pop() {\n                continue;\n\
    \            }\n        }\n        if l1.len() == 2 {\n            l3.pop();\n\
    \            l4.pop();\n            l5.pop();\n            l6.pop();\n       \
    \     l7.pop();\n            l8.pop();\n        }\n        if l2.len() == 2 {\n\
    \            l1.pop();\n            l3.pop();\n            l4.pop();\n       \
    \     l5.pop();\n            l6.pop();\n            l7.pop();\n            l8.pop();\n\
    \        }\n\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8911uauq.rs:106:3\n\
    \    |\n6   | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    |\
    \                                                         - unclosed delimiter\n\
    ...\n15  |     while l1.len() != 0 || l2.len() != 0 {\n    |                 \
    \                         - this delimiter might not be properly closed...\n...\n\
    98  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    106 | }\n    |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmp8911uauq.rs:6:46\n\
    \  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------\
    \                                    ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit\
    \ type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            if l1[0] < l2[0] {\n   \
    \             l3.push(l1[0]);\n                l1.pop();\n            } else {\n\
    \                l3.push(l2[0]);\n                l2.pop();\n            }\n \
    \       }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpwzsg7t2r.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    let mut l3 = l2.clone();\n\
    \    while l3.len() > 0 {\n        let mut l4 = l3.clone();\n        while l4.len()\
    \ > 0 {\n            let mut l5 = l4.clone();\n            while l5.len() > 0\
    \ {\n                if l5[0] < l3[0] {\n                    l5.swap(0, 0);\n\
    \                }\n                l5.pop();\n            }\n            l4.pop();\n\
    \        }\n        l3.swap(0, 0);\n        l3.pop();\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp9py_yd9n.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 && l2.len() != 0 {\n      \
    \          if l1.front() == l2.front() {\n                    l1.pop();\n    \
    \                l2.pop();\n                } else {\n                    i +=\
    \ 1;\n                }\n            }\n            if l1.len() != 0 {\n     \
    \           result.push(l1.pop());\n            }\n            if l2.len() !=\
    \ 0 {\n                result.push(l2.pop());\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpras6dab5.rs:20:23\n   |\n20 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpras6dab5.rs:20:37\n   |\n20\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpras6dab5.rs:35:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n35 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    let mut l4 =\
    \ l2.clone();\n    l4.sort();\n    let mut l5 = l3.clone();\n    l5.sort();\n\
    \    let mut l6 = l4.clone();\n    l6.sort();\n    let mut l7 = l5.clone();\n\
    \    l7.sort();\n    let mut l8 = l6.clone();\n    l8.sort();\n    let mut l9\
    \ = l7.clone();\n    l9.sort();\n    let mut l10 = l8.clone();\n    l10.sort();\n\
    \    let mut l11 = l9.clone();\n    l11.sort();\n    let mut l12 = l10.clone();\n\
    \    l12.sort();\n    let mut l13 = l11.clone();\n    l13.sort();\n    let mut\
    \ l14 = l12.clone();\n    l14.sort();\n    let mut l15 = l13.clone();\n    l15.sort();\n\
    \    let mut l16 = l14.clone();\n    l16.sort();\n    let mut l17 = l15.clone();\n\
    \    l17.sort();\n    let mut l18 = l16.clone();\n    l18.sort();\n    let mut\
    \ l19 = l17.clone();\n    l19.sort();\n    let mut l20 = l18.clone();\n    l20.sort();\n\
    \    let mut l21 = l19.clone();\n    l21.sort();\n    let mut l22 = l20.clone();\n\
    \    l22.sort();\n    let mut l23 = l21.clone();\n    l23.sort();\n    let mut\
    \ l24 = l22.clone();\n    l24.sort();\n    let mut l25 = l23.clone();\n    l25.sort();\n\
    \    let mut l26 = l24.clone();\n    l26.sort();\n    let mut l27 = l25.clone();\n\
    \    l27.sort();\n    let mut l28 = l26.clone();\n    l28.sort();\n    let mut\
    \ l29 = l27.clone();\n    l29.sort();\n    let mut l30 = l28.clone();\n    l30.sort();\n\
    \    let mut l31 = l29.clone();\n    l31.sort();\n    let mut l32 = l30.clone();\n\
    \    l32.sort();\n    let mut l33 = l31.clone();\n    l33.sort();\n    let mut\
    \ l34 = l32.clone();\n    l34.sort();\n    let mut l35 = l33.clone();\n    l35.sort();\n\
    \    let mut l36 = l34.clone();\n    l36.sort();\n    let mut l37 = l35.clone();\n\
    \    l37.sort\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `sort` on type `Vec<isize>`\n\
    \  --> /tmp/tmp9diw2uz2.rs:76:9\n   |\n76 |     l37.sort\n   |         ^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n76 |    \
    \ l37.sort()\n   |             ++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        let mut l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n        if\
    \ l1.len() > 0 {\n            if l2.len() > 0 {\n                while l1_iter.any(|&x|\
    \ l2_iter.any(|&y| x == y)) {\n                    l1_iter.next();\n         \
    \           l2_iter.next();\n                }\n            }\n            l1\
    \ = l1_iter;\n        }\n        if l2.len() > 0 {\n            if l1.len() >\
    \ 0 {\n                while l2_iter.any(|&x| l1_iter.any(|&y| x == y)) {\n  \
    \                  l2_iter.next();\n                    l1_iter.next();\n    \
    \            }\n            }\n            l2 = l2_iter;\n        }\n        result.push(l1.pop());\n\
    \        result.push(l2.pop());\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `any` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmp8qvu4vjb.rs:15:31\n   |\n15 |                 while\
    \ l1_iter.any(|&x| l2_iter.any(|&y| x == y)) {\n   |                         \
    \      ^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `any`\
    \ found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp8qvu4vjb.rs:15:48\n\
    \   |\n15 |                 while l1_iter.any(|&x| l2_iter.any(|&y| x == y)) {\n\
    \   |                                                ^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `next` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp8qvu4vjb.rs:16:29\n   |\n16 |                     l1_iter.next();\n\
    \   |                             ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `next` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmp8qvu4vjb.rs:17:29\n   |\n17 |                     l2_iter.next();\n\
    \   |                             ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `any` found for struct `Vec<isize>` in the current scope\n \
    \ --> /tmp/tmp8qvu4vjb.rs:24:31\n   |\n24 |                 while l2_iter.any(|&x|\
    \ l1_iter.any(|&y| x == y)) {\n   |                               ^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `any` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp8qvu4vjb.rs:24:48\n   |\n24\
    \ |                 while l2_iter.any(|&x| l1_iter.any(|&y| x == y)) {\n   | \
    \                                               ^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `next` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp8qvu4vjb.rs:25:29\n   |\n25 |                     l2_iter.next();\n\
    \   |                             ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `next` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmp8qvu4vjb.rs:26:29\n   |\n26 |                     l1_iter.next();\n\
    \   |                             ^^^^ method not found in "
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    let mut l4 =\
    \ l2.clone();\n    l4.sort();\n    while l3.len() > 0 && l4.len() > 0 {\n    \
    \    if l3[0] != l4[0] {\n            break;\n        }\n        l3.remove(0);\n\
    \        l4.remove(0);\n    }\n    l3.extend(l4.iter().cloned());\n    l3\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 34, 653, 5, 5, 7, 9, 121, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpz2n8wojd.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp6enomuw7.rs:19:23\n   |\n19 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp6enomuw7.rs:19:37\n   |\n19\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6enomuw7.rs:30:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut i = 0;\n   \
    \         let mut j = 0;\n            while i < l1.len() && j < l2.len() {\n \
    \               if l1[i] < l2[j] {\n                    i += 1;\n            \
    \    } else if l1[i] > l2[j] {\n                    j += 1;\n                }\
    \ else {\n                    result.push(l1[i]);\n                    i += 1;\n\
    \                    j += 1;\n                }\n            }\n            if\
    \ i == l1.len() {\n                result.push(l2[j]);\n            } else if\
    \ j == l2.len() {\n                result.push(l1[i]);\n            }\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphem5h2fw.rs:24:33\n   |\n\
    24 |                     result.push(l1[i]);\n   |                           \
    \      ^^^^^ expected enum `Option`, found `isize`\n   |\n   = note: expected\
    \ enum `Option<isize>`\n              found type `isize`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n24 |                     result.push(Some(l1[i]));\n\
    \   |                                 +++++     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphem5h2fw.rs:30:29\n   |\n30 |                 result.push(l2[j]);\n\
    \   |                             ^^^^^ expected enum `Option`, found `isize`\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found type `isize`\n\
    help: try wrapping the expression in `Some`\n   |\n30 |                 result.push(Some(l2[j]));\n\
    \   |                             +++++     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphem5h2fw.rs:32:29\n   |\n32 |                 result.push(l1[i]);\n\
    \   |                             ^^^^^ expected enum `Option`, found `isize`\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found type `isize`\n\
    help: try wrapping the expression in `Some`\n   |\n32 |                 result.push(Some(l1[i]));\n\
    \   |                             +++++     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphem5h2fw.rs:36:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n36 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    let mut result = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n\
    \        if l1.len() == 0 {\n            result.push(l2.pop());\n        } else\
    \ if l2.len() == 0 {\n            result.push(l1.pop());\n        } else {\n \
    \           let mut l1 = l1.to_vec();\n            let mut l2 = l2.to_vec();\n\
    \            let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0\
    \ {\n                if l1.len() == 0 {\n                    result.push(l2.pop());\n\
    \                } else if l2.len() == 0 {\n                    result.push(l1.pop());\n\
    \                } else {\n                    if l1.len() == l2.len() {\n   \
    \                     if l1.len() == 1 {\n                            result.push(l1.pop());\n\
    \                        } else {\n                            result.push(l1.pop());\n\
    \                            result.push(l2.pop());\n                        }\n\
    \                    } else {\n                        if l1.len() < l2.len()\
    \ {\n                            result.push(l1.pop());\n                    \
    \    } else {\n                            result.push(l2.pop());\n          \
    \              }\n                    }\n                }\n                i\
    \ += 1;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm0azpjiz.rs:44:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n44 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = vec![];\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1[0] < l2[0] {\n                    result.push(l1.pop());\n    \
    \            } else {\n                    result.push(l2.pop());\n          \
    \      }\n                i += 1;\n            }\n            while l1.len() >\
    \ 0 {\n                result.push(l1.pop());\n                i += 1;\n     \
    \       }\n            while l2.len() > 0 {\n                result.push(l2.pop());\n\
    \                i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdplzp7_x.rs:37:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n37 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    let mut l4 =\
    \ l2.clone();\n    l4.sort();\n    let mut l5 = l3.clone();\n    l5.sort();\n\
    \    let mut l6 = l4.clone();\n    l6.sort();\n    let mut l7 = l5.clone();\n\
    \    l7.sort();\n    let mut l8 = l6.clone();\n    l8.sort();\n    let mut l9\
    \ = l7.clone();\n    l9.sort();\n    let mut l10 = l8.clone();\n    l10.sort();\n\
    \    let mut l11 = l9.clone();\n    l11.sort();\n    let mut l12 = l10.clone();\n\
    \    l12.sort();\n    let mut l13 = l11.clone();\n    l13.sort();\n    let mut\
    \ l14 = l12.clone();\n    l14.sort();\n    let mut l15 = l13.clone();\n    l15.sort();\n\
    \    let mut l16 = l14.clone();\n    l16.sort();\n    let mut l17 = l15.clone();\n\
    \    l17.sort();\n    let mut l18 = l16.clone();\n    l18.sort();\n    let mut\
    \ l19 = l17.clone();\n    l19.sort();\n    let mut l20 = l18.clone();\n    l20.sort();\n\
    \    let mut l21 = l19.clone();\n    l21.sort();\n    let mut l22 = l20.clone();\n\
    \    l22.sort();\n    let mut l23 = l21.clone();\n    l23.sort();\n    let mut\
    \ l24 = l22.clone();\n    l24.sort();\n    let mut l25 = l23.clone();\n    l25.sort();\n\
    \    let mut l26 = l24.clone();\n    l26.sort();\n    let mut l27 = l25.clone();\n\
    \    l27.sort();\n    let mut l28 = l26.clone();\n    l28.sort();\n    let mut\
    \ l29 = l27.clone();\n    l29.sort();\n    let mut l30 = l28.clone();\n    l30.sort();\n\
    \    let mut l31 = l29.clone();\n    l31.sort();\n    let mut l32 = l30.clone();\n\
    \    l32.sort();\n    let mut l33 = l31.clone();\n    l33.sort();\n    let mut\
    \ l34 = l32.clone();\n    l34.sort();\n    let mut l35 = l33.clone();\n    l35.sort();\n\
    \    let mut l36 = l34.clone();\n    l36.sort();\n    let mut l37 = l35.clone();\n\
    \    l37.sort\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `sort` on type `Vec<isize>`\n\
    \  --> /tmp/tmpgcn4je8r.rs:76:9\n   |\n76 |     l37.sort\n   |         ^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n76 |    \
    \ l37.sort()\n   |             ++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    let mut result = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n\
    \        if l1.len() == 0 {\n            result.push(l2.pop());\n        } else\
    \ if l2.len() == 0 {\n            result.push(l1.pop());\n        } else {\n \
    \           let mut l1 = l1.to_vec();\n            let mut l2 = l2.to_vec();\n\
    \            let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0\
    \ {\n                if l1.len() == 0 {\n                    result.push(l2.pop());\n\
    \                    i += 1;\n                } else if l2.len() == 0 {\n    \
    \                result.push(l1.pop());\n                    i += 1;\n       \
    \         } else {\n                    if l1.len() == l2.len() {\n          \
    \              if l1.len() == 1 {\n                            result.push(l1.pop());\n\
    \                        } else {\n                            result.push(l1.pop());\n\
    \                            result.push(l2.pop());\n                        }\n\
    \                        i += 1;\n                    } else if l1.len() < l2.len()\
    \ {\n                        result.push(l1.pop());\n                        i\
    \ += 1;\n                    } else {\n                        result.push(l2.pop());\n\
    \                        i += 1;\n                    }\n                }\n \
    \           }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk38e7zol.rs:46:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n46 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        let mut i = 0;\n        while l1.len() > 0 &&\
    \ l2.len() > 0 {\n            if l1[0] < l2[0] {\n                result.push(l1[0]);\n\
    \                l1.remove(0);\n            } else {\n                result.push(l2[0]);\n\
    \                l2.remove(0);\n            }\n            i += 1;\n        }\n\
    \        if l1.len() > 0 {\n            result.push(l1[0]);\n            l1.remove(0);\n\
    \        }\n        if l2.len() > 0 {\n            result.push(l2[0]);\n     \
    \       l2.remove(0);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 5, 7, 1, 5, 9, 34, 653, 121, 653, 2, 5]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmplyf1367d.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2\
    \ = l2.iter().cloned().collect::<Vec<_>>();\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2\
    \ = l2.iter().cloned().collect::<Vec<_>>();\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2\
    \ = l2.iter().cloned().collect::<Vec<_>>();\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2\
    \ = l2.iter().cloned().collect::<Vec<_>>();\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2\
    \ = l2.iter().cloned().collect::<Vec<_>>();\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp06rl4nem.rs:46:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() > 0 || l2.len() > 0 {\n   |                     \
    \                   - unclosed delimiter\n...\n15 |         } else {\n   |   \
    \             - this delimiter might not be properly closed...\n...\n38 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n46 | }\n\
    \   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp06rl4nem.rs:10:5\n\
    \   |\n6  |   fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |\
    \                                                ---------- expected `Vec<isize>`\
    \ because of return type\n...\n10 | /     while l1.len() > 0 || l2.len() > 0 {\n\
    11 | |         if l1.len() == 0 {\n12 | |             result.push(l2.pop());\n\
    13 | |         } else if l2.len() == 0 {\n...  |\n45 | |     assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n46 | | }\n   | |__^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \         found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        } else {\n            let mut\
    \ l3_iter = l3.iter();\n            let mut l4_iter = l4.iter();\n           \
    \ let mut l3_next = l3_iter.next();\n            let mut l4_next = l4_iter.next();\n\
    \            while l3_next.unwrap() == l4_next.unwrap() {\n                l3_next\
    \ = l3_iter.next();\n                l4_next = l4_iter.next();\n            }\n\
    \            l3.push(l3_next.unwrap());\n            l4.push(l4_next.unwrap());\n\
    \        }\n    }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6kzkxajw.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6kzkxajw.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp6kzkxajw.rs:25:21\n   |\n25 |  \
    \           l3.push(l3_next.unwrap());\n   |                     ^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n25 |             l3.push(*l3_next.unwrap());\n   |                    \
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6kzkxajw.rs:26:21\n   |\n\
    26 |             l4.push(l4_next.unwrap());\n   |                     ^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n26 |             l4.push(*l4_next.unwrap());\n   |                    \
    \ +\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    l1.sort();\n    l2.sort();\n\
    \    let mut l3 = Vec::new();\n    while l1.len() > 0 || l2.len() > 0 {\n    \
    \    if l1.len() == 0 {\n            l3.push(l2[0]);\n            l2.pop();\n\
    \        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n            l1.pop();\n\
    \        } else {\n            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n\
    \                l1.pop();\n            } else {\n                l3.push(l2[0]);\n\
    \                l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpyqn6p_w_.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpcqdzqu0v.rs:24:27\n   |\n24 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpcqdzqu0v.rs:24:41\n\
    \   |\n24 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcqdzqu0v.rs:34:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n34 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp14bqtj4a.rs:19:23\n   |\n19 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp14bqtj4a.rs:19:37\n   |\n19\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp14bqtj4a.rs:30:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpcmzsomdr.rs:19:23\n   |\n19 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpcmzsomdr.rs:19:37\n   |\n19\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcmzsomdr.rs:30:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    let mut result = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n\
    \        if l1.len() == 0 {\n            result.push(l2.pop());\n        } else\
    \ if l2.len() == 0 {\n            result.push(l1.pop());\n        } else {\n \
    \           if l1.pop() == l2.pop() {\n                result.push(l1.pop());\n\
    \            } else {\n                break;\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn_shzebk.rs:23:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n23 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpyl7zd4tm.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() > 0 || l4.len() > 0 {\n    \
    \    if l3.len() == 0 {\n            l3.pop();\n        }\n        if l4.len()\
    \ == 0 {\n            l4.pop();\n        }\n        let mut l3_iter = l3.iter().cloned();\n\
    \        let mut l4_iter = l4.iter().cloned();\n        if l3_iter.next().unwrap()\
    \ != l4_iter.next().unwrap() {\n            l3.pop();\n            l4.pop();\n\
    \        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpnnyhzmz6.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.dedup();\n\
    \    let mut l4 = l2.clone();\n    l4.sort();\n    l4.dedup();\n    l3.iter().zip(l4.iter()).filter(|&(a,\
    \ b)| a == b).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n    --> /tmp/tmpkfe8ddpw.rs:13:55\n\
    \     |\n13   |     l3.iter().zip(l4.iter()).filter(|&(a, b)| a == b).collect()\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize, &isize)>`\n\
    \     |\n     = help: the trait `FromIterator<(&isize, &isize)>` is not implemented\
    \ for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    let mut l3 = l2.clone();\n\
    \    while l3.len() > 0 {\n        let mut found = false;\n        for &i in result\
    \ {\n            if l3.contains(&i) {\n                found = true;\n       \
    \         break;\n            }\n        }\n        if found {\n            break;\n\
    \        }\n        result.push(l3.pop());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7icvm8mu.rs:11:13\n   |\n\
    11 |         for &i in result {\n   |             ^^    ------ this expression\
    \ has type `Option<isize>`\n   |             |\n   |             expected `isize`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `i`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7icvm8mu.rs:20:21\n  \
    \ |\n20 |         result.push(l3.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 && l2.len() != 0 {\n      \
    \          if l1.front() == l2.front() {\n                    l1.pop();\n    \
    \                l2.pop();\n                } else {\n                    i +=\
    \ 1;\n                }\n            }\n            if l1.len() != 0 || l2.len()\
    \ != 0 {\n                result.push(i);\n            }\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp771gpivg.rs:20:23\n   |\n20 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp771gpivg.rs:20:37\n   |\n20\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp771gpivg.rs:28:29\n   |\n28 |                 result.push(i);\n\
    \   |                             ^ expected enum `Option`, found integer\n  \
    \ |\n   = note: expected enum `Option<isize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n28 |                 result.push(Some(i));\n\
    \   |                             +++++ +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp771gpivg.rs:32:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n32 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(*l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(*l1.pop());\n    \
    \    } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if *l1.front() == *l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(*l1.pop());\n            result.push(*l2.pop());\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpfrb8x3wv.rs:12:25\n\
    \   |\n12 |             result.push(*l2.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmpfrb8x3wv.rs:14:25\n   |\n14 |             result.push(*l1.pop());\n\
    \   |                         ^^^^^^^^^\n\nerror[E0599]: no method named `front`\
    \ found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpfrb8x3wv.rs:19:24\n\
    \   |\n19 |                 if *l1.front() == *l2.front() {\n   |            \
    \            ^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method\
    \ named `front` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpfrb8x3wv.rs:19:39\n\
    \   |\n19 |                 if *l1.front() == *l2.front() {\n   |            \
    \                           ^^^^^ method not found in `Vec<isize>`\n\nerror[E0614]:\
    \ type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpfrb8x3wv.rs:26:25\n\
    \   |\n26 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmpfrb8x3wv.rs:27:25\n   |\n27 |             result.push(*l2.pop());\n\
    \   |                         ^^^^^^^^^\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpddn423c5.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l2.pop();\n        } else if l2.len() == 0 {\n            l1.pop();\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                l1_el\
    \ = l1.pop();\n                l2_el = l2.pop();\n            }\n            result.push(l1_el);\n\
    \            result.push(l2_el);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdp2jd2fg.rs:26:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            result.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2\
    \ = l2.iter().cloned().collect::<Vec<_>>();\n            while l1.len() > 0 &&\
    \ l2.len() > 0 {\n                if l1[0] < l2[0] {\n                    result.push(l1[0]);\n\
    \                    l1.pop();\n                } else {\n                   \
    \ result.push(l2[0]);\n                    l2.pop();\n                }\n    \
    \        }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpnz9ilute.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    for i in l1.iter() {\n \
    \       if l2.iter().any(|&x| x == i) {\n            result.push(i);\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoplegbsv.rs:9:36\n  |\n9 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n9 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoplegbsv.rs:13:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n13 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n            \
    \  found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.len() == l2.len() {\n                        let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n                        let mut\
    \ l2 = l2.iter().cloned().collect::<Vec<_>>();\n                        while\
    \ l1.len() != 0 || l2.len() != 0 {\n                            if l1.len() ==\
    \ 0 {\n                                result.push(l2.pop());\n              \
    \              } else if l2.len() == 0 {\n                                result.push(l1.pop());\n\
    \                            } else {\n                                if l1.len()\
    \ == l2.len() {\n                                    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                                    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                                }\n                            }\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvf5ufm1y.rs:44:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n44 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    let mut l2 = l2.clone();\n\
    \    while l1.len() != l2.len() {\n        let mut i = 0;\n        let mut j =\
    \ 0;\n        while i < l1.len() && j < l2.len() {\n            if l1[i] < l2[j]\
    \ {\n                result.push(l1[i]);\n                i += 1;\n          \
    \  } else {\n                result.push(l2[j]);\n                j += 1;\n  \
    \          }\n        }\n        if i == l1.len() {\n            result.push(l2[j]);\n\
    \            j += 1;\n        }\n        if j == l2.len() {\n            result.push(l1[i]);\n\
    \            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp95rumm9t.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            if l1[0] < l2[0] {\n   \
    \             l3.push(l1[0]);\n                l1.pop();\n            } else {\n\
    \                l3.push(l2[0]);\n                l2.pop();\n            }\n \
    \       }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpwhdcdm0_.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            result.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 && l2.len() != 0 {\n      \
    \          if l1[0] < l2[0] {\n                    result.push(l1[0]);\n     \
    \               l1.pop();\n                } else {\n                    result.push(l2[0]);\n\
    \                    l2.pop();\n                }\n                i += 1;\n \
    \           }\n            while l1.len() != 0 {\n                result.push(l1[0]);\n\
    \                l1.pop();\n                i += 1;\n            }\n         \
    \   while l2.len() != 0 {\n                result.push(l2[0]);\n             \
    \   l2.pop();\n                i += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        let mut l1_iter = l1.iter();\n        let mut\
    \ l2_iter = l2.iter();\n        if l1.len() != 0 {\n            if l2.len() !=\
    \ 0 {\n                if l1_iter.next().unwrap() == l2_iter.next().unwrap() {\n\
    \                    result.push(l1_iter.next().unwrap());\n                 \
    \   l1.pop();\n                    l2.pop();\n                } else {\n     \
    \               l1.pop();\n                }\n            } else {\n         \
    \       l1.pop();\n            }\n        } else {\n            l2.pop();\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpezub5sqc.rs:29:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n29 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        let mut i = 0;\n        let\
    \ mut j = 0;\n        while l1.len() > 0 && l2.len() > 0 {\n            if l1[0]\
    \ < l2[0] {\n                result.push(l1[0]);\n                l1.remove(0);\n\
    \            } else {\n                result.push(l2[0]);\n                l2.remove(0);\n\
    \            }\n            i += 1;\n            j += 1;\n        }\n        if\
    \ l1.len() > 0 {\n            result.push(l1[0]);\n            l1.remove(0);\n\
    \        }\n        if l2.len() > 0 {\n            result.push(l2[0]);\n     \
    \       l2.remove(0);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 5, 7, 1, 5, 9, 34, 653, 121, 653, 2, 5]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmp3q1srrcs.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut result = Vec::new();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            result.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            if l1[0] < l2[0] {\n   \
    \             result.push(l1[0]);\n                l1.pop();\n            } else\
    \ {\n                result.push(l2[0]);\n                l2.pop();\n        \
    \    }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpzw3dkjm4.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut i = 0;\n    while\
    \ i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n            result.push(l1[i]);\n\
    \            i += 1;\n        } else {\n            if l1[i] > l2[i] {\n     \
    \           i += 1;\n            } else {\n                i += 1;\n         \
    \   }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpr1fbhpf1.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() > 0 || l4.len() > 0 {\n    \
    \    if l3.len() > 0 {\n            if l4.len() > 0 {\n                if l3[0]\
    \ == l4[0] {\n                    l3.remove(0);\n                    l4.remove(0);\n\
    \                } else {\n                    l3.remove(0);\n               \
    \ }\n            } else {\n                l3.remove(0);\n            }\n    \
    \    } else {\n            l4.remove(0);\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpt_l1px3z.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut common = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l2.pop();\n        } else if l2.len() == 0 {\n            l1.pop();\n \
    \       } else {\n            let mut l1_el = l1.pop();\n            let mut l2_el\
    \ = l2.pop();\n            while l1_el == l2_el {\n                common.push(l1_el);\n\
    \                l1_el = l1.pop();\n                l2_el = l2.pop();\n      \
    \      }\n        }\n    }\n    common\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi35dblwc.rs:25:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     common\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        let mut l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n        if\
    \ l1.len() > 0 {\n            if l2.len() > 0 {\n                while l1_iter.next().unwrap()\
    \ != l2_iter.next().unwrap() {\n                    l1.pop();\n              \
    \      l2.pop();\n                }\n            }\n            else {\n     \
    \           while l1_iter.next().unwrap() != l1_iter.next().unwrap() {\n     \
    \               l1.pop();\n                }\n            }\n        }\n     \
    \   else {\n            if l2.len() > 0 {\n                while l2_iter.next().unwrap()\
    \ != l2_iter.next().unwrap() {\n                    l2.pop();\n              \
    \  }\n            }\n            else {\n                while l2_iter.next().unwrap()\
    \ != l2_iter.next().unwrap() {\n                    l2.pop();\n              \
    \  }\n            }\n        }\n        result.push(l1.pop());\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `next` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpu49j87pp.rs:15:31\n   |\n15 |                 while\
    \ l1_iter.next().unwrap() != l2_iter.next().unwrap() {\n   |                 \
    \              ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method\
    \ named `next` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpu49j87pp.rs:15:58\n\
    \   |\n15 |                 while l1_iter.next().unwrap() != l2_iter.next().unwrap()\
    \ {\n   |                                                          ^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `next` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpu49j87pp.rs:21:31\n\
    \   |\n21 |                 while l1_iter.next().unwrap() != l1_iter.next().unwrap()\
    \ {\n   |                               ^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `next` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpu49j87pp.rs:21:58\n   |\n21 |                 while l1_iter.next().unwrap()\
    \ != l1_iter.next().unwrap() {\n   |                                         \
    \                 ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method\
    \ named `next` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpu49j87pp.rs:28:31\n\
    \   |\n28 |                 while l2_iter.next().unwrap() != l2_iter.next().unwrap()\
    \ {\n   |                               ^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `next` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpu49j87pp.rs:28:58\n   |\n28 |                 while l2_iter.next().unwrap()\
    \ != l2_iter.next().unwrap() {\n   |                                         \
    \                 ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method\
    \ named `next` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpu49j87pp.rs:33:31\n\
    \   |\n33 |                 while l2_iter.next().unwrap() != l2_iter.next().unwrap()\
    \ {\n   |                               ^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: "
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    let mut l2 = l2.clone();\n\
    \    let mut i = 0;\n    while i < l1.len() && i < l2.len() {\n        if l1[i]\
    \ == l2[i] {\n            result.push(i);\n            i += 1;\n        } else\
    \ {\n            if l1[i] > l2[i] {\n                i += 1;\n            } else\
    \ {\n                i += 1;\n            }\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpti0lrktl.rs:12:25\n   |\n\
    12 |             result.push(i);\n   |                         ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n12 |             result.push(i.try_into().unwrap());\n\
    \   |                          ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpgwk6zrt0.rs:19:23\n   |\n19 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpgwk6zrt0.rs:19:37\n   |\n19\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgwk6zrt0.rs:30:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    let mut l3 = l2.clone();\n\
    \    let mut l4 = l1.clone();\n    while l4.len() > 0 {\n        let mut l5 =\
    \ l4.clone();\n        while l5.len() > 0 {\n            if l5[0] < l3[0] {\n\
    \                result.swap(0, 0);\n                l4.swap(0, 0);\n        \
    \        l5.swap(0, 0);\n            }\n            if l5[0] > l3[0] {\n     \
    \           break;\n            }\n            l5.swap(0, 1);\n        }\n   \
    \     l3.swap(0, 1);\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(*l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(*l1.pop());\n    \
    \    } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if *l1.front() == *l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(*l1.pop());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpi9d1xd16.rs:12:25\n\
    \   |\n12 |             result.push(*l2.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmpi9d1xd16.rs:14:25\n   |\n14 |             result.push(*l1.pop());\n\
    \   |                         ^^^^^^^^^\n\nerror[E0599]: no method named `front`\
    \ found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpi9d1xd16.rs:19:24\n\
    \   |\n19 |                 if *l1.front() == *l2.front() {\n   |            \
    \            ^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method\
    \ named `front` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpi9d1xd16.rs:19:39\n\
    \   |\n19 |                 if *l1.front() == *l2.front() {\n   |            \
    \                           ^^^^^ method not found in `Vec<isize>`\n\nerror[E0614]:\
    \ type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpi9d1xd16.rs:26:25\n\
    \   |\n26 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            if l1[0] < l2[0] {\n   \
    \             l3.push(l1[0]);\n                l1.pop();\n            } else {\n\
    \                l3.push(l2[0]);\n                l2.pop();\n            }\n \
    \       }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpzbs8yq64.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l3_iter = l3.iter_mut();\n            let\
    \ mut l3_iter = l3_iter.zip2(l1, l2).collect();\n            let mut l3_iter =\
    \ l3_iter.filter(|&(_, y)| y != None);\n            let mut l3_iter = l3_iter.map(|&(_,\
    \ y)| y.unwrap());\n            l3_iter.sort();\n            l3.extend(l3_iter);\n\
    \        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `zip2` found for struct `std::slice::IterMut`\
    \ in the current scope\n  --> /tmp/tmp51f4f7tl.rs:17:39\n   |\n17 |          \
    \   let mut l3_iter = l3_iter.zip2(l1, l2).collect();\n   |                  \
    \                     ^^^^ method not found in `std::slice::IterMut<'_, Option<isize>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp51f4f7tl.rs:24:5\n   |\n6  | fn\
    \ common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |               \
    \                               ---------- expected `Vec<isize>` because of return\
    \ type\n...\n24 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2[0]);\n\
    \            l2.remove(0);\n        } else if l2.len() == 0 {\n            result.push(l1[0]);\n\
    \            l1.remove(0);\n        } else {\n            let mut l1_iter = l1.iter().cloned();\n\
    \            let mut l2_iter = l2.iter().cloned();\n            let mut l1_next\
    \ = l1_iter.next();\n            let mut l2_next = l2_iter.next();\n         \
    \   while l1_next.unwrap() != l2_next.unwrap() {\n                if l1_next.unwrap()\
    \ < l2_next.unwrap() {\n                    result.push(l1_next.unwrap());\n \
    \                   l1_next = l1_iter.next();\n                } else {\n    \
    \                result.push(l2_next.unwrap());\n                    l2_next =\
    \ l2_iter.next();\n                }\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1[0] < l2[0] {\n                    result.push(l1.pop());\n    \
    \            } else {\n                    result.push(l2.pop());\n          \
    \      }\n                i += 1;\n            }\n            while l1.len() >\
    \ 0 {\n                result.push(l1.pop());\n                i += 1;\n     \
    \       }\n            while l2.len() > 0 {\n                result.push(l2.pop());\n\
    \                i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmg8jwzr_.rs:37:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n37 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        let mut i = 0;\n        let mut j = 0;\n  \
    \      while l1.len() != 0 && l2.len() != 0 {\n            if l1[0] < l2[0] {\n\
    \                result.push(l1[0]);\n                l1.remove(0);\n        \
    \    } else {\n                result.push(l2[0]);\n                l2.remove(0);\n\
    \            }\n            i += 1;\n            j += 1;\n        }\n        if\
    \ l1.len() != 0 {\n            result.push(l1[0]);\n            l1.remove(0);\n\
    \        }\n        if l2.len() != 0 {\n            result.push(l2[0]);\n    \
    \        l2.remove(0);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 5, 7, 1, 5, 9, 34, 653, 121, 653, 2, 5]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmp_4h8y6jv.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            result.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0 {\n      \
    \          if l1.len() == 0 {\n                    result.push(l2[i]);\n     \
    \               l2.pop();\n                } else if l2.len() == 0 {\n       \
    \             result.push(l1[i]);\n                    l1.pop();\n           \
    \     } else {\n                    if l1[0] < l2[0] {\n                     \
    \   result.push(l1[0]);\n                        l1.pop();\n                 \
    \   } else {\n                        result.push(l2[0]);\n                  \
    \      l2.pop();\n                    }\n                }\n                i\
    \ += 1;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 7 but the index\
    \ is 7', /tmp/tmp47fwfd6e.rs:23:33\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1_el = l1.pop();\n\
    \            let mut l2_el = l2.pop();\n            while l1_el == l2_el {\n \
    \               l1_el = l1.pop();\n                l2_el = l2.pop();\n       \
    \     }\n            result.push(l1_el);\n            result.push(l2_el);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7lpf_h98.rs:26:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut l3 = l1.clone();\n    let mut l4\
    \ = l2.clone();\n    while l3.len() > 0 || l4.len() > 0 {\n        if l3.len()\
    \ == 0 {\n            l3.push(0);\n            l4.push(0);\n        }\n      \
    \  if l4.len() == 0 {\n            l4.push(0);\n            l3.push(0);\n    \
    \    }\n        if l3[0] == l4[0] {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            l3.pop();\n            l4.pop();\n            l3.push(0);\n\
    \            l4.push(0);\n        }\n    }\n    l3.into_iter().collect()\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmp0ey5pyhc.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.ded\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `ded` on type `Vec<isize>`\n  --> /tmp/tmpfo7w0u37.rs:99:8\n\
    \   |\n99 |     l3.ded\n   |        ^^^ unknown field\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0609`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpgc3rssdx.rs:19:23\n   |\n19 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpgc3rssdx.rs:19:37\n   |\n19\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgc3rssdx.rs:30:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.retain(l2.clone());\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(&isize,)>` closure, found `Vec<isize>`\n\
    \    --> /tmp/tmp2pl2gfgx.rs:9:15\n     |\n9    |     l3.retain(l2.clone());\n\
    \     |        ------ ^^^^^^^^^^ expected an `FnMut<(&isize,)>` closure, found\
    \ `Vec<isize>`\n     |        |\n     |        required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `for<'r> FnMut<(&'r isize,)>` is\
    \ not implemented for `Vec<isize>`\nnote: required by a bound in `Vec::<T, A>::retain`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() > 0 || l4.len() > 0 {\n    \
    \    if l3.len() == 0 {\n            l3.pop();\n            l4.pop();\n      \
    \  }\n        if l4.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        }\n        if l3[0] == l4[0] {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            l3.pop();\n            l4.pop();\n        }\n \
    \   }\n    l1.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp33vr0ke7.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1[0] < l2[0] {\n                    result.push(l1.pop());\n    \
    \            } else {\n                    result.push(l2.pop());\n          \
    \      }\n                i += 1;\n            }\n            while l1.len() >\
    \ 0 {\n                result.push(l1.pop());\n                i += 1;\n     \
    \       }\n            while l2.len() > 0 {\n                result.push(l2.pop());\n\
    \                i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqw98st3i.rs:37:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n37 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    l1.sort();\n    l2.sort();\n\
    \    let mut l3 = Vec::new();\n    while l1.len() > 0 || l2.len() > 0 {\n    \
    \    if l1.len() == 0 {\n            l3.push(l2[0]);\n            l2.pop();\n\
    \        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n            l1.pop();\n\
    \        } else {\n            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n\
    \                l1.pop();\n            } else {\n                l3.push(l2[0]);\n\
    \                l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpohriliqo.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 && l2.len() != 0 {\n      \
    \          if l1.front() == l2.front() {\n                    l1.pop();\n    \
    \                l2.pop();\n                } else {\n                    i +=\
    \ 1;\n                }\n            }\n            result.push(l1.pop());\n \
    \           result.push(l2.pop());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpt0qz5bhh.rs:20:23\n   |\n20 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpt0qz5bhh.rs:20:37\n   |\n20\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt0qz5bhh.rs:31:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n31 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            if l1[0] < l2[0] {\n   \
    \             l3.push(l1[0]);\n                l1.pop();\n            } else {\n\
    \                l3.push(l2[0]);\n                l2.pop();\n            }\n \
    \       }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpjk4k1v84.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  if l1.len() == l2.len() {\n                while l1.len() > 0 && l2.len() >\
    \ 0 {\n                    if l1.pop() == l2.pop() {\n                       \
    \ continue;\n                    }\n                    break;\n             \
    \   }\n                while l1.len() > 0 {\n                    result.push(l1.pop());\n\
    \                }\n                while l2.len() > 0 {\n                   \
    \ result.push(l2.pop());\n                }\n            } else {\n          \
    \      while l1.len() > 0 && l2.len() > 0 {\n                    if l1.pop() ==\
    \ l2.pop() {\n                        continue;\n                    }\n     \
    \               break;\n                }\n                while l1.len() > 0\
    \ {\n                    result.push(l1.pop());\n                }\n         \
    \       while l2.len() > 0 {\n                    result.push(l2.pop());\n   \
    \             }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxaua1z19.rs:47:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n47 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut k = l1.len();\n    let mut l = l2.len();\n    while i < l && j < k {\n \
    \       if l1[i] == l2[j] {\n            i += 1;\n            j += 1;\n      \
    \  } else {\n            if l1[i] < l2[j] {\n                i += 1;\n       \
    \     } else {\n                j += 1;\n            }\n        }\n    }\n   \
    \ l1.truncate(i);\n    l2.truncate(i);\n    l1.extend(l2.into_iter().filter(|&x|\
    \ x == l1.first()));\n    l2\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9hyw_kvd.rs:29:47\n   |\n\
    29 |     l1.extend(l2.into_iter().filter(|&x| x == l1.first()));\n   |       \
    \                                        ^^^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            result.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1[0] < l2[0] {\n\
    \                    result.push(l1[0]);\n                    l1.pop();\n    \
    \            } else {\n                    result.push(l2[0]);\n             \
    \       l2.pop();\n                }\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            result.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1[0] < l2[0] {\n                    result.push(l1[0]);\n       \
    \             l1.pop();\n                } else {\n                    result.push(l2[0]);\n\
    \                    l2.pop();\n                }\n                i += 1;\n \
    \           }\n            while l1.len() > 0 {\n                result.push(l1[0]);\n\
    \                l1.pop();\n                i += 1;\n            }\n         \
    \   while l2.len() > 0 {\n                result.push(l2[0]);\n              \
    \  l2.pop();\n                i += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            if l1[0] < l2[0] {\n   \
    \             l3.push(l1[0]);\n                l1.pop();\n            } else {\n\
    \                l3.push(l2[0]);\n                l2.pop();\n            }\n \
    \       }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpi6v0_xgq.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    let mut l3 = l2.clone();\n\
    \    let mut l4 = l1.clone();\n    let mut l5 = l2.clone();\n    while l4.len()\
    \ > 0 || l5.len() > 0 {\n        if l4.len() > 0 {\n            if l5.len() >\
    \ 0 {\n                if l4[0] == l5[0] {\n                    l4.pop();\n  \
    \                  l5.pop();\n                } else {\n                    result.push(*l4.pop());\n\
    \                }\n            } else {\n                result.push(*l4.pop());\n\
    \            }\n        }\n        if l5.len() > 0 {\n            if l4.len()\
    \ > 0 {\n                if l5[0] == l4[0] {\n                    l5.pop();\n\
    \                    l4.pop();\n                } else {\n                   \
    \ result.push(*l5.pop());\n                }\n            } else {\n         \
    \       result.push(*l5.pop());\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpsoujxpgx.rs:18:33\n\
    \   |\n18 |                     result.push(*l4.pop());\n   |                \
    \                 ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n\
    \  --> /tmp/tmpsoujxpgx.rs:21:29\n   |\n21 |                 result.push(*l4.pop());\n\
    \   |                             ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpsoujxpgx.rs:30:33\n   |\n30 |        \
    \             result.push(*l5.pop());\n   |                                 ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpsoujxpgx.rs:33:29\n\
    \   |\n33 |                 result.push(*l5.pop());\n   |                    \
    \         ^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmppj0wa5f7.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    let mut l3 = l2.clone();\n\
    \    let mut l4 = l1.clone();\n    let mut l5 = l2.clone();\n    while l4.len()\
    \ > 0 || l5.len() > 0 {\n        if l4.len() == 0 {\n            l3.pop();\n \
    \           l4.pop();\n        }\n        if l5.len() == 0 {\n            l4.pop();\n\
    \            l5.pop();\n        }\n        if l4[0] == l5[0] {\n            result.remove(l4[0]);\n\
    \            l4.pop();\n            l5.pop();\n        } else {\n            l4.pop();\n\
    \            l5.pop();\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl_lzoh_x.rs:21:27\n   |\n\
    21 |             result.remove(l4[0]);\n   |                           ^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n21 |             result.remove(l4[0].try_into().unwrap());\n\
    \   |                                ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        let mut found = false;\n        if l1.len() >\
    \ 0 {\n            if l2.len() > 0 {\n                if l1.pop().unwrap() ==\
    \ l2.pop().unwrap() {\n                    found = true;\n                }\n\
    \            } else {\n                found = true;\n            }\n        }\n\
    \        if !found {\n            result.push(*l1.pop());\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp7nm9qtt3.rs:22:25\n\
    \   |\n22 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpwj4ohlzc.rs:24:27\n   |\n24 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwj4ohlzc.rs:24:41\n\
    \   |\n24 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwj4ohlzc.rs:34:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n34 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpygbstmgj.rs:19:23\n   |\n19 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpygbstmgj.rs:19:37\n   |\n19\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpygbstmgj.rs:29:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n29 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 && l1.front()\
    \ == l2.front() {\n                l1.pop();\n                l2.pop();\n    \
    \            i += 1;\n            }\n            result.push(l1.pop());\n    \
    \        result.push(l2.pop());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp0h8ejs7t.rs:19:54\n   |\n19 |             while\
    \ l1.len() > 0 && l2.len() > 0 && l1.front() == l2.front() {\n   |           \
    \                                           ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp0h8ejs7t.rs:19:68\n   |\n19 |             while l1.len()\
    \ > 0 && l2.len() > 0 && l1.front() == l2.front() {\n   |                    \
    \                                                ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0h8ejs7t.rs:28:5\n   |\n6  | fn\
    \ common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |               \
    \                               ---------- expected `Vec<isize>` because of return\
    \ type\n...\n28 |     result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(0);\n            l4.push(0);\n\
    \        }\n        if l4.len() == 0 {\n            l4.push(0);\n        }\n \
    \       let mut l3_iter = l3.iter();\n        let mut l4_iter = l4.iter();\n \
    \       let mut l3_next = l3_iter.next();\n        let mut l4_next = l4_iter.next();\n\
    \        while l3_next.unwrap() != l4_next.unwrap() {\n            if l3_next.unwrap()\
    \ < l4_next.unwrap() {\n                l3.push(l3_next.unwrap());\n         \
    \       l3_next = l3_iter.next();\n            } else {\n                l4.push(l4_next.unwrap());\n\
    \                l4_next = l4_iter.next();\n            }\n        }\n    }\n\
    \    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphxahvbt4.rs:25:25\n   |\n\
    25 |                 l3.push(l3_next.unwrap());\n   |                        \
    \ ^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n25 |                 l3.push(*l3_next.unwrap());\n   |   \
    \                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphxahvbt4.rs:28:25\n\
    \   |\n28 |                 l4.push(l4_next.unwrap());\n   |                 \
    \        ^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n28 |                 l4.push(*l4_next.unwrap());\n\
    \   |                         +\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            let mut l3_iter = l3.iter();\n            let mut\
    \ l4_iter = l4.iter();\n            let mut l3_next = l3_iter.next();\n      \
    \      let mut l4_next = l4_iter.next();\n            while l3_next.unwrap() !=\
    \ l4_next.unwrap() {\n                let mut l3_cur = l3_next.unwrap();\n   \
    \             let mut l4_cur = l4_next.unwrap();\n                while l3_cur.unwrap()\
    \ != l4_cur.unwrap() {\n                    l3_cur = l3_iter.next();\n       \
    \             l4_cur = l4_iter.next();\n                }\n                l3_next\
    \ = l3_iter.next();\n                l4_next = l4_iter.next();\n            }\n\
    \            l3.pop();\n            l4.pop();\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmp2094pud0.rs:26:30\n   |\n26 |             \
    \    while l3_cur.unwrap() != l4_cur.unwrap() {\n   |                        \
    \      ^^^^^^ method not found in `&isize`\n\nerror[E0599]: no method named `unwrap`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmp2094pud0.rs:26:49\n\
    \   |\n26 |                 while l3_cur.unwrap() != l4_cur.unwrap() {\n   | \
    \                                                ^^^^^^ method not found in `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2094pud0.rs:27:30\n   |\n24 |\
    \                 let mut l3_cur = l3_next.unwrap();\n   |                   \
    \               ---------------- expected due to this value\n...\n27 |       \
    \              l3_cur = l3_iter.next();\n   |                              ^^^^^^^^^^^^^^\
    \ expected `&isize`, found enum `Option`\n   |\n   = note: expected reference\
    \ `&isize`\n                   found enum `Option<&isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2094pud0.rs:28:30\n   |\n25 |                 let mut l4_cur\
    \ = l4_next.unwrap();\n   |                                  ----------------\
    \ expected due to this value\n...\n28 |                     l4_cur = l4_iter.next();\n\
    \   |                              ^^^^^^^^^^^^^^ expected `&isize`, found enum\
    \ `Option`\n   |\n   = note: expected reference `&isize`\n                   found\
    \ enum `Option<&isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            result.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1[0] < l2[0] {\n                    result.push(l1[0]);\n       \
    \             l1.pop();\n                } else {\n                    result.push(l2[0]);\n\
    \                    l2.pop();\n                }\n                i += 1;\n \
    \           }\n            while l1.len() > 0 {\n                result.push(l1[0]);\n\
    \                l1.pop();\n                i += 1;\n            }\n         \
    \   while l2.len() > 0 {\n                result.push(l2[0]);\n              \
    \  l2.pop();\n                i += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.front() == l2.front() {\n               \
    \ l3.push(l1.pop());\n                l1.pop();\n            } else {\n      \
    \          l3.push(l1.pop());\n                l2.pop();\n            }\n    \
    \    }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpqsx0vj7c.rs:16:19\n   |\n16 |             if\
    \ l1.front() == l2.front() {\n   |                   ^^^^^ method not found in\
    \ `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpqsx0vj7c.rs:16:33\n   |\n16 |          \
    \   if l1.front() == l2.front() {\n   |                                 ^^^^^\
    \ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqsx0vj7c.rs:25:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n25 |     l3\n   |     ^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    let mut l3 = l2.clone();\n\
    \    let mut l4 = l1.clone();\n    let mut l5 = l2.clone();\n    let mut l6 =\
    \ l1.clone();\n    let mut l7 = l2.clone();\n    let mut l8 = l1.clone();\n  \
    \  let mut l9 = l2.clone();\n    let mut l10 = l1.clone();\n    let mut l11 =\
    \ l2.clone();\n    let mut l12 = l1.clone();\n    let mut l13 = l2.clone();\n\
    \    let mut l14 = l1.clone();\n    let mut l15 = l2.clone();\n    let mut l16\
    \ = l1.clone();\n    let mut l17 = l2.clone();\n    let mut l18 = l1.clone();\n\
    \    let mut l19 = l2.clone();\n    let mut l20 = l1.clone();\n    let mut l21\
    \ = l2.clone();\n    let mut l22 = l1.clone();\n    let mut l23 = l2.clone();\n\
    \    let mut l24 = l1.clone();\n    let mut l25 = l2.clone();\n    let mut l26\
    \ = l1.clone();\n    let mut l27 = l2.clone();\n    let mut l28 = l1.clone();\n\
    \    let mut l29 = l2.clone();\n    let mut l30 = l1.clone();\n    let mut l31\
    \ = l2.clone();\n    let mut l32 = l1.clone();\n    let mut l33 = l2.clone();\n\
    \    let mut l34 = l1.clone();\n    let mut l35 = l2.clone();\n    let mut l36\
    \ = l1.clone();\n    let mut l37 = l2.clone();\n    let mut l38 = l1.clone();\n\
    \    let mut l39 = l2.clone();\n    let mut l40 = l1.clone();\n    let mut l41\
    \ = l2.clone();\n    let mut l42 = l1.clone();\n    let mut l43 = l2.clone();\n\
    \    let mut l44 = l1.clone();\n    let mut l45 = l2.clone();\n    let mut l46\
    \ = l1.clone();\n    let mut l47 = l2.clone();\n    let mut l48 = l1.clone();\n\
    \    let mut l49 = l2.clone();\n    let mut l50 = l1.clone();\n    let mut l51\
    \ = l2.clone();\n    let mut l52 = l1.clone();\n    let mut l53 = l2.clone();\n\
    \    let mut l54\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpe8b639tw.rs:59:16\n   |\n\
    59 |     let mut l54\n   |                ^ help: add `;` here\n60 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpe8b639tw.rs:6:46\n\
    \  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------\
    \                                    ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit\
    \ type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut common = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      common.push(*l2.pop());\n        } else if l2.len() == 0 {\n          \
    \  common.push(*l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if *l1.front() == *l2.front()\
    \ {\n                    common.push(*l1.pop());\n                    l1.pop();\n\
    \                    l2.pop();\n                } else {\n                   \
    \ break;\n                }\n            }\n        }\n    }\n    common\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp9_jcih6j.rs:12:25\n\
    \   |\n12 |             common.push(*l2.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmp9_jcih6j.rs:14:25\n   |\n14 |             common.push(*l1.pop());\n\
    \   |                         ^^^^^^^^^\n\nerror[E0599]: no method named `front`\
    \ found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp9_jcih6j.rs:19:24\n\
    \   |\n19 |                 if *l1.front() == *l2.front() {\n   |            \
    \            ^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method\
    \ named `front` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp9_jcih6j.rs:19:39\n\
    \   |\n19 |                 if *l1.front() == *l2.front() {\n   |            \
    \                           ^^^^^ method not found in `Vec<isize>`\n\nerror[E0614]:\
    \ type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp9_jcih6j.rs:20:33\n\
    \   |\n20 |                     common.push(*l1.pop());\n   |                \
    \                 ^^^^^^^^^\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0599, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() > 0 || l4.len() > 0 {\n    \
    \    if l3.len() == 0 {\n            l3.pop();\n        }\n        if l4.len()\
    \ == 0 {\n            l4.pop();\n        }\n        if l3[0] == l4[0] {\n    \
    \        l3.pop();\n            l4.pop();\n        } else {\n            l3.pop();\n\
    \            l4.pop();\n        }\n    }\n    l1.iter().cloned().collect()\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpgxw1jgfm.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    l1.sort();\n    l2.sort();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut k = l1.len();\n    while\
    \ i < k {\n        if l1[i] < l2[j] {\n            i += 1;\n        } else {\n\
    \            j += 1;\n        }\n        if i == k {\n            i += 1;\n  \
    \          j += 1;\n        }\n    }\n    l1.drain(..i);\n    l2.drain(..j);\n\
    \    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 7 but the index\
    \ is 7', /tmp/tmpzwz91e6r.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpvckeleyc.rs:24:27\n   |\n24 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpvckeleyc.rs:24:41\n\
    \   |\n24 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvckeleyc.rs:34:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n34 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        let mut i = 0;\n        let mut j = 0;\n  \
    \      while l1.len() != 0 && l2.len() != 0 {\n            if l1[i] < l2[j] {\n\
    \                result.push(l1[i]);\n                l1.remove(&mut i);\n   \
    \         } else {\n                result.push(l2[j]);\n                l2.remove(&mut\
    \ j);\n            }\n        }\n        while l1.len() != 0 {\n            result.push(l1[i]);\n\
    \            l1.remove(&mut i);\n            i += 1;\n        }\n        while\
    \ l2.len() != 0 {\n            result.push(l2[j]);\n            l2.remove(&mut\
    \ j);\n            j += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvne4_v86.rs:16:27\n   |\n\
    16 |                 l1.remove(&mut i);\n   |                           ^^^^^^\
    \ expected `usize`, found `&mut usize`\n   |\nhelp: consider removing the borrow\n\
    \   |\n16 -                 l1.remove(&mut i);\n16 +                 l1.remove(i);\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvne4_v86.rs:19:27\n  \
    \ |\n19 |                 l2.remove(&mut j);\n   |                           ^^^^^^\
    \ expected `usize`, found `&mut usize`\n   |\nhelp: consider removing the borrow\n\
    \   |\n19 -                 l2.remove(&mut j);\n19 +                 l2.remove(j);\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvne4_v86.rs:24:23\n  \
    \ |\n24 |             l1.remove(&mut i);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&mut usize`\n   |\nhelp: consider removing the borrow\n   |\n\
    24 -             l1.remove(&mut i);\n24 +             l1.remove(i);\n   | \n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpvne4_v86.rs:29:23\n   |\n29 |  \
    \           l2.remove(&mut j);\n   |                       ^^^^^^ expected `usize`,\
    \ found `&mut usize`\n   |\nhelp: consider removing the borrow\n   |\n29 -   \
    \          l2.remove(&mut j);\n29 +             l2.remove(j);\n   | \n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    let mut l3 = l2.clone();\n\
    \    let mut l4 = l1.clone();\n    let mut l5 = l2.clone();\n    while l4.len()\
    \ > 0 || l5.len() > 0 {\n        if l4.len() > 0 {\n            if l5.len() >\
    \ 0 {\n                if l4[0] == l5[0] {\n                    l4.pop();\n  \
    \                  l5.pop();\n                } else {\n                    l4.sort();\n\
    \                    l5.sort();\n                    result.push(l4[0]);\n   \
    \                 l4.pop();\n                    l5.pop();\n                }\n\
    \            } else {\n                l4.sort();\n                result.push(l4[0]);\n\
    \                l4.pop();\n            }\n        } else {\n            l5.sort();\n\
    \            result.push(l5[0]);\n            l5.pop();\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpb90tsi0x.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1.front() == l2.front() {\n                    l1.pop();\n      \
    \              l2.pop();\n                } else {\n                    i += 1;\n\
    \                }\n            }\n            if l1.len() == 0 {\n          \
    \      result.push(l2.pop());\n            } else if l2.len() == 0 {\n       \
    \         result.push(l1.pop());\n            } else {\n                result.push(i);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpsi2cnugw.rs:20:23\n   |\n20 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpsi2cnugw.rs:20:37\n   |\n20\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsi2cnugw.rs:32:29\n   |\n32 |                 result.push(i);\n\
    \   |                             ^ expected enum `Option`, found integer\n  \
    \ |\n   = note: expected enum `Option<isize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n32 |                 result.push(Some(i));\n\
    \   |                             +++++ +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsi2cnugw.rs:36:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n36 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l1.len() == 1 {\n            if l2.len() == 1 {\n         \
    \       l3.pop();\n                l4.pop();\n            } else {\n         \
    \       l3.pop();\n                l4.pop();\n            }\n        } else if\
    \ l2.len() == 1 {\n            l3.pop();\n            l4.pop();\n        } else\
    \ {\n            let mut l5 = l3.clone();\n            let mut l6 = l4.clone();\n\
    \            while l5.len() != 0 || l6.len() != 0 {\n                if l5.len()\
    \ == 0 {\n                    l6.pop();\n                    l5.pop();\n     \
    \           } else if l6.len() == 0 {\n                    l6.pop();\n       \
    \             l5.pop();\n                } else if l5.len() == 1 {\n         \
    \           if l6.len() == 1 {\n                        l6.pop();\n          \
    \              l5.pop();\n                    } else {\n                     \
    \   l6.pop();\n                        l5.pop();\n                    }\n    \
    \            } else {\n                    let mut l7 = l6.clone();\n        \
    \            let mut l8 = l5.clone();\n                    while l7.len() != 0\
    \ || l8.len() != 0 {\n                        if l7.len() == 0 {\n           \
    \                 l8.pop();\n                            l7.pop();\n         \
    \               } else if l8.len() == 0 {\n                            l8.pop();\n\
    \                            l7.pop();\n                        } else if l7.len()\
    \ == 1 {\n                            if l8.len() == 1 {\n                   \
    \             l8.pop();\n                                l7.pop();\n         \
    \                   } else {\n                                l8.pop();\n    \
    \                            l7.pop();\n                            }\n      \
    \                  } else {\n                            let mut l9 = l8.clone();\n\
    \                            let mut l10 = l7.clone();\n                     \
    \       while l9.len() != 0 || l10.len() != 0 {\n                            \
    \    if l9.len() == 0 {\n                                    l10.pop();\n    \
    \                                l9.pop();\n                                }\
    \ else if l10.len() == 0 {\n                                    l10.pop();\n \
    \                                   l9.pop();\n                              \
    \  } else if l9.len() == 1 {\n                                    if l10.len()\
    \ == 1 {\n                                        l10.pop();\n               \
    \                         l9.pop();\n                                    } else\
    \ {\n                                        l\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpgcvlecgw.rs:89:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n11 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n29 |         } else {\n   |\
    \                - unclosed delimiter\n...\n32 |             while l5.len() !=\
    \ 0 || l6.len() != 0 {\n   |                                                 \
    \ - unclosed delimiter\n...\n47 |                 } else {\n   |             \
    \           - unclosed delimiter\n...\n50 |                     while l7.len()\
    \ != 0 || l8.len() != 0 {\n   |                                              \
    \            - unclosed delimiter\n...\n65 |                         } else {\n\
    \   |                                - unclosed delimiter\n...\n68 |         \
    \                    while l9.len() != 0 || l10.len() != 0 {\n   |           \
    \                                                        - unclosed delimiter\n\
    ...\n75 |                                 } else if l9.len() == 1 {\n   |    \
    \                                                     - unclosed delimiter\n...\n\
    79 |                                     } else {\n   |                      \
    \                      - this delimiter might not be properly closed...\n80 |\
    \                                         l\n81 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n89 | }\n   |   ^\n\nerror[E0425]: cannot\
    \ find value `l` in this scope\n  --> /tmp/tmpgcvlecgw.rs:80:41\n   |\n80 | ...\
    \                   l\n   |                       ^ help: a local variable with\
    \ a similar name exists: `l1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgcvlecgw.rs:11:5\n\
    \   |\n6  |   fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |\
    \                                                ---------- expected `Vec<isize>`\
    \ because of return type\n...\n11 | /     while l1.len() != 0 || l2.len() != 0\
    \ {\n12 | |         if l1.len() == 0 {\n13 | |             l3.pop();\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.ded\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `ded` on type `Vec<isize>`\n  --> /tmp/tmp4y304o7x.rs:99:8\n\
    \   |\n99 |     l3.ded\n   |        ^^^ unknown field\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0609`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() > 0 || l4.len() > 0 {\n    \
    \    if l3.len() > 0 {\n            if l4.len() > 0 {\n                if l3[0]\
    \ == l4[0] {\n                    l3.remove(0);\n                    l4.remove(0);\n\
    \                } else {\n                    l3.remove(0);\n               \
    \ }\n            } else {\n                l3.remove(0);\n            }\n    \
    \    } else {\n            l4.remove(0);\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmp3e21yrmv.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.len() == l2.len() {\n                        let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n                        let mut\
    \ l2 = l2.iter().cloned().collect::<Vec<_>>();\n                        while\
    \ l1.len() != 0 || l2.len() != 0 {\n                            if l1.len() ==\
    \ 0 {\n                                result.push(l2.pop());\n              \
    \              } else if l2.len() == 0 {\n                                result.push(l1.pop());\n\
    \                            } else {\n                                if l1.len()\
    \ == l2.len() {\n                                    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                                    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                                }\n                            }\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph1w40zmb.rs:44:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n44 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        } else {\n            let mut\
    \ l3_iter = l3.iter();\n            let mut l4_iter = l4.iter();\n           \
    \ let mut l3_item = l3_iter.next();\n            let mut l4_item = l4_iter.next();\n\
    \            while l3_item.is_some() && l4_item.is_some() {\n                if\
    \ *l3_item.unwrap() < *l4_item.unwrap() {\n                    l3.push(l3_item.unwrap());\n\
    \                    l3_item = l3_iter.next();\n                } else {\n   \
    \                 l4.push(l4_item.unwrap());\n                    l4_item = l4_iter.next();\n\
    \                }\n            }\n            if l3_item.is_some() {\n      \
    \          l3.push(l3_item.unwrap());\n            }\n            if l4_item.is_some()\
    \ {\n                l4.push(l4_item.unwrap());\n            }\n        }\n  \
    \  }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpztwjq6p8.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpztwjq6p8.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpztwjq6p8.rs:23:29\n   |\n23 |  \
    \                   l3.push(l3_item.unwrap());\n   |                         \
    \    ^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n23 |                     l3.push(*l3_item.unwrap());\n   |\
    \                             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpztwjq6p8.rs:26:29\n\
    \   |\n26 |                     l4.push(l4_item.unwrap());\n   |             \
    \                ^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n26 |                     l4.push(*l4_item.unwrap());\n\
    \   |                             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpztwjq6p8.rs:31:25\n\
    \   |\n31 |                 l3.push(l3_item.unwrap());\n   |                 \
    \        ^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n31 |                 l3.push(*l3_item.unwrap());\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpztwjq6p8.rs:34:25\n\
    \   |\n34 |                 l4.push(l4_item.unwrap());\n   |                 \
    \        ^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n34 |                 l4.push(*l4_item.unwrap());\n\
    \   |                         +\n\nerror: aborting due to 6 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l3 = Vec::new();\n            while l1.len() != 0 || l2.len() != 0\
    \ {\n                if l1.len() == 0 {\n                    l3.push(l2.pop());\n\
    \                } else if l2.len() == 0 {\n                    l3.push(l1.pop());\n\
    \                } else {\n                    if l1.last() == l2.last() {\n \
    \                       l3.push(l1.pop());\n                        l3.push(l2.pop());\n\
    \                    } else {\n                        l3.push(l1.pop());\n  \
    \                  }\n                }\n            }\n        }\n    }\n   \
    \ l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpduf95ovy.rs:35:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n35 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut l3 = vec![];\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else if l1[0] < l2[0] {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            l3.push(l2[0]);\n      \
    \      l2.pop();\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpo5yn8vip.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut i = 0;\n    while i\
    \ < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n            result.push(l1[i]);\n\
    \            i += 1;\n        } else {\n            if l1[i] > l2[i] {\n     \
    \           i += 1;\n            } else {\n                i += 1;\n         \
    \   }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpv090d6ll.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        let mut i = 0;\n        let\
    \ mut j = 0;\n        while l1.len() > 0 && l2.len() > 0 {\n            if l1[0]\
    \ > l2[0] {\n                i += 1;\n                l1.pop();\n            }\
    \ else {\n                j += 1;\n                l2.pop();\n            }\n\
    \        }\n        if l1.len() > 0 {\n            result.push(l1[0]);\n     \
    \       l1.pop();\n        } else {\n            result.push(l2[0]);\n       \
    \     l2.pop();\n        }\n        if i > j {\n            result.push(i);\n\
    \            i += 1;\n        } else {\n            result.push(j);\n        \
    \    j += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 7, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]`,\n right: `[1, 5, 653]`', /tmp/tmp2uvaro4f.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 && l2.len() != 0 && l1.front()\
    \ == l2.front() {\n                i += 1;\n                l1.pop();\n      \
    \          l2.pop();\n            }\n            if l1.len() != 0 || l2.len()\
    \ != 0 {\n                result.push(i);\n            }\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpvv1ofu2e.rs:19:56\n   |\n19 |             while\
    \ l1.len() != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |         \
    \                                               ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpvv1ofu2e.rs:19:70\n   |\n19 |             while l1.len()\
    \ != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |                  \
    \                                                    ^^^^^ method not found in\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvv1ofu2e.rs:25:29\n\
    \   |\n25 |                 result.push(i);\n   |                            \
    \ ^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n25 |                 result.push(Some(i));\n   |                      \
    \       +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvv1ofu2e.rs:29:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n29 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<Option<isize>>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l3_iter = l3.iter_mut();\n            let\
    \ mut l3_iter = l3_iter.zip(l1.iter()).cloned().collect();\n            let mut\
    \ l3_iter = l3_iter.zip(l2.iter()).cloned().collect();\n            let mut l3_iter\
    \ = l3_iter.filter(|&(l, &r)| l == r).cloned().collect();\n            let mut\
    \ l3_iter = l3_iter.filter(|&(l, &r)| l < r).cloned().collect();\n           \
    \ let mut l3_iter = l3_iter.filter(|&(l, &r)| l > r).cloned().collect();\n   \
    \         let mut l3_iter = l3_iter.filter(|&(l, &r)| l == r).cloned().collect();\n\
    \            let mut l3_iter = l3_iter.filter(|&(l, &r)| l < r).cloned().collect();\n\
    \            let mut l3_iter = l3_iter.filter(|&(l, &r)| l > r).cloned().collect();\n\
    \            l3_iter.iter().cloned().for_each(|&(l, &r)| {\n                l3.push(l);\n\
    \            });\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Zip<std::slice::IterMut<'_, Option<isize>>,\
    \ std::slice::Iter<'_, isize>> as Iterator>::Item == &_`\n    --> /tmp/tmp3tl8ecky.rs:17:54\n\
    \     |\n17   |             let mut l3_iter = l3_iter.zip(l1.iter()).cloned().collect();\n\
    \     |                                                      ^^^^^^ expected reference,\
    \ found tuple\n     |\n     = note: expected reference `&_`\n                \
    \    found tuple `(&mut Option<isize>, &isize)`\nnote: required by a bound in\
    \ `cloned`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<Zip<std::slice::IterMut<'_,\
    \ Option<isize>>, std::slice::Iter<'_, isize>>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp3tl8ecky.rs:17:63\n   |\n17 |                let mut\
    \ l3_iter = l3_iter.zip(l1.iter()).cloned().collect();\n   |                 \
    \                                                 ^^^^^^^ method cannot be called\
    \ on `Cloned<Zip<std::slice::IterMut<'_, Option<isize>>, std::slice::Iter<'_,\
    \ isize>>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<Zip<std::slice::IterMut<'_, Option<isize>>,\
    \ std::slice::Iter<'_, isize>> as Iterator>::Item = &_`\n           which is required\
    \ by `Cloned<Zip<std::slice::IterMut<'_, Option<isize>>, std::slice::Iter<'_,\
    \ isize>>>: Iterator`\n           `Cloned<Zip<std::slice::IterMut<'_, Option<isize>>,\
    \ std::slice::Iter<'_, isize>>>: Iterator`\n           which is required by `&mut\
    \ Cloned<Zip<std::slice::IterMut<'_, Option<isize>>, std::slice::Iter<'_, isize>>>:\
    \ Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3tl8ecky.rs:30:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n30 |     l3\n   |     ^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0271, E0308, E0"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2[0]);\n\
    \            l2.pop();\n        } else if l2.len() == 0 {\n            result.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2[0]);\n                    l2.pop();\n    \
    \            } else if l2.len() == 0 {\n                    result.push(l1[0]);\n\
    \                    l1.pop();\n                } else {\n                   \
    \ let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n                    let\
    \ mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n                }\n      \
    \      }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    let mut l4 =\
    \ l2.clone();\n    l4.sort();\n    let mut l5 = l3.clone();\n    l5.sort();\n\
    \    let mut l6 = l4.clone();\n    l6.sort();\n    let mut l7 = l5.clone();\n\
    \    l7.sort();\n    let mut l8 = l6.clone();\n    l8.sort();\n    let mut l9\
    \ = l7.clone();\n    l9.sort();\n    let mut l10 = l8.clone();\n    l10.sort();\n\
    \    let mut l11 = l9.clone();\n    l11.sort();\n    let mut l12 = l10.clone();\n\
    \    l12.sort();\n    let mut l13 = l11.clone();\n    l13.sort();\n    let mut\
    \ l14 = l12.clone();\n    l14.sort();\n    let mut l15 = l13.clone();\n    l15.sort();\n\
    \    let mut l16 = l14.clone();\n    l16.sort();\n    let mut l17 = l15.clone();\n\
    \    l17.sort();\n    let mut l18 = l16.clone();\n    l18.sort();\n    let mut\
    \ l19 = l17.clone();\n    l19.sort();\n    let mut l20 = l18.clone();\n    l20.sort();\n\
    \    let mut l21 = l19.clone();\n    l21.sort();\n    let mut l22 = l20.clone();\n\
    \    l22.sort();\n    let mut l23 = l21.clone();\n    l23.sort();\n    let mut\
    \ l24 = l22.clone();\n    l24.sort();\n    let mut l25 = l23.clone();\n    l25.sort();\n\
    \    let mut l26 = l24.clone();\n    l26.sort();\n    let mut l27 = l25.clone();\n\
    \    l27.sort();\n    let mut l28 = l26.clone();\n    l28.sort();\n    let mut\
    \ l29 = l27.clone();\n    l29.sort();\n    let mut l30 = l28.clone();\n    l30.sort();\n\
    \    let mut l31 = l29.clone();\n    l31.sort();\n    let mut l32 = l30.clone();\n\
    \    l32.sort();\n    let mut l33 = l31.clone();\n    l33.sort();\n    let mut\
    \ l34 = l32.clone();\n    l34.sort();\n    let mut l35 = l33.clone();\n    l35.sort();\n\
    \    let mut l36 = l34.clone();\n    l36.sort();\n    let mut l37 = l35.clone();\n\
    \    l37.sort\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `sort` on type `Vec<isize>`\n\
    \  --> /tmp/tmpnhdy55cu.rs:76:9\n   |\n76 |     l37.sort\n   |         ^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n76 |    \
    \ l37.sort()\n   |             ++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpl6y6p5oz.rs:6:46\n  |\n6 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------   \
    \                                 ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit\
    \ type `()`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        } else {\n            let mut\
    \ l3_iter = l3.iter().cloned();\n            let mut l4_iter = l4.iter().cloned();\n\
    \            let mut l3_next = l3_iter.next();\n            let mut l4_next =\
    \ l4_iter.next();\n            while l3_next.unwrap() != l4_next.unwrap() {\n\
    \                if l3_next.unwrap() < l4_next.unwrap() {\n                  \
    \  l3.push(l3_next.unwrap());\n                    l3_next = l3_iter.next();\n\
    \                } else {\n                    l4.push(l4_next.unwrap());\n  \
    \                  l4_next = l4_iter.next();\n                }\n            }\n\
    \        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfqher8he.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfqher8he.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    }\n        if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        }\n        if l1.len() == 0 && l2.len() == 0 {\n            break;\n\
    \        }\n        if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        }\n        if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        }\n        if l1.len() == 0 && l2.len() == 0 {\n            break;\n\
    \        }\n        if l1.len() == 1 {\n            if l2.len() == 1 {\n     \
    \           l3.pop();\n                l4.pop();\n            }\n            else\
    \ {\n                l3.pop();\n                l4.pop();\n                l3.push(l4.pop());\n\
    \            }\n        }\n        if l2.len() == 1 {\n            if l1.len()\
    \ == 1 {\n                l3.pop();\n                l4.pop();\n            }\n\
    \            else {\n                l3.pop();\n                l4.pop();\n  \
    \              l3.push(l4.pop());\n            }\n        }\n        if l1.len()\
    \ == 1 && l2.len() == 1 {\n            if l1.pop() == l2.pop() {\n           \
    \     l3.pop();\n                l4.pop();\n            }\n            else {\n\
    \                l3.pop();\n                l4.pop();\n                l3.push(l4.pop());\n\
    \            }\n        }\n    }\n    l3.into_iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaexjcma5.rs:42:25\n   |\n\
    42 |                 l3.push(l4.pop());\n   |                         ^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpaexjcma5.rs:53:25\n   |\n53 |                 l3.push(l4.pop());\n\
    \   |                         ^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpaexjcma5.rs:64:25\n   |\n64 |\
    \                 l3.push(l4.pop());\n   |                         ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i] < l2[j]\
    \ {\n            result.push(l1[i]);\n            i += 1;\n        } else {\n\
    \            result.push(l2[j]);\n            j += 1;\n        }\n    }\n    while\
    \ i < l1.len() {\n        result.push(l1[i]);\n        i += 1;\n    }\n    while\
    \ j < l2.len() {\n        result.push(l2[j]);\n        j += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 5, 7, 1, 5, 9, 34, 653, 121, 653, 2, 5]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmpge2sry8y.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l3 = Vec::new();\n            while l1.len() > 0 || l2.len() > 0 {\n\
    \                if l1.len() == 0 {\n                    l3.push(l2.pop());\n\
    \                } else if l2.len() == 0 {\n                    l3.push(l1.pop());\n\
    \                } else {\n                    if l1.first() == l2.first() {\n\
    \                        l3.push(l1.pop());\n                        l3.push(l2.pop());\n\
    \                    } else {\n                        break;\n              \
    \      }\n                }\n            }\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `Option<isize>`\n    --> /tmp/tmp898agmye.rs:35:20\n \
    \    |\n35   |     l3.into_iter().collect()\n     |                    ^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=Option<isize>>`\n\
    \     |\n     = help: the trait `FromIterator<Option<isize>>` is not implemented\
    \ for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l2.pop();\n        } else if l2.len() == 0 {\n            l1.pop();\n\
    \        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0 {\n      \
    \          if l1.len() == 0 {\n                    l2.pop();\n               \
    \ } else if l2.len() == 0 {\n                    l1.pop();\n                }\
    \ else {\n                    if l1.len() == l2.len() {\n                    \
    \    result.push(*l1.pop());\n                        l1.pop();\n            \
    \            l2.pop();\n                    } else {\n                       \
    \ let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n                     \
    \   let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n                   \
    \     i += 1;\n                    }\n                }\n            }\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpgjdfywq_.rs:26:37\n\
    \   |\n26 |                         result.push(*l1.pop());\n   |            \
    \                         ^^^^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.pop() == l2.pop() {\n                l3.push(l1.pop());\n\
    \            } else {\n                break;\n            }\n        }\n    }\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk4opbnmk.rs:23:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n23 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut common: Vec<isize>\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n         \
    \   l1.pop();\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut common: Vec<isize> = Vec::new();\n            while l1.len() != 0 ||\
    \ l2.len() != 0 {\n                if l1.len() == 0 {\n                    l2.pop();\n\
    \                } else if l2.len() == 0 {\n                    l1.pop();\n  \
    \              } else {\n                    if l1.len() == l2.len() {\n     \
    \                   common = common.append(l1.pop());\n                    } else\
    \ {\n                        break;\n                    }\n                }\n\
    \            }\n        }\n    }\n    common\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp07hg9fbz.rs:26:48\n   |\n\
    26 |                         common = common.append(l1.pop());\n   |         \
    \                                       ^^^^^^^^ expected `&mut Vec<isize>`, found\
    \ enum `Option`\n   |\n   = note: expected mutable reference `&mut Vec<isize>`\n\
    \                           found enum `Option<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp07hg9fbz.rs:26:34\n   |\n18 |             let mut common:\
    \ Vec<isize> = Vec::new();\n   |                             ---------- expected\
    \ due to this type\n...\n26 |                         common = common.append(l1.pop());\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n         \
    \  found unit type `()`\nnote: method `append` modifies its receiver in-place\n\
    \  --> /tmp/tmp07hg9fbz.rs:26:41\n   |\n26 |                         common =\
    \ common.append(l1.pop());\n   |                                  ------ ^^^^^^\
    \ this call modifies `common` in-place\n   |                                 \
    \ |\n   |                                  you probably want to use this value\
    \ after calling the method...\n   = note: ...instead of the `()` output of method\
    \ `append`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0 {\n      \
    \          if l1.len() == 0 {\n                    result.push(l2.pop());\n  \
    \              } else if l2.len() == 0 {\n                    result.push(l1.pop());\n\
    \                } else {\n                    if l1.len() == l2.len() {\n   \
    \                     if l1.len() == 1 {\n                            result.push(l1.pop());\n\
    \                        } else {\n                            result.push(l1.pop());\n\
    \                            result.push(l2.pop());\n                        }\n\
    \                    } else {\n                        if l1.len() < l2.len()\
    \ {\n                            result.push(l1.pop());\n                    \
    \    } else {\n                            result.push(l2.pop());\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxdi7_su_.rs:43:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n43 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
