name: HumanEval_128_prod_signs
language: rust
results:
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut res = isize::one();\n    for x in arr {\n     \
    \   res *= x;\n        if x < 0 {\n            res = -res;\n        }\n    }\n\
    \    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpol703kct.rs:10:26\n   |\n10 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for &i in arr {\n        product *= i;\n    }\n \
    \   let mut res = product;\n    for i in arr {\n        res *= i;\n    }\n   \
    \ Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3luwvi1y.rs:14:9\n   |\n\
    14 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut product = arr.iter().product();\n    let mut sign\
    \ = 1;\n    for x in arr.iter() {\n        product *= sign;\n        sign *= x;\n\
    \    }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-128)`,\n right: `Some(-9)`', /tmp/tmpr0nj6y5h.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for &x in &arr {\n        product *= x;\n    }\n\
    \    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpvhrg_nk2.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        product\
    \ *= x;\n        sign *= match x {\n            1 => 1,\n            -1 => -1,\n\
    \            _ => 0,\n        };\n    }\n\n    Some(product * sign)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(0)`,\n right: `Some(-9)`', /tmp/tmpbxdkne67.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &i in &arr {\n        product *= i;\n  \
    \  }\n\n    if product < 0 {\n        Some(-product)\n    } else {\n        Some(product)\n\
    \    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpeb_ftjep.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut res = 0;\n    for &i in arr {\n        if *i < 0 {\n            res\
    \ -= 1;\n        } else {\n            res += 1;\n        }\n    }\n\n    Some(res)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsbt7ctnz.rs:15:9\n   |\n\
    15 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        product\
    \ *= x;\n        sign *= match x {\n            1 => 1,\n            -1 => -1,\n\
    \            _ => 0,\n        };\n    }\n    Some(product * sign)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(0)`,\n right: `Some(-9)`', /tmp/tmpzy7vikc9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 0;\n    for x in arr {\n        res += x * sign(x);\n    }\n    Some(res)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sign` in this scope\n  --> /tmp/tmprtz0d44v.rs:15:20\n\
    \   |\n15 |         res += x * sign(x);\n   |                    ^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for &i in arr {\n        product\
    \ *= i;\n        sign *= if i == -1 {\n            -1\n        } else {\n    \
    \        1\n        };\n    }\n    Some(product * sign)\n}\n\nfn main() {\n  \
    \  let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptwwt852h.rs:16:9\n   |\n\
    16 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sign = 1;\n    for x in arr {\n        prod *= x;\n\
    \        sign *= sign;\n    }\n    Some(prod * sign)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp0fhdqe86.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0] as isize;\n    for &i in arr {\n        product *= i as\
    \ isize;\n    }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8z48ph28.rs:14:9\n   |\n\
    14 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 0;\n    for i in arr {\n        res += if i < 0 {\n            1\n\
    \        } else {\n            -1\n        };\n    }\n    Some(res)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-2)`,\n right: `Some(-9)`', /tmp/tmpocgke5oe.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0] as isize;\n    for x in arr.iter().skip(1) {\n        product\
    \ *= x;\n    }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp79__l7a7.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for &i in arr {\n        product *= i;\n    }\n \
    \   Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1vqastob.rs:14:9\n   |\n\
    14 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        if x < 0 {\n            product\
    \ *= -1;\n        } else {\n            product *= 1;\n        }\n    }\n    Some(product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmp_2i_j5aq.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut product = arr[0];\n    for &x in arr.iter().rev()\
    \ {\n        product *= x;\n    }\n    Some(product)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpdnvq19zt.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        product\
    \ *= x;\n        sign *= if x < 0 { -1 } else { 1 };\n    }\n    Some(product\
    \ * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpv6gkh1uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        product *= x;\n    }\n    let\
    \ mut res = 0;\n    for x in arr {\n        res += x * product;\n    }\n    Some(res)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpc3htw686.rs:18:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n18  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n14  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for &i in &arr {\n        product *= i;\n    }\n\
    \    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpo_nsfxk_.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for &i in arr {\n        product *= i;\n    }\n    let\
    \ mut sum = 0;\n    for i in arr {\n        sum += if i == -1 {\n            -1\n\
    \        } else {\n            1\n        };\n    }\n    Some(product * sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwybex9j_.rs:14:9\n   |\n\
    14 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 0;\n    let mut sign = 1;\n    for x in arr {\n        res += x *\
    \ sign;\n        sign *= -1;\n    }\n    Some(res)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(5)`,\n right: `Some(-9)`', /tmp/tmpwnxg_nm4.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for &i in arr {\n        product *= i;\n    }\n \
    \   let mut sign = 1;\n    for &i in arr {\n        sign *= i;\n    }\n    Some(product\
    \ * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp86wsulwo.rs:14:9\n   |\n\
    14 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp86wsulwo.rs:18:9\n   |\n18 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for &x in &arr {\n        product *= x;\n    }\n\
    \    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmplcxlod0f.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &i in &arr {\n        product *= i;\n  \
    \  }\n\n    let mut res = product;\n    for i in &arr {\n        if *i < 0 {\n\
    \            res *= -1;\n        }\n    }\n\n    Some(res)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpard2p7nt.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    for x in arr {\n        prod *= x;\n    }\n    Some(prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpry5imjxt.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut prod = 1;\n    for x in arr {\n        prod *= x;\n    }\n\n    let\
    \ mut sum = 0;\n    for x in arr {\n        sum += x * prod;\n        prod *=\
    \ x;\n    }\n\n    Some(sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpsfvg36eo.rs:20:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n20  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n15  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        if\
    \ x < 0 {\n            product *= sign;\n            sign *= -1;\n        } else\
    \ {\n            product *= sign;\n        }\n        product *= x;\n    }\n \
    \   Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpvvyg1neg.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n\n    for x in arr {\n       \
    \ if x < 0 {\n            product *= -1;\n            sign *= -1;\n        } else\
    \ {\n            product *= 1;\n            sign *= 1;\n        }\n    }\n\n \
    \   Some(product * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(-9)`', /tmp/tmpwvh781l8.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        product\
    \ *= x;\n        sign *= sign;\n    }\n    Some(product * sign)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpxb77by6k.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0] as isize;\n    for &i in &arr {\n        product *=\
    \ i as isize;\n    }\n\n    Some(product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpc7q5rezz.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for i in arr.iter().rev() {\n        product\
    \ *= i;\n    }\n\n    let mut sum = 0;\n    for i in arr.iter().rev() {\n    \
    \    sum += if i == -1 {\n            -1\n        } else {\n            1\n  \
    \      };\n    }\n\n    Some(product * sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpq1cwpdd2.rs:21:21\n\
    \   |\n21 |         sum += if i == -1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0] as isize;\n    for x in arr.iter().rev() {\n     \
    \   product *= x;\n    }\n\n    let mut sum = 0;\n    for x in arr.iter() {\n\
    \        sum += if x < 0 {\n            -1\n        } else {\n            1\n\
    \        };\n    }\n\n    Some(product * sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb89vfsgs.rs:21:23\n   |\n\
    21 |         sum += if x < 0 {\n   |                       ^\n   |           \
    \            |\n   |                       expected `&isize`, found integer\n\
    \   |                       help: consider borrowing here: `&0`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut res = arr[0];\n    for i in 1..arr.len() {\n        res *= if arr[i]\
    \ < 0 { -1 } else { 1 };\n        res += arr[i];\n    }\n    Some(res)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpmt82hlyn.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for i in 1..arr.len() {\n        product *=\
    \ if arr[i] > 0 { 1 } else { -1 };\n    }\n    Some(product)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpd8hx99gy.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &i in arr {\n        product *= i;\n   \
    \ }\n\n    let mut magnitude = product;\n    for &i in arr {\n        magnitude\
    \ *= i;\n    }\n\n    Some(magnitude)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr403ascu.rs:15:9\n   |\n\
    15 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpr403ascu.rs:20:9\n   |\n20 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &x in &arr {\n        product *= x;\n  \
    \  }\n\n    let mut sign = 1;\n    for &x in &arr {\n        sign *= x;\n    }\n\
    \n    Some(product * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(256)`,\n right: `Some(-9)`', /tmp/tmpzijdaoyk.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    for x in arr {\n        if x < 0 {\n            prod *= -1;\n\
    \        }\n        prod *= x;\n    }\n    Some(prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpv3dmitf7.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for i in 1..arr.len() {\n        product *=\
    \ arr[i];\n    }\n\n    let mut sum = 0;\n    for i in 0..arr.len() {\n      \
    \  sum += if arr[i] >= 0 {\n            1\n        } else {\n            -1\n\
    \        };\n    }\n\n    Some(product * sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-32)`,\n right: `Some(-9)`', /tmp/tmpsyxz_5ma.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 0;\n    for i in arr {\n        res += if i < 0 {\n            1\n\
    \        } else {\n            -1\n        };\n    }\n    Some(res)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-2)`,\n right: `Some(-9)`', /tmp/tmp2ul1h1f7.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut res = 0;\n    let mut sign = 1;\n\n    for x in arr {\n        res\
    \ += x * sign;\n        sign *= -1;\n    }\n\n    Some(res)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(5)`,\n right: `Some(-9)`', /tmp/tmp8d2wcwnd.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 0;\n    for i in arr {\n        res += if i < 0 {\n            1\n\
    \        } else {\n            -1\n        };\n    }\n    Some(res)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-2)`,\n right: `Some(-9)`', /tmp/tmpyhw70rr9.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &i in arr {\n        product *= i;\n   \
    \ }\n\n    let mut res = Some(0);\n    for &i in arr {\n        if i == -1 {\n\
    \            res = Some(-product);\n            break;\n        }\n        if\
    \ i == 1 {\n            res = Some(product);\n            break;\n        }\n\
    \    }\n\n    res\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxfjjx8t7.rs:15:9\n   |\n\
    15 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxfjjx8t7.rs:20:9\n   |\n20 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0] as isize;\n    for x in arr.iter().rev() {\n        product\
    \ *= x;\n    }\n    let mut sum = 0;\n    for x in arr.iter() {\n        sum +=\
    \ x * product;\n        product *= x;\n    }\n    Some(sum)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(144)`,\n right: `Some(-9)`', /tmp/tmpfcc7g4i7.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n\n    for x in arr.iter() {\n\
    \        if x < 0 {\n            product *= -1;\n            sign *= -1;\n   \
    \     } else {\n            product *= 1;\n            sign *= 1;\n        }\n\
    \    }\n\n    Some(product * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqb2mpf_8.rs:18:16\n   |\n\
    18 |         if x < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &i in &arr {\n        product *= i;\n  \
    \  }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n \
    \   assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp9j5g1t99.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut res = isize::one();\n    for &i in arr {\n        if i > 0 {\n    \
    \        res *= i;\n        }\n    }\n\n    Some(res)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpkzjo30mc.rs:14:26\n   |\n14 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkzjo30mc.rs:15:9\n   |\n15 |     for &i in arr {\n   |         ^^  \
    \  --- this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut res = 0;\n    for x in arr {\n        res += x\
    \ * sign(x);\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sign` in this scope\n  --> /tmp/tmp7n7li95g.rs:12:20\n\
    \   |\n12 |         res += x * sign(x);\n   |                    ^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for i in arr.iter().rev() {\n        product\
    \ *= i;\n    }\n\n    let mut res = Some(product);\n    for i in arr.iter().rev()\
    \ {\n        if *i < *product {\n            res = Some(product - *i);\n     \
    \       break;\n        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpl2z67jbj.rs:21:17\n\
    \   |\n21 |         if *i < *product {\n   |                 ^^^^^^^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for &i in arr {\n        product *= i;\n    }\n    let\
    \ mut res = 0;\n    for &i in arr {\n        res += i * (product * if i < 0 {\
    \ 1 } else { -1 });\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8kgibi_0.rs:14:9\n   |\n\
    14 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8kgibi_0.rs:18:9\n   |\n18 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &i in arr {\n        product *= i;\n   \
    \ }\n\n    let mut sign = 1;\n    for &i in arr {\n        if *i < 0 {\n     \
    \       *i = -(*i);\n            sign *= -1;\n        }\n    }\n\n    Some(product\
    \ * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpped3xj7q.rs:15:9\n   |\n\
    15 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpped3xj7q.rs:20:9\n   |\n20 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &i in arr {\n        product *= i;\n   \
    \ }\n\n    let mut sum = 0;\n    for i in arr {\n        sum += if i == -1 {\n\
    \            -1\n        } else if i == 1 {\n            1\n        } else {\n\
    \            0\n        };\n    }\n\n    Some(product * sum)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4yw5pdqg.rs:15:9\n   |\n\
    15 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for x in arr.iter().rev() {\n        product *= x;\n\
    \    }\n    let mut sum = 0;\n    for x in arr.iter() {\n        sum += x * product;\n\
    \        product *= x;\n    }\n    Some(sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(144)`,\n right: `Some(-9)`', /tmp/tmpcxse0c2q.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        if x <\
    \ 0 {\n            sign *= -1;\n        }\n        product *= x;\n    }\n    Some(sign\
    \ * product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmponax2ltw.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    for &x in arr {\n        product *= x;\n    }\n\n\
    \    let mut sum = 0;\n    for &x in arr {\n        sum += if x == -1 {\n    \
    \        -1\n        } else {\n            1\n        };\n    }\n\n    Some(product\
    \ * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqkd5exfo.rs:15:9\n   |\n\
    15 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqkd5exfo.rs:20:9\n   |\n20 |     for &x in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut res = vec![0];\n    for x in arr {\n        res.iter().for_each(|&x|\
    \ {\n            if x < 0 {\n                *x = -x;\n            }\n       \
    \ });\n        res.iter().for_each(|&x| {\n            *x = *x * x;\n        });\n\
    \    }\n    Some(res.iter().sum())\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp2hho5vk5.rs:14:17\n\
    \   |\n14 |                 *x = -x;\n   |                 ^^\n\nerror[E0614]:\
    \ type `{integer}` cannot be dereferenced\n  --> /tmp/tmp2hho5vk5.rs:18:13\n \
    \  |\n18 |             *x = *x * x;\n   |             ^^\n\nerror[E0614]: type\
    \ `{integer}` cannot be dereferenced\n  --> /tmp/tmp2hho5vk5.rs:18:18\n   |\n\
    18 |             *x = *x * x;\n   |                  ^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for &x in &arr {\n        product *= x;\n    }\n\
    \    let mut sum = 0;\n    for &x in &arr {\n        sum += if x < 0 {\n     \
    \       -1\n        } else {\n            1\n        };\n    }\n    Some(product\
    \ * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-32)`,\n right: `Some(-9)`', /tmp/tmpazry4aay.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr.iter().product();\n    let mut sign = 1;\n    for x in arr.iter()\
    \ {\n        if x < 0 {\n            product *= sign;\n        }\n        sign\
    \ *= -1;\n    }\n    Some(product as isize)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps37klwsz.rs:16:16\n   |\n\
    16 |         if x < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        product *= x;\n    }\n    let\
    \ mut sum = 0;\n    for x in arr {\n        sum += if x < 0 { -1 } else { 1 }\
    \ * x;\n    }\n    Some(product * sum)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmp74lcc83v.rs:18:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n18  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n14  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 0;\n    for i in arr {\n        if *i < *i {\n            res *= -1;\n\
    \        } else {\n            res *= 1;\n        }\n    }\n    Some(res)\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp6pzkgz7b.rs:15:12\n\
    \   |\n15 |         if *i < *i {\n   |            ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp6pzkgz7b.rs:15:17\n   |\n15 |        \
    \ if *i < *i {\n   |                 ^^\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0] as isize;\n    for &i in arr {\n        product *=\
    \ i;\n    }\n\n    let mut sign = 1;\n    for &i in arr {\n        sign *= i;\n\
    \    }\n\n    Some(product * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsnmxogs0.rs:15:9\n   |\n\
    15 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsnmxogs0.rs:20:9\n   |\n20 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        product\
    \ *= x;\n        sign *= if x < 0 { -1 } else { 1 };\n    }\n    Some(product\
    \ * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmps1c5wpqz.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &i in &arr {\n        product *= i;\n  \
    \  }\n\n    let mut sum = 0;\n    for &i in &arr {\n        sum += if i == -1\
    \ {\n            -1\n        } else if i == 1 {\n            1\n        } else\
    \ {\n            0\n        };\n    }\n\n    Some(product * sum)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp_lbuhp6p.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = isize::one();\n    for i in arr.iter() {\n        res *= i;\n    \
    \    if *i < *i {\n            res *= -1;\n        }\n    }\n    Some(res)\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpqusxkuts.rs:13:26\n   |\n13 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0] as isize;\n    for i in arr.iter().rev() {\n     \
    \   product *= i;\n    }\n\n    let mut res = Some(product);\n    for i in arr.iter().rev()\
    \ {\n        if *i < *(arr.iter().rev().next().unwrap()) {\n            res =\
    \ None;\n            break;\n        }\n    }\n\n    res\n}\n\nfn main() {\n \
    \   let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmptqmemgfn.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for i in arr.iter().rev() {\n        product *= i;\n\
    \    }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpkf7hd38_.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &x in &arr {\n        product *= x;\n  \
    \  }\n\n    let mut result = product;\n    for &x in &arr {\n        if x < 0\
    \ {\n            result *= -1;\n        }\n    }\n\n    Some(result)\n}\n\nfn\
    \ main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpjbo4y8_w.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 0;\n    for x in arr {\n        res += x * sign(x);\n    }\n    Some(res)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sign` in this scope\n  --> /tmp/tmp43s4oami.rs:15:20\n\
    \   |\n15 |         res += x * sign(x);\n   |                    ^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &i in arr {\n        product *= i;\n   \
    \ }\n\n    let mut res = Some(0);\n    for &i in arr {\n        if i == -1 {\n\
    \            res = Some(-1);\n        } else if i == 0 {\n            res = Some(0);\n\
    \        } else {\n            res = Some(1);\n        }\n    }\n\n    Some(product\
    \ * res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9f1qbo95.rs:15:9\n   |\n\
    15 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9f1qbo95.rs:20:9\n   |\n20 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: cannot multiply `isize` by `Option<{integer}>`\n\
    \  --> /tmp/tmp9f1qbo95.rs:30:18\n   |\n30 |     Some(product * res)\n   |   \
    \               ^ no implementation for `isize * Option<{integer}>`\n   |\n  \
    \ = help: the trait `Mul<Option<{integer}>>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Mul<Rhs>`:\n          \
    \   <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a\
    \ i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32\
    \ as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for x in arr.iter().rev() {\n        product *= x;\n\
    \    }\n    let mut sum = 0;\n    for x in arr.iter() {\n        sum += x * product;\n\
    \        product *= x;\n    }\n    Some(sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(144)`,\n right: `Some(-9)`', /tmp/tmpqv6gst1g.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        product *= x;\n    }\n    let\
    \ mut sum = 0;\n    for x in arr {\n        sum += if x < 0 {\n            -1\n\
    \        } else {\n            1\n        } * x;\n    }\n    Some(sum * product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpedmgdcnw.rs:18:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n18  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n14  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut res = 0;\n    for x in arr {\n        if x < 0\
    \ {\n            res -= x;\n        } else {\n            res += x;\n        }\n\
    \    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(9)`,\n right: `Some(-9)`', /tmp/tmptw7ia3dh.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0] as isize;\n    for i in 1..arr.len() {\n        let\
    \ mut product = product * i;\n        if arr[i] > 0 {\n            product *=\
    \ -1;\n        }\n    }\n    Some(product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmposo96tv2.rs:16:37\n   |\n\
    16 |         let mut product = product * i;\n   |                            \
    \         ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot multiply `isize`\
    \ by `usize`\n  --> /tmp/tmposo96tv2.rs:16:35\n   |\n16 |         let mut product\
    \ = product * i;\n   |                                   ^ no implementation for\
    \ `isize * usize`\n   |\n   = help: the trait `Mul<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = arr[0];\n    for i in 1..arr.len() {\n        let mut prod = 1;\n\
    \        for j in 0..i {\n            prod *= arr[j];\n        }\n        res\
    \ *= prod;\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(8)`,\n right: `Some(-9)`', /tmp/tmpg_o7f5j5.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut res = 0;\n    for x in arr {\n        res += if x < 0 {\n         \
    \   -1\n        } else {\n            1\n        };\n    }\n\n    Some(res)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(2)`,\n right: `Some(-9)`', /tmp/tmpunb4_ee_.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for i in arr.iter().rev() {\n        product *= i;\n\
    \    }\n    let mut sum = 0;\n    for i in arr {\n        sum += i * product;\n\
    \        product *= i;\n    }\n    Some(sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(144)`,\n right: `Some(-9)`', /tmp/tmp903uk5ig.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    for x in arr {\n        prod *= x;\n        if x < 0 {\n\
    \            prod *= -1;\n        }\n    }\n    Some(prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmp9gj2t831.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for &i in &arr {\n        product *= i;\n    }\n\
    \    let mut sum = 0;\n    for &i in &arr {\n        sum += i;\n    }\n    Some(product\
    \ * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmppfjdq_98.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for i in arr.iter().rev() {\n        product\
    \ *= i;\n    }\n\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpzok80wvh.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = vec![0];\n    for i in arr {\n        res.iter_mut().for_each(|&x|\
    \ {\n            *x = *x * i as isize;\n        });\n    }\n    let mut prod =\
    \ 1;\n    for i in res {\n        prod *= i;\n    }\n    Some(prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc5id0z_g.rs:15:34\n   |\n\
    15 |         res.iter_mut().for_each(|&x| {\n   |                            \
    \      ^--\n   |                                  ||\n   |                   \
    \               |expected due to this\n   |                                  types\
    \ differ in mutability\n   |                                  help: did you mean\
    \ `x`: `&&mut {integer}`\n   |\n   = note: expected mutable reference `&mut {integer}`\n\
    \                      found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod = 1;\n    for x in arr {\n        prod *=\
    \ x;\n    }\n    Some(prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp0bz1h0o4.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        product *= x;\n    }\n    let\
    \ mut sum = 0;\n    for x in arr {\n        sum += x * product;\n    }\n    Some(sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpdd97n_2d.rs:18:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n18  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n14  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0] as isize;\n    for x in arr.iter().skip(1) {\n   \
    \     product *= x;\n    }\n\n    let mut sign = 1;\n    for x in arr.iter() {\n\
    \        sign *= x;\n    }\n\n    Some(sign * product)\n}\n\nfn main() {\n   \
    \ let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(256)`,\n right: `Some(-9)`', /tmp/tmpp2o8muj6.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        product\
    \ *= x;\n        if x < 0 {\n            sign *= -1;\n        }\n    }\n    Some(product\
    \ * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmp03ly3pdv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for &i in &arr {\n        product *= i;\n    }\n\
    \    let mut res = product;\n    for &i in &arr {\n        res *= i;\n    }\n\
    \    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(256)`,\n right: `Some(-9)`', /tmp/tmp7xm50ln_.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0] as isize;\n    for x in arr.iter().skip(1) {\n        product\
    \ *= x;\n    }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpzp_50ktq.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr.iter().product();\n    let mut sum = 0;\n    for x in arr\
    \ {\n        sum += x * product;\n        product *= x;\n    }\n    Some(sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp2v_s91a8.rs:13:9\n\
    \   |\n13 |     let mut product = arr.iter().product();\n   |         ^^^^^^^^^^^\
    \ consider giving `product` a type\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut res = 0;\n    let mut sign = 1;\n    for x in arr {\n        res +=\
    \ x * sign;\n        sign = -sign;\n    }\n    Some(res)\n}\n\nfn main() {\n \
    \   let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(5)`,\n right: `Some(-9)`', /tmp/tmp_5s10zn7.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0] as isize;\n    for &i in arr {\n        product *=\
    \ i;\n    }\n\n    let mut res = product;\n    for i in arr.iter().rev() {\n \
    \       if *i < 0 {\n            *i = -(*i);\n        }\n        res *= *i;\n\
    \    }\n\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n \
    \   assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzuf3ud6l.rs:15:9\n   |\n\
    15 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for &x in &arr {\n        product *= x;\n    }\n\
    \    let mut res = product;\n    for &x in &arr {\n        res *= if x < 0 { -1\
    \ } else { 1 };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmplejxepjh.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    for x in arr {\n        product *= x;\n    }\n\n\
    \    let mut sum = 0;\n    for x in arr {\n        sum += if x < 0 {\n       \
    \     -1\n        } else {\n            1\n        };\n    }\n\n    Some(product\
    \ * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmp2vw9yy9i.rs:20:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n20  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n15  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut res = 0;\n    let mut sign = 1;\n    for x in arr {\n        res +=\
    \ x * sign;\n        sign *= -1;\n    }\n    Some(res)\n}\n\nfn main() {\n   \
    \ let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(5)`,\n right: `Some(-9)`', /tmp/tmp1h4v9vwi.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut prod = 1;\n    let mut sign = 1;\n    for x in arr {\n        prod\
    \ *= x;\n        sign *= sign;\n    }\n    Some(prod * sign)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp84_lq_9v.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for &i in &arr {\n        product *= i;\n    }\n\
    \    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmprd8k11hi.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for i in arr.iter().rev() {\n        product\
    \ *= i;\n    }\n\n    let mut sign = 1;\n    for i in arr.iter().rev() {\n   \
    \     sign *= i;\n    }\n\n    Some(product * sign)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(256)`,\n right: `Some(-9)`', /tmp/tmp__alqg6x.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr.iter().product();\n    let mut sum = 0;\n    for x in arr\
    \ {\n        sum += x * product;\n        product *= x;\n    }\n    Some(sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpokldjb2n.rs:13:9\n\
    \   |\n13 |     let mut product = arr.iter().product();\n   |         ^^^^^^^^^^^\
    \ consider giving `product` a type\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut res = 0;\n    for x in arr {\n        res += if\
    \ x < 0 { -1 } else { 1 };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(2)`,\n right: `Some(-9)`', /tmp/tmp9czrjxdi.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut res = 0;\n    for x in arr {\n        res += x * sign(x);\n    }\n\
    \    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sign` in this scope\n  --> /tmp/tmp197ex_0b.rs:16:20\n\
    \   |\n16 |         res += x * sign(x);\n   |                    ^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        product\
    \ *= x;\n        sign *= sign;\n    }\n    Some(product * sign)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpzm7yo_a4.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = vec![0; arr.len()];\n    for i in arr.iter() {\n        let mut j\
    \ = i;\n        while j > 0 {\n            if j % 2 == 1 {\n                res[i]\
    \ += 1;\n            }\n            j -= 1;\n        }\n    }\n    Some(res\n\
    \        .iter()\n        .fold(0, |acc, x| acc * x.signum()))\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwvk4fei6.rs:16:19\n   |\n\
    16 |         while j > 0 {\n   |                   ^\n   |                   |\n\
    \   |                   expected `&isize`, found integer\n   |               \
    \    help: consider borrowing here: `&0`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `&isize`\n  --> /tmp/tmpwvk4fei6.rs:18:17\n   |\n18 | \
    \                res[i] += 1;\n   |                 ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<{integer}>`\n\nerror[E0368]: binary assignment operation\
    \ `-=` cannot be applied to type `&isize`\n  --> /tmp/tmpwvk4fei6.rs:20:13\n \
    \  |\n20 |             j -= 1;\n   |             -^^^^^\n   |             |\n\
    \   |             cannot use `-=` on type `&isize`\n   |\nhelp: `-=` can be used\
    \ on `isize`, you can dereference `j`\n   |\n20 |             *j -= 1;\n   | \
    \            +\n\nerror[E0599]: no method named `signum` found for reference `&{integer}`\
    \ in the current scope\n  --> /tmp/tmpwvk4fei6.rs:25:35\n   |\n25 |         .fold(0,\
    \ |acc, x| acc * x.signum()))\n   |                                   ^^^^^^ method\
    \ not found in `&{integer}`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut res = 0;\n    for x in arr {\n        res += x * sign(x);\n    }\n\
    \    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sign` in this scope\n  --> /tmp/tmpyvxd_bqe.rs:16:20\n\
    \   |\n16 |         res += x * sign(x);\n   |                    ^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for x in arr.iter().rev() {\n        product\
    \ *= x;\n    }\n\n    let mut sum = 0;\n    for x in arr.iter() {\n        sum\
    \ += if x < 0 {\n            -1\n        } else {\n            1\n        };\n\
    \    }\n\n    Some(product * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplxyi6x61.rs:21:23\n   |\n\
    21 |         sum += if x < 0 {\n   |                       ^\n   |           \
    \            |\n   |                       expected `&isize`, found integer\n\
    \   |                       help: consider borrowing here: `&0`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &i in &arr {\n        product *= i;\n  \
    \  }\n\n    let mut res = Some(product);\n    for i in &arr {\n        if *i <\
    \ 0 {\n            res = Some(-*res + product);\n        } else {\n          \
    \  res = Some(*res + product);\n        }\n    }\n\n    res\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp51rtez41.rs:22:25\n\
    \   |\n22 |             res = Some(-*res + product);\n   |                   \
    \      ^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmp51rtez41.rs:24:24\n   |\n24 |             res = Some(*res + product);\n\
    \   |                        ^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        product\
    \ *= x;\n        sign *= if x < 0 { -1 } else { 1 };\n    }\n\n    Some(sign *\
    \ product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpf6tvyp61.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr.iter().product();\n    let mut signs = arr.iter().map(|x|\
    \ if x < 0 { -1 } else { 1 }).collect::<Vec<_>>();\n\n    signs.iter_mut().for_each(|x|\
    \ product *= x);\n\n    Some(product * signs.iter().sum())\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6el00lba.rs:15:47\n   |\n\
    15 |     let mut signs = arr.iter().map(|x| if x < 0 { -1 } else { 1 }).collect::<Vec<_>>();\n\
    \   |                                               ^\n   |                  \
    \                             |\n   |                                        \
    \       expected `&isize`, found integer\n   |                               \
    \                help: consider borrowing here: `&0`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        if x < 0 {\n            product\
    \ *= -1;\n        } else {\n            product *= 1;\n        }\n    }\n    Some(product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpxaa8d5eg.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut res = 0;\n    let mut sign = 1;\n    for x in arr {\n        res +=\
    \ x * sign;\n        sign *= -1;\n    }\n    Some(res)\n}\n\nfn main() {\n   \
    \ let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(5)`,\n right: `Some(-9)`', /tmp/tmpt3l9q4a1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut res = 0;\n    let mut sign = 1;\n    for x in arr {\n        res +=\
    \ x * sign;\n        sign = -sign;\n    }\n    Some(res)\n}\n\nfn main() {\n \
    \   let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(5)`,\n right: `Some(-9)`', /tmp/tmpi40j_0h7.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for x in arr.iter().skip(1) {\n        product *=\
    \ x;\n    }\n    let mut sum = 0;\n    for x in arr.iter() {\n        sum += if\
    \ x < 0 { -1 } else { 1 };\n    }\n    Some(product * sum)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8al4cebl.rs:19:23\n   |\n\
    19 |         sum += if x < 0 { -1 } else { 1 };\n   |                       ^\n\
    \   |                       |\n   |                       expected `&isize`, found\
    \ integer\n   |                       help: consider borrowing here: `&0`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for &i in arr {\n        product *= i;\n    }\n    let\
    \ mut res = 0;\n    for i in arr {\n        res += if i == -1 {\n            -1\n\
    \        } else {\n            1\n        } * i;\n    }\n    Some(product * res)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa_cdqnkb.rs:14:9\n   |\n\
    14 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod = 1;\n    for &i in arr {\n        prod *=\
    \ i;\n    }\n    if prod == 0 {\n        return None;\n    }\n    let mut sum\
    \ = 0;\n    for &i in arr {\n        sum += if i == -1 {\n            -1\n   \
    \     } else {\n            1\n        };\n    }\n    Some(sum * prod)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxo5tz78e.rs:11:9\n   |\n\
    11 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxo5tz78e.rs:18:9\n   |\n18 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = vec![0; arr.len()];\n    let mut sign = 1;\n    for &i in arr {\n\
    \        sign = sign * i;\n    }\n    for i in 0..arr.len() {\n        res[i]\
    \ = sign;\n    }\n    Some(arr.iter().product().unwrap() * res.iter().sum::<isize>())\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp923p_cpj.rs:15:9\n   |\n\
    15 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        if x < 0 {\n            product\
    \ *= -1;\n        } else {\n            product *= 1;\n        }\n    }\n    Some(product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpk_eavd0c.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for i in 1..arr.len() {\n        product *=\
    \ arr[i];\n    }\n\n    let mut sum = 0;\n    for i in arr {\n        sum += if\
    \ i == -1 {\n            -1\n        } else if i == 1 {\n            1\n     \
    \   } else {\n            0\n        };\n    }\n\n    Some(product * sum)\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpteoheuq7.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut prod = 1;\n    let mut sign = 1;\n    for x in arr {\n        prod\
    \ *= x;\n        sign *= x;\n    }\n\n    Some(prod * sign)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(256)`,\n right: `Some(-9)`', /tmp/tmp9z754icv.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        product *= x;\n    }\n    let\
    \ mut sum = 0;\n    for x in arr {\n        sum += x * product;\n        product\
    \ *= x;\n    }\n    Some(sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmp4kks6z0w.rs:18:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n18  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n14  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr.iter().product();\n    let mut signs = vec![0; arr.len()];\n\
    \n    for &i in arr.iter() {\n        signs[i] = match i {\n            1 => 1,\n\
    \            -1 => -1,\n            _ => 0,\n        };\n        product *= signs[i];\n\
    \    }\n\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpij9aqt7h.rs:18:9\n   |\n18 |         signs[i] = match i {\n   |    \
    \     ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpij9aqt7h.rs:23:20\n\
    \   |\n23 |         product *= signs[i];\n   |                    ^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &x in arr.iter().rev() {\n        product\
    \ *= x;\n    }\n\n    let mut sum = 0;\n    for &x in arr.iter() {\n        sum\
    \ += if x < 0 {\n            -1\n        } else {\n            1\n        };\n\
    \    }\n\n    Some(product * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-32)`,\n right: `Some(-9)`', /tmp/tmpet22szie.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        product\
    \ *= x;\n        sign *= if x < 0 { -1 } else { 1 };\n    }\n    Some(product\
    \ * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmp999ezuev.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for i in arr.iter().rev() {\n        product\
    \ *= i;\n    }\n\n    let mut res = product;\n    for i in arr.iter().rev() {\n\
    \        res *= i;\n    }\n\n    Some(res)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(256)`,\n right: `Some(-9)`', /tmp/tmpba16d88m.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sign = 1;\n    for x in arr {\n        if x < 0 {\n\
    \            sign *= -1;\n        }\n        prod *= sign;\n    }\n    Some(prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmp441_pdck.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    for &i in arr {\n        prod *= i;\n    }\n    let mut res\
    \ = 0;\n    for &i in arr {\n        res += if i == -1 {\n            -1\n   \
    \     } else if i == 1 {\n            1\n        } else {\n            0\n   \
    \     };\n    }\n    Some(prod * res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl8f7o769.rs:14:9\n   |\n\
    14 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl8f7o769.rs:18:9\n   |\n18 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 0;\n    let mut sign = 1;\n    for x in arr {\n        res += sign\
    \ * x;\n        sign *= -1;\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(5)`,\n right: `Some(-9)`', /tmp/tmpve7mnrk6.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut product = arr[0] as isize;\n    for x in arr.iter().rev()\
    \ {\n        product *= x;\n    }\n    Some(product)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp2v_ugmnp.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        product *= x;\n    }\n    let\
    \ mut sum = 0;\n    for x in arr {\n        sum += if x < 0 {\n            -1\n\
    \        } else {\n            1\n        } * x;\n    }\n    Some(sum * product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpnhci6276.rs:18:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n18  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n14  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut res = 0;\n    for x in arr {\n        res += if\
    \ x > 0 { 1 } else { -1 };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(2)`,\n right: `Some(-9)`', /tmp/tmpo64h15gv.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = arr[0];\n    for &x in arr.iter().rev() {\n        res *= x;\n   \
    \     if x < 0 {\n            res *= -1;\n        }\n    }\n    Some(res)\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpmy0c0qn_.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for i in 1..arr.len() {\n        product *= arr[i];\n\
    \    }\n    let mut res = Some(product);\n    for i in 1..arr.len() {\n      \
    \  if arr[i] < 0 {\n            res = Some(-product);\n            break;\n  \
    \      }\n    }\n    res\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmp7qwxd5ts.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0] as isize;\n    for x in arr.iter().rev() {\n        product\
    \ *= x;\n    }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp5barfil3.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &x in &arr {\n        product *= x;\n  \
    \  }\n\n    let mut sign = 1;\n    for &x in &arr {\n        sign *= x;\n    }\n\
    \n    Some(product * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(256)`,\n right: `Some(-9)`', /tmp/tmp5g1yl5hu.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut res = vec![0];\n    for x in arr {\n        let mut prod = 1;\n   \
    \     for y in &res {\n            prod *= *y;\n        }\n        *y = prod;\n\
    \        res.push(x);\n    }\n\n    let mut res = vec![0];\n    for x in arr {\n\
    \        let mut prod = 1;\n        for y in &res {\n            prod *= *y;\n\
    \        }\n        *y = prod;\n        res.push(x);\n    }\n\n    let mut res\
    \ = vec![0];\n    for x in arr {\n        let mut prod = 1;\n        for y in\
    \ &res {\n            prod *= *y;\n        }\n        *y = prod;\n        res.push(x);\n\
    \    }\n\n    Some(*res.iter().sum())\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `y` in this scope\n  --> /tmp/tmpyv_v0wpy.rs:20:10\n\
    \   |\n20 |         *y = prod;\n   |          ^ help: a local variable with a\
    \ similar name exists: `x`\n\nerror[E0425]: cannot find value `y` in this scope\n\
    \  --> /tmp/tmpyv_v0wpy.rs:30:10\n   |\n30 |         *y = prod;\n   |        \
    \  ^ help: a local variable with a similar name exists: `x`\n\nerror[E0425]: cannot\
    \ find value `y` in this scope\n  --> /tmp/tmpyv_v0wpy.rs:40:10\n   |\n40 |  \
    \       *y = prod;\n   |          ^ help: a local variable with a similar name\
    \ exists: `x`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for i in 1..arr.len() {\n        product *= arr[i];\n\
    \    }\n    let mut sum = 0;\n    for i in 0..arr.len() {\n        sum += if arr[i]\
    \ > 0 {\n            1\n        } else {\n            -1\n        };\n    }\n\
    \    Some(product * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-32)`,\n right: `Some(-9)`', /tmp/tmpu_nl4fhb.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        product *= x;\n    }\n    let\
    \ mut res = 0;\n    for x in arr {\n        res += x * product;\n    }\n    Some(res)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmps9g7dseo.rs:18:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n18  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n14  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        product\
    \ *= x;\n        if x < 0 {\n            sign *= -1;\n        }\n    }\n    Some(sign\
    \ * product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmps1yoyy5r.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod = 1;\n    for x in arr {\n        if x < 0\
    \ {\n            prod *= -1;\n        } else {\n            prod *= 1;\n     \
    \   }\n    }\n    Some(prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmp26benr0q.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        product *= x;\n    }\n    let\
    \ mut res = 0;\n    for x in arr {\n        res += x * product;\n    }\n    Some(res)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpmuit0tcx.rs:18:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n18  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n14  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &i in &arr {\n        product *= i;\n  \
    \  }\n\n    let mut sum = 0;\n    for &i in &arr {\n        sum += if i == -1\
    \ {\n            -1\n        } else {\n            1\n        };\n    }\n\n  \
    \  Some(product * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n  \
    \  assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-64)`,\n right: `Some(-9)`', /tmp/tmpf5pqlezx.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for &i in arr {\n        product *= i;\n    }\n    let\
    \ mut res = 0;\n    for i in arr {\n        res += i * (product * sign(i));\n\
    \    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sign` in this scope\n  --> /tmp/tmpjkm77dxk.rs:19:31\n\
    \   |\n19 |         res += i * (product * sign(i));\n   |                    \
    \           ^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpjkm77dxk.rs:14:9\n   |\n14 |     for &i in arr {\n   |         ^^\
    \    --- this expression has type `Option<isize>`\n   |         |\n   |      \
    \   expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        if\
    \ x < 0 {\n            sign *= -1;\n        }\n        product *= x;\n    }\n\
    \    Some(sign * product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpw5wnggkl.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for i in arr.iter().rev() {\n        product *= i;\n\
    \    }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp_nxn2er9.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 0;\n    let mut sign = 1;\n    for x in arr {\n        res += x *\
    \ sign;\n        sign = -sign;\n    }\n    Some(res)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(5)`,\n right: `Some(-9)`', /tmp/tmp89mxex1d.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        product\
    \ *= x;\n        sign *= if x < 0 { -1 } else { 1 };\n    }\n    Some(product\
    \ * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmp1rkmsz98.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for i in 1..arr.len() {\n        product *= if arr[i]\
    \ > 0 { 1 } else { -1 };\n    }\n    Some(product)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpbp3p1826.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 0;\n    let mut sign = 1;\n    for &x in arr {\n        res += x *\
    \ sign;\n        sign *= -1;\n    }\n    Some(res)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpktsi4hc8.rs:15:9\n   |\n\
    15 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        if\
    \ x < 0 {\n            sign *= -1;\n        }\n        product *= x;\n    }\n\
    \    Some(product * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpvtp1yy68.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        product *= x;\n    }\n    let\
    \ mut res = 0;\n    for x in arr {\n        res += x * product;\n    }\n    Some(res)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpe2x2b2t8.rs:18:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n18  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n14  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut product = arr[0];\n    for &i in arr {\n      \
    \  product *= i;\n    }\n    if product < 0 {\n        Some(-product)\n    } else\
    \ {\n        Some(product)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyxkwwkw9.rs:11:9\n   |\n\
    11 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    for x in arr {\n        prod *= x;\n    }\n    let mut sum\
    \ = 0;\n    for x in arr {\n        sum += if x < 0 {\n            -x\n      \
    \  } else {\n            x\n        };\n    }\n    Some(prod * sum)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmp0ktnoznj.rs:18:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n18  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n14  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0] as isize;\n    for x in arr.iter().skip(1) {\n   \
    \     product *= x;\n    }\n    Some(product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpgu7xv92r.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut res = 0;\n    let mut sign = 1;\n    for x in arr {\n        res +=\
    \ x * sign;\n        sign *= -1;\n    }\n\n    Some(res)\n}\n\nfn main() {\n \
    \   let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(5)`,\n right: `Some(-9)`', /tmp/tmphrsh4cas.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for &x in arr.iter().rev() {\n        product *=\
    \ x;\n    }\n    let mut sum = 0;\n    for &x in arr.iter() {\n        sum +=\
    \ x * product;\n        product *= x;\n    }\n    Some(sum)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(144)`,\n right: `Some(-9)`', /tmp/tmp5o7ugbw8.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        product\
    \ *= x;\n        if x < 0 {\n            sign *= -1;\n        }\n    }\n    Some(product\
    \ * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmp4yjoa9lm.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut product = arr[0];\n    for &i in arr {\n      \
    \  product *= i;\n    }\n    Some(product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu85n8_zj.rs:11:9\n   |\n\
    11 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut product = arr[0];\n    for x in arr.iter().rev()\
    \ {\n        product *= x;\n    }\n    Some(product)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp_tuvig1b.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = vec![0; arr.len()];\n    for i in arr.iter() {\n        res[i] = if\
    \ *i < 0 { -1 } else { 1 };\n    }\n    Some(arr.iter().product().unwrap().pow(2).sum().unwrap())\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n  -->\
    \ /tmp/tmp0f94z0la.rs:15:9\n   |\n15 |         res[i] = if *i < 0 { -1 } else\
    \ { 1 };\n   |         ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod = 1;\n    for x in arr {\n        prod *=\
    \ x;\n        if x < 0 {\n            prod *= -1;\n        }\n    }\n    Some(prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpfelsycrt.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        product *= x;\n    }\n    let\
    \ mut sum = 0;\n    for x in arr {\n        sum += if x < 0 {\n            -1\n\
    \        } else {\n            1\n        } * x;\n    }\n    Some(product * sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmprw5g0uhk.rs:18:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n18  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n14  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &x in arr.iter().rev() {\n        product\
    \ *= x;\n    }\n\n    let mut sign = 1;\n    for &x in arr.iter() {\n        sign\
    \ *= x;\n    }\n\n    Some(product * sign)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(256)`,\n right: `Some(-9)`', /tmp/tmpjprinckk.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        product *= x;\n    }\n    let\
    \ mut sum = 0;\n    for x in arr {\n        sum += x * product;\n    }\n    Some(sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmp4i2safyh.rs:18:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n18  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n14  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut res = isize::one();\n    for x in arr {\n        res *= x;\n      \
    \  res *= if x < 0 { -1 } else { 1 };\n    }\n    Some(res)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmp1qp01_0f.rs:14:26\n   |\n14 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        if x < 0 {\n            product\
    \ *= -1;\n        }\n        product *= x;\n    }\n    Some(product)\n}\n\nfn\
    \ main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmp5prjacgc.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut res = 0;\n    for x in arr {\n        res += x * sign(x);\n    }\n\
    \    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sign` in this scope\n  --> /tmp/tmpokf5hx_s.rs:16:20\n\
    \   |\n16 |         res += x * sign(x);\n   |                    ^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    for x in arr {\n        if x < 0 {\n            product\
    \ *= -1;\n        } else {\n            product *= 1;\n        }\n    }\n\n  \
    \  Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmp29g408_i.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        product\
    \ *= x;\n        sign *= sign;\n    }\n    Some(product * sign)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp_0eu1icx.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        product *= x;\n    }\n    let\
    \ mut sum = 0;\n    for x in arr {\n        sum += if x == -1 {\n            -1\n\
    \        } else {\n            1\n        };\n    }\n    Some(product * sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmp38pcttik.rs:18:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n18  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n14  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0] as isize;\n    for &i in arr {\n        product *= i as\
    \ isize;\n    }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4l2mrd8c.rs:14:9\n   |\n\
    14 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for i in 1..arr.len() {\n        product *= arr[i];\n\
    \    }\n    let mut res = product;\n    for i in 1..arr.len() {\n        res *=\
    \ if arr[i] < 0 { -1 } else { 1 };\n    }\n    Some(res)\n}\n\nfn main() {\n \
    \   let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmp0y_kgzkt.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        product\
    \ *= x;\n        sign *= sign;\n    }\n    Some(product)\n}\n\nfn main() {\n \
    \   let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp8pqb7w95.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 0;\n    let mut sign = 1;\n    for &i in arr {\n        res += sign\
    \ * i;\n        sign *= sign;\n    }\n    Some(res)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0btf7ccm.rs:15:9\n   |\n\
    15 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    for &x in arr {\n        prod *= x;\n    }\n    Some(prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwt59e6t4.rs:14:9\n   |\n\
    14 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0] as isize;\n    for i in arr.iter().rev() {\n     \
    \   product *= i as isize;\n    }\n\n    Some(product)\n}\n\nfn main() {\n   \
    \ let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmp9ls0uh1s.rs:16:20\n\
    \   |\n16 |         product *= i as isize;\n   |                    -^^^^^^^^^\n\
    \   |                    |\n   |                    cannot cast `&isize` as `isize`\n\
    \   |                    help: dereference the expression: `*i`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0606`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for &i in arr {\n        product *= i;\n    }\n    let\
    \ mut sum = 0;\n    for &i in arr {\n        sum += i * product;\n    }\n    Some(sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp53nwn_ni.rs:14:9\n   |\n\
    14 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp53nwn_ni.rs:18:9\n   |\n18 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr.iter().product();\n    let mut signs = arr.iter().map(|x|\
    \ if x < 0 { -1 } else { 1 }).collect::<Vec<_>>();\n\n    for x in &mut signs\
    \ {\n        *x *= product;\n    }\n\n    Some(product)\n}\n\nfn main() {\n  \
    \  let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmper8l44yv.rs:15:47\n   |\n\
    15 |     let mut signs = arr.iter().map(|x| if x < 0 { -1 } else { 1 }).collect::<Vec<_>>();\n\
    \   |                                               ^\n   |                  \
    \                             |\n   |                                        \
    \       expected `&isize`, found integer\n   |                               \
    \                help: consider borrowing here: `&0`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        if\
    \ x < 0 {\n            product *= -1;\n            sign *= -1;\n        } else\
    \ {\n            product *= sign;\n        }\n    }\n    Some(product)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmplmv7b0qd.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0] as isize;\n    for &i in arr {\n        product *=\
    \ i as isize;\n    }\n\n    let mut res = Some(product);\n    for i in arr.iter().rev()\
    \ {\n        if *i == -1 {\n            res = Some(product * -1);\n          \
    \  break;\n        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb710zkqw.rs:15:9\n   |\n\
    15 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for &x in arr.iter().rev() {\n        product *=\
    \ x;\n    }\n    let mut sum = 0;\n    for &x in arr.iter() {\n        sum +=\
    \ x * product;\n        product *= x;\n    }\n    Some(sum)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(144)`,\n right: `Some(-9)`', /tmp/tmpyz2f25_q.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 0;\n    for i in arr {\n        res += if i < 0 {\n            1\n\
    \        } else {\n            -1\n        };\n    }\n    Some(res)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-2)`,\n right: `Some(-9)`', /tmp/tmprhl971yd.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = vec![0; arr.len()];\n    for i in arr.iter() {\n        res[i] = if\
    \ *i < 0 { 1 } else { -1 };\n    }\n    Some(arr.iter().product().unwrap() * res.iter().sum())\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n  -->\
    \ /tmp/tmpdnzq2hj9.rs:15:9\n   |\n15 |         res[i] = if *i < 0 { 1 } else {\
    \ -1 };\n   |         ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for x in arr.iter().skip(1) {\n        product\
    \ *= x;\n    }\n    let mut sum = 0;\n    for x in arr.iter() {\n        sum +=\
    \ if x < 0 { -x } else { x };\n    }\n    Some(product * sum)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpur7u8qpz.rs:20:23\n   |\n\
    20 |         sum += if x < 0 { -x } else { x };\n   |                       ^\n\
    \   |                       |\n   |                       expected `&isize`, found\
    \ integer\n   |                       help: consider borrowing here: `&0`\n\n\
    error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpur7u8qpz.rs:20:39\n\
    \   |\n20 |         sum += if x < 0 { -x } else { x };\n   |                 \
    \          --          ^ expected `isize`, found `&isize`\n   |              \
    \             |\n   |                           expected because of this\n   |\n\
    help: consider dereferencing the borrow\n   |\n20 |         sum += if x < 0 {\
    \ -x } else { *x };\n   |                                       +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for &x in arr.iter() {\n        product *= x;\n \
    \   }\n    if product < 0 {\n        Some(-product)\n    } else {\n        Some(product)\n\
    \    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmp2n56igbc.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    for x in arr {\n        product *= x;\n    }\n\n\
    \    let mut sum = 0;\n    for x in arr {\n        sum += x * product;\n    }\n\
    \n    Some(sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpgwstt1hu.rs:20:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n20  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n15  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        product\
    \ *= x;\n        sign *= if x < 0 { -1 } else { 1 };\n    }\n    Some(product\
    \ * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpk9r6fed6.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 0;\n    for x in arr {\n        if x < 0 {\n            res -= x;\n\
    \        } else {\n            res += x;\n        }\n    }\n    Some(res)\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(9)`,\n right: `Some(-9)`', /tmp/tmpp5_bf8k2.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0] as isize;\n    for &i in arr {\n        product *=\
    \ i;\n    }\n\n    let mut sign = 1;\n    for &i in arr {\n        sign *= i;\n\
    \    }\n\n    Some(sign * product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi9opbv8_.rs:15:9\n   |\n\
    15 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi9opbv8_.rs:20:9\n   |\n20 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 0;\n    for x in arr {\n        res += x * sign(x);\n    }\n    Some(res)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sign` in this scope\n  --> /tmp/tmpiz4snmq_.rs:15:20\n\
    \   |\n15 |         res += x * sign(x);\n   |                    ^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    for x in arr {\n        prod *= x;\n        if x != 0 {\n\
    \            return Some(prod * (-1));\n        }\n    }\n    None\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpqowka_4x.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    for x in arr {\n        product *= x;\n    }\n    let\
    \ mut sum = 0;\n    for x in arr {\n        sum += if x < 0 {\n            -1\n\
    \        } else {\n            1\n        } * x;\n    }\n    Some(product * sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpr45nuqrb.rs:18:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n18  |     for x in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n14  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for &x in arr.iter() {\n        product *= x;\n\
    \    }\n\n    let mut sign = 1;\n    for &x in arr.iter() {\n        sign *= x;\n\
    \    }\n\n    Some(product * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(256)`,\n right: `Some(-9)`', /tmp/tmp59uz9utp.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut res = isize::one();\n    for &i in arr {\n        if *i < 0 {\n   \
    \         res *= isize::one();\n        } else {\n            res *= isize::from_sign(*i);\n\
    \        }\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpxvf51wqo.rs:14:26\n   |\n14 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxvf51wqo.rs:15:9\n   |\n15 |     for &i in arr {\n   |         ^^  \
    \  --- this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0599]: no function or associated item named\
    \ `one` found for type `isize` in the current scope\n  --> /tmp/tmpxvf51wqo.rs:17:27\n\
    \   |\n17 |             res *= isize::one();\n   |                           ^^^\
    \ function or associated item not found in `isize`\n\nerror[E0599]: no function\
    \ or associated item named `from_sign` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpxvf51wqo.rs:19:27\n   |\n19 |             res *= isize::from_sign(*i);\n\
    \   |                           ^^^^^^^^^\n   |                           |\n\
    \   |                           function or associated item not found in `isize`\n\
    \   |                           help: there is an associated function with a similar\
    \ name: `from_be`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for i in arr.iter().rev() {\n        product\
    \ *= i;\n    }\n\n    let mut res = Some(0);\n    for i in arr.iter().rev() {\n\
    \        res *= i as isize;\n        if *i as isize < 0 {\n            res = Some(-*res\
    \ as isize);\n        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error: `<` is interpreted as a start of generic arguments for `isize`,\
    \ not a comparison\n  --> /tmp/tmpod6bjugt.rs:22:24\n   |\n22 |         if *i\
    \ as isize < 0 {\n   |                        ^ --- interpreted as generic arguments\n\
    \   |                        |\n   |                        not interpreted as\
    \ comparison\n   |\nhelp: try comparing the cast value\n   |\n22 |         if\
    \ (*i as isize) < 0 {\n   |            +           +\n\nerror[E0368]: binary assignment\
    \ operation `*=` cannot be applied to type `Option<{integer}>`\n  --> /tmp/tmpod6bjugt.rs:21:9\n\
    \   |\n21 |         res *= i as isize;\n   |         ---^^^^^^^^^^^^^^\n   | \
    \        |\n   |         cannot use `*=` on type `Option<{integer}>`\n\nerror[E0614]:\
    \ type `Option<{integer}>` cannot be dereferenced\n  --> /tmp/tmpod6bjugt.rs:23:25\n\
    \   |\n23 |             res = Some(-*res as isize);\n   |                    \
    \     ^^^^\n\nerror[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmpod6bjugt.rs:21:16\n\
    \   |\n21 |         res *= i as isize;\n   |                -^^^^^^^^^\n   | \
    \               |\n   |                cannot cast `&isize` as `isize`\n   | \
    \               help: dereference the expression: `*i`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0368, E0606,\
    \ E0614.\nFor more information about an error, try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut product = arr[0] as isize;\n    for x in arr.iter().skip(1)\
    \ {\n        product *= x;\n    }\n    Some(product)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpbm6umnl3.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0] as isize;\n    for x in arr.iter().skip(1) {\n   \
    \     product *= x;\n    }\n\n    Some(product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpdjd9pu9j.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = arr[0];\n    for i in arr.iter().rev() {\n        product\
    \ *= i;\n    }\n\n    let mut sum = 0;\n    for i in arr.iter() {\n        sum\
    \ += if i == -1 {\n            -1\n        } else if i == 1 {\n            1\n\
    \        } else {\n            0\n        };\n    }\n\n    Some(product * sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp5njpceav.rs:21:21\n\
    \   |\n21 |         sum += if i == -1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmp5njpceav.rs:23:21\n   |\n23 |         } else\
    \ if i == 1 {\n   |                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for i in 1..arr.len() {\n        product *= arr[i];\n\
    \    }\n    let mut sum = 0;\n    for i in 0..arr.len() {\n        sum += if arr[i]\
    \ > 0 { 1 } else { -1 };\n    }\n    Some(product * sum)\n}\n\nfn main() {\n \
    \   let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-32)`,\n right: `Some(-9)`', /tmp/tmp3rtlv_np.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n  \
    \  let mut product = 1;\n    let mut sign = 1;\n    for x in arr {\n        product\
    \ *= x;\n        sign *= if x < 0 { -1 } else { 1 };\n    }\n    Some(product\
    \ * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmp81hky6uh.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod = 1;\n    for x in arr {\n        prod *=\
    \ x;\n    }\n    if prod == 0 {\n        return None;\n    }\n    let mut sign\
    \ = 1;\n    for x in arr {\n        if x < 0 {\n            sign *= -1;\n    \
    \    }\n    }\n    Some(sign * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmp1cr_yfbz.rs:18:14\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n10  |     let mut prod = 1;\n11  |     for x in arr {\n  \
    \  |              --- `arr` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for x in arr {\n    |              ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `arr`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n11  |     for x in &arr {\n    |  \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = arr[0];\n    for i in 1..arr.len() {\n        product *= arr[i];\n\
    \    }\n    let mut res = product;\n    for i in arr {\n        if *i < *0 {\n\
    \            *res += *i;\n        } else {\n            *res += *0;\n        }\n\
    \    }\n    Some(*res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n  \
    \  assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpy179k11q.rs:19:12\n\
    \   |\n19 |         if *i < *0 {\n   |            ^^\n\nerror[E0614]: type `{integer}`\
    \ cannot be dereferenced\n  --> /tmp/tmpy179k11q.rs:19:17\n   |\n19 |        \
    \ if *i < *0 {\n   |                 ^^\n\nerror[E0614]: type `isize` cannot be\
    \ dereferenced\n  --> /tmp/tmpy179k11q.rs:20:13\n   |\n20 |             *res +=\
    \ *i;\n   |             ^^^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpy179k11q.rs:20:21\n   |\n20 |             *res += *i;\n   |   \
    \                  ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n \
    \ --> /tmp/tmpy179k11q.rs:22:13\n   |\n22 |             *res += *0;\n   |    \
    \         ^^^^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  -->\
    \ /tmp/tmpy179k11q.rs:22:21\n   |\n22 |             *res += *0;\n   |        \
    \             ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpy179k11q.rs:25:10\n\
    \   |\n25 |     Some(*res)\n   |          ^^^^\n\nerror: aborting due to 7 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    for x in arr {\n        prod *= x;\n    }\n    Some(prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp2csi3kwo.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = isize::one();\n    for i in arr {\n        res *= i;\n        if i\
    \ < 0 {\n            res *= -1;\n        }\n    }\n    Some(res)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmphy4o10jq.rs:13:26\n   |\n13 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    for x in arr {\n        if x < 0 {\n            prod *= -1;\n\
    \        }\n        prod *= x;\n    }\n    Some(prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmp8iik0f1s.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
