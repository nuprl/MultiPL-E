name: HumanEval_49_modp
language: rust
results:
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp7ko5i0k3.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p {\n        result -= p;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp1r4dnbyg.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(n % p == 0);\n    n / p\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmp_j8g455a.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p != 1);\n    debug_assert!(p != 2);\n    debug_assert!(p\
    \ != 3);\n    debug_assert!(p != 4);\n    debug_assert!(p != 5);\n    debug_assert!(p\
    \ != 6);\n    debug_assert!(p != 7);\n    debug_assert!(p != 8);\n    debug_assert!(p\
    \ != 9);\n    debug_assert!(p != 10);\n    debug_assert!(p != 11);\n    debug_assert!(p\
    \ != 12);\n    debug_assert!(p != 13);\n    debug_assert!(p != 14);\n    debug_assert!(p\
    \ != 15);\n    debug_assert!(p != 16);\n    debug_assert!(p != 17);\n    debug_assert!(p\
    \ != 18);\n    debug_assert!(p != 19);\n    debug_assert!(p != 20);\n    debug_assert!(p\
    \ != 21);\n    debug_assert!(p != 22);\n    debug_assert!(p != 23);\n    debug_assert!(p\
    \ != 24);\n    debug_assert!(p != 25);\n    debug_assert!(p != 26);\n    debug_assert!(p\
    \ != 27);\n    debug_assert!(p != 28);\n    debug_assert!(p != 29);\n    debug_assert!(p\
    \ != 30);\n    debug_assert!(p != 31);\n    debug_assert!(p != 32);\n    debug_assert!(p\
    \ != 33);\n    debug_assert!(p != 34);\n    debug_assert!(p != 35);\n    debug_assert!(p\
    \ != 36);\n    debug_assert!(p != 37);\n    debug_assert!(p != 38);\n    debug_assert!(p\
    \ != 39);\n    debug_assert!(p != 40);\n    debug_assert!(p != 41);\n    debug_assert!(p\
    \ != 42);\n    debug_assert!(p != 43);\n    debug_assert!(p != 44);\n    debug_assert!(p\
    \ != 45);\n    debug_assert!(p != 46);\n    debug_assert!(p != 47);\n    debug_assert!(p\
    \ != 48);\n    debug_assert!(p != 49);\n    debug_assert!(p != 50);\n    debug_assert!(p\
    \ != 51);\n    debug_assert!(p != 52);\n    debug_assert!(p != 53);\n    debug_assert!(p\
    \ != 54);\n    debug_assert!(p != 55);\n    debug_assert!(p != 56);\n    debug_assert\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found macro `debug_assert`\n  --> /tmp/tmpv6k065ef.rs:72:5\n\
    \   |\n72 |     debug_assert\n   |     ^^^^^^^^^^^^ not a value\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0423`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpykw0fw0m.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp43ylh5qr.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n - (n % p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpx8g1gvtp.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp63yh4tkx.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxkfbpslh.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpqjjkbte9.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpdmhnsvvh.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p as isize)\n    } else {\n        n % p\n \
    \   }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpzxnseo_t.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n >= 0);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert!(p\
    \ >= 0);\n    debug_assert!(n <= 64);\n    debug_assert!(p <= 64);\n    debug_assert\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found macro `debug_assert`\n  --> /tmp/tmphu6kf5it.rs:72:5\n\
    \   |\n72 |     debug_assert\n   |     ^^^^^^^^^^^^ not a value\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0423`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpqek7ptfa.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p as isize)\n    } else {\n        n % p\n \
    \   }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpwljrsrxm.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpfskwdpyi.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n1 = n;\n    let mut n2 = n;\n    let mut n3 = n;\n    let mut\
    \ n4 = n;\n    let mut n5 = n;\n    let mut n6 = n;\n    let mut n7 = n;\n   \
    \ let mut n8 = n;\n    let mut n9 = n;\n    let mut n10 = n;\n    let mut n11\
    \ = n;\n    let mut n12 = n;\n    let mut n13 = n;\n    let mut n14 = n;\n   \
    \ let mut n15 = n;\n    let mut n16 = n;\n    let mut n17 = n;\n    let mut n18\
    \ = n;\n    let mut n19 = n;\n    let mut n20 = n;\n    let mut n21 = n;\n   \
    \ let mut n22 = n;\n    let mut n23 = n;\n    let mut n24 = n;\n    let mut n25\
    \ = n;\n    let mut n26 = n;\n    let mut n27 = n;\n    let mut n28 = n;\n   \
    \ let mut n29 = n;\n    let mut n30 = n;\n    let mut n31 = n;\n    let mut n32\
    \ = n;\n    let mut n33 = n;\n    let mut n34 = n;\n    let mut n35 = n;\n   \
    \ let mut n36 = n;\n    let mut n37 = n;\n    let mut n38 = n;\n    let mut n39\
    \ = n;\n    let mut n40 = n;\n    let mut n41 = n;\n    let mut n42 = n;\n   \
    \ let mut n43 = n;\n    let mut n44 = n;\n    let mut n45 = n;\n    let mut n46\
    \ = n;\n    let mut n47 = n;\n    let mut n48 = n;\n    let mut n49 = n;\n   \
    \ let mut n50 = n;\n    let mut n51 = n;\n    let mut n52 = n;\n    let mut n53\
    \ = n;\n    let mut n54 = n;\n    let mut n55 = n;\n    let mut n56 = n;\n   \
    \ let mut n57 = n;\n    let mut n58 = n;\n    let mut n59 = n;\n    let mut n60\
    \ = n;\n    let mut n61 = n;\n    let mut n62 = n;\n    let mut n63 = n;\n   \
    \ let mut n64 = n;\n    let mut n65 = n;\n    let mut n66\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9ukuhx56.rs:78:16\n   |\n\
    78 |     let mut n66\n   |                ^ help: add `;` here\n79 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ukuhx56.rs:12:32\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----             \
    \           ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    if n == 0 {\n    \
    \    return 1;\n    }\n    if n == 1 {\n        return p;\n    }\n    if n ==\
    \ p {\n        return n;\n    }\n    if n % p == 0 {\n        return modp(n /\
    \ p, p);\n    }\n    if n % p == p {\n        return modp(n / p, p);\n    }\n\
    \    if n % p == 0 {\n        return modp(n / p, p);\n    }\n    if n % p == p\
    \ {\n        return modp(n / p, p);\n    }\n    if n % p == 0 {\n        return\
    \ modp(n / p, p);\n    }\n    if n % p == p {\n        return modp(n / p, p);\n\
    \    }\n    if n % p == 0 {\n        return modp(n / p, p);\n    }\n    if n %\
    \ p == p {\n        return modp(n / p, p);\n    }\n    if n % p == 0 {\n     \
    \   return modp(n / p, p);\n    }\n    if n % p == p {\n        return modp(n\
    \ / p, p);\n    }\n    if n % p == 0 {\n        return modp(n / p, p);\n    }\n\
    \    if n % p == p {\n        return modp(n / p, p);\n    }\n    if n % p == 0\
    \ {\n        return modp(n / p, p);\n    }\n    if n % p == p {\n        return\
    \ modp(n / p, p);\n    }\n    if n % p == 0 {\n        return modp(n / p, p);\n\
    \    }\n    if n % p == p {\n        return modp(n / p, p);\n    }\n    if n %\
    \ p == 0 {\n        return modp(n / p, p);\n    }\n    if n % p == p {\n     \
    \   return modp(n / p, p);\n    }\n    if n % p == 0 {\n        return modp(n\
    \ / p, p);\n    }\n    if n % p == p {\n        return modp(n / p, p);\n    }\n\
    \    if n % p == 0 {\n        return modp(n / p, p);\n    }\n    if n % p == p\
    \ {\n        return modp(n / p, p);\n    }\n    if n % p == 0 {\n        return\
    \ modp(n / p, p);\n    }\n    if n % p == p {\n        return modp(n / p, p);\n\
    \    }\n    if n % p == 0 {\n        return modp(n / p, p);\n    }\n    if n %\
    \ p == p {\n        return modp(n / p, p);\n    }\n    if n % p == 0 {\n     \
    \   return modp(n / p, p);\n    }\n    if n % p == p {\n        return modp(n\
    \ / p, p);\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpt0d9875m.rs:15:24\n\
    \   |\n15 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmpt0d9875m.rs:16:24\n   |\n16 |     debug_assert!(n <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0317]:\
    \ `if` may be missing an `else` clause\n   --> /tmp/tmpt0d9875m.rs:107:5\n   \
    \ |\n12  |   fn modp(n: isize, p: isize) -> isize {\n    |                   \
    \               ----- expected `isize` because of this return type\n...\n107 |\
    \ /     if n % p == p {\n108 | |         return modp(n / p, p);\n109 | |     }\n\
    \    | |_____^ expected `isize`, found `()`\n    |\n    = note: `if` expressions\
    \ without `else` evaluate to `()`\n    = help: consider adding an `else` block\
    \ that evaluates to the expected type\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0317, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0317`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp1_9156my.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpkw3uoldy.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n1 = n;\n    let mut n2 = n;\n    while n2 > 1 {\n        n1\
    \ %= p;\n        n2 %= p;\n    }\n    n1\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    debug_assert\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found macro `debug_assert`\n  --> /tmp/tmpbruy_vqq.rs:72:5\n\
    \   |\n72 |     debug_assert\n   |     ^^^^^^^^^^^^ not a value\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0423`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p % n == 0);\n    debug_assert!(n % p == 0);\n    n\
    \ / p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmp48h9_u8x.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p % n == 0);\n    debug_assert!(n % p == 0);\n    n\
    \ / p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmp2y1w65je.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!((n % p) == 0);\n    n + (n - p) % p\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p <= n', /tmp/tmp8m_qr9gt.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp7nq2sko0.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp7bca__ym.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp30uuisnl.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    let mut res = 0;\n    while n > 0 {\n        if n % p == 0 {\n  \
    \          res += 1;\n        }\n        n /= p;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp459369xt.rs:21:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n21 |         n /= p;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp97khzeu8.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpeu_nvk23.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpuf6jzbpk.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp8fr5hp6o.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp387efs33.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut r = n;\n    while r > p && r != 0 {\n        r = r / p;\n   \
    \ }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `2`', /tmp/tmpu2w8fp28.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n ^ (p - 1)\n    } else {\n        n & (p - 1)\n\
    \    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp2m2r92vi.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpw0x8f_xt.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p % n == 0);\n    n - (p % n)\n}\n\nfn main() {\n \
    \   let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmptdi2k420.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpz98mdkqj.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpi3on3i5x.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpwehxa_0j.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpfesbb3_z.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpg8f1f6kk.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpu7o875o1.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p {\n        result -= p;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp9l47rsjp.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(p >= 1);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp9inmqkib.rs:74:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n74 |     debug_assert!(\n\
    \   |                  ^ unclosed delimiter\n75 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: macro requires a boolean expression as an argument\n  -->\
    \ /tmp/tmp9inmqkib.rs:74:5\n   |\n74 | /     debug_assert!(\n75 | | }\n   | |_^\
    \ boolean expression required\n   |\n   = note: this error originates in the macro\
    \ `debug_assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9inmqkib.rs:74:5\n   |\n74 | /\
    \     debug_assert!(\n75 | | }\n   | |_^ expected `isize`, found `()`\n   |\n\
    \   = note: this error originates in the macro `debug_assert` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpjj10v3hf.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpiod283zk.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p {\n        result -= p;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpja3t64s0.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp8ch19yme.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    \n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpe8rmg9zl.rs:15:24\n\
    \   |\n15 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmpe8rmg9zl.rs:16:24\n   |\n16 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpe8rmg9zl.rs:17:24\n\
    \   |\n17 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmpe8rmg9zl.rs:18:24\n   |\n18 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpe8rmg9zl.rs:19:24\n\
    \   |\n19 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmpe8rmg9zl.rs:20:24\n   |\n20 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpe8rmg9zl.rs:21:24\n\
    \   |\n21 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmpe8rmg9zl.rs:22:24\n   |\n22 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpe8rmg9zl.rs:23:24\n\
    \   |\n23 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmpe8rmg9zl.rs:24:24\n   |\n24 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_D"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmphpcov8nw.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p < 64);\n    debug_assert!(p\
    \ < 64);\n    debug_\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `debug_` in this scope\n  --> /tmp/tmpqumg__on.rs:70:5\n\
    \   |\n70 |     debug_\n   |     ^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(n >= p);\n    debug_assert!(n <= (p - 1));\n    debug_assert!((p\
    \ - 1) <= n);\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p - 1));\n\
    \    debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n\
    \ <= (p - 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p -\
    \ 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p - 1));\n \
    \   debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n\
    \ <= (p - 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p -\
    \ 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p - 1));\n \
    \   debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n\
    \ <= (p - 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p -\
    \ 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p - 1));\n \
    \   debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n\
    \ <= (p - 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p -\
    \ 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p - 1));\n \
    \   debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n\
    \ <= (p - 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p -\
    \ 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p - 1));\n \
    \   debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n\
    \ <= (p - 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p -\
    \ 1));\n    debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p - 1));\n \
    \   debug_assert!(n <= (p - 1));\n    debug_assert!(n <= (p - 1));\n\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvh6fv6bz.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::u32::MAX as isize);\n    debug_assert!(p <= std::i64::MAX as isize);\n\
    \    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p <= std::isize::MAX\
    \ as isize);\n    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p\
    \ <= std::i8::MAX as isize);\n    debug_assert!(p <= std::u8::MAX as isize);\n\
    \    debug_assert!(p <= std::u16::MAX as isize);\n    debug_assert!(p <= std::u32::MAX\
    \ as isize);\n    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p\
    \ <= std::i16::MAX as isize);\n    debug_assert!(p <= std::u16::MAX as isize);\n\
    \    debug_assert!(p <= std::u32::MAX as isize);\n    debug_assert!(p <= std::u64::MAX\
    \ as isize);\n    debug_assert!(p <= std::i64::MAX as isize);\n    debug_assert!(p\
    \ <= std::u64::MAX as isize);\n    debug_assert!(p <= std::isize::MAX as isize);\n\
    \    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p <= std::i8::MAX\
    \ as isize);\n    debug_assert!(p <= std::u8::MAX as isize);\n    debug_assert!(p\
    \ <= std::u16::MAX as isize);\n    debug_assert!(p <= std::u32::MAX as isize);\n\
    \    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p <= std::i16::MAX\
    \ as isize);\n    debug_assert!(p <= std::u16::MAX as isize);\n    debug_assert!(p\
    \ <= std::u32::MAX as isize);\n    debug_assert!(p <= std::u64::MAX as isize);\n\
    \    debug_assert!(p <= std::i64::MAX as isize);\n    debug_assert!(p <= std::u64::MAX\
    \ as isize);\n    debug_assert!(p <= std::isize::MAX as isize);\n    debug_assert!(p\
    \ <= std::usize::MAX as isize);\n    debug_assert!(p <= std::i8::MAX as isize);\n\
    \    debug_assert!(p <= std::u8::MAX as isize);\n    \n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjsai77d5.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpd2vrqqt6.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpdsgyx2r3.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n > 0);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(n % p == 0);\n    n / p\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmpyhrbuss0.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpiv_nhj6q.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp4mpjlt3o.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpn_49ckb4.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p && result % p != 0 {\n    \
    \    result -= p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpkfi0ln2j.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p && result % p != 0 {\n    \
    \    result -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1010`,\n right: `2`', /tmp/tmp_a11p2u_.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut npow = pow2(n);\n    npow %= p;\n    if npow == 0 {\n       \
    \ npow = 1;\n    }\n    npow\n}\n\nfn main() {\n    let candidate = modp;\n  \
    \  assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow2` in this scope\n  --> /tmp/tmp5wg0myor.rs:13:20\n\
    \   |\n13 |     let mut npow = pow2(n);\n   |                    ^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpr193gfle.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    \n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp8namgnhh.rs:15:24\n\
    \   |\n15 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp8namgnhh.rs:16:24\n   |\n16 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp8namgnhh.rs:17:24\n\
    \   |\n17 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp8namgnhh.rs:18:24\n   |\n18 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp8namgnhh.rs:19:24\n\
    \   |\n19 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp8namgnhh.rs:20:24\n   |\n20 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp8namgnhh.rs:21:24\n\
    \   |\n21 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp8namgnhh.rs:22:24\n   |\n22 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp8namgnhh.rs:23:24\n\
    \   |\n23 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp8namgnhh.rs:24:24\n   |\n24 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_D"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::u32::MAX as isize);\n    debug_assert!(p <= std::i64::MAX as isize);\n\
    \    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p <= std::isize::MAX\
    \ as isize);\n    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p\
    \ <= std::i8::MAX as isize);\n    debug_assert!(p <= std::u8::MAX as isize);\n\
    \    debug_assert!(p <= std::u16::MAX as isize);\n    debug_assert!(p <= std::u32::MAX\
    \ as isize);\n    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p\
    \ <= std::i16::MAX as isize);\n    debug_assert!(p <= std::u16::MAX as isize);\n\
    \    debug_assert!(p <= std::u32::MAX as isize);\n    debug_assert!(p <= std::u64::MAX\
    \ as isize);\n    debug_assert!(p <= std::i64::MAX as isize);\n    debug_assert!(p\
    \ <= std::u64::MAX as isize);\n    debug_assert!(p <= std::isize::MAX as isize);\n\
    \    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p <= std::i8::MAX\
    \ as isize);\n    debug_assert!(p <= std::u8::MAX as isize);\n    debug_assert!(p\
    \ <= std::u16::MAX as isize);\n    debug_assert!(p <= std::u32::MAX as isize);\n\
    \    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p <= std::i16::MAX\
    \ as isize);\n    debug_assert!(p <= std::u16::MAX as isize);\n    debug_assert!(p\
    \ <= std::u32::MAX as isize);\n    debug_assert!(p <= std::u64::MAX as isize);\n\
    \    debug_assert!(p <= std::i64::MAX as isize);\n    debug_assert!(p <= std::u64::MAX\
    \ as isize);\n    debug_assert!(p <= std::isize::MAX as isize);\n    debug_assert!(p\
    \ <= std::usize::MAX as isize);\n    debug_assert!(p <= std::i8::MAX as isize);\n\
    \    debug_assert!(p <= std::u8::MAX as isize);\n    \n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv4e79vg_.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpc_h7dcjw.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(n % p == 0);\n    n / p\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmph03z9_wn.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp_fh02ruz.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpvkz8tpyg.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p);\n    debug_assert!(p >\
    \ 0);\n    debug_assert!(p <= n);\n    debug_assert!(p < 64);\n    let mut result\
    \ = n;\n    while result > p {\n        result -= p;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6ex7j4d2.rs:14:5\n   |\n\
    14 |     debug_assert!(p);\n   |     ^^^^^^^^^^^^^^^^ expected `bool`, found `isize`\n\
    \   |\n   = note: this error originates in the macro `debug_assert` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp20cjq6js.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpbyt4nec4.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp922ig4j6.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 0;\n    while n > 0 {\n        if n % p == 0 {\n      \
    \      res += p;\n        }\n        n /= p;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp48sezfrn.rs:18:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n18 |         n /= p;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp9ueov9sr.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp7dt93d78.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p {\n        result -= p;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmptb1tm4o8.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n ^ (p - 1)\n    } else {\n        n & (p - 1)\n\
    \    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp6bh7ddwg.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n\
    \    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX\
    \ as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n\
    \    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX\
    \ as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n\
    \    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX\
    \ as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n\
    \    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX\
    \ as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n\
    \    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX\
    \ as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n\
    \    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX\
    \ as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n\
    \    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX\
    \ as i\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpydq2akui.rs:50:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n50 |     debug_assert!(p\
    \ <= std::i32::MAX as i\n   |                  ^ unclosed delimiter\n51 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0412]: cannot find type `i` in\
    \ this scope\n  --> /tmp/tmpydq2akui.rs:50:41\n   |\n50 |     debug_assert!(p\
    \ <= std::i32::MAX as i\n   |                                         ^ help:\
    \ a builtin type with a similar name exists: `i8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpydq2akui.rs:50:5\n   |\n50 | /     debug_assert!(p <= std::i32::MAX\
    \ as i\n51 | | }\n   | |_^ expected `isize`, found `()`\n   |\n   = note: this\
    \ error originates in the macro `debug_assert` (in Nightly builds, run with -Z\
    \ macro-backtrace for more info)\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0412.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n > 0);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    \n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsydf59wf.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmps8vd1bdc.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp4np2wosk.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p {\n        result -= p;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpqs1tib90.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpox7lp8zg.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpzek6fyav.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= std::i32::MAX);\n    debug_assert!(p <= std::i64::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::u16::MAX);\n\
    \    debug_assert!(p <= std::u32::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::i8::MAX);\n\
    \    debug_assert!(p <= std::i16::MAX);\n    debug_assert!(p <= std::u32::MAX);\n\
    \    debug_assert!(p <= std::u64::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    \n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp46pe21z5.rs:16:24\n   |\n\
    16 |     debug_assert!(p <= std::i32::MAX);\n   |                        ^^^^^^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n16 |     debug_assert!(p\
    \ <= std::i32::MAX.try_into().unwrap());\n   |                               \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp46pe21z5.rs:17:24\n\
    \   |\n17 |     debug_assert!(p <= std::i64::MAX);\n   |                     \
    \   ^^^^^^^^^^^^^ expected `isize`, found `i64`\n   |\nhelp: you can convert an\
    \ `i64` to an `isize` and panic if the converted value doesn't fit\n   |\n17 |\
    \     debug_assert!(p <= std::i64::MAX.try_into().unwrap());\n   |           \
    \                          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp46pe21z5.rs:18:24\n   |\n18 |     debug_assert!(p <= std::usize::MAX);\n\
    \   |                        ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     debug_assert!(p <= std::usize::MAX.try_into().unwrap());\n\
    \   |                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp46pe21z5.rs:19:24\n   |\n19 |     debug_assert!(p\
    \ <= std::u16::MAX);\n   |                        ^^^^^^^^^^^^^ expected `isize`,\
    \ found `u16`\n   |\nhelp: you can convert a `u16` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |     debug_assert!(p <= std::u16::MAX.try_into().unwrap());\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp46pe21z5.rs:20:24\n   |\n20 |     debug_assert!(p\
    \ <= std::u32::MAX);\n   |                        ^^^^^^^^^^^^^ expected `isize`,\
    \ found `u32`\n   |\nhelp: you can convert a `u32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |     debug_assert!(p <= std::u32::MAX.try_into().unwrap());\n\
    \   |                                     ++++++"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpgjlvt765.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmph___9evr.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n > 0);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(n >= p);\n    debug_assert!(n % p == 0);\n    n / p\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmpjms5cnbo.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::u32::MAX as isize);\n    debug_assert!(p <= std::i64::MAX as isize);\n\
    \    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p <= std::isize::MAX\
    \ as isize);\n    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p\
    \ <= std::i8::MAX as isize);\n    debug_assert!(p <= std::u8::MAX as isize);\n\
    \    debug_assert!(p <= std::u16::MAX as isize);\n    debug_assert!(p <= std::u32::MAX\
    \ as isize);\n    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p\
    \ <= std::i16::MAX as isize);\n    debug_assert!(p <= std::u16::MAX as isize);\n\
    \    debug_assert!(p <= std::u32::MAX as isize);\n    debug_assert!(p <= std::u64::MAX\
    \ as isize);\n    debug_assert!(p <= std::i64::MAX as isize);\n    debug_assert!(p\
    \ <= std::u64::MAX as isize);\n    debug_assert!(p <= std::isize::MAX as isize);\n\
    \    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p <= std::i8::MAX\
    \ as isize);\n    debug_assert!(p <= std::u8::MAX as isize);\n    debug_assert!(p\
    \ <= std::u16::MAX as isize);\n    debug_assert!(p <= std::u32::MAX as isize);\n\
    \    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p <= std::i16::MAX\
    \ as isize);\n    debug_assert!(p <= std::u16::MAX as isize);\n    debug_assert!(p\
    \ <= std::u32::MAX as isize);\n    debug_assert!(p <= std::u64::MAX as isize);\n\
    \    debug_assert!(p <= std::i64::MAX as isize);\n    debug_assert!(p <= std::u64::MAX\
    \ as isize);\n    debug_assert!(p <= std::isize::MAX as isize);\n    debug_assert!(p\
    \ <= std::usize::MAX as isize);\n    debug_assert!(p <= std::i8::MAX as isize);\n\
    \    debug_assert!(p <= std::u8::MAX as isize);\n    \n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaq4ouril.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmporgweyv6.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp1bebh8jo.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n - (n % p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp1p9qznsm.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpses536wl.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpzajj42iv.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp2u3xyr1b.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpnef5d1su.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpe8ig9pn5.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpvwvbpwy0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpfkxtavpq.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p && result % p != 0 {\n    \
    \    result -= p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp8w7inbpg.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpofyf4189.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp59z0jagc.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpuy3kv4hs.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpf1pq1xch.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(n % p == 0);\n    n\
    \ / p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmpvn_qm_90.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpt_zks1k6.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        p\n    } else {\n        n & (p - 1)\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp28rv2c4z.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p % 2 == 0);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n\
    \ >= p);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n\
    \ % 2 == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n % 2 == 0);\n   \
    \ debug_assert!(n >= p);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n\
    \ >= p);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n\
    \ % 2 == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n % 2 == 0);\n   \
    \ debug_assert!(n >= p);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n\
    \ >= p);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n\
    \ % 2 == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n % 2 == 0);\n   \
    \ debug_assert!(n >= p);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n\
    \ >= p);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n\
    \ % 2 == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n % 2 == 0);\n   \
    \ debug_assert!(n >= p);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n\
    \ >= p);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n\
    \ % 2 == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n % 2 == 0);\n   \
    \ debug_assert!(n >= p);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n\
    \ >= p);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n\
    \ % 2 == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n % 2 == 0);\n   \
    \ debug_assert!(n >= p);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n\
    \ >= p);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n\
    \ % 2 == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n % 2 == 0);\n   \
    \ debug_assert!(n >= p);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n\
    \ >= p);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n >= p);\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4729ykvn.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return\
    \ p;\n    }\n    if p < 2 {\n        return n;\n    }\n    if p < n {\n      \
    \  return modp(n - p, p);\n    }\n    if p > n {\n        return modp(n - p, p);\n\
    \    }\n    let mut res = n;\n    while res > p {\n        res -= p;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp9gacgho8.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp8680s0u0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpylm0quea.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp_d5hxv1q.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= std::i32::MAX);\n    debug_assert!(p <= std::i64::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::u16::MAX);\n\
    \    debug_assert!(p <= std::u32::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::i16::MAX);\n\
    \    debug_assert!(p <= std::i8::MAX);\n    debug_assert!(p <= std::i64::MAX);\n\
    \    debug_assert!(p <= std::u64::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::u16::MAX);\n    debug_assert!(p <= std::u32::MAX);\n\
    \    debug_assert!(p <= std::u64::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::i16::MAX);\n    debug_assert!(p <= std::i8::MAX);\n\
    \    debug_assert!(p <= std::i64::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::u16::MAX);\n\
    \    debug_assert!(p <= std::u32::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::i16::MAX);\n\
    \    debug_assert!(p <= std::i8::MAX);\n    debug_assert!(p <= std::i64::MAX);\n\
    \    debug_assert!(p <= std::u64::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::u16::MAX);\n    debug_assert!(p <= std::u32::MAX);\n\
    \    debug_assert!(p <= std::u64::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::i16::MAX);\n    debug_assert!(p <= std::i8::MAX);\n\
    \    debug_assert!(p <= std::i64::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `debug_` in this scope\n  --> /tmp/tmpwtuo48sg.rs:55:5\n\
    \   |\n55 |     debug_\n   |     ^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwtuo48sg.rs:16:24\n   |\n16 |     debug_assert!(p\
    \ <= std::i32::MAX);\n   |                        ^^^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |     debug_assert!(p <= std::i32::MAX.try_into().unwrap());\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwtuo48sg.rs:17:24\n   |\n17 |     debug_assert!(p\
    \ <= std::i64::MAX);\n   |                        ^^^^^^^^^^^^^ expected `isize`,\
    \ found `i64`\n   |\nhelp: you can convert an `i64` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n17 |     debug_assert!(p <= std::i64::MAX.try_into().unwrap());\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwtuo48sg.rs:18:24\n   |\n18 |     debug_assert!(p\
    \ <= std::usize::MAX);\n   |                        ^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |     debug_assert!(p <= std::usize::MAX.try_into().unwrap());\n\
    \   |                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwtuo48sg.rs:19:24\n   |\n19 |     debug_assert!(p\
    \ <= std::u16::MAX);\n   |                        ^^^^^^^^^^^^^ expected `isize`,\
    \ found `u16`\n   |\nhelp: you can convert a `u16` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |     debug_assert!(p <= std::u16::MAX.try_into().unwrap());\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwtuo48sg.rs:20:24\n   |\n20 |     debug_assert!(p\
    \ <= std::u32::MAX);\n   |                        ^^^^^^^^^^^^^ expected `isize`,\
    \ found `u32`\n   |\nhelp: you can convert a `u32` to an `isize` and panic if "
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmptub4msti.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 0;\n    while n != 0 {\n        if n % p == 0 {\n     \
    \       res += p;\n            n /= p;\n        } else {\n            res += 1;\n\
    \            n -= 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp5r8l6xvb.rs:17:13\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n17 |             n /= p;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `n`\n  --> /tmp/tmp5r8l6xvb.rs:20:13\n   |\n12\
    \ | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider making\
    \ this binding mutable: `mut n`\n...\n20 |             n -= 1;\n   |         \
    \    ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(n % p == 0);\n    n / p\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmpzn_rnfli.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpiqlwlwcm.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p);\n    debug_assert!(p >\
    \ 0);\n    debug_assert!(p < 256);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != 2);\n    debug_assert!(p != 4);\n    debug_assert!(p != 8);\n    debug_assert!(p\
    \ != 16);\n    debug_assert!(p != 32);\n    debug_assert!(p != 64);\n    debug_assert!(p\
    \ != 128);\n    debug_assert!(p != 256);\n    debug_assert!(p != 512);\n    debug_assert!(p\
    \ != 1024);\n    debug_assert!(p != 2048);\n    debug_assert!(p != 4096);\n  \
    \  debug_assert!(p != 8192);\n    debug_assert!(p != 16384);\n    debug_assert!(p\
    \ != 32768);\n    debug_assert!(p != 65536);\n    debug_assert!(p != 131072);\n\
    \    debug_assert!(p != 262144);\n    debug_assert!(p != 524288);\n    debug_assert!(p\
    \ != 1048576);\n    debug_assert!(p != 2097152);\n    debug_assert!(p != 4194304);\n\
    \    debug_assert!(p != 8388608);\n    debug_assert!(p != 16777216);\n    debug_assert!(p\
    \ != 33554432);\n    debug_assert!(p != 67108864);\n    debug_assert!(p != 134217728);\n\
    \    debug_assert!(p != 268435456);\n    debug_assert!(p != 536870912);\n    debug_assert!(p\
    \ != 1073741824);\n    debug_assert!(p != 2147483648);\n    debug_assert!(p !=\
    \ 4294967296);\n    debug_assert!(p != 8589934592);\n    debug_assert!(p != 17179869184);\n\
    \    debug_assert!(p != 34359738368);\n    debug_assert!(p != 68719476736);\n\
    \    debug_assert!(p != 137438953472);\n    debug_assert!(p != 274877906944);\n\
    \    debug_assert!(p != 549755813888);\n    debug_assert!(p != 1099511627776);\n\
    \    debug_assert!(p != 2199023255552);\n    debug_assert!(p != 4398046511104);\n\
    \    debug_assert!(p != 8796093022208);\n    debug_assert!(p \n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp46mcnljw.rs:61:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n61 |     debug_assert!(p\
    \ \n   |                  ^ unclosed delimiter\n62 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp46mcnljw.rs:14:5\n\
    \   |\n14 |     debug_assert!(p);\n   |     ^^^^^^^^^^^^^^^^ expected `bool`,\
    \ found `isize`\n   |\n   = note: this error originates in the macro `debug_assert`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp46mcnljw.rs:61:5\n   |\n61 | /     debug_assert!(p\
    \ \n62 | | }\n   | |_^ expected `bool`, found `isize`\n   |\n   = note: this error\
    \ originates in the macro `debug_assert` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp46mcnljw.rs:61:5\n\
    \   |\n61 | /     debug_assert!(p \n62 | | }\n   | |_^ expected `isize`, found\
    \ `()`\n   |\n   = note: this error originates in the macro `debug_assert` (in\
    \ Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p as isize)\n    } else {\n        n % p\n \
    \   }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpkatjbp_a.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmptbkbs877.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut npow = pow2(n);\n    npow %= p;\n    if npow == 0 {\n       \
    \ npow = 1;\n    }\n    npow\n}\n\nfn main() {\n    let candidate = modp;\n  \
    \  assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow2` in this scope\n  --> /tmp/tmphbc3pk_k.rs:13:20\n\
    \   |\n13 |     let mut npow = pow2(n);\n   |                    ^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmps606qjn5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpqwl58xiu.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpeah4bbip.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp1bytqpti.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmppphvwv2e.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 0;\n    while n > 0 {\n        if n % p == 0 {\n      \
    \      res += p;\n            n /= p;\n        } else {\n            res += 1;\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpal__lqvu.rs:17:13\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n17 |             n /= p;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4i0o9aus.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpwo3u4mkv.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpc5o96s6t.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return\
    \ p;\n    }\n    if n == p {\n        return n;\n    }\n    if n % p == 0 {\n\
    \        return modp(n - 1, p) * p;\n    }\n    if n % p == p {\n        return\
    \ modp(n - 1, p);\n    }\n    if n % p == 0 {\n        return modp(n - 1, p);\n\
    \    }\n    if n % p == p {\n        return modp(n - 1, p) * p;\n    }\n    if\
    \ n % p == 0 {\n        return modp(n - 1, p) * p;\n    }\n    if n % p == p {\n\
    \        return modp(n - 1, p);\n    }\n    if n % p == 0 {\n        return modp(n\
    \ - 1, p) * p;\n    }\n    if n % p == p {\n        return modp(n - 1, p) * p;\n\
    \    }\n    if n % p == 0 {\n        return modp(n - 1, p) * p;\n    }\n    if\
    \ n % p == p {\n        return modp(n - 1, p) * p;\n    }\n    if n % p == 0 {\n\
    \        return modp(n - 1, p) * p;\n    }\n    if n % p == p {\n        return\
    \ modp(n - 1, p) * p;\n    }\n    if n % p == 0 {\n        return modp(n - 1,\
    \ p) * p;\n    }\n    if n % p == p {\n        return modp(n - 1, p) * p;\n  \
    \  }\n    if n % p == 0 {\n        return modp(n - 1, p) * p;\n    }\n    if n\
    \ % p == p {\n        return modp(n - 1, p) * p;\n    }\n    if n % p == 0 {\n\
    \        return modp(n - 1, p) * p;\n    }\n    if n % p == p {\n        return\
    \ modp(n - 1, p) * p;\n    }\n    if n % p == 0 {\n        return modp(n - 1,\
    \ p) * p;\n    }\n    if n % p == p {\n        return modp(n - 1, p) * p;\n  \
    \  }\n    if n % p == 0 {\n        return modp(n - 1, p) * p;\n    }\n    if n\
    \ % p == p {\n        return modp(n - 1, p) * p;\n    }\n    if n % p == 0 {\n\
    \        return modp(n - 1, p) * p;\n    }\n    if n % p == p {\n        return\
    \ modp(n - 1, p) * p;\n    }\n    if n % p == 0 {\n        return modp(n - 1,\
    \ p) * p;\n    }\n    if n % p == p {\n        return modp(n - 1, p) * p;\n  \
    \  }\n    if n % p == 0 {\n        return modp(n - 1, p) * p;\n    }\n    if n\
    \ % p == p {\n        return modp(n - 1, p) * p;\n    }\n    if n % p == 0 {\n\
    \        return modp(n - 1, p) * p;\n    }\n    if n % p == p {\n        return\
    \ modp(n - 1, p) * p;\n    }\n    if n % p == 0 {\n        return mod\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpoji08oku.rs:125:3\n\
    \    |\n12  | fn modp(n: isize, p: isize) -> isize {\n    |                  \
    \                    - unclosed delimiter\n...\n112 |     if n % p == 0 {\n  \
    \  |                   - this delimiter might not be properly closed...\n113 |\
    \         return mod\n114 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n125 | }\n    |   ^\n\nerror: expected one of `.`, `;`, `?`,\
    \ `}`, or an operator, found keyword `mod`\n   --> /tmp/tmpoji08oku.rs:12:38\n\
    \    |\n12  | fn modp(n: isize, p: isize) -> isize {\n    |                  \
    \                    ^ unclosed delimiter\n...\n113 |         return mod\n   \
    \ |               -^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n  \
    \  |               |\n    |               help: `}` may belong here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoji08oku.rs:12:32\n   |\n12 | fn modp(n: isize,\
    \ p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p % 2 == 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != n);\n    debug_assert!(p != 0);\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdha7mxin.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpzc49lfy7.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n ^ (p - 1)\n    } else {\n        n & (p - 1)\n\
    \    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp5o4vbkom.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpd5m0eilg.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp3p_bae3z.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpr1fijncu.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpacejnipo.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p as isize)\n    } else {\n        n % p\n \
    \   }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpqosajyau.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    if result > p {\n        result = p - 1;\n \
    \   }\n    if result < 0 {\n        result = 0;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `100`,\n right: `2`', /tmp/tmpjm_go9gd.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::i32::MAX as usize);\n    debug_assert!(p <= std::u32::MAX as isize);\n\
    \    debug_assert!(p <= std::u32::MAX as usize);\n    debug_assert!(p <= std::i64::MAX\
    \ as isize);\n    debug_assert!(p <= std::i64::MAX as usize);\n    debug_assert!(p\
    \ <= std::u64::MAX as isize);\n    debug_assert!(p <= std::u64::MAX as usize);\n\
    \    debug_assert!(p <= std::isize::MAX as isize);\n    debug_assert!(p <= std::isize::MAX\
    \ as usize);\n    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p\
    \ <= std::usize::MAX as usize);\n    debug_assert!(p <= std::usize::MAX as isize);\n\
    \    debug_assert!(p <= std::usize::MAX as usize);\n    debug_assert!(p <= std::usize::MAX\
    \ as isize);\n    debug_assert!(p <= std::usize::MAX as usize);\n    debug_assert!(p\
    \ <= std::usize::MAX as isize);\n    debug_assert!(p <= std::usize::MAX as usize);\n\
    \    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p <= std::usize::MAX\
    \ as usize);\n    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p\
    \ <= std::usize::MAX as usize);\n    debug_assert!(p <= std::usize::MAX as isize);\n\
    \    debug_assert!(p <= std::usize::MAX as usize);\n    debug_assert!(p <= std::usize::MAX\
    \ as isize);\n    debug_assert!(p <= std::usize::MAX as usize);\n    debug_assert!(p\
    \ <= std::usize::MAX as isize);\n    debug_assert!(p <= std::usize::MAX as usize);\n\
    \    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p <= std::usize::MAX\
    \ as usize);\n    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p\
    \ <= std::usize::MAX as usize);\n    debug_assert!(p <= std::usize::MAX as isize);\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn50vx9i0.rs:17:24\n   |\n\
    17 |     debug_assert!(p <= std::i32::MAX as usize);\n   |                   \
    \     ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     debug_assert!(p <= (std::i32::MAX as usize).try_into().unwrap());\n\
    \   |                        +                      +++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpn50vx9i0.rs:19:24\n   |\n19 |  \
    \   debug_assert!(p <= std::u32::MAX as usize);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n19 |     debug_assert!(p\
    \ <= (std::u32::MAX as usize).try_into().unwrap());\n   |                    \
    \    +                      +++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn50vx9i0.rs:21:24\n   |\n21 |     debug_assert!(p <= std::i64::MAX\
    \ as usize);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     debug_assert!(p <= (std::i64::MAX\
    \ as usize).try_into().unwrap());\n   |                        +             \
    \         +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn50vx9i0.rs:23:24\n\
    \   |\n23 |     debug_assert!(p <= std::u64::MAX as usize);\n   |            \
    \            ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n23 |     debug_assert!(p <= (std::u64::MAX as usize).try_into().unwrap());\n\
    \   |                        +                      +++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpn50vx9i0.rs:25:24\n   |\n25 |  \
    \   debug_assert!(p <= std::isize::MAX as usize);\n   |                      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ conve"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp5ttmni0e.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpij282dji.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n >= p {\n        n\n    } else {\n        n % p\n    }\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmprr83lbja.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n - (n % p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpiuhlx2ab.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpd0h_2vr3.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n2 = n * n;\n    while n2 > p {\n        n2 -= p;\n    }\n  \
    \  n2\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpe8vgg7gx.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::u32::MAX as isize);\n    debug_assert!(p <= std::i64::MAX as isize);\n\
    \    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p <= std::isize::MAX\
    \ as isize);\n    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p\
    \ <= std::i8::MAX as isize);\n    debug_assert!(p <= std::u8::MAX as isize);\n\
    \    debug_assert!(p <= std::u16::MAX as isize);\n    debug_assert!(p <= std::u32::MAX\
    \ as isize);\n    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p\
    \ <= std::i16::MAX as isize);\n    debug_assert!(p <= std::u16::MAX as isize);\n\
    \    debug_assert!(p <= std::u32::MAX as isize);\n    debug_assert!(p <= std::u64::MAX\
    \ as isize);\n    debug_assert!(p <= std::i64::MAX as isize);\n    debug_assert!(p\
    \ <= std::u64::MAX as isize);\n    debug_assert!(p <= std::isize::MAX as isize);\n\
    \    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p <= std::i8::MAX\
    \ as isize);\n    debug_assert!(p <= std::u8::MAX as isize);\n    debug_assert!(p\
    \ <= std::u16::MAX as isize);\n    debug_assert!(p <= std::u32::MAX as isize);\n\
    \    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p <= std::i16::MAX\
    \ as isize);\n    debug_assert!(p <= std::u16::MAX as isize);\n    debug_assert!(p\
    \ <= std::u32::MAX as isize);\n    debug_assert!(p <= std::u64::MAX as isize);\n\
    \    debug_assert!(p <= std::i64::MAX as isize);\n    debug_assert!(p <= std::u64::MAX\
    \ as isize);\n    debug_assert!(p <= std::isize::MAX as isize);\n    debug_assert!(p\
    \ <= std::usize::MAX as isize);\n    debug_assert!(p <= std::i8::MAX as isize);\n\
    \    debug_assert!(p <= std::u8::MAX as isize);\n    \n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp17psff9x.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp4zoe1q4k.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    \n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpnsyeknvb.rs:15:24\n\
    \   |\n15 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmpnsyeknvb.rs:16:24\n   |\n16 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpnsyeknvb.rs:17:24\n\
    \   |\n17 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmpnsyeknvb.rs:18:24\n   |\n18 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpnsyeknvb.rs:19:24\n\
    \   |\n19 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmpnsyeknvb.rs:20:24\n   |\n20 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpnsyeknvb.rs:21:24\n\
    \   |\n21 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmpnsyeknvb.rs:22:24\n   |\n22 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpnsyeknvb.rs:23:24\n\
    \   |\n23 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmpnsyeknvb.rs:24:24\n   |\n24 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_D"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p);\n    debug_assert!(p ==\
    \ 0 || n % p == 0);\n    debug_assert!(p > 0);\n    debug_assert!(p <= 64);\n\
    \    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p <= std::u32::MAX\
    \ as isize);\n    debug_assert!(p <= std::i64::MAX as isize);\n    debug_assert!(p\
    \ <= std::u64::MAX as isize);\n    debug_assert!(p <= std::isize::MAX as isize);\n\
    \    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p <= std::i8::MAX\
    \ as isize);\n    debug_assert!(p <= std::u8::MAX as isize);\n    debug_assert!(p\
    \ <= std::u16::MAX as isize);\n    debug_assert!(p <= std::u32::MAX as isize);\n\
    \    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p <= std::i16::MAX\
    \ as isize);\n    debug_assert!(p <= std::u16::MAX as isize);\n    debug_assert!(p\
    \ <= std::u32::MAX as isize);\n    debug_assert!(p <= std::u64::MAX as isize);\n\
    \    debug_assert!(p <= std::i64::MAX as isize);\n    debug_assert!(p <= std::u64::MAX\
    \ as isize);\n    debug_assert!(p <= std::isize::MAX as isize);\n    debug_assert!(p\
    \ <= std::usize::MAX as isize);\n    debug_assert!(p <= std::i8::MAX as isize);\n\
    \    debug_assert!(p <= std::u8::MAX as isize);\n    debug_assert!(p <= std::u16::MAX\
    \ as isize);\n    debug_assert!(p <= std::u32::MAX as isize);\n    debug_assert!(p\
    \ <= std::u64::MAX as isize);\n    debug_assert!(p <= std::i16::MAX as isize);\n\
    \    debug_assert!(p <= std::u16::MAX as isize);\n    debug_assert!(p <= std::u32::MAX\
    \ as isize);\n    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p\
    \ <= std::i64::MAX as isize);\n    debug_assert!(p <= std::u64::MAX as isize);\n\
    \    debug_assert!(p <= std::isize::MAX as isize);\n    debug_assert!(p <= std::usize::MAX\
    \ as isize);\n    debug_assert!(p <= std::i8::\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmprqv7797l.rs:50:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n50 |     debug_assert!(p\
    \ <= std::i8::\n   |                  ^ unclosed delimiter\n51 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror: expected identifier, found `<eof>`\n  --> /tmp/tmprqv7797l.rs:50:31\n\
    \   |\n50 |     debug_assert!(p <= std::i8::\n   |                           \
    \    ^^ expected identifier\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprqv7797l.rs:14:5\n\
    \   |\n14 |     debug_assert!(p);\n   |     ^^^^^^^^^^^^^^^^ expected `bool`,\
    \ found `isize`\n   |\n   = note: this error originates in the macro `debug_assert`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprqv7797l.rs:50:5\n   |\n50 | /     debug_assert!(p\
    \ <= std::i8::\n51 | | }\n   | |_^ expected `isize`, found `()`\n   |\n   = note:\
    \ this error originates in the macro `debug_assert` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpql7nrd76.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p\
    \ != 2);\n    debug_assert!(p != 3);\n    debug_assert!(p != 4);\n    debug_assert!(p\
    \ != 5);\n    debug_assert!(p != 6);\n    debug_assert!(p != 7);\n    debug_assert!(p\
    \ != 8);\n    debug_assert!(p != 9);\n    debug_assert!(p != 10);\n    debug_assert!(p\
    \ != 11);\n    debug_assert!(p != 12);\n    debug_assert!(p != 13);\n    debug_assert!(p\
    \ != 14);\n    debug_assert!(p != 15);\n    debug_assert!(p != 16);\n    debug_assert!(p\
    \ != 17);\n    debug_assert!(p != 18);\n    debug_assert!(p != 19);\n    debug_assert!(p\
    \ != 20);\n    debug_assert!(p != 21);\n    debug_assert!(p != 22);\n    debug_assert!(p\
    \ != 23);\n    debug_assert!(p != 24);\n    debug_assert!(p != 25);\n    debug_assert!(p\
    \ != 26);\n    debug_assert!(p != 27);\n    debug_assert!(p != 28);\n    debug_assert!(p\
    \ != 29);\n    debug_assert!(p != 30);\n    debug_assert!(p != 31);\n    debug_assert!(p\
    \ != 32);\n    debug_assert!(p != 33);\n    debug_assert!(p != 34);\n    debug_assert!(p\
    \ != 35);\n    debug_assert!(p != 36);\n    debug_assert!(p != 37);\n    debug_assert!(p\
    \ != 38);\n    debug_assert!(p != 39);\n    debug_assert!(p != 40);\n    debug_assert!(p\
    \ != 41);\n    debug_assert!(p != 42);\n    debug_assert!(p != 43);\n    debug_assert!(p\
    \ != 44);\n    debug_assert!(p != 45);\n    debug_assert!(p != 46);\n    debug_assert!(p\
    \ != 47);\n    debug_assert!(p != 48);\n    debug_assert!(p != 49);\n    debug_assert!(p\
    \ != 50);\n    debug_assert!(p != 51);\n    debug_assert!(p != 52);\n    debug_assert!(p\
    \ != 53);\n    debug_assert!(p != 54);\n    debug_assert!(p != 55);\n    debug_assert!(\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp6qaxjt65.rs:72:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n72 |     debug_assert!(\n\
    \   |                  ^ unclosed delimiter\n73 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: macro requires a boolean expression as an argument\n  -->\
    \ /tmp/tmp6qaxjt65.rs:72:5\n   |\n72 | /     debug_assert!(\n73 | | }\n   | |_^\
    \ boolean expression required\n   |\n   = note: this error originates in the macro\
    \ `debug_assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6qaxjt65.rs:72:5\n   |\n72 | /\
    \     debug_assert!(\n73 | | }\n   | |_^ expected `isize`, found `()`\n   |\n\
    \   = note: this error originates in the macro `debug_assert` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n - (n % p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpiopseada.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpe8l_f85n.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n > 0);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    \n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq4dmbmjq.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p % 2 == 0);\n    debug_assert!(n % 2 == 0);\n    n\
    \ + (n - p) / 2\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmp6rinio6x.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n > 0);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ < n);\n    (p - 1) & (n - 1)\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmp2877ga8c.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(n % p == 0);\n    n / p\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmpb4ygaw3l.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    \n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpwwdk9s52.rs:15:24\n\
    \   |\n15 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmpwwdk9s52.rs:16:24\n   |\n16 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpwwdk9s52.rs:17:24\n\
    \   |\n17 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmpwwdk9s52.rs:18:24\n   |\n18 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpwwdk9s52.rs:19:24\n\
    \   |\n19 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmpwwdk9s52.rs:20:24\n   |\n20 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpwwdk9s52.rs:21:24\n\
    \   |\n21 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmpwwdk9s52.rs:22:24\n   |\n22 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpwwdk9s52.rs:23:24\n\
    \   |\n23 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmpwwdk9s52.rs:24:24\n   |\n24 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_D"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpgzsktta9.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n1 = n;\n    let mut n2 = n;\n    let mut n3 = n;\n    let mut\
    \ n4 = n;\n    let mut n5 = n;\n    let mut n6 = n;\n    let mut n7 = n;\n   \
    \ let mut n8 = n;\n    let mut n9 = n;\n    let mut n10 = n;\n    let mut n11\
    \ = n;\n    let mut n12 = n;\n    let mut n13 = n;\n    let mut n14 = n;\n   \
    \ let mut n15 = n;\n    let mut n16 = n;\n    let mut n17 = n;\n    let mut n18\
    \ = n;\n    let mut n19 = n;\n    let mut n20 = n;\n    let mut n21 = n;\n   \
    \ let mut n22 = n;\n    let mut n23 = n;\n    let mut n24 = n;\n    let mut n25\
    \ = n;\n    let mut n26 = n;\n    let mut n27 = n;\n    let mut n28 = n;\n   \
    \ let mut n29 = n;\n    let mut n30 = n;\n    let mut n31 = n;\n    let mut n32\
    \ = n;\n    let mut n33 = n;\n    let mut n34 = n;\n    let mut n35 = n;\n   \
    \ let mut n36 = n;\n    let mut n37 = n;\n    let mut n38 = n;\n    let mut n39\
    \ = n;\n    let mut n40 = n;\n    let mut n41 = n;\n    let mut n42 = n;\n   \
    \ let mut n43 = n;\n    let mut n44 = n;\n    let mut n45 = n;\n    let mut n46\
    \ = n;\n    let mut n47 = n;\n    let mut n48 = n;\n    let mut n49 = n;\n   \
    \ let mut n50 = n;\n    let mut n51 = n;\n    let mut n52 = n;\n    let mut n53\
    \ = n;\n    let mut n54 = n;\n    let mut n55 = n;\n    let mut n56 = n;\n   \
    \ let mut n57 = n;\n    let mut n58 = n;\n    let mut n59 = n;\n    let mut n60\
    \ = n;\n    let mut n61 = n;\n    let mut n62 = n;\n    let mut n63 = n;\n   \
    \ let mut n64 = n;\n    let mut n65 = n;\n    let mut n66\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1l9abp5w.rs:78:16\n   |\n\
    78 |     let mut n66\n   |                ^ help: add `;` here\n79 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1l9abp5w.rs:12:32\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----             \
    \           ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p % 2 == 0);\n    debug_assert!(n % p == 0);\n    n\
    \ / p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmpzvic586i.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp8ra0puxv.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p {\n        result -= p;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp4_w_m7nz.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return\
    \ p;\n    }\n    if n == p {\n        return n;\n    }\n    if n < p {\n     \
    \   return modp(n - 1, p) + p;\n    }\n    if n > p {\n        return modp(n,\
    \ p - 1) + p;\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0317]: `if` may be missing an `else` clause\n  --> /tmp/tmpb656qoev.rs:25:5\n\
    \   |\n12 |   fn modp(n: isize, p: isize) -> isize {\n   |                   \
    \               ----- expected `isize` because of this return type\n...\n25 |\
    \ /     if n > p {\n26 | |         return modp(n, p - 1) + p;\n27 | |     }\n\
    \   | |_____^ expected `isize`, found `()`\n   |\n   = note: `if` expressions\
    \ without `else` evaluate to `()`\n   = help: consider adding an `else` block\
    \ that evaluates to the expected type\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0317`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p {\n        result -= p;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmplgboccqe.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpev22wxf0.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpa_mw84w5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p as isize)\n    } else {\n        n % p\n \
    \   }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpcdr2ql4b.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpk29cpm_0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return\
    \ p;\n    }\n    if p == 1 {\n        return n;\n    }\n    if p < n {\n     \
    \   return modp(n - 1, p) % p;\n    }\n    modp(n - 1, p)\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpoj6i6vys.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(n % p == 0);\n    n / p\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmp8pbtysyw.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpjvouhj5k.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n > 0);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(n % p == 0);\n    n / p\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmpn80oicb2.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpg_tn09ft.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmptelfizsb.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    let mut result = n;\n    while result > p {\n        result -= p;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmpzubxf894.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 256);\n    \n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk22z_vp2.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpcufk_6er.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n > 0);\n    debug_assert!(p > 0);\n    let mut result\
    \ = 1;\n    while n > 0 {\n        if n % p == 0 {\n            result *= p;\n\
    \            n /= p;\n        } else {\n            result *= n;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpa2_9ipzo.rs:19:13\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n19 |             n /= p;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpy84fgkxr.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(n <= 64);\n    let mut result = n;\n    while result\
    \ > p {\n        result -= p;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p <= n', /tmp/tmpwjy6fg1u.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut npow = pow2(n);\n    npow %= p;\n    if npow == 0 {\n       \
    \ npow = 1;\n    }\n    npow\n}\n\nfn main() {\n    let candidate = modp;\n  \
    \  assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow2` in this scope\n  --> /tmp/tmpbz61pfl1.rs:13:20\n\
    \   |\n13 |     let mut npow = pow2(n);\n   |                    ^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(n % p == 0);\n    n / p\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: p < n', /tmp/tmphvhq84q1.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp4pb8d3n0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n > 0 && p > 0);\n    let mut result = 1;\n    while n\
    \ > 0 {\n        if n % p == 0 {\n            result *= p;\n            n /= p;\n\
    \        } else {\n            result *= p;\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpy4y9ft2s.rs:18:13\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n18 |             n /= p;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p % 2 == 0);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n\
    \ >= p);\n    debug_assert!(n % p == 0);\n    debug_assert!(n >= 2);\n    debug_assert!(n\
    \ % 2 == 0);\n    debug_assert!(n >= 2);\n    debug_assert!(n % 2 == 0);\n   \
    \ debug_assert!(n >= 2);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n\
    \ >= 2);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n >= 2);\n    debug_assert!(n\
    \ % 2 == 0);\n    debug_assert!(n >= 2);\n    debug_assert!(n % 2 == 0);\n   \
    \ debug_assert!(n >= 2);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n\
    \ >= 2);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n >= 2);\n    debug_assert!(n\
    \ % 2 == 0);\n    debug_assert!(n >= 2);\n    debug_assert!(n % 2 == 0);\n   \
    \ debug_assert!(n >= 2);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n\
    \ >= 2);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n >= 2);\n    debug_assert!(n\
    \ % 2 == 0);\n    debug_assert!(n >= 2);\n    debug_assert!(n % 2 == 0);\n   \
    \ debug_assert!(n >= 2);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n\
    \ >= 2);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n >= 2);\n    debug_assert!(n\
    \ % 2 == 0);\n    debug_assert!(n >= 2);\n    debug_assert!(n % 2 == 0);\n   \
    \ debug_assert!(n >= 2);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n\
    \ >= 2);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n >= 2);\n    debug_assert!(n\
    \ % 2 == 0);\n    debug_assert!(n >= 2);\n    debug_assert!(n % 2 == 0);\n   \
    \ debug_assert!(n >= 2);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n\
    \ >= 2);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n >= 2);\n    debug_assert!(n\
    \ % 2 == 0);\n    debug_assert!(n >= 2);\n    debug_assert!(n % 2 == 0);\n   \
    \ debug_assert!(n >= 2);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n\
    \ >= 2);\n    debug_assert!(n % 2 == 0);\n    debug_assert!(n >= \n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmps6lyyxpx.rs:76:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n76 |     debug_assert!(n\
    \ >= \n   |                  ^ unclosed delimiter\n77 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: expected expression, found end of macro arguments\n  -->\
    \ /tmp/tmps6lyyxpx.rs:76:23\n   |\n76 |     debug_assert!(n >= \n   |        \
    \               ^ expected expression\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmps6lyyxpx.rs:76:5\n   |\n76 | /     debug_assert!(n >= \n77 | | }\n \
    \  | |_^ expected `isize`, found `()`\n   |\n   = note: this error originates\
    \ in the macro `debug_assert` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmprhl_np6z.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= std::i32::MAX);\n    debug_assert!(p <= std::i64::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::u16::MAX);\n\
    \    debug_assert!(p <= std::u32::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::i8::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::i8::MAX);\n\
    \    debug_assert!(p <= std::u16::MAX);\n    debug_assert!(p <= std::u32::MAX);\n\
    \    debug_assert!(p <= std::u64::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::i8::MAX);\n    debug_assert!(p <= std::u16::MAX);\n\
    \    debug_assert!(p <= std::u32::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::i8::MAX);\n\
    \    debug_assert!(p <= std::u16::MAX);\n    debug_assert!(p <= std::u32::MAX);\n\
    \    debug_assert!(p <= std::u64::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::i8::MAX);\n    debug_assert!(p <= std::u16::MAX);\n\
    \    debug_assert!(p <= std::u32::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::i8::MAX);\n\
    \    debug_assert!(p <= std::u16::MAX);\n    debug_assert!(p <= std::u32::MAX);\n\
    \    debug_assert!(p <= std::u64::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::i8::MAX);\n    debug_assert!(p <= std::u16::MAX);\n\
    \    debug_assert!(p <= std::u32::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::i8::MAX\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpl5hn8chl.rs:55:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n55 |     debug_assert!(p\
    \ <= std::i8::MAX\n   |                  ^ unclosed delimiter\n56 | }\n   | ^\
    \ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl5hn8chl.rs:16:24\n\
    \   |\n16 |     debug_assert!(p <= std::i32::MAX);\n   |                     \
    \   ^^^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert an\
    \ `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n16 |\
    \     debug_assert!(p <= std::i32::MAX.try_into().unwrap());\n   |           \
    \                          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl5hn8chl.rs:17:24\n   |\n17 |     debug_assert!(p <= std::i64::MAX);\n\
    \   |                        ^^^^^^^^^^^^^ expected `isize`, found `i64`\n   |\n\
    help: you can convert an `i64` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n17 |     debug_assert!(p <= std::i64::MAX.try_into().unwrap());\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl5hn8chl.rs:18:24\n   |\n18 |     debug_assert!(p\
    \ <= std::usize::MAX);\n   |                        ^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |     debug_assert!(p <= std::usize::MAX.try_into().unwrap());\n\
    \   |                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl5hn8chl.rs:19:24\n   |\n19 |     debug_assert!(p\
    \ <= std::u16::MAX);\n   |                        ^^^^^^^^^^^^^ expected `isize`,\
    \ found `u16`\n   |\nhelp: you can convert a `u16` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |     debug_assert!(p <= std::u16::MAX.try_into().unwrap());\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl5hn8chl."
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p != 1);\n    debug_assert!(p != 2);\n    debug_assert!(p\
    \ != 4);\n    debug_assert!(p != 8);\n    debug_assert!(p != 16);\n    debug_assert!(p\
    \ != 32);\n    debug_assert!(p != 64);\n    debug_assert!(p != 128);\n    debug_assert!(p\
    \ != 256);\n    debug_assert!(p != 512);\n    debug_assert!(p != 1024);\n    debug_assert!(p\
    \ != 2048);\n    debug_assert!(p != 4096);\n    debug_assert!(p != 8192);\n  \
    \  debug_assert!(p != 16384);\n    debug_assert!(p != 32768);\n    debug_assert!(p\
    \ != 65536);\n    debug_assert!(p != 131072);\n    debug_assert!(p != 262144);\n\
    \    debug_assert!(p != 524288);\n    debug_assert!(p != 1048576);\n    debug_assert!(p\
    \ != 2097152);\n    debug_assert!(p != 4194304);\n    debug_assert!(p != 8388608);\n\
    \    debug_assert!(p != 16777216);\n    debug_assert!(p != 33554432);\n    debug_assert!(p\
    \ != 67108864);\n    debug_assert!(p != 134217728);\n    debug_assert!(p != 268435456);\n\
    \    debug_assert!(p != 536870912);\n    debug_assert!(p != 1073741824);\n   \
    \ debug_assert!(p != -2147483648);\n    debug_assert!(p != -1);\n    debug_assert!(p\
    \ != 1);\n    debug_assert!(p != 2);\n    debug_assert!(p != 4);\n    debug_assert!(p\
    \ != 8);\n    debug_assert!(p != 16);\n    debug_assert!(p != 32);\n    debug_assert!(p\
    \ != 64);\n    debug_assert!(p != 128);\n    debug_assert!(p != 256);\n    debug_assert!(p\
    \ != 512);\n    debug_assert!(p != 1024);\n    debug_assert!(p != 2048);\n   \
    \ debug_assert!(p != 4096);\n    debug_assert!(p != 8192);\n    debug_assert!(p\
    \ != 16384);\n    debug_assert!(p != 32768);\n    debug_assert!(p != 65536);\n\
    \    debug_assert!(p != 131072);\n    \n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj6dlezp2.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = n;\n    while res > p {\n        res -= p;\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp0qoqnjj6.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n - (n % p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpk4rye1f2.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 0;\n    while n > 0 {\n        if n % p == 0 {\n      \
    \      res += p;\n        }\n        n /= p;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpfdpcdgpk.rs:18:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n18 |         n /= p;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp8r362g2t.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p <= n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= n);\n\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfe_8w7fi.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
