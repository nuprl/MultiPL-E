name: HumanEval_6_parse_nested_parens
language: rust
results:
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut paren_count =\
    \ 0;\n    let mut paren_level = 0;\n    let mut paren_start = 0;\n    let mut\
    \ paren_end = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd94f59km.rs:48:18\n   |\n\
    48 |     let mut paren\n   |                  ^ help: add `;` here\n49 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpd94f59km.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = 0;\n    let\
    \ mut paren_levels_stack_size = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = 0;\n    let mut paren_levels_stack_size\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_pos = 0;\n    let mut paren_levels_stack_size = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = 0;\n    let\
    \ mut paren_levels_stack_size = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = 0;\n    let mut paren_levels_stack_size\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_pos = 0;\n    let mut paren_levels_stack_size = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = 0;\n    let\
    \ mut paren_levels_stack_size = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpas56ic9c.rs:40:44\n   |\n\
    40 |     let mut paren_levels_stack_top = paren_\n   |                       \
    \                     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `paren_` in this scope\n  --> /tmp/tmpas56ic9c.rs:40:38\n\
    \   |\n40 |     let mut paren_levels_stack_top = paren_\n   |                \
    \                      ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpas56ic9c.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_chars = vec![];\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_char_length\
    \ = 0;\n    let mut paren_level_char_char_length = 0;\n    let mut paren_level_char_char_char_length\
    \ = 0;\n    let mut paren_level_char_char_char_char_length = 0;\n    let mut paren_level_char_char_char_char_char_length\
    \ = 0;\n    let mut paren_level_char_char_char_char_char_char_length = 0;\n  \
    \  let mut paren_level_char_char_char_char_char_char_char_length = 0;\n    let\
    \ mut paren_level_char_char_char_char_char_char_char_char_length = 0;\n    let\
    \ mut paren_level_char_char_char_char_char_char_char_char_char_length = 0;\n \
    \   let mut paren_level_char_char_char_char_char_char_char_char_char_char_length\
    \ = 0;\n    let mut paren_level_char_char_char_char_char_char_char_char_char_char_char_length\
    \ = 0;\n    let mut paren_level_char_char_char_char_char_char_char_char_char_char_char_length\
    \ = 0;\n    let mut paren_level_char_char_char_char_char_char_char_char_char_char_char_char_length\
    \ = 0;\n    let mut paren_level_char_char_char_char_char_char_char_char_char_char_char_char_char_length\
    \ = 0;\n    let mut paren_level_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length\
    \ = 0;\n    let mut paren_level_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length\
    \ = 0;\n    let mut paren_level_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length\
    \ = 0;\n    let mut paren_level_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length\
    \ = 0;\n    let mut paren_level_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length\
    \ = 0;\n    let mut paren_level_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length\
    \ = 0;\n    let mut paren_level_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length\
    \ = 0;\n    let mut paren_level_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_length\
    \ = 0;\n    let mut paren_level_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4umoue5b.rs:34:110\n   |\n\
    34 |     let mut paren_level_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_\n\
    \   |                                                                        \
    \                                      ^ help: add `;` here\n35 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4umoue5b.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2gpbv7ue.rs:37:32\n   |\n\
    37 |     let mut paren_levels_stack_\n   |                                ^ help:\
    \ add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp2gpbv7ue.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_pos = 0;\n    let\
    \ mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_pos = 0;\n\
    \    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_pos = 0;\n    let\
    \ mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_pos = 0;\n\
    \    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_pos = 0;\n    let\
    \ mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_pos = 0;\n\
    \    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_pos = 0;\n    let\
    \ mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_pos = 0;\n\
    \    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_pos = 0;\n    let\
    \ mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_pos = 0;\n\
    \    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp10xhbono.rs:42:43\n   |\n\
    42 |     let mut paren_levels_stack_top = paren\n   |                        \
    \                   ^ help: add `;` here\n43 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `paren` in this scope\n  --> /tmp/tmp10xhbono.rs:42:38\n\
    \   |\n42 |     let mut paren_levels_stack_top = paren\n   |                 \
    \                     ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp10xhbono.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: usize = 0;\n    let mut paren_levels: Vec<isize> = vec![];\n  \
    \  let mut paren_levels_len: usize = 0;\n    let mut paren_levels_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_len: usize = 0;\n    let mut paren_levels_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_len: usize = 0;\n \
    \   let mut paren_levels_lens_lens_lens: Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens: Vec<isize> = vec![];\n\
    \    let mut paren_levels_lens_lens_lens_lens_len: usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_len: usize\
    \ = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmp2vcbjo.rs:28:36\n   |\n\
    28 |     let mut paren_levels_lens_lens_\n   |                               \
    \     ^ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpmp2vcbjo.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut paren_count\
    \ = 0;\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_len = 0;\n    let mut paren_levels_lens = Vec::new();\n\
    \    let mut paren_levels_lens_len = 0;\n    let mut paren_levels_lens_len2 =\
    \ 0;\n    let mut paren_levels_lens_len3 = 0;\n    let mut paren_levels_lens_len4\
    \ = 0;\n    let mut paren_levels_lens_len5 = 0;\n    let mut paren_levels_lens_len6\
    \ = 0;\n    let mut paren_levels_lens_len7 = 0;\n    let mut paren_levels_lens_len8\
    \ = 0;\n    let mut paren_levels_lens_len9 = 0;\n    let mut paren_levels_lens_len10\
    \ = 0;\n    let mut paren_levels_lens_len11 = 0;\n    let mut paren_levels_lens_len12\
    \ = 0;\n    let mut paren_levels_lens_len13 = 0;\n    let mut paren_levels_lens_len14\
    \ = 0;\n    let mut paren_levels_lens_len15 = 0;\n    let mut paren_levels_lens_len16\
    \ = 0;\n    let mut paren_levels_lens_len17 = 0;\n    let mut paren_levels_lens_len18\
    \ = 0;\n    let mut paren_levels_lens_len19 = 0;\n    let mut paren_levels_lens_len20\
    \ = 0;\n    let mut paren_levels_lens_len21 = 0;\n    let mut paren_levels_lens_len22\
    \ = 0;\n    let mut paren_levels_lens_len23 = 0;\n    let mut paren_levels_lens_len24\
    \ = 0;\n    let mut paren_levels_lens_len25 = 0;\n    let mut paren_levels_lens_len26\
    \ = 0;\n    let mut paren_levels_lens_len27 = 0;\n    let mut paren_levels_lens_len28\
    \ = 0;\n    let mut paren_levels_lens_len29 = 0;\n    let mut paren_levels_lens_len30\
    \ = 0;\n    let mut paren_levels_lens_len31 = 0;\n    let mut paren_levels_lens_len32\
    \ = 0;\n    let mut paren_levels_lens_len33 = 0;\n    let mut paren_levels_lens_len34\
    \ = 0;\n    let mut paren_levels_lens_len35 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptzeo_zq9.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_stack = vec![];\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_len = paren_level_stack.len();\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptk7uo28p.rs:43:55\n   |\n\
    43 |     let mut paren_level_stack_top = paren_level_stack_\n   |            \
    \                                           ^ help: add `;` here\n44 | }\n   |\
    \ - unexpected token\n\nerror[E0425]: cannot find value `paren_level_stack_` in\
    \ this scope\n  --> /tmp/tmptk7uo28p.rs:43:37\n   |\n43 |     let mut paren_level_stack_top\
    \ = paren_level_stack_\n   |                                     ^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_level_stack`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmptk7uo28p.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_count_max = 0;\n    let mut paren_level_char_pos_count_max_index\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index2 = 0;\n    let mut paren_level_char_pos_count_max_index3\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index4 = 0;\n    let mut paren_level_char_pos_count_max_index5\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index6 = 0;\n    let mut paren_level_char_pos_count_max_index7\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index8 = 0;\n    let mut paren_level_char_pos_count_max_index9\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index10 = 0;\n    let mut paren_level_char_pos_count_max_index11\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index12 = 0;\n    let mut paren_level_char_pos_count_max_index13\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index14 = 0;\n    let mut paren_level_char_pos_count_max_index15\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index16 = 0;\n    let mut paren_level_char_pos_count_max_index17\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index18 = 0;\n    let mut paren_level_char_pos_count_max_index19\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index20 = 0;\n    let mut paren_level_char_pos_count_max_index21\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index22 = 0;\n    let mut paren_level_char_pos_count_max_index23\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index24 = 0;\n    let mut paren_level_char_pos_count_max_index25\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index26 = 0;\n    let mut paren_level_char_pos_count_max_index27\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index28 = 0;\n    let mut paren_level_char_pos_count_max_index29\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index30 = 0;\n    let mut paren_level_char_pos_count_max_index31\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index32\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjl4hsw8b.rs:45:51\n   |\n\
    45 |     let mut paren_level_char_pos_count_max_index32\n   |                \
    \                                   ^ help: add `;` here\n46 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpjl4hsw8b.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcv_a1k2h.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpcv_a1k2h.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting_level = 0;\n    let mut paren_nesting_levels\
    \ = Vec::new();\n    let mut paren_nesting_levels_len = paren_nesting_levels.len();\n\
    \    let mut paren_nesting_levels_lens = paren_nesting_levels_len.clone();\n \
    \   let mut paren_nesting_levels_lens_len = paren_nesting_levels_lens.len();\n\
    \    let mut paren_nesting_levels_lens_len = 0;\n    let mut paren_nesting_levels_lens_lens\
    \ = paren_nesting_levels_lens_len.clone();\n    let mut paren_nesting_levels_lens_lens_len\
    \ = paren_nesting_levels_lens_lens.len();\n    let mut paren_nesting_levels_lens_lens_len\
    \ = 0;\n    let mut paren_nesting_levels_lens_lens_lens = paren_nesting_levels_lens_lens_len.clone();\n\
    \    let mut paren_nesting_levels_lens_lens_lens_len = paren_nesting_levels_lens_lens_lens.len();\n\
    \    let mut paren_nesting_levels_lens_lens_lens_len = 0;\n    let mut paren_nesting_levels_lens_lens_lens_lens\
    \ = paren_nesting_levels_lens_lens_lens_len.clone();\n    let mut paren_nesting_levels_lens_lens_lens_lens_len\
    \ = paren_nesting_levels_lens_lens_lens_lens.len();\n    let mut paren_nesting_levels_lens_lens_lens_lens_len\
    \ = 0;\n    let mut paren_nesting_levels_lens_lens_lens_lens_lens = paren_nesting_levels_lens_lens_lens_lens_lens_len.clone();\n\
    \    let mut paren_nesting_levels_lens_lens_lens_lens_lens_len = paren_nesting_levels_lens_lens_lens_lens_lens_lens.len();\n\
    \    let mut paren_nesting_levels_lens_lens_lens_lens_lens_len = 0;\n    let mut\
    \ paren_nesting_levels_lens_lens_lens_lens_lens_lens = paren_nesting_levels_lens_lens_lens_lens_lens_lens_lens_.clone();\n\
    \    let mut paren_nesting_levels_lens_len\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpu47n8y35.rs:28:42\n   |\n\
    28 |     let mut paren_nesting_levels_lens_len\n   |                         \
    \                 ^ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `paren_nesting_levels_lens_lens_lens_lens_lens_len` in this\
    \ scope\n  --> /tmp/tmpu47n8y35.rs:24:61\n   |\n24 |     let mut paren_nesting_levels_lens_lens_lens_lens_lens\
    \ = paren_nesting_levels_lens_lens_lens_lens_lens_len.clone();\n   |         \
    \                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_nesting_levels_lens_lens_lens_lens_len`\n\
    \nerror[E0425]: cannot find value `paren_nesting_levels_lens_lens_lens_lens_lens_lens`\
    \ in this scope\n  --> /tmp/tmpu47n8y35.rs:25:65\n   |\n25 |     let mut paren_nesting_levels_lens_lens_lens_lens_lens_len\
    \ = paren_nesting_levels_lens_lens_lens_lens_lens_lens.len();\n   |          \
    \                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_nesting_levels_lens_lens_lens_lens_lens`\n\
    \nerror[E0425]: cannot find value `paren_nesting_levels_lens_lens_lens_lens_lens_lens_lens_`\
    \ in this scope\n  --> /tmp/tmpu47n8y35.rs:27:66\n   |\n27 |     let mut paren_nesting_levels_lens_lens_lens_lens_lens_lens\
    \ = paren_nesting_levels_lens_lens_lens_lens_lens_lens_lens_.clone();\n   |  \
    \                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_nesting_levels_lens_lens_lens_lens_lens_len`\n\
    \nerror[E0599]: no method named `len` found for type `usize` in the current scope\n\
    \  --> /tmp/tmpu47n8y35.rs:13:71\n   |\n13 |     let mut paren_nesting_levels_lens_len\
    \ = paren_nesting_levels_lens.len();\n   |                                   \
    \                                    ^^^ method not found in `usize`\n\nerror[E0689]:\
    \ can't call method `len` on ambiguous numeric typ"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut paren_level =\
    \ 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_stack = Vec::new();\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_len = paren_level_stack.len();\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6_zjij97.rs:43:55\n   |\n\
    43 |     let mut paren_level_stack_top = paren_level_stack_\n   |            \
    \                                           ^ help: add `;` here\n44 | }\n   |\
    \ - unexpected token\n\nerror[E0425]: cannot find value `paren_level_stack_` in\
    \ this scope\n  --> /tmp/tmp6_zjij97.rs:43:37\n   |\n43 |     let mut paren_level_stack_top\
    \ = paren_level_stack_\n   |                                     ^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_level_stack`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp6_zjij97.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack = Vec::new();\n\
    \    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n    let\
    \ mut paren_levels_len = paren_stack.len();\n    let mut paren_levels_len_ptr\
    \ = paren_levels_len as *const isize;\n    let mut paren_levels_ptr = paren_levels_len_ptr\
    \ as *const Vec<isize>;\n    let mut paren_levels_ptr_len = paren_levels_ptr as\
    \ *const usize;\n    let mut paren_levels_ptr_len_copy = paren_levels_len_ptr\
    \ as *const usize;\n    let mut paren_levels_ptr_len_copy_copy = paren_levels_ptr_len_copy\
    \ as *const usize;\n    let mut paren_levels_ptr_len_copy_copy_copy = paren_levels_ptr_len_copy_copy\
    \ as *const usize;\n    let mut paren_levels_ptr_len_copy_copy_copy_copy = paren_levels_ptr_len_copy_copy_copy\
    \ as *const usize;\n    let mut paren_levels_ptr_len_copy_copy_copy_copy_copy\
    \ = paren_levels_ptr_len_copy_copy_copy_copy_copy as *const usize;\n    let mut\
    \ paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy = paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy\
    \ as *const usize;\n    let mut paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy_copy\
    \ = paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy_copy as *const usize;\n\
    \    let mut paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy_copy_copy\
    \ = paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy as\
    \ *const usize;\n    let mut paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy\
    \ = paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy\
    \ as *const usize;\n    let mut paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy\
    \ = paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy\
    \ as *const usize;\n    let mut paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy\
    \ = paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdrqjnewo.rs:25:177\n   |\n\
    25 |     let mut paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy\
    \ = paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_\n\
    \   |                                                                        \
    \                                                                            \
    \                             ^ help: add `;` here\n26 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `paren_levels_ptr_len_copy_copy_copy_copy_copy`\
    \ in this scope\n  --> /tmp/tmpdrqjnewo.rs:19:61\n   |\n19 |     let mut paren_levels_ptr_len_copy_copy_copy_copy_copy\
    \ = paren_levels_ptr_len_copy_copy_copy_copy_copy as *const usize;\n   |     \
    \                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_ptr_len_copy_copy_copy_copy`\n\
    \nerror[E0425]: cannot find value `paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy`\
    \ in this scope\n  --> /tmp/tmpdrqjnewo.rs:20:71\n   |\n20 | ...opy_copy_copy_copy_copy_copy\
    \ = paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy as *const usize;\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_ptr_len_copy_copy_copy_copy_copy`\n\
    \nerror[E0425]: cannot find value `paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy_copy`\
    \ in this scope\n  --> /tmp/tmpdrqjnewo.rs:21:76\n   |\n21 | ...y_copy_copy_copy_copy_copy\
    \ = paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy_copy as *const usize;\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy`\n\
    \nerror[E0425]: cannot find value `paren_levels_ptr_len_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy`\
    \ in this scope\n  --> /tmp/tmpdrqjnewo.rs:22:81\n   |\n22 | ...py_copy_copy_copy"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len\
    \ = paren_level_chars.len();\n    let mut paren_level_char_pos = 0;\n    let mut\
    \ paren_level_char_len = paren_level_chars.len();\n    let mut paren_level_char_pos\
    \ = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n    let mut\
    \ paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptqvah84s.rs:47:30\n   |\n\
    47 |     let mut paren_level_char_\n   |                              ^ help:\
    \ add `;` here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmptqvah84s.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr = paren_levels_stack;\n    let mut paren_levels_stack_ptr_pos\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_size = paren_levels_stack_ptr.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack_ptr + paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_ptr_end_pos = paren_levels_stack_ptr_end;\n  \
    \  let mut paren_levels_stack_ptr_end_size = paren_levels_stack_ptr_end - paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr_end;\n  \
    \  let mut paren_levels_stack_ptr_end_ptr_pos = paren_levels_stack_ptr_end_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_size = paren_levels_stack_ptr_end_ptr\
    \ - paren_levels_stack_ptr_end;\n    let mut paren_levels_stack_ptr_end_ptr_end\
    \ = paren_levels_stack_ptr_end_ptr + paren_levels_stack_ptr_end_size;\n    let\
    \ mut paren_levels_stack_ptr_end_ptr_end_pos = paren_levels_stack_ptr_end_ptr_end;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_size = paren_levels_stack_ptr_end_ptr_end\
    \ - paren_levels_stack_ptr_end_ptr;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr\
    \ = paren_levels_stack_ptr_end_ptr_end;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_pos\
    \ = paren_levels_stack_ptr_end_ptr_end_ptr;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_size\
    \ = paren_levels_stack_ptr_end_ptr_end_ptr - paren_levels_stack_ptr_end_ptr_end;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end = paren_levels_stack_ptr_end_ptr_end_ptr\
    \ + paren_levels_stack_ptr_end_ptr_end_size;\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `usize` to `Vec<_>`\n  --> /tmp/tmprx78th1y.rs:15:65\n\
    \   |\n15 |     let mut paren_levels_stack_ptr_end = paren_levels_stack_ptr +\
    \ paren_levels_stack_size;\n   |                                          ----------------------\
    \ ^ ----------------------- usize\n   |                                      \
    \    |\n   |                                          Vec<_>\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmprx78th1y.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_stack = Vec::new();\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_len = paren_level_stack.len();\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpn8fhbyay.rs:44:49\n   |\n\
    44 |     let mut paren_level_stack_top = paren_level_\n   |                  \
    \                               ^ help: add `;` here\n45 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `paren_level_` in this scope\n  -->\
    \ /tmp/tmpn8fhbyay.rs:44:37\n   |\n44 |     let mut paren_level_stack_top = paren_level_\n\
    \   |                                     ^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `paren_level`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpn8fhbyay.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nest\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw0fs2mmc.rs:41:31\n   |\n\
    41 |     let mut paren_nesting_nest\n   |                               ^ help:\
    \ add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpw0fs2mmc.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack = vec![];\n\
    \    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_char = paren_string[paren_stack_pos];\n    let\
    \ mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmkrwbu4u.rs:42:30\n   |\n\
    42 |     let mut paren_stack_char_\n   |                              ^ help:\
    \ add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmpmkrwbu4u.rs:11:32\n   |\n11\
    \ |     let mut paren_stack_char = paren_string[paren_stack_pos];\n   |      \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpmkrwbu4u.rs:13:36\n   |\n13 |     let mut paren_stack_char_len\
    \ = paren_string[paren_stack_char_pos].len();\n   |                          \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpmkrwbu4u.rs:15:36\n   |\n15 |     let mut paren_stack_char_len\
    \ = paren_string[paren_stack_char_pos].len();\n   |                          \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the t"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_top = paren_levels_stack_len - 1;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_len\
    \ - 1;\n    let mut paren_levels_stack_bottom = paren_levels_stack_len - 1;\n\
    \    let mut paren_levels_stack_top = paren_levels_stack_len - 1;\n    let mut\
    \ paren_levels_stack_bottom = paren_levels_stack_len - 1;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack_len - 1;\n    let mut paren_levels_stack_bottom = paren_levels_stack_len\
    \ - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_len - 1;\n   \
    \ let mut paren_levels_stack_bottom = paren_levels_stack_len - 1;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len - 1;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_len\
    \ - 1;\n    let mut paren_levels_stack_bottom = paren_levels_stack_len - 1;\n\
    \    let mut paren_levels_stack_top = paren_levels_stack_len - 1;\n    let mut\
    \ paren_levels_stack_bottom = paren_levels_stack_len - 1;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack_len - 1;\n    let mut paren_levels_stack_bottom = paren_levels_stack_len\
    \ - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_len - 1;\n   \
    \ let mut paren_levels_stack_bottom = paren_levels_stack_len - 1;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len - 1;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_len\
    \ - 1;\n    let mut paren_levels_stack_bottom = paren_levels_stack_len - 1;\n\
    \    let mut paren_levels_stack_top = paren_levels_stack_len - 1;\n    let mut\
    \ paren_levels_stack_bottom = paren_levels_stack_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_6k2kdj8.rs:37:60\n   |\n\
    37 |     let mut paren_levels_stack_bottom = paren_levels_stack_\n   |       \
    \                                                     ^ help: add `;` here\n38\
    \ | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `paren_levels_stack_`\
    \ in this scope\n  --> /tmp/tmp_6k2kdj8.rs:37:41\n   |\n37 |     let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_\n   |                                         ^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_stack`\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmp_6k2kdj8.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: usize = 0;\n    let mut paren_level_count: usize = 0;\n    let\
    \ mut paren_level_max_count: usize = 0;\n    let mut paren_level_max_level: usize\
    \ = 0;\n    let mut paren_level_max_level_char: char = '(';\n    let mut paren_level_max_level_char_count:\
    \ usize = 0;\n    let mut paren_level_max_level_char_counts: Vec<usize> = vec![];\n\
    \    let mut paren_level_max_level_char_counts_index: usize = 0;\n    let mut\
    \ paren_level_max_level_char_counts_index: usize = 0;\n    let mut paren_level_max_level_char_counts_index:\
    \ usize = 0;\n    let mut paren_level_max_level_char_counts_index: usize = 0;\n\
    \    let mut paren_level_max_level_char_counts_index: usize = 0;\n    let mut\
    \ paren_level_max_level_char_counts_index: usize = 0;\n    let mut paren_level_max_level_char_counts_index:\
    \ usize = 0;\n    let mut paren_level_max_level_char_counts_index: usize = 0;\n\
    \    let mut paren_level_max_level_char_counts_index: usize = 0;\n    let mut\
    \ paren_level_max_level_char_counts_index: usize = 0;\n    let mut paren_level_max_level_char_counts_index:\
    \ usize = 0;\n    let mut paren_level_max_level_char_counts_index: usize = 0;\n\
    \    let mut paren_level_max_level_char_counts_index: usize = 0;\n    let mut\
    \ paren_level_max_level_char_counts_index: usize = 0;\n    let mut paren_level_max_level_char_counts_index:\
    \ usize = 0;\n    let mut paren_level_max_level_char_counts_index: usize = 0;\n\
    \    let mut paren_level_max_level_char_counts_index: usize = 0;\n    let mut\
    \ paren_level_max_level_char_counts_index: usize = 0;\n    let mut paren_level_max_level_char_counts_index:\
    \ usize = 0;\n    let mut paren_level_max_level_char_counts_index: usize = 0;\n\
    \    let mut paren_level_max_level_char_counts_index: usize = 0;\n    let mut\
    \ paren_level_max_level_char_counts_index: usize = 0;\n    let mut paren_level_max_level_char_counts_index:\
    \ usize = 0;\n    let mut paren_level_max_level_char_counts_index: usize = 0;\n\
    \    let mut paren_level_max_level_char_counts_index: \n}\n\nfn main() {\n   \
    \ let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpadhzt69q.rs:40:1\n   |\n\
    39 |     let mut paren_level_max_level_char_counts_index: \n   |         -------------------------------------------\
    \ while parsing the type for `mut paren_level_max_level_char_counts_index`\n40\
    \ | }\n   | ^ expected type\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4e5_3xge.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4e5_3xge.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxfo0440q.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxfo0440q.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_chars: Vec<char>;\n\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp6u0qjfto.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = 0;\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpej3_f0up.rs:37:52\n   |\n\
    37 |     let mut paren_levels_stack_bottom = paren_level\n   |               \
    \                                     ^ help: add `;` here\n38 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpej3_f0up.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack = Vec::new();\n\
    \    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_char = paren_string[paren_stack_pos];\n    while\
    \ paren_stack_pos < paren_string.len() {\n        if paren_stack_char == ')' {\n\
    \            paren_stack.pop();\n            paren_stack_len -= paren_stack.len();\n\
    \            paren_stack_pos += 1;\n            level -= 1;\n        } else if\
    \ paren_stack_char == '(' {\n            paren_stack.push(level);\n          \
    \  paren_stack_len += 1;\n            paren_stack_pos += 1;\n            level\
    \ += 1;\n        } else {\n            paren_stack_pos += 1;\n        }\n    \
    \    paren_stack_char = paren_string[paren_stack_pos];\n    }\n    paren_stack\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpfmawyygz.rs:11:32\n   |\n11 |     let mut paren_stack_char = paren_string[paren_stack_pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfmawyygz.rs:26:28\n   |\n26 |         paren_stack_char = paren_string[paren_stack_pos];\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack: Vec<isize>\
    \ = vec![];\n    for paren in paren_string.chars() {\n        if paren == '('\
    \ {\n            paren_stack.push(level);\n            level += 1;\n        }\
    \ else if paren == ')' {\n            level -= 1;\n            if level == 0 {\n\
    \                paren_stack.pop();\n            }\n        } else {\n       \
    \     level += 1;\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 2, 3, 2, 3, 4, 5, 4, 4]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpbkqyue21.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut paren_count =\
    \ 0;\n    let mut paren_level = 0;\n    let mut paren_nesting = 0;\n    let mut\
    \ paren_levels = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n \
    \   let mut paren_levels_stack_ptr = 0;\n    let mut paren_levels_ptr = paren_levels_stack.as_mut_ptr();\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n    let mut paren_levels_ptr_end = paren_levels_ptr.\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp2_mayn7l.rs:31:1\n   |\n31\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp2_mayn7l.rs:30:53\n\
    \   |\n30 |     let mut paren_levels_ptr_end = paren_levels_ptr.\n   |       \
    \                                              ^ help: add `;` here\n31 | }\n\
    \   | - unexpected token\n\nwarning: type annotations needed\n  --> /tmp/tmp2_mayn7l.rs:15:53\n\
    \   |\n15 |     let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n   |                                                     ^^^^^^\n   |\n\
    \   = note: `#[warn(tyvar_behind_raw_pointer)]` on by default\n   = warning: this\
    \ is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!\n\
    \   = note: for more information, see issue #46906 <https://github.com/rust-lang/rust/issues/46906>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2_mayn7l.rs:15:60\n   |\n15 |\
    \     let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n   |                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n15 |     let mut\
    \ paren_levels_ptr_end = paren_levels_ptr.offset((paren_levels_stack.len() - 1).try_into().unwrap());\n\
    \   |                                                            +           \
    \                 +++++++++++++++++++++\n\nwarning: type annotations needed\n\
    \  --> /tmp/tmp2_mayn7l.rs:16:53\n   |\n16 |     let mut paren_levels_ptr_end\
    \ = paren_levels_ptr.offset(paren_levels_stack.len() - 1);\n   |             \
    \                                        ^^^^^^\n   |\n   = warning: this is accepted\
    \ in the current edition (Rust 2015) but is a hard error in Rust 2018!\n   = note:\
    \ for more information, see issue #46906 <https://github.com/rust-lang/rust/issues/46906>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2_mayn7l.rs:16:60\n   |\n16 |\
    \     let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len()\
    \ - 1);\n   |              "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_size\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmporse2lui.rs:29:134\n   |\n\
    29 |     let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new\n   |                                                           \
    \                                                                           ^\
    \ help: add `;` here\n30 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmporse2lui.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = 0;\n    let mut paren_levels_stack_ptr_max = paren_levels_stack.len();\n \
    \   let mut paren_levels_stack_ptr_cur = 0;\n    let mut paren_levels_stack_ptr_max2\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_cur2 = 0;\n\
    \    let mut paren_levels_stack_ptr_max3 = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr_cur3 = 0;\n    let mut paren_levels_stack_ptr_max4\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_cur4 = 0;\n\
    \    let mut paren_levels_stack_ptr_max5 = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr_cur5 = 0;\n    let mut paren_levels_stack_ptr_max6\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_cur6 = 0;\n\
    \    let mut paren_levels_stack_ptr_max7 = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr_cur7 = 0;\n    let mut paren_levels_stack_ptr_max8\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_cur8 = 0;\n\
    \    let mut paren_levels_stack_ptr_max9 = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr_cur9 = 0;\n    let mut paren_levels_stack_ptr_max10\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_cur10 = 0;\n\
    \    let mut paren_levels_stack_ptr_max11 = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr_cur11 = 0;\n    let mut paren_levels_stack_ptr_max12\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_cur12 = 0;\n\
    \    let mut paren_levels_stack_ptr_max13 = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr_cur13 = 0;\n    let mut paren_levels_stack_ptr_max14\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgko7lu79.rs:38:35\n   |\n\
    38 |     let mut paren_levels_stack_ptr\n   |                                \
    \   ^ help: add `;` here\n39 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpgko7lu79.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_indexes: Vec<isize>\
    \ = Vec::new();\n    let mut paren_level_indexes_len = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_indexes = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpz02b_1tp.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack = Vec::new();\n\
    \    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_len = paren_string.\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpm99o39qo.rs:54:1\n   |\n54\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpm99o39qo.rs:53:44\n\
    \   |\n53 |     let mut paren_stack_len = paren_string.\n   |                \
    \                            ^ help: add `;` here\n54 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpm99o39qo.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: usize = 0;\n    let mut paren_levels: Vec<isize> = vec![];\n  \
    \  let mut paren_levels_len: usize = 0;\n    let mut paren_levels_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_len: usize = 0;\n    let mut paren_levels_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_len: usize = 0;\n \
    \   let mut paren_levels_lens_lens_lens: Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens: Vec<isize> = vec![];\n\
    \    let mut paren_levels_lens_lens_lens_lens_len: usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_len: usize\
    \ = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfzpvp9q_.rs:28:56\n   |\n\
    28 |     let mut paren_levels_lens_lens_lens_lens_lens_lens_\n   |           \
    \                                             ^ help: add `;` here\n29 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfzpvp9q_.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len\
    \ = paren_level_chars.len();\n    let mut paren_level_char_len = paren_level_char_count\
    \ + paren_level_char_count;\n    let mut paren_level_char_pos = paren_level_char_len;\n\
    \    let mut paren_level_char_pos = paren_level_char_len;\n    let mut paren_level_char_pos\
    \ = paren_level_char_len;\n    let mut paren_level_char_pos = paren_level_char_len;\n\
    \    let mut paren_level_char_pos = paren_level_char_len;\n    let mut paren_level_char_pos\
    \ = paren_level_char_len;\n    let mut paren_level_char_pos = paren_level_char_len;\n\
    \    let mut paren_level_char_pos = paren_level_char_len;\n    let mut paren_level_char_pos\
    \ = paren_level_char_len;\n    let mut paren_level_char_pos = paren_level_char_len;\n\
    \    let mut paren_level_char_pos = paren_level_char_len;\n    let mut paren_level_char_pos\
    \ = paren_level_char_len;\n    let mut paren_level_char_pos = paren_level_char_len;\n\
    \    let mut paren_level_char_pos = paren_level_char_len;\n    let mut paren_level_char_pos\
    \ = paren_level_char_len;\n    let mut paren_level_char_pos = paren_level_char_len;\n\
    \    let mut paren_level_char_pos = paren_level_char_len;\n    let mut paren_level_char_pos\
    \ = paren_level_char_len;\n    let mut paren_level_char_pos = paren_level_char_len;\n\
    \    let mut paren_level_char_pos = paren_level_char_len;\n    let mut paren_level_char_pos\
    \ = paren_level_char_len;\n    let mut paren_level_char_pos = paren_level_char_len;\n\
    \    let mut paren_level_char_pos = paren_level_char_len;\n    let mut paren_level_char_pos\
    \ = paren_level_char_len;\n    let mut paren_level_char_pos = paren_level_char_len;\n\
    \    let mut paren_level_char_pos = paren_level_char_len;\n    let mut paren_level_char_pos\
    \ = paren_level_char_len;\n    let mut paren_level_char_pos = paren_level_char_len;\n\
    \    let mut paren_level_char_pos = paren_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk9rjalt3.rs:44:42\n   |\n\
    44 |     let mut paren_level_char_pos = paren_\n   |                         \
    \                 ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `paren_` in this scope\n  --> /tmp/tmpk9rjalt3.rs:44:36\n\
    \   |\n44 |     let mut paren_level_char_pos = paren_\n   |                  \
    \                  ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpk9rjalt3.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpawv_t9_2.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpawv_t9_2.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpspf8t2nm.rs:37:59\n   |\n\
    37 |     let mut paren_levels_stack_bottom = paren_levels_stack\n   |        \
    \                                                   ^ help: add `;` here\n38 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpspf8t2nm.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut paren_stack =\
    \ Vec::new();\n    let mut paren_level = 0;\n    let mut paren_level_count = 0;\n\
    \    let mut paren_level_max_count = 0;\n    let mut paren_level_max_count_index\
    \ = 0;\n    let mut paren_level_max_count_index2 = 0;\n    let mut paren_level_max_count_index3\
    \ = 0;\n    let mut paren_level_max_count_index4 = 0;\n    let mut paren_level_max_count_index5\
    \ = 0;\n    let mut paren_level_max_count_index6 = 0;\n    let mut paren_level_max_count_index7\
    \ = 0;\n    let mut paren_level_max_count_index8 = 0;\n    let mut paren_level_max_count_index9\
    \ = 0;\n    let mut paren_level_max_count_index10 = 0;\n    let mut paren_level_max_count_index11\
    \ = 0;\n    let mut paren_level_max_count_index12 = 0;\n    let mut paren_level_max_count_index13\
    \ = 0;\n    let mut paren_level_max_count_index14 = 0;\n    let mut paren_level_max_count_index15\
    \ = 0;\n    let mut paren_level_max_count_index16 = 0;\n    let mut paren_level_max_count_index17\
    \ = 0;\n    let mut paren_level_max_count_index18 = 0;\n    let mut paren_level_max_count_index19\
    \ = 0;\n    let mut paren_level_max_count_index20 = 0;\n    let mut paren_level_max_count_index21\
    \ = 0;\n    let mut paren_level_max_count_index22 = 0;\n    let mut paren_level_max_count_index23\
    \ = 0;\n    let mut paren_level_max_count_index24 = 0;\n    let mut paren_level_max_count_index25\
    \ = 0;\n    let mut paren_level_max_count_index26 = 0;\n    let mut paren_level_max_count_index27\
    \ = 0;\n    let mut paren_level_max_count_index28 = 0;\n    let mut paren_level_max_count_index29\
    \ = 0;\n    let mut paren_level_max_count_index30 = 0;\n    let mut paren_level_max_count_index31\
    \ = 0;\n    let mut paren_level_max_count_index32 = 0;\n    let mut paren_level_max_count_index33\
    \ = 0;\n    let mut paren_level_max_count_index34 = 0;\n    let mut paren_level_max_count_index35\
    \ = 0;\n    let mut paren_level_max_count_index36 = 0;\n    let mut paren_level_max_count_index37\
    \ = 0;\n    let mut paren_level_max_count_index38 = 0;\n    let mut paren_level_max_count_index39\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpsukn9zgp.rs:52:1\n  \
    \ |\n52 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjtld0bxk.rs:37:59\n   |\n\
    37 |     let mut paren_levels_stack_bottom = paren_levels_stack\n   |        \
    \                                                   ^ help: add `;` here\n38 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpjtld0bxk.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: usize = 0;\n    let mut paren_levels: Vec<isize> = vec![];\n  \
    \  let mut paren_levels_len: usize = 0;\n    let mut paren_levels_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_len: usize = 0;\n    let mut paren_levels_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_len: usize = 0;\n \
    \   let mut paren_levels_lens_lens_lens: Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens: Vec<isize> = vec![];\n\
    \    let mut paren_levels_lens_lens_lens_lens_len: usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_len: usize\
    \ = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_len\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp16jvglm0.rs:28:69\n   |\n\
    28 |     let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_len\n  \
    \ |                                                                     ^ help:\
    \ add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp16jvglm0.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_levels: Vec<isize> = vec![];\n  \
    \  let mut paren_levels_len: isize = 0;\n    let mut paren_levels_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_len: isize = 0;\n    let mut paren_levels_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_len: isize = 0;\n \
    \   let mut paren_levels_lens_lens_lens: Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_len:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_lens: Vec<isize> = vec![];\n\
    \    let mut paren_levels_lens_lens_lens_lens_len: isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_len: isize = 0;\n\
    \    let mut paren_levels_lens_lens_lens_lens_lens_lens: isize = 0;\n    let mut\
    \ paren_levels_lens_lens_lens_lens_lens_lens_len: isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_len\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp92i01btk.rs:29:44\n   |\n\
    29 |     let mut paren_levels_lens_lens_lens_len\n   |                       \
    \                     ^ help: add `;` here\n30 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmp92i01btk.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfbc69o7r.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut level = 0;\n\
    \    let mut paren_chars = paren_string.chars();\n    let mut paren_chars_iter\
    \ = paren_chars.iter();\n    let mut paren_chars_next = paren_chars_iter.next();\n\
    \    while paren_chars_next.is_some() {\n        if paren_chars_next.unwrap()\
    \ == '(' {\n            level += 1;\n        }\n        if paren_chars_next.unwrap()\
    \ == ')' {\n            level -= 1;\n        }\n        levels.push(level);\n\
    \        paren_chars = paren_chars.chain(paren_chars_iter);\n        paren_chars_next\
    \ = paren_chars_iter.next();\n    }\n    levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmptp6hraiu.rs:10:44\n   |\n10 |     let mut paren_chars_iter\
    \ = paren_chars.iter();\n   |                                            ^^^^\
    \ private field, not a method\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptp6hraiu.rs:20:23\n\
    \   |\n9  |     let mut paren_chars = paren_string.chars();\n   |            \
    \               -------------------- expected due to this value\n...\n20 |   \
    \      paren_chars = paren_chars.chain(paren_chars_iter);\n   |              \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Chars`, found struct\
    \ `std::iter::Chain`\n   |\n   = note: expected struct `Chars<'_>`\n         \
    \     found struct `std::iter::Chain<Chars<'_>, _>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string_index = 0;\n    while paren_level_string_index\
    \ < paren_string.len() {\n        let mut paren_level_string = paren_string;\n\
    \        let mut paren_level_string_index = 0;\n        while paren_level_string_index\
    \ < paren_string.len() {\n            let mut paren_level_string = paren_string;\n\
    \            let mut paren_level_string_index = 0;\n            while paren_level_string_index\
    \ < paren_string.len() {\n                let mut paren_level_string = paren_string;\n\
    \                let mut paren_level_string_index = 0;\n                while\
    \ paren_level_string_index < paren_string.len() {\n                    let mut\
    \ paren_level_string = paren_string;\n                    let mut paren_level_string_index\
    \ = 0;\n                    while paren_level_string_index < paren_string.len()\
    \ {\n                        let mut paren_level_string = paren_string;\n    \
    \                    let mut paren_level_string_index = 0;\n                 \
    \       while paren_level_string_index < paren_string.len() {\n              \
    \              let mut paren_level_string = paren_string;\n                  \
    \          let mut paren_level_string_index = 0;\n                           \
    \ while paren_level_string_index < paren_string.len() {\n                    \
    \            let mut paren_level_string = paren_string;\n                    \
    \            let mut paren_level_string_index = 0;\n                         \
    \       while paren_level_string_index < paren_string.len() {\n              \
    \                      let mut paren_level_string = paren_string;\n          \
    \                          let mut paren_level_string_index = 0;\n           \
    \                         while paren_level_string_index < paren_string.len()\
    \ {\n                                        let mut paren_level_string = paren_string;\n\
    \                                        let mut paren_level_string_index = 0;\n\
    \                                        while paren_level_string_index < paren_string.len()\
    \ {\n                                            let mut paren_level_string =\
    \ paren_string;\n                                            let mut paren_level_string_index\
    \ = 0;\n                                            while paren_level_string_index\
    \ < paren_string.len() {\n                                                let\
    \ mut paren_level_string = paren_string;\n                                   \
    \             let mut paren_level_string_index = 0;\n                        \
    \                        while paren_level_string_index < paren_string.len() {\n\
    \                                                    let mut paren_level_string\
    \ = paren_string;\n                                                    let mut\
    \ paren_level_string_index = 0;\n                                            \
    \        while paren_level_string_index < paren_string.len() {\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpocst8hxd.rs:56:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n12 |     while paren_level_string_index < paren_string.len() {\n   |    \
    \                                                     - unclosed delimiter\n...\n\
    15 |         while paren_level_string_index < paren_string.len() {\n   |     \
    \                                                        - unclosed delimiter\n\
    ...\n18 |             while paren_level_string_index < paren_string.len() {\n\
    \   |                                                                 - unclosed\
    \ delimiter\n...\n21 |                 while paren_level_string_index < paren_string.len()\
    \ {\n   |                                                                    \
    \ - unclosed delimiter\n...\n24 |                     while paren_level_string_index\
    \ < paren_string.len() {\n   |                                               \
    \                          - unclosed delimiter\n...\n27 |                   \
    \      while paren_level_string_index < paren_string.len() {\n   |           \
    \                                                                  - unclosed\
    \ delimiter\n...\n30 |                             while paren_level_string_index\
    \ < paren_string.len() {\n   |                                               \
    \                                  - unclosed delimiter\n...\n33 |           \
    \                      while paren_level_string_index < paren_string.len() {\n\
    \   |                                                                        \
    \             - unclosed delimiter\n...\n36 |                                \
    \     while paren_level_string_index < paren_string.len() {\n   |            \
    \                                                                            \
    \ - unclosed delimiter\n...\n39 |                                         while\
    \ paren_level_string_index < paren_string.len() {\n   |                      \
    \                                                       "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n\
    \    let mut paren_levels_stack_pos = 0;\n    let mut paren_levels_stack_size\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl6d11qv5.rs:38:26\n   |\n\
    38 |     let mut paren_levels_\n   |                          ^ help: add `;`\
    \ here\n39 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpl6d11qv5.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0usize;\n    let mut paren_level = 0usize;\n\
    \    let mut paren_nesting = 0usize;\n    let mut paren_nesting_level = 0usize;\n\
    \    let mut paren_nesting_nesting = 0usize;\n    let mut paren_nesting_nesting_level\
    \ = 0usize;\n    let mut paren_nesting_nesting_nesting = 0usize;\n    let mut\
    \ paren_nesting_nesting_nesting_level = 0usize;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0usize;\n    let mut paren_nesting_nesting_nesting_level = 0usize;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting = 0usize;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0usize;\n    let mut paren_nesting_nesting_nesting_nesting = 0usize;\n   \
    \ let mut paren_nesting_nesting_nesting_level = 0usize;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0usize;\n    let mut paren_nesting_nesting_nesting_level = 0usize;\n    let\
    \ mut paren_nesting_nesting_nesting = 0usize;\n    let mut paren_nesting_nesting_level\
    \ = 0usize;\n    let mut paren_nesting_nesting = 0usize;\n    let mut paren_nesting_level\
    \ = 0usize;\n    let mut paren_level = 0usize;\n    let mut paren_nesting = 0usize;\n\
    \    let mut paren_nesting_level = 0usize;\n    let mut paren_nesting_nesting\
    \ = 0usize;\n    let mut paren_nesting_nesting_level = 0usize;\n    let mut paren_nesting_nesting_nesting\
    \ = 0usize;\n    let mut paren_nesting_nesting_nesting_level = 0usize;\n    let\
    \ mut paren_nesting_nesting_nesting_level = 0usize;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0usize;\n    let mut paren_nesting_nesting_nesting_level = 0usize;\n    let\
    \ mut paren_nesting_nesting_nesting_level = 0usize;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0usize;\n    let mut paren_nesting_nesting_nesting_level = 0usize;\n    let\
    \ mut paren_nesting_nesting_nesting_level = 0usize;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0usize;\n    let mut paren_nesting_nest\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt5ki60_2.rs:42:31\n   |\n\
    42 |     let mut paren_nesting_nest\n   |                               ^ help:\
    \ add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpt5ki60_2.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9grbmfc9.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9grbmfc9.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_level_count: isize = 0;\n    for\
    \ paren in paren_string.chars() {\n        if paren == ')' {\n            paren_stack.push(paren_level);\n\
    \            paren_level_count = paren_level_count;\n            paren_level_count\
    \ = paren_level_count + 1;\n        } else if paren == '(' {\n            paren_stack.push(paren_level);\n\
    \            paren_level_count = paren_level_count;\n            paren_level_count\
    \ = paren_level_count - 1;\n        } else {\n            paren_level_count =\
    \ paren_level_count;\n        }\n    }\n    paren_stack.push(paren_level_count);\n\
    \    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]`,\n\
    \ right: `[2, 3, 1, 3]`', /tmp/tmpu_l4aawk.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_char = 0;\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_char_length\
    \ = 0;\n    let mut paren_level_char_length_index = 0;\n    let mut paren_level_char_length_value\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n    let mut paren_level_char_length_value_index = 0;\n    let mut paren_level_char_length_value_index\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpndqracpv.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut paren_level =\
    \ 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr6x89ae4.rs:50:11\n   |\n\
    50 |     let mu\n   |           ^ help: add `;` here\n51 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpr6x89ae4.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_levels: Vec<isize> = vec![];\n  \
    \  let mut paren_levels_len: isize = 0;\n    let mut paren_levels_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_len: isize = 0;\n    let mut paren_levels_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_len: isize = 0;\n \
    \   let mut paren_levels_lens_lens_lens: Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_len:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_lens: Vec<isize> = vec![];\n\
    \    let mut paren_levels_lens_lens_lens_lens_len: isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_len: isize = 0;\n\
    \    let mut paren_levels_lens_lens_lens_lens_lens_lens_len: isize = 0;\n    let\
    \ mut paren_levels_lens_lens_lens_lens_lens_lens_lens_len: isize = 0;\n    let\
    \ mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_len: isize = 0;\n \
    \   let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_: isize\
    \ = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg8qcc_7i.rs:28:76\n   |\n\
    28 |     let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_\n\
    \   |                                                                        \
    \    ^ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpg8qcc_7i.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = 0;\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n \
    \   let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end_ptr = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end_ptr\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr_end_ptr = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end_ptr = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end_ptr\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr_end_ptr = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end_ptr = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end_ptr\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr_end_ptr = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end_ptr = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end_ptr\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr_end_ptr = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgo8kfv5k.rs:33:35\n   |\n\
    33 |     let mut paren_levels_stack_ptr\n   |                                \
    \   ^ help: add `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpgo8kfv5k.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_level = 0;\n    let\
    \ mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n    let mut paren_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt_r4ayqu.rs:41:56\n   |\n\
    41 |     let mut paren_nesting_nesting_nesting_nesting_level\n   |           \
    \                                             ^ help: add `;` here\n42 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpt_r4ayqu.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptzkr7iq1.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmptzkr7iq1.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpn96ocqs6.rs:41:35\n   |\n\
    41 |     let mut paren_nesting_nesting_\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpn96ocqs6.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_level_count: usize = 0;\n    let\
    \ mut paren_level_char: char = '(';\n    for paren in paren_string.chars() {\n\
    \        if paren_level_char == paren {\n            paren_level_count += 1;\n\
    \        } else {\n            paren_level_count -= 1;\n            if paren_level_count\
    \ == 0 {\n                paren_stack.push(paren_level);\n                paren_level_count\
    \ = 1;\n                paren_level_char = paren;\n            }\n        }\n\
    \    }\n    paren_stack.push(paren_level);\n    paren_stack\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpq4jz0smh.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_level = 0;\n    let\
    \ mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n    let mut paren_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp74nw44l0.rs:41:56\n   |\n\
    41 |     let mut paren_nesting_nesting_nesting_nesting_level\n   |           \
    \                                             ^ help: add `;` here\n42 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp74nw44l0.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_char = 0;\n    let mut paren_level_char_pos =\
    \ 0;\n    let mut paren_level_char_pos_count = 0;\n    let mut paren_level_char_pos_char\
    \ = 0;\n    let mut paren_level_char_pos_char_pos = 0;\n    let mut paren_level_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char = 0;\n    let mut paren_level_char_pos_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_count = 0;\n    let\
    \ mut paren_level_char_pos_char_pos_char_pos_char = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_count = 0;\n\
    \    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char = 0;\n    let\
    \ mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos = 0;\n    let mut\
    \ paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_count = 0;\n    let\
    \ mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char = 0;\n   \
    \ let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos =\
    \ 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbqjxyb8j.rs:37:93\n   |\n\
    37 |     let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_\n\
    \   |                                                                        \
    \                     ^ help: add `;` here\n38 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmpbqjxyb8j.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_level_count: isize = 0;\n    let\
    \ mut paren_level_max: isize = 0;\n    let mut paren_level_max_count: isize =\
    \ 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_count: isize = 0;\n    let mut paren\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpci596_3j.rs:49:18\n   |\n\
    49 |     let mut paren\n   |                  ^ help: add `;` here\n50 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpci596_3j.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_indexes: Vec<isize>\
    \ = Vec::new();\n    let mut paren_level_indexes_len = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_indexes = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len = 0;\n    let mut paren_level_indexes_len_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes = 0;\n    let\
    \ mut paren_level_indexes_len_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_index = 0;\n\
    \    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes = 0;\n  \
    \  let mut paren_level_indexes_len_indexes_len_indexes_len_indexe = 0;\n    let\
    \ mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len = 0;\n    let\
    \ mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_index = 0;\n\
    \    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexes\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_indexes\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_indexes\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptg5zwmdq.rs:34:69\n   |\n\
    34 |     let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_\n  \
    \ |                                                                     ^ help:\
    \ add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmptg5zwmdq.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut paren_depth\
    \ = 0;\n    let mut paren_level = 0;\n    let mut paren_level_count = 0;\n   \
    \ let mut paren_level_char_count = 0;\n    let mut paren_level_chars = Vec::new();\n\
    \    let mut paren_level_chars = paren_level_chars.clone();\n    let mut paren_level_chars\
    \ = paren_level_chars.clone();\n    let mut paren_level_chars = paren_level_chars.clone();\n\
    \    let mut paren_level_chars = paren_level_chars.clone();\n    let mut paren_level_chars\
    \ = paren_level_chars.clone();\n    let mut paren_level_chars = paren_level_chars.clone();\n\
    \    let mut paren_level_chars = paren_level_chars.clone();\n    let mut paren_level_chars\
    \ = paren_level_chars.clone();\n    let mut paren_level_chars = paren_level_chars.clone();\n\
    \    let mut paren_level_chars = paren_level_chars.clone();\n    let mut paren_level_chars\
    \ = paren_level_chars.clone();\n    let mut paren_level_chars = paren_level_chars.clone();\n\
    \    let mut paren_level_chars = paren_level_chars.clone();\n    let mut paren_level_chars\
    \ = paren_level_chars.clone();\n    let mut paren_level_chars = paren_level_chars.clone();\n\
    \    let mut paren_level_chars = paren_level_chars.clone();\n    let mut paren_level_chars\
    \ = paren_level_chars.clone();\n    let mut paren_level_chars = paren_level_chars.clone();\n\
    \    let mut paren_level_chars = paren_level_chars.clone();\n    let mut paren_level_chars\
    \ = paren_level_chars.clone();\n    let mut paren_level_chars = paren_level_chars.clone();\n\
    \    let mut paren_level_chars = paren_level_chars.clone();\n    let mut paren_level_chars\
    \ = paren_level_chars.clone();\n    let mut paren_level_chars = paren_level_chars.clone();\n\
    \    let mut paren_level_chars = paren_level_chars.clone();\n    let mut paren_level_chars\
    \ = paren_level_chars.clone();\n    let mut paren_level_chars = paren_level_chars.clone();\n\
    \    let mut paren_level_chars = paren_level_chars.clone();\n    let mut paren_level_chars\
    \ = paren_level_chars.clone();\n    let mut paren_level_chars = paren_level_chars.clone();\n\
    \    let mut \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp6ah9rrwh.rs:44:1\n\
    \   |\n44 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut paren_count =\
    \ paren_string.chars().filter(|c| *c != '(').count();\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyfwvx064.rs:36:67\n   |\n\
    36 |     let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_\n   |\
    \                                                                   ^ help: add\
    \ `;` here\n37 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpyfwvx064.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack = vec![];\n\
    \    let mut paren_levels = vec![];\n    let mut paren_level = 0;\n    let mut\
    \ paren_level_count = 0;\n    let mut paren_level_stack = vec![];\n    let mut\
    \ paren_level_stack_count = 0;\n    let mut paren_level_stack_depth = 0;\n   \
    \ let mut paren_level_stack_depth_max = 0;\n    let mut paren_level_stack_depth_max_index\
    \ = 0;\n    let mut paren_level_stack_depth_max_index2 = 0;\n    let mut paren_level_stack_depth_max_index3\
    \ = 0;\n    let mut paren_level_stack_depth_max_index4 = 0;\n    let mut paren_level_stack_depth_max_index5\
    \ = 0;\n    let mut paren_level_stack_depth_max_index6 = 0;\n    let mut paren_level_stack_depth_max_index7\
    \ = 0;\n    let mut paren_level_stack_depth_max_index8 = 0;\n    let mut paren_level_stack_depth_max_index9\
    \ = 0;\n    let mut paren_level_stack_depth_max_index10 = 0;\n    let mut paren_level_stack_depth_max_index11\
    \ = 0;\n    let mut paren_level_stack_depth_max_index12 = 0;\n    let mut paren_level_stack_depth_max_index13\
    \ = 0;\n    let mut paren_level_stack_depth_max_index14 = 0;\n    let mut paren_level_stack_depth_max_index15\
    \ = 0;\n    let mut paren_level_stack_depth_max_index16 = 0;\n    let mut paren_level_stack_depth_max_index17\
    \ = 0;\n    let mut paren_level_stack_depth_max_index18 = 0;\n    let mut paren_level_stack_depth_max_index19\
    \ = 0;\n    let mut paren_level_stack_depth_max_index20 = 0;\n    let mut paren_level_stack_depth_max_index21\
    \ = 0;\n    let mut paren_level_stack_depth_max_index22 = 0;\n    let mut paren_level_stack_depth_max_index23\
    \ = 0;\n    let mut paren_level_stack_depth_max_index24 = 0;\n    let mut paren_level_stack_depth_max_index25\
    \ = 0;\n    let mut paren_level_stack_depth_max_index26 = 0;\n    let mut paren_level_stack_depth_max_index27\
    \ = 0;\n    let mut paren_level_stack_depth_max_index28 = 0;\n    let mut paren_level_stack_depth_max_index29\
    \ = 0;\n    let mut paren_level_stack_depth_max_index30 = 0;\n    let mut paren_level_stack_depth\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyufyx8z5.rs:46:36\n   |\n\
    46 |     let mut paren_level_stack_depth\n   |                               \
    \     ^ help: add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpyufyx8z5.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let \n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpms2_cjuc.rs:38:1\n  \
    \ |\n38 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_level = 0;\n    let mut paren_level_count = 0;\n    let mut\
    \ paren_level_stack = Vec::new();\n    let mut paren_level_stack_pos = 0;\n  \
    \  let mut paren_level_stack_len = paren_level_stack.len();\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphij144rf.rs:44:18\n   |\n\
    44 |     let mut paren\n   |                  ^ help: add `;` here\n45 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmphij144rf.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_count_max = 0;\n    let mut paren_level_char_pos_count_max_index\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index2 = 0;\n    let mut paren_level_char_pos_count_max_index3\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index4 = 0;\n    let mut paren_level_char_pos_count_max_index5\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index6 = 0;\n    let mut paren_level_char_pos_count_max_index7\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index8 = 0;\n    let mut paren_level_char_pos_count_max_index9\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index10 = 0;\n    let mut paren_level_char_pos_count_max_index11\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index12 = 0;\n    let mut paren_level_char_pos_count_max_index13\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index14 = 0;\n    let mut paren_level_char_pos_count_max_index15\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index16 = 0;\n    let mut paren_level_char_pos_count_max_index17\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index18 = 0;\n    let mut paren_level_char_pos_count_max_index19\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index20 = 0;\n    let mut paren_level_char_pos_count_max_index21\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index22 = 0;\n    let mut paren_level_char_pos_count_max_index23\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index24 = 0;\n    let mut paren_level_char_pos_count_max_index25\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index26 = 0;\n    let mut paren_level_char_pos_count_max_index27\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index28 = 0;\n    let mut paren_level_char_pos_count_max_index29\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index30 = 0;\n    let mut paren_level_char_pos_count_max_index31\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index32 = 0;\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpa5ccsmwf.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string_index = 0;\n    let mut paren_level_string = paren_string;\n\
    \    while paren_level_string_index < paren_string.len() {\n        let mut paren_level_string\
    \ = paren_string;\n        let mut paren_level_string_index = 0;\n        while\
    \ paren_level_string_index < paren_string.len() {\n            let mut paren_level_string\
    \ = paren_string;\n            let mut paren_level_string_index = 0;\n       \
    \     while paren_level_string_index < paren_string.len() {\n                let\
    \ mut paren_level_string = paren_string;\n                let mut paren_level_string_index\
    \ = 0;\n                while paren_level_string_index < paren_string.len() {\n\
    \                    let mut paren_level_string = paren_string;\n            \
    \        let mut paren_level_string_index = 0;\n                    while paren_level_string_index\
    \ < paren_string.len() {\n                        let mut paren_level_string =\
    \ paren_string;\n                        let mut paren_level_string_index = 0;\n\
    \                        while paren_level_string_index < paren_string.len() {\n\
    \                            let mut paren_level_string = paren_string;\n    \
    \                        let mut paren_level_string_index = 0;\n             \
    \               while paren_level_string_index < paren_string.len() {\n      \
    \                          let mut paren_level_string = paren_string;\n      \
    \                          let mut paren_level_string_index = 0;\n           \
    \                     while paren_level_string_index < paren_string.len() {\n\
    \                                    let mut paren_level_string = paren_string;\n\
    \                                    let mut paren_level_string_index = 0;\n \
    \                                   while paren_level_string_index < paren_string.len()\
    \ {\n                                        let mut paren_level_string = paren_string;\n\
    \                                        let mut paren_level_string_index = 0;\n\
    \                                        while paren_level_string_index < paren_string.len()\
    \ {\n                                            let mut paren_level_string =\
    \ paren_string;\n                                            let mut paren_level_string_index\
    \ = 0;\n                                            while paren_level_string_index\
    \ < paren_string.len() {\n                                                let\
    \ mut paren_level_string = paren_string;\n                                   \
    \             let mut paren_level_string_index = 0;\n                        \
    \                        while paren_level_string_index < paren_string.len() {\n\
    \                                                    let mut paren_level_string\
    \ = paren_string;\n                                                    let mut\
    \ paren_level_string_index = 0;\n                                            \
    \        \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpjrh4bqb_.rs:57:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n13 |     while paren_level_string_index < paren_string.len() {\n   |    \
    \                                                     - unclosed delimiter\n...\n\
    16 |         while paren_level_string_index < paren_string.len() {\n   |     \
    \                                                        - unclosed delimiter\n\
    ...\n19 |             while paren_level_string_index < paren_string.len() {\n\
    \   |                                                                 - unclosed\
    \ delimiter\n...\n22 |                 while paren_level_string_index < paren_string.len()\
    \ {\n   |                                                                    \
    \ - unclosed delimiter\n...\n25 |                     while paren_level_string_index\
    \ < paren_string.len() {\n   |                                               \
    \                          - unclosed delimiter\n...\n28 |                   \
    \      while paren_level_string_index < paren_string.len() {\n   |           \
    \                                                                  - unclosed\
    \ delimiter\n...\n31 |                             while paren_level_string_index\
    \ < paren_string.len() {\n   |                                               \
    \                                  - unclosed delimiter\n...\n34 |           \
    \                      while paren_level_string_index < paren_string.len() {\n\
    \   |                                                                        \
    \             - unclosed delimiter\n...\n37 |                                \
    \     while paren_level_string_index < paren_string.len() {\n   |            \
    \                                                                            \
    \ - unclosed delimiter\n...\n40 |                                         while\
    \ paren_level_string_index < paren_string.len() {\n   |                      \
    \                                                       "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut paren_levels_stack_max_pos\
    \ = 0;\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n \
    \   let mut paren_levels_stack_max_pos = 0;\n    let mut paren_levels_stack_max_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_pos = 0;\n \
    \   let mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_max_pos = 0;\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_pos = 0;\n    let mut paren_levels_stack_max_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_pos = 0;\n \
    \   let mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_max_pos = 0;\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_pos = 0;\n    let mut paren_levels_stack_max_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_pos = 0;\n \
    \   let mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_max_pos = 0;\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_pos = 0;\n    let mut paren_levels_stack_max_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_pos = 0;\n \
    \   let mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_max_pos = 0;\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_pos = 0;\n    let mut paren_levels_stack_max_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_pos = 0;\n \
    \   let mu\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7iklblui.rs:42:11\n   |\n\
    42 |     let mu\n   |           ^ help: add `;` here\n43 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7iklblui.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len\
    \ = paren_level_chars.len();\n    let mut paren_level_char_pos = 0;\n    let mut\
    \ paren_level_char_len = paren_level_chars.len();\n    let mut paren_level_char_pos\
    \ = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n    let mut\
    \ paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj3apfhio.rs:47:30\n   |\n\
    47 |     let mut paren_level_char_\n   |                              ^ help:\
    \ add `;` here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpj3apfhio.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_char_next: char;\n    let mut paren_level_char_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next: char;\n    let mut paren_level_char_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next: char;\n    let\
    \ mut paren_level_char_next_next_next_next_next_next: char;\n    let mut paren_level_char_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp11t0d5_y.rs:34:55\n   |\n\
    34 |     let mut paren_level_char_next_next_next_next_next_\n   |            \
    \                                           ^ help: add `;` here\n35 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp11t0d5_y.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr = paren_levels_stack_len;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_len = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_len = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_len = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_len = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_len = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg6qnmwkk.rs:37:49\n   |\n\
    37 |     let mut paren_levels_stack_top = paren_level\n   |                  \
    \                               ^ help: add `;` here\n38 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpg6qnmwkk.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_len = paren_levels.len();\n    let mut paren_levels_stack\
    \ = Vec::new();\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr = paren_levels_stack_len;\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_ptr_start = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_ptr_start_end = paren_levels_stack_ptr;\n    let\
    \ mut paren_levels_stack_ptr_start_end_end = paren_levels_stack_ptr;\n    let\
    \ mut paren_levels_stack_ptr_start_end_end_end = paren_levels_stack_ptr;\n   \
    \ let mut paren_levels_stack_ptr_start_end_end_end_end = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_ptr_start_end_end_end_end_end = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_ptr_start_end_end_end_end_end_end = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_ptr_start_end_end_end_end_end_end_end = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_ptr_start_end_end_end_end_end_end_end_end = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_ptr_start_end_end_end_end_end_end_end_end_end\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_start_end_end_end_end_end_end_end_end_end_end_end\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_start_end_end_end_end_end_end_end_end_end_end_end\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_start_end_end_end_end_end_end_end_end_end_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplqdacnvc.rs:29:78\n   |\n\
    29 |     let mut paren_levels_stack_ptr_start_end_end_end_end_end_end_end_end_end_\n\
    \   |                                                                        \
    \      ^ help: add `;` here\n30 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmplqdacnvc.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut open_braces =\
    \ 0;\n    let mut close_braces = 0;\n    let mut paren_level = 0;\n    let mut\
    \ paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n    let mut paren_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting_level = 0;\n    let mut \n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpg4b6fiad.rs:41:1\n\
    \   |\n41 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_levels_len =\
    \ paren_stack.len();\n    let mut paren_levels_lens = paren_levels_len.clone();\n\
    \    let mut paren_levels_lens_len = paren_levels_lens.len();\n    let mut paren_levels_lens_lens\
    \ = paren_levels_lens_len.clone();\n    let mut paren_levels_lens_lens_len = paren_levels_lens_lens.len();\n\
    \    let mut paren_levels_lens_lens_lens_len = paren_levels_lens_lens_lens.len();\n\
    \    let mut paren_levels_lens_lens_lens_lens_len = paren_levels_lens_lens_lens_lens.len();\n\
    \    let mut paren_levels_lens_lens_lens_lens_lens_len = paren_levels_lens_lens_lens_lens_lens.len();\n\
    \    let mut paren_levels_lens_lens_lens_lens_lens_lens_len = paren_levels_lens_lens_lens_lens_lens_lens.len();\n\
    \    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_len = paren_levels_lens_lens_lens_lens_lens_lens_lens.len();\n\
    \    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_len = paren_levels_lens_lens_lens_lens_lens_lens_lens_lens.len();\n\
    \    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_len\
    \ = paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens.len();\n  \
    \  let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_len\
    \ = paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens.len();\n\
    \    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_len\
    \ = paren_levels_lens_lens_lens_lens_lens_lens_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpraqw8sdn.rs:23:135\n   |\n\
    23 |     let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_len\
    \ = paren_levels_lens_lens_lens_lens_lens_lens_\n   |                        \
    \                                                                            \
    \                                   ^ help: add `;` here\n24 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `paren_levels_lens_lens_lens` in this\
    \ scope\n  --> /tmp/tmpraqw8sdn.rs:15:47\n   |\n15 |     let mut paren_levels_lens_lens_lens_len\
    \ = paren_levels_lens_lens_lens.len();\n   |                                 \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `paren_levels_lens_lens_len`\n\nerror[E0425]: cannot find value\
    \ `paren_levels_lens_lens_lens_lens` in this scope\n  --> /tmp/tmpraqw8sdn.rs:16:52\n\
    \   |\n16 |     let mut paren_levels_lens_lens_lens_lens_len = paren_levels_lens_lens_lens_lens.len();\n\
    \   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_lens_lens_lens_len`\n\
    \nerror[E0425]: cannot find value `paren_levels_lens_lens_lens_lens_lens` in this\
    \ scope\n  --> /tmp/tmpraqw8sdn.rs:17:57\n   |\n17 |     let mut paren_levels_lens_lens_lens_lens_lens_len\
    \ = paren_levels_lens_lens_lens_lens_lens.len();\n   |                       \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `paren_levels_lens_lens_lens_lens_len`\n\
    \nerror[E0425]: cannot find value `paren_levels_lens_lens_lens_lens_lens_lens`\
    \ in this scope\n  --> /tmp/tmpraqw8sdn.rs:18:62\n   |\n18 |     let mut paren_levels_lens_lens_lens_lens_lens_lens_len\
    \ = paren_levels_lens_lens_lens_lens_lens_lens.len();\n   |                  \
    \                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_lens_lens_lens_lens_lens_len`\n\
    \nerror[E0425]: cannot find value"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_level = 0;\n    let\
    \ mut paren_levels: Vec<isize> = Vec::new();\n    let mut paren_levels_len = 0;\n\
    \    let mut paren_levels_lens: Vec<isize> = Vec::new();\n    let mut paren_levels_lens_len\
    \ = 0;\n    let mut paren_levels_lens_len2 = 0;\n    let mut paren_levels_lens_len3\
    \ = 0;\n    let mut paren_levels_lens_len4 = 0;\n    let mut paren_levels_lens_len5\
    \ = 0;\n    let mut paren_levels_lens_len6 = 0;\n    let mut paren_levels_lens_len7\
    \ = 0;\n    let mut paren_levels_lens_len8 = 0;\n    let mut paren_levels_lens_len9\
    \ = 0;\n    let mut paren_levels_lens_len10 = 0;\n    let mut paren_levels_lens_len11\
    \ = 0;\n    let mut paren_levels_lens_len12 = 0;\n    let mut paren_levels_lens_len13\
    \ = 0;\n    let mut paren_levels_lens_len14 = 0;\n    let mut paren_levels_lens_len15\
    \ = 0;\n    let mut paren_levels_lens_len16 = 0;\n    let mut paren_levels_lens_len17\
    \ = 0;\n    let mut paren_levels_lens_len18 = 0;\n    let mut paren_levels_lens_len19\
    \ = 0;\n    let mut paren_levels_lens_len20 = 0;\n    let mut paren_levels_lens_len21\
    \ = 0;\n    let mut paren_levels_lens_len22 = 0;\n    let mut paren_levels_lens_len23\
    \ = 0;\n    let mut paren_levels_lens_len24 = 0;\n    let mut paren_levels_lens_len25\
    \ = 0;\n    let mut paren_levels_lens_len26 = 0;\n    let mut paren_levels_lens_len27\
    \ = 0;\n    let mut paren_levels_lens_len28 = 0;\n    let mut paren_levels_lens_len29\
    \ = 0;\n    let mut paren_levels_lens_len30 = 0;\n    let mut paren_levels_lens_len31\
    \ = 0;\n    let mut paren_levels_lens_len32 = 0;\n    let mut paren_levels_lens_len33\
    \ = 0;\n    let mut paren_levels_lens_len34 = 0;\n    let mut paren_levels_lens_len35\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpynr6c_q8.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len\
    \ = paren_level_chars.len();\n    let mut paren_level_char_pos_end = 0;\n    let\
    \ mut paren_level_char_len_end = 0;\n    let mut paren_level_char_pos_start =\
    \ 0;\n    let mut paren_level_char_len_start = 0;\n    let mut paren_level_char_pos_end\
    \ = 0;\n    let mut paren_level_char_len_end = 0;\n    let mut paren_level_char_pos_start\
    \ = 0;\n    let mut paren_level_char_len_start = 0;\n    let mut paren_level_char_pos_end\
    \ = 0;\n    let mut paren_level_char_len_end = 0;\n    let mut paren_level_char_pos_start\
    \ = 0;\n    let mut paren_level_char_len_start = 0;\n    let mut paren_level_char_pos_end\
    \ = 0;\n    let mut paren_level_char_len_end = 0;\n    let mut paren_level_char_pos_start\
    \ = 0;\n    let mut paren_level_char_len_start = 0;\n    let mut paren_level_char_pos_end\
    \ = 0;\n    let mut paren_level_char_len_end = 0;\n    let mut paren_level_char_pos_start\
    \ = 0;\n    let mut paren_level_char_len_start = 0;\n    let mut paren_level_char_pos_end\
    \ = 0;\n    let mut paren_level_char_len_end = 0;\n    let mut paren_level_char_pos_start\
    \ = 0;\n    let mut paren_level_char_len_start = 0;\n    let mut paren_level_char_pos_end\
    \ = 0;\n    let mut paren_level_char_len_end = 0;\n    let mut paren_level_char_pos_start\
    \ = 0;\n    let mut paren_level_char_len_start = 0;\n    let mut paren_level_char_pos_end\
    \ = 0;\n    let mut paren_level_char_len_end = 0;\n    let mut paren_level_char_pos_start\
    \ = 0;\n    let mut paren_level_char_len_start = 0;\n    let mut paren_level_char_pos_end\
    \ = 0;\n    let mut paren_level_char_len_end = 0;\n    let mut paren_level_char_pos_start\
    \ = 0;\n    let mut paren_level_char_len_start = 0;\n    let mut paren_level_char_pos_end\
    \ = 0;\n    let mut paren_level_char_len_end = 0;\n    let mut paren_\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpui9cbxil.rs:53:19\n   |\n\
    53 |     let mut paren_\n   |                   ^ help: add `;` here\n54 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpui9cbxil.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut paren_depth\
    \ = 0;\n    let mut paren_level = 0;\n    let mut paren_level_count = 0;\n   \
    \ let mut paren_level_max_count = 0;\n    let mut paren_level_max_depth = 0;\n\
    \    let mut paren_level_max_depth_count = 0;\n    let mut paren_level_max_depth_max_count\
    \ = 0;\n    let mut paren_level_max_depth_max_depth = 0;\n    let mut paren_level_max_depth_max_depth_count\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_count = 0;\n    let mut\
    \ paren_level_max_depth_max_depth_max_depth = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_count\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_count = 0;\n\
    \    let mut paren_level_max_depth_max_depth_max_depth_max_depth = 0;\n    let\
    \ mut paren_level_max_depth_max_depth_max_depth_max_count = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth_count\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth_max_count\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth_max_depth\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth_max_count\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth_max_depth\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth_max_depth_count\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth_max_depth_max_count\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth_max_depth_max_depth\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth_max_depth_max_count\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth_max_depth_max_depth\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth_max_depth_max_count\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth_max_depth_max_depth\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth_max_depth_max_depth_count\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth_max_depth_max_depth_max_count\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth_max_depth_max_depth_max_depth\
    \ = 0;\n    let mut paren_level_max_depth_max_depth_max_depth_max_depth_max_depth_max_depth_max_count\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbkr1ikfk.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0usize;\n    let mut paren_stack: Vec<isize>\
    \ = vec![];\n    let mut paren_levels: Vec<isize> = vec![];\n    let mut paren_levels_stack:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_stack_size: usize = 0;\n    let\
    \ mut paren_levels_size: usize = 0;\n    let mut paren_levels_size: usize = 0;\n\
    \    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size: usize\
    \ = 0;\n    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size:\
    \ usize = 0;\n    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size:\
    \ usize = 0;\n    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size:\
    \ usize = 0;\n    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size:\
    \ usize = 0;\n    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size:\
    \ usize = 0;\n    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size:\
    \ usize = 0;\n    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size:\
    \ usize = 0;\n    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size:\
    \ usize = 0;\n    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size:\
    \ usize = 0;\n    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size:\
    \ usize = 0;\n    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size:\
    \ usize = 0;\n    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size:\
    \ usize = 0;\n    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size:\
    \ usize = 0;\n    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size:\
    \ usize = 0;\n    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size:\
    \ usize = 0;\n    let mut paren_levels_size: usize = 0;\n    let mut paren_levels_size:\
    \ usize = 0;\n    let mut paren_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7plzp_nz.rs:48:19\n   |\n\
    48 |     let mut paren_\n   |                   ^ help: add `;` here\n49 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7plzp_nz.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_char: char;\n    let mut paren_level_char_next: char;\n\
    \    let mut paren_level_char_next_next: char;\n    let mut paren_level_char_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next: char;\n    let mut\
    \ paren_level_char_next_next_next_next_next: char;\n    let mut paren_level_char_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next: char;\n\
    \    let mut paren_level_char_next_next_next_next_next_next_next_next: char;\n\
    \    let mut paren_level_char_next_next_next_next_next_next_next_next_next: char;\n\
    \    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdfee48mp.rs:33:65\n   |\n\
    33 |     let mut paren_level_char_next_next_next_next_next_next_next_\n   |  \
    \                                                               ^ help: add `;`\
    \ here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpdfee48mp.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp37gxvmr2.rs:37:32\n   |\n\
    37 |     let mut paren_levels_stack_\n   |                                ^ help:\
    \ add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp37gxvmr2.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr = Vec::new();\n    let mut paren_levels_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr = Vec::new();\n    let mut\
    \ paren_levels_ptr_end_ptr_end = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end = Vec::new();\n\
    \    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr = Vec::new();\n    let mut\
    \ paren_levels_ptr_end_ptr_end_ptr_end_ptr_end = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_u1feo_x.rs:28:58\n   |\n\
    28 |     let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_\n   |         \
    \                                                 ^ help: add `;` here\n29 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp_u1feo_x.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels = vec![];\n\
    \    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_ptr\
    \ = 0;\n    let mut paren_levels_ptr = 0;\n    let mut paren_levels_ptr_next =\
    \ 0;\n    let mut paren_levels_ptr_next_next = 0;\n    let mut paren_levels_ptr_next_next_next\
    \ = 0;\n    let mut paren_levels_ptr_next_next_next_next = 0;\n    let mut paren_levels_ptr_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next = 0;\n    let\
    \ mut paren_levels_ptr_next_next_next_next_next_next_next = 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next_next_next =\
    \ 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_ptr_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp5rm0z8ro.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsrvlo9su.rs:39:19\n   |\n\
    39 |     let mut paren_\n   |                   ^ help: add `;` here\n40 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpsrvlo9su.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = vec![];\n    let mut paren_level_char\
    \ = 0;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len\
    \ = paren_string.len();\n    let mut paren_level_char_len = paren_level_char_len.saturating_sub(paren_level_char_pos);\n\
    \    let mut paren_level_char_pos = paren_level_char_len;\n    let mut paren_level_char_pos\
    \ = paren_level_char_pos.saturating_sub(paren_level_char_count);\n    let mut\
    \ paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level_count);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(paren_level);\n\
    \    let mut paren_level_char_pos = paren_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp08h7xmhc.rs:35:42\n   |\n\
    35 |     let mut paren_level_char_pos = paren_\n   |                         \
    \                 ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `paren_` in this scope\n  --> /tmp/tmp08h7xmhc.rs:35:36\n\
    \   |\n35 |     let mut paren_level_char_pos = paren_\n   |                  \
    \                  ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp08h7xmhc.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr = Vec::new();\n    let mut paren_levels_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr = Vec::new();\n    let mut\
    \ paren_levels_ptr_end_ptr_end = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end = Vec::new();\n\
    \    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr = Vec::new();\n    let mut\
    \ paren_levels_ptr_end_ptr_end_ptr_end_ptr_end = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgue2btdh.rs:28:62\n   |\n\
    28 |     let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_\n   |     \
    \                                                         ^ help: add `;` here\n\
    29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpgue2btdh.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack = Vec::new();\n\
    \    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_char = paren_string[paren_stack_pos];\n    while\
    \ paren_stack_pos < paren_stack_len {\n        if paren_stack_char == ')' {\n\
    \            level += 1;\n            paren_stack.pop();\n            paren_stack_pos\
    \ = paren_stack_len;\n            paren_stack_char = paren_string[paren_stack_pos];\n\
    \        } else if paren_stack_char == '(' {\n            level += 1;\n      \
    \      paren_stack.push(level);\n            paren_stack_pos = paren_stack_len;\n\
    \            paren_stack_char = paren_string[paren_stack_pos];\n        } else\
    \ {\n            paren_stack_pos += 1;\n            paren_stack_char = paren_string[paren_stack_pos];\n\
    \        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp7yq_xaog.rs:11:32\n   |\n11 |     let mut paren_stack_char = paren_string[paren_stack_pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7yq_xaog.rs:17:32\n   |\n17 |             paren_stack_char = paren_string[paren_stack_pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7yq_xaog.rs:22:32\n   |\n22 |             paren_stack_char = paren_string[paren_stack_pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usi"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = 0;\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp911lk2hu.rs:37:52\n   |\n\
    37 |     let mut paren_levels_stack_bottom = paren_level\n   |               \
    \                                     ^ help: add `;` here\n38 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp911lk2hu.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_count_max = 0;\n    let mut paren_level_char_pos_count_max_max\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min_max\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_pos_count_min\
    \ = 0;\n    let mut paren_level_char_pos_count_min = 0;\n    let mut paren_level_char_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw5h3lqxr.rs:50:30\n   |\n\
    50 |     let mut paren_level_char_\n   |                              ^ help:\
    \ add `;` here\n51 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpw5h3lqxr.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = 0;\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n \
    \   let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = \n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp02j3by1m.rs:36:1\n\
    \   |\n36 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char\
    \ = 0;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_count = 0;\n    let mut paren_level_char_pos_chars\
    \ = Vec::new();\n    let mut paren_level_char_pos_char = 0;\n    let mut paren_level_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_count = 0;\n    let mut paren_level_char_pos_char_pos_char_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_chars = Vec::new();\n    let\
    \ mut paren_level_char_pos_char_pos_char = 0;\n    let mut paren_level_char_pos_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_count = 0;\n    let\
    \ mut paren_level_char_pos_char_pos_char_pos_char_count = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_chars\
    \ = Vec::new();\n    let mut paren_level_char_pos_char_pos_char_pos_char = 0;\n\
    \    let mut paren_level_char_pos_char_pos_char_pos_char_pos = 0;\n    let mut\
    \ paren_level_char_pos_char_pos_char_pos_char_pos_count = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_chars = Vec::new();\n\
    \    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char = 0;\n    let\
    \ mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos = 0;\n    let mut\
    \ paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_count = 0;\n    let\
    \ mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_count = 0;\n\
    \    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_chars =\
    \ Vec::new();\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_count\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnj718rh_.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut paren_level =\
    \ 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_levels_stack =\
    \ Vec::new();\n    let mut paren_levels_stack_size = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_end_ptr = Vec::new();\n  \
    \  let mut paren_levels_stack_ptr_end_ptr_end = Vec::new();\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr = Vec::new();\n  \
    \  let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr =\
    \ Vec::new();\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfedbozcn.rs:28:109\n   |\n\
    28 |     let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec\n   |                                                                \
    \                                             ^ help: add `;` here\n29 | }\n \
    \  | - unexpected token\n\nerror[E0423]: expected value, found struct `Vec`\n\
    \   --> /tmp/tmpfedbozcn.rs:28:106\n    |\n28  |       let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec\n    |                                                               \
    \                                             ^^^ help: use struct literal syntax\
    \ instead: `Vec { buf: val, len: val }`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpfedbozcn.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_level_count: isize = 0;\n    let\
    \ mut paren_level_max: isize = 0;\n    let mut paren_level_max_count: isize =\
    \ 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcd__zz37.rs:49:18\n   |\n\
    49 |     let mut paren\n   |                  ^ help: add `;` here\n50 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpcd__zz37.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let mut \n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpgoma94kg.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nest\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2qlsh7af.rs:41:31\n   |\n\
    41 |     let mut paren_nesting_nest\n   |                               ^ help:\
    \ add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp2qlsh7af.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack = Vec::new();\n\
    \    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_char = paren_string[paren_stack_pos];\n    while\
    \ paren_stack_pos < paren_string.len() {\n        if paren_stack_char == ')' {\n\
    \            paren_stack.pop();\n            paren_stack_len -= paren_stack.len();\n\
    \            if paren_stack.len() == 0 {\n                level += 1;\n      \
    \      }\n        }\n        if paren_stack_char == '(' {\n            paren_stack.push(level);\n\
    \            paren_stack_len += 1;\n        }\n        paren_stack_pos += 1;\n\
    \        paren_stack_char = paren_string[paren_stack_pos];\n    }\n    paren_stack\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpdqc_6as0.rs:11:32\n   |\n11 |     let mut paren_stack_char = paren_string[paren_stack_pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdqc_6as0.rs:25:28\n   |\n25 |         paren_stack_char = paren_string[paren_stack_pos];\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting = 0;\n\
    \    let mut paren_levels: Vec<isize> = Vec::new();\n    let mut paren_nesting_levels:\
    \ Vec<isize> = Vec::new();\n    let mut paren_levels_stack: Vec<isize> = Vec::new();\n\
    \    let mut paren_nesting_levels_stack: Vec<isize> = Vec::new();\n    let mut\
    \ paren_levels_stack_size = 0;\n    let mut paren_nesting_levels_stack_size =\
    \ 0;\n    let mut paren_levels_stack_ptr = 0;\n    let mut paren_nesting_levels_stack_ptr\
    \ = 0;\n    let mut paren_levels_stack_ptr_next = 0;\n    let mut paren_nesting_levels_stack_ptr_next\
    \ = 0;\n    let mut paren_levels_stack_ptr_next_next = 0;\n    let mut paren_nesting_levels_stack_ptr_next_next\
    \ = 0;\n    let mut paren_levels_stack_ptr_next_next_next = 0;\n    let mut paren_nesting_levels_stack_ptr_next_next_next\
    \ = 0;\n    let mut paren_levels_stack_ptr_next_next_next_next = 0;\n    let mut\
    \ paren_nesting_levels_stack_ptr_next_next_next_next = 0;\n    let mut paren_levels_stack_ptr_next_next_next_next_next\
    \ = 0;\n    let mut paren_nesting_levels_stack_ptr_next_next_next_next_next =\
    \ 0;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_next = 0;\n\
    \    let mut paren_nesting_levels_stack_ptr_next_next_next_next_next_next = 0;\n\
    \    let mut paren_levels_stack_ptr_next_next_next_next_next_next_next = 0;\n\
    \    let mut paren_nesting_levels_stack_ptr_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_nesting_levels_stack_ptr_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp14hk7ou_.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr =\
    \ Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpixhivf1s.rs:29:95\n   |\n\
    29 |     let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    \   |                                                                        \
    \                       ^ help: add `;` here\n30 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpixhivf1s.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_levels_size\
    \ = Vec::new();\n    let mut paren_levels_size_ptr = Vec::new();\n    let mut\
    \ paren_levels_size_ptr_ptr = Vec::new();\n    let mut paren_levels_size_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_size_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_size_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_size_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfilhhqrp.rs:29:130\n   |\n\
    29 |     let mut paren_levels_size_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    \   |                                                                        \
    \                                                          ^ help: add `;` here\n\
    30 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfilhhqrp.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_level_count: isize = 0;\n    let\
    \ mut paren_level_char: char;\n    let mut paren_level_char_count: usize = 0;\n\
    \    let mut paren_level_char_next: char;\n    let mut paren_level_char_next_count:\
    \ usize = 0;\n    let mut paren_level_char_next_next: char;\n    let mut paren_level_char_next_next_count:\
    \ usize = 0;\n    let mut paren_level_char_next_next_next: char;\n    let mut\
    \ paren_level_char_next_next_next_count: usize = 0;\n    let mut paren_level_char_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_count: usize = 0;\n\
    \    let mut paren_level_char_next_next_next_next_next: char;\n    let mut paren_level_char_next_next_next_next_next_count:\
    \ usize = 0;\n    let mut paren_level_char_next_next_next_next_next_next: char;\n\
    \    let mut paren_level_char_next_next_next_next_next_next_count: usize = 0;\n\
    \    let mut paren_level_char_next_next_next_next_next_next_next: char;\n    let\
    \ mut paren_level_char_next_next_next_next_next_next_next_count: usize = 0;\n\
    \    let mut paren_level_char_next_next_next_next_next_next_next_next: char;\n\
    \    let mut paren_level_char_next_next_next_next_next_next_next_next_count: usize\
    \ = 0;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_count:\
    \ usize = 0;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_count:\
    \ usize = 0;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_count:\
    \ usize = 0;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_count:\
    \ usize = 0;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_count:\
    \ usize = 0;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_count:\
    \ usize = 0;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_count:\
    \ usize\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmqn03lrc.rs:36:92\n   |\n\
    36 |     let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_count:\
    \ usize\n   |                                                                \
    \                            ^ help: add `;` here\n37 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpmqn03lrc.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut level = 0;\n\
    \    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let\
    \ mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n\
    \    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n    let\
    \ mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let\
    \ mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n\
    \    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n    let\
    \ mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let\
    \ mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n\
    \    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n    let\
    \ mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let\
    \ mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n\
    \    let mut paren_levels = Vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv6fap2g4.rs:58:31\n   |\n\
    58 |     let mut paren_levels = Vec\n   |                               ^ help:\
    \ add `;` here\n59 | }\n   | - unexpected token\n\nerror[E0423]: expected value,\
    \ found struct `Vec`\n   --> /tmp/tmpv6fap2g4.rs:58:28\n    |\n58  |       let\
    \ mut paren_levels = Vec\n    |                              ^^^ help: use struct\
    \ literal syntax instead: `Vec { buf: val, len: val }`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpv6fap2g4.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0423.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpddplcjnf.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpddplcjnf.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels = vec![];\n\
    \    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_size\
    \ = vec![];\n    let mut paren_levels_stack_ptr = vec![];\n    let mut paren_levels_stack_ptr_ptr\
    \ = vec![];\n    let mut paren_levels_stack_ptr_ptr_ptr = vec![];\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr = vec![];\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr\
    \ = vec![];\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = vec![];\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = vec![];\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = vec![];\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = vec![];\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = vec![];\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = vec![];\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = vec![];\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = vec![];\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = vec![];\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = vec![];\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = vec![];\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = vec![];\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = vec![];\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = vec![];\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = vec![];\n    let mut \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpqiindfj3.rs:32:1\n\
    \   |\n32 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = vec![];\n    let mut paren_level = 0;\n\
    \    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1owtu1v_.rs:41:43\n   |\n\
    41 |     let mut paren_nesting_nesting_nesting_\n   |                        \
    \                   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmp1owtu1v_.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr = paren_levels_stack_len;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_ptr;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_top = paren_levels_stack_ptr\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp14jg2blo.rs:37:60\n   |\n\
    37 |     let mut paren_levels_stack_top = paren_levels_stack_ptr\n   |       \
    \                                                     ^ help: add `;` here\n38\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp14jg2blo.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0usize;\n    let mut paren_stack = Vec::new();\n\
    \    let mut paren_levels = Vec::new();\n    let mut paren_levels_len = Vec::new();\n\
    \    let mut paren_levels_len_count = Vec::new();\n    let mut paren_levels_len_max\
    \ = Vec::new();\n    let mut paren_levels_len_max_count = Vec::new();\n    let\
    \ mut paren_levels_len_max_index = Vec::new();\n    let mut paren_levels_len_max_index2\
    \ = Vec::new();\n    let mut paren_levels_len_max_index3 = Vec::new();\n    let\
    \ mut paren_levels_len_max_index4 = Vec::new();\n    let mut paren_levels_len_max_index5\
    \ = Vec::new();\n    let mut paren_levels_len_max_index6 = Vec::new();\n    let\
    \ mut paren_levels_len_max_index7 = Vec::new();\n    let mut paren_levels_len_max_index8\
    \ = Vec::new();\n    let mut paren_levels_len_max_index9 = Vec::new();\n    let\
    \ mut paren_levels_len_max_index10 = Vec::new();\n    let mut paren_levels_len_max_index11\
    \ = Vec::new();\n    let mut paren_levels_len_max_index12 = Vec::new();\n    let\
    \ mut paren_levels_len_max_index13 = Vec::new();\n    let mut paren_levels_len_max_index14\
    \ = Vec::new();\n    let mut paren_levels_len_max_index15 = Vec::new();\n    let\
    \ mut paren_levels_len_max_index16 = Vec::new();\n    let mut paren_levels_len_max_index17\
    \ = Vec::new();\n    let mut paren_levels_len_max_index18 = Vec::new();\n    let\
    \ mut paren_levels_len_max_index19 = Vec::new();\n    let mut paren_levels_len_max_index20\
    \ = Vec::new();\n    let mut paren_levels_len_max_index21 = Vec::new();\n    let\
    \ mut paren_levels_len_max_index22 = Vec::new();\n    let mut paren_levels_len_max_index23\
    \ = Vec::new();\n    let mut paren_levels_len_max_index24 = Vec::new();\n    let\
    \ mut paren_levels_len_max_index25 = Vec::new();\n    let mut paren_levels_len_max_index26\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxrl3kvtj.rs:39:41\n   |\n\
    39 |     let mut paren_levels_len_max_index26\n   |                          \
    \               ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpxrl3kvtj.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = vec![];\n    let mut paren_level_char\
    \ = 0;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len\
    \ = paren_level_char.len();\n    let mut paren_level_char_pos = 0;\n    let mut\
    \ paren_level_char_len = paren_level_char.len();\n    let mut paren_level_char_pos\
    \ = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n    let mut\
    \ paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let \n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpp5f89shx.rs:49:1\n  \
    \ |\n49 | }\n   | ^ expected pattern\n\nerror[E0689]: can't call method `len`\
    \ on ambiguous numeric type `{integer}`\n  --> /tmp/tmpp5f89shx.rs:14:53\n   |\n\
    14 |     let mut paren_level_char_len = paren_level_char.len();\n   |        \
    \                                             ^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `i32`\n   |\n12 |     let mut paren_level_char:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call\
    \ method `len` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpp5f89shx.rs:16:53\n\
    \   |\n16 |     let mut paren_level_char_len = paren_level_char.len();\n   | \
    \                                                    ^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `i32`\n   |\n12 |     let mut paren_level_char:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call\
    \ method `len` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpp5f89shx.rs:18:53\n\
    \   |\n18 |     let mut paren_level_char_len = paren_level_char.len();\n   | \
    \                                                    ^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `i32`\n   |\n12 |     let mut paren_level_char:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call\
    \ method `len` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpp5f89shx.rs:20:53\n\
    \   |\n20 |     let mut paren_level_char_len = paren_level_char.len();\n   | \
    \                                                    ^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `i32`\n   |\n12 |     let mut paren_level_char:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call\
    \ method `len` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpp5f89shx.rs:22:53\n\
    \   |\n22 |     let mut paren_level_char_len = paren_level_char.len();\n   | \
    \                                                    ^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `i32`\n   |\n12 |     let mut paren_level_char:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_char_next: char;\n    let mut paren_level_char_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next: char;\n    let mut paren_level_char_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next: char;\n    let\
    \ mut paren_level_char_next_next_next_next_next_next: char;\n    let mut paren_level_char_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next:\
    \ char;\n    let mut paren_level_char_next_next_next_next_next_\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuiyjx04j.rs:34:55\n   |\n\
    34 |     let mut paren_level_char_next_next_next_next_next_\n   |            \
    \                                           ^ help: add `;` here\n35 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpuiyjx04j.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len\
    \ = paren_level_chars.len();\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1usfqj6d.rs:47:30\n   |\n\
    47 |     let mut paren_level_char_\n   |                              ^ help:\
    \ add `;` here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp1usfqj6d.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_level = 0;\n    let\
    \ mut paren_levels = Vec::new();\n    let mut paren_levels_size = paren_string.len();\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_levels_len = paren_levels_size;\n\
    \    let mut paren_levels_pos = 0;\n    let mut paren_level\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp925na43b.rs:50:24\n   |\n\
    50 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    51 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp925na43b.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack_top - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_top\
    \ - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_top - 1;\n   \
    \ let mut paren_levels_stack_top = paren_levels_stack_top - 1;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack_top - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_top\
    \ - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_top - 1;\n   \
    \ let mut paren_levels_stack_top = paren_levels_stack_top - 1;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack_top - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_top\
    \ - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_top - 1;\n   \
    \ let mut paren_levels_stack_top = paren_levels_stack_top - 1;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack_top - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_top\
    \ - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_top - 1;\n   \
    \ let mut paren_levels_stack_top = paren_levels_stack_top - 1;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack_top - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_top\
    \ - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_top - 1;\n   \
    \ let mut paren_levels_stack_top = paren_levels_stack_top - 1;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack_top - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_top\
    \ - 1;\n    let mut paren_levels_stack_top = paren_levels_stack_top - 1;\n   \
    \ let mut paren_levels_stack_top = paren_levels_stack_top - 1;\n    let \n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpttgsunkm.rs:38:1\n  \
    \ |\n38 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut level = 0;\n\
    \    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let\
    \ mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n\
    \    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n    let\
    \ mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let\
    \ mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n\
    \    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n    let\
    \ mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let\
    \ mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n\
    \    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n    let\
    \ mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let\
    \ mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n\
    \    let mut paren_levels = Vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo_nlwnuh.rs:58:31\n   |\n\
    58 |     let mut paren_levels = Vec\n   |                               ^ help:\
    \ add `;` here\n59 | }\n   | - unexpected token\n\nerror[E0423]: expected value,\
    \ found struct `Vec`\n   --> /tmp/tmpo_nlwnuh.rs:58:28\n    |\n58  |       let\
    \ mut paren_levels = Vec\n    |                              ^^^ help: use struct\
    \ literal syntax instead: `Vec { buf: val, len: val }`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpo_nlwnuh.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0423.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let \n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpqd_6jd37.rs:38:1\n  \
    \ |\n38 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr = Vec::new();\n    let mut paren_levels_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr = Vec::new();\n    let mut\
    \ paren_levels_ptr_end_ptr_end = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end = Vec::new();\n\
    \    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr = Vec::new();\n    let mut\
    \ paren_levels_ptr_end_ptr_end_ptr_end_ptr_end = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9zn7rop3.rs:28:58\n   |\n\
    28 |     let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_\n   |         \
    \                                                 ^ help: add `;` here\n29 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9zn7rop3.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp25y8quob.rs:38:11\n   |\n\
    38 |     let mu\n   |           ^ help: add `;` here\n39 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp25y8quob.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_level_count: usize = 0;\n    let\
    \ mut paren_levels: Vec<isize> = vec![];\n    let mut paren_levels_count: usize\
    \ = 0;\n    let mut paren_levels_string: String = String::new();\n    let mut\
    \ paren_levels_string_count: usize = 0;\n    let mut paren_levels_strings: Vec<String>\
    \ = vec![];\n    let mut paren_levels_strings_count: usize = 0;\n    let mut paren_levels_strings_count:\
    \ usize = 0;\n    let mut paren_levels_strings_string: String = String::new();\n\
    \    let mut paren_levels_strings_string_count: usize = 0;\n    let mut paren_levels_strings_strings:\
    \ Vec<String> = vec![];\n    let mut paren_levels_strings_strings_count: usize\
    \ = 0;\n    let mut paren_levels_strings_strings_count: usize = 0;\n    let mut\
    \ paren_levels_strings_strings_string: String = String::new();\n    let mut paren_levels_strings_strings_strings_count:\
    \ usize = 0;\n    let mut paren_levels_strings_strings_strings_count: usize =\
    \ 0;\n    let mut paren_levels_strings_strings_strings_string: String = String::new();\n\
    \    let mut paren_levels_strings_strings_strings_strings_count: usize = 0;\n\
    \    let mut paren_levels_strings_strings_strings_strings_count: usize = 0;\n\
    \    let mut paren_levels_strings_strings_strings_strings_string: String = String::new();\n\
    \    let mut paren_levels_strings_strings_strings_strings_strings_count: usize\
    \ = 0;\n    let mut paren_levels_strings_strings_strings_strings_strings_count:\
    \ usize = 0;\n    let mut paren_levels_strings_strings_strings_strings_strings_string:\
    \ String = String::new();\n    let mut paren_levels_strings_strings_strings_strings_strings_strings_count:\
    \ usize = 0;\n    let mut paren_levels_strings_strings_strings_strings_strings_strings_count:\
    \ usize = 0;\n    let mut paren_levels_strings_strings_strings_strings_strings_strings_string:\
    \ String = String::new();\n\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpay4vgops.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8ofhsm9t.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp8ofhsm9t.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkxaac034.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpkxaac034.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_level_count: isize = 0;\n    for\
    \ paren in paren_string.chars() {\n        if paren == '(' {\n            paren_stack.push(paren_level);\n\
    \            paren_level_count = paren_level_count;\n            paren_level +=\
    \ 1;\n        } else if paren == ')' {\n            paren_level -= 1;\n      \
    \      if paren_level == 0 {\n                paren_stack.push(paren_level_count);\n\
    \                paren_level_count += 1;\n            }\n        } else {\n  \
    \          paren_level_count += 1;\n        }\n    }\n    paren_stack\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 0, 1, 2, 2, 0, 4, 0, 1, 2, 1, 1, 6]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmp3i2fa_64.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting = 0;\n\
    \    let mut paren_levels = Vec::new();\n    let mut paren_nestings = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_nestings_stack\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_nestings_stack_ptr = paren_nestings_stack.len();\n    let mut\
    \ paren_levels_ptr = paren_levels.len();\n    let mut paren_nestings_ptr = paren_nestings.len();\n\
    \    let mut paren_levels_ptr = paren_levels.len();\n    let mut paren_nestings_ptr\
    \ = paren_nestings.len();\n    let mut paren_levels_ptr = paren_levels.len();\n\
    \    let mut paren_nestings_ptr = paren_nestings.len();\n    let mut paren_levels_ptr\
    \ = paren_levels.len();\n    let mut paren_nestings_ptr = paren_nestings.len();\n\
    \    let mut paren_levels_ptr = paren_levels.len();\n    let mut paren_nestings_ptr\
    \ = paren_nestings.len();\n    let mut paren_levels_ptr = paren_levels.len();\n\
    \    let mut paren_nestings_ptr = paren_nestings.len();\n    let mut paren_levels_ptr\
    \ = paren_levels.len();\n    let mut paren_nestings_ptr = paren_nestings.len();\n\
    \    let mut paren_levels_ptr = paren_levels.len();\n    let mut paren_nestings_ptr\
    \ = paren_nestings.len();\n    let mut paren_levels_ptr = paren_levels.len();\n\
    \    let mut paren_nestings_ptr = paren_nestings.len();\n    let mut paren_levels_ptr\
    \ = paren_levels.len();\n    let mut paren_nestings_ptr = paren_nestings.len();\n\
    \    let mut paren_levels_ptr = paren_levels.len();\n    let mut paren_nestings_ptr\
    \ = paren_nestings.len();\n    let mut paren_levels_ptr = paren_levels.len();\n\
    \    let mut paren_nestings_ptr = paren_nestings.len();\n    let mut paren_levels_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqrqghyff.rs:39:26\n   |\n\
    39 |     let mut paren_levels_\n   |                          ^ help: add `;`\
    \ here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpqrqghyff.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_char: char;\n    let mut paren_level_char_count = 0;\n\
    \    while paren_level_char_count < paren_string.len() {\n        paren_level_char\
    \ = paren_level_string[paren_level_char_count];\n        paren_level_char_count\
    \ = paren_level_char_count + 1;\n        if paren_level_char == ' ' {\n      \
    \      paren_level_char_count = paren_level_char_count + 1;\n            paren_level_string\
    \ = paren_level_string.clone();\n            paren_level_string.truncate(paren_level_char_count);\n\
    \            paren_level_string.push_str(\" \");\n            paren_level_string.push_str(paren_level_string[paren_level_char_count..]);\n\
    \            paren_level_string.truncate(paren_level_char_count);\n          \
    \  paren_level_string.push_str(\" \");\n            paren_level_string.push_str(paren_level_string[paren_level_char_count..]);\n\
    \            paren_level_string.truncate(paren_level_char_count);\n          \
    \  paren_level_string.push_str(\" \");\n            paren_level_string.push_str(paren_level_string[paren_level_char_count..]);\n\
    \            paren_level_string.truncate(paren_level_char_count);\n          \
    \  paren_level_string.push_str(\" \");\n            paren_level_string.push_str(paren_level_string[paren_level_char_count..]);\n\
    \            paren_level_string.truncate(paren_level_char_count);\n          \
    \  paren_level_string.push_str(\" \");\n            paren_level_string.push_str(paren_level_string[paren_level_char_count..]);\n\
    \            paren_level_string.truncate(paren_level_char_count);\n          \
    \  paren_level_string.push_str(\" \");\n            paren_level_string.push_str(paren_level_string[paren_level_char_count..]);\n\
    \            paren_level_string.truncate(paren_level_char_count);\n          \
    \  paren_level_string.push_str(\" \");\n            paren_level_string.push_str(paren_level_string[paren_level_char_count..]);\n\
    \            paren_level_string.truncate(paren_level_char_count);\n          \
    \  paren_level_string.push_str(\" \");\n            paren_level_string.push_str(paren_level_string\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpg21g7xs2.rs:50:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n13 |     while paren_level_char_count < paren_string.len() {\n   |      \
    \                                                 - unclosed delimiter\n...\n\
    16 |         if paren_level_char == ' ' {\n   |                              \
    \      - this delimiter might not be properly closed...\n...\n43 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n50 | }\n   |   ^\n\n\
    error: mismatched closing delimiter: `}`\n  --> /tmp/tmpg21g7xs2.rs:42:40\n  \
    \ |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   | \
    \                                                           - closing delimiter\
    \ possibly meant for this\n...\n42 |             paren_level_string.push_str(paren_level_string\n\
    \   |                                        ^ unclosed delimiter\n43 | }\n  \
    \ | ^ mismatched closing delimiter\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpg21g7xs2.rs:14:28\n   |\n14 |         paren_level_char\
    \ = paren_level_string[paren_level_char_count];\n   |                        \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg21g7xs2.rs:21:41\n\
    \   |\n21 |             paren_level_string.push_str(paren_level_string[paren_level_char_count..]);\n\
    \   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack = Vec::new();\n\
    \    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_char = paren_string[paren_stack_pos];\n    let\
    \ mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string[paren_stack_char_pos].len();\n\
    \    let mut paren_stack_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpruaqpq7m.rs:42:25\n   |\n\
    42 |     let mut paren_stack_\n   |                         ^ help: add `;` here\n\
    43 | }\n   | - unexpected token\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpruaqpq7m.rs:11:32\n   |\n11 |     let mut paren_stack_char\
    \ = paren_string[paren_stack_pos];\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpruaqpq7m.rs:13:36\n   |\n13 |     let mut paren_stack_char_len\
    \ = paren_string[paren_stack_char_pos].len();\n   |                          \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpruaqpq7m.rs:15:36\n   |\n15 |     let mut paren_stack_char_len\
    \ = paren_string[paren_stack_char_pos].len();\n   |                          \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Inde"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_level_count: isize = 0;\n    let\
    \ mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_level: isize\
    \ = 0;\n    let mut paren_level_max_level_count: isize = 0;\n    let mut paren_level_max_level_max_count:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level: isize = 0;\n    let\
    \ mut paren_level_max_level_max_level_count: isize = 0;\n    let mut paren_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_count: isize\
    \ = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level: isize\
    \ = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_count:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmph0zqj3pl.rs:34:1\n  \
    \ |\n34 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_char = 0;\n    let mut paren_level_char_pos =\
    \ 0;\n    let mut paren_level_char_pos_count = 0;\n    let mut paren_level_char_pos_char\
    \ = 0;\n    let mut paren_level_char_pos_char_pos = 0;\n    let mut paren_level_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char = 0;\n    let mut paren_level_char_pos_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_count = 0;\n    let\
    \ mut paren_level_char_pos_char_pos_char_pos_char = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_count = 0;\n\
    \    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char = 0;\n    let\
    \ mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos = 0;\n    let mut\
    \ paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_count = 0;\n    let\
    \ mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char = 0;\n   \
    \ let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos =\
    \ 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa0wsbjxu.rs:37:93\n   |\n\
    37 |     let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_\n\
    \   |                                                                        \
    \                     ^ help: add `;` here\n38 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmpa0wsbjxu.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_level = 0;\n    let mut paren_level_count = 0;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9ld5filw.rs:50:39\n   |\n\
    50 |     let mut paren_level_string = paren\n   |                            \
    \           ^ help: add `;` here\n51 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `paren` in this scope\n  --> /tmp/tmp9ld5filw.rs:50:34\n \
    \  |\n50 |     let mut paren_level_string = paren\n   |                      \
    \            ^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp9ld5filw.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nest\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3wkb1s26.rs:41:31\n   |\n\
    41 |     let mut paren_nesting_nest\n   |                               ^ help:\
    \ add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp3wkb1s26.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut paren_stack =\
    \ Vec::new();\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len_len\
    \ = paren_levels_len;\n    let mut paren_levels_len_len_len = paren_levels_len_len;\n\
    \    let mut paren_levels_len_len_len_len = paren_levels_len_len_len;\n    let\
    \ mut paren_levels_len_len_len_len_len = paren_levels_len_len_len_len;\n    let\
    \ mut paren_levels_len_len_len_len_len_len = paren_levels_len_len_len_len_len_len;\n\
    \    let mut paren_levels_len_len_len_len_len_len_len_len = paren_levels_len_len_len_len_len_len_len_len_len;\n\
    \    let mut paren_levels_len_len_len_len_len_len_len_len_len_len = paren_levels_len_len_len_len_len_len_len_len_len_len_len;\n\
    \    let mut paren_levels_len_len_len_len_len_len_len_len_len_len_len_len = paren_levels_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len;\n\
    \    let mut paren_levels_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len\
    \ = paren_levels_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpm53q11ur.rs:20:1037\n   |\n\
    20 |     let mut paren_levels_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len\
    \ = paren_levels_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_\n\
    \   |                                                                        \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                        "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = vec![];\n    let mut paren_level = 0;\n\
    \    let mut paren_nesting = 0;\n    for paren in paren_string.chars() {\n   \
    \     if paren == '(' {\n            paren_nesting += 1;\n            levels.push(paren_nesting);\n\
    \        } else if paren == ')' {\n            paren_nesting -= 1;\n         \
    \   if paren_nesting == 0 {\n                levels.push(paren_level);\n     \
    \       }\n        }\n    }\n    levels.reverse()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp_p3sgod.rs:21:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n21 |     levels.reverse()\n   |     ^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \         found unit type `()`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = vec![];\n    let mut paren_count = 0;\n\
    \    for paren in paren_string.chars() {\n        if paren == '(' {\n        \
    \    paren_count += 1;\n        }\n        if paren == ')' {\n            paren_count\
    \ -= 1;\n        }\n        if paren_count == 0 {\n            levels.push(paren_count);\n\
    \        }\n    }\n    levels.sort_unstable();\n    levels\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp0qn5uxr4.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack: Vec<isize>\
    \ = vec![];\n    for paren in paren_string.chars().filter_map(|c| match c {\n\
    \        '(' | ')' | ' ' => false,\n        _ => true,\n    }) {\n        if paren\
    \ == ' ' {\n            paren_stack.push(level);\n            level += 1;\n  \
    \      } else {\n            level -= 1;\n            if paren_stack.len() ==\
    \ 0 {\n                panic!(\"Unexpected paren encountered while parsing nested\
    \ parens.\");\n            }\n            paren_stack.pop();\n        }\n    }\n\
    \    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdnkhflwh.rs:10:28\n   |\n\
    10 |         '(' | ')' | ' ' => false,\n   |                            ^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n10 |         '(' | ')' | ' ' => Some(false),\n   |                    \
    \        +++++     +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n\
    \    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n    let mut paren_levels_stack_size\
    \ = -1;\n    let mut paren_levels_stack_top = -1;\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp3tbxmcff.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpafmys407.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpafmys407.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_level_count: isize = 0;\n    for\
    \ paren in paren_string.chars() {\n        if paren == '(' {\n            paren_stack.push(paren_level);\n\
    \            paren_level_count = paren_level_count;\n        } else if paren ==\
    \ ')' {\n            paren_level_count = paren_stack.pop();\n            if paren_level_count\
    \ == 0 {\n                paren_level_count = paren_level_count;\n           \
    \ }\n        }\n        paren_level = paren_level + 1;\n    }\n    paren_level_count\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxpymt0ov.rs:15:33\n   |\n\
    9  |     let mut paren_level_count: isize = 0;\n   |                         \
    \       ----- expected due to this type\n...\n15 |             paren_level_count\
    \ = paren_stack.pop();\n   |                                 ^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxpymt0ov.rs:22:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n22 |     paren_level_count\n\
    \   |     ^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_len = paren_string.len();\n    let mut paren_levels_ptr\
    \ = paren_levels_len as *const isize;\n    let mut paren_levels_ptr_end = paren_levels_ptr\
    \ + paren_levels_len;\n    let mut paren_levels_ptr_end_ptr = paren_levels_ptr_end\
    \ as *const isize;\n    let mut paren_levels_ptr_end_ptr_end = paren_levels_ptr_end_ptr\
    \ + paren_levels_len;\n    let mut paren_levels_ptr_end_ptr_end_ptr = paren_levels_ptr_end_ptr_end\
    \ as *const isize;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end = paren_levels_ptr_end_ptr_end_ptr\
    \ + paren_levels_len;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr =\
    \ paren_levels_ptr_end_ptr_end_ptr_end as *const isize;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_ptr_end_ptr_end_ptr_end_ptr + paren_levels_len;\n    let mut\
    \ paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr = paren_levels_ptr_end_ptr_end_ptr_end_ptr_end\
    \ as *const isize;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr + paren_levels_len;\n   \
    \ let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr = paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ as *const isize;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr + paren_levels_len;\n\
    \    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end as *const \n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpt3_xjli3.rs:23:1\n   |\n\
    23 | }\n   | ^ expected type\n\nerror[E0369]: cannot add `usize` to `*const isize`\n\
    \  --> /tmp/tmpt3_xjli3.rs:11:53\n   |\n11 |     let mut paren_levels_ptr_end\
    \ = paren_levels_ptr + paren_levels_len;\n   |                               \
    \     ---------------- ^ ---------------- usize\n   |                        \
    \            |\n   |                                    *const isize\n\nerror[E0369]:\
    \ cannot add `usize` to `*const isize`\n  --> /tmp/tmpt3_xjli3.rs:13:69\n   |\n\
    13 |     let mut paren_levels_ptr_end_ptr_end = paren_levels_ptr_end_ptr + paren_levels_len;\n\
    \   |                                            ------------------------ ^ ----------------\
    \ usize\n   |                                            |\n   |             \
    \                               *const isize\n\nerror[E0369]: cannot add `usize`\
    \ to `*const isize`\n  --> /tmp/tmpt3_xjli3.rs:15:85\n   |\n15 |     let mut paren_levels_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_ptr_end_ptr_end_ptr + paren_levels_len;\n   |               \
    \                                     -------------------------------- ^ ----------------\
    \ usize\n   |                                                    |\n   |     \
    \                                               *const isize\n\nerror[E0369]:\
    \ cannot add `usize` to `*const isize`\n  --> /tmp/tmpt3_xjli3.rs:17:101\n   |\n\
    17 |     let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end = paren_levels_ptr_end_ptr_end_ptr_end_ptr\
    \ + paren_levels_len;\n   |                                                  \
    \          ---------------------------------------- ^ ---------------- usize\n\
    \   |                                                            |\n   |     \
    \                                                       *const isize\n\nerror[E0369]:\
    \ cannot add `usize` to `*const isize`\n  --> /tmp/tmpt3_xjli3.rs:19:117\n   |\n\
    19 |     let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end = paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ + paren_levels_len;\n   |                                                  \
    \      "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr = paren_levels_stack_len;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzge2kca9.rs:37:49\n   |\n\
    37 |     let mut paren_levels_stack_top = paren_level\n   |                  \
    \                               ^ help: add `;` here\n38 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpzge2kca9.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_levels: Vec<isize> = vec![];\n  \
    \  let mut paren_levels_len: usize = 0;\n    let mut paren_levels_lens: Vec<usize>\
    \ = vec![];\n    let mut paren_levels_lens_len: usize = 0;\n    let mut paren_levels_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_len: usize = 0;\n \
    \   let mut paren_levels_lens_lens_lens: Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens: Vec<usize> = vec![];\n\
    \    let mut paren_levels_lens_lens_lens_lens_len: usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens: Vec<usize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_len: usize\
    \ = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens: Vec<usize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_len\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmdyuqyoh.rs:28:64\n   |\n\
    28 |     let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_len\n   |   \
    \                                                             ^ help: add `;`\
    \ here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpmdyuqyoh.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nest\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoljdoe8u.rs:41:31\n   |\n\
    41 |     let mut paren_nesting_nest\n   |                               ^ help:\
    \ add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpoljdoe8u.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels = vec![];\n\
    \    let mut paren_levels_len = 0;\n    let mut paren_levels_len2 = 0;\n    let\
    \ mut paren_levels_len3 = 0;\n    let mut paren_levels_len4 = 0;\n    let mut\
    \ paren_levels_len5 = 0;\n    let mut paren_levels_len6 = 0;\n    let mut paren_levels_len7\
    \ = 0;\n    let mut paren_levels_len8 = 0;\n    let mut paren_levels_len9 = 0;\n\
    \    let mut paren_levels_len10 = 0;\n    let mut paren_levels_len11 = 0;\n  \
    \  let mut paren_levels_len12 = 0;\n    let mut paren_levels_len13 = 0;\n    let\
    \ mut paren_levels_len14 = 0;\n    let mut paren_levels_len15 = 0;\n    let mut\
    \ paren_levels_len16 = 0;\n    let mut paren_levels_len17 = 0;\n    let mut paren_levels_len18\
    \ = 0;\n    let mut paren_levels_len19 = 0;\n    let mut paren_levels_len20 =\
    \ 0;\n    let mut paren_levels_len21 = 0;\n    let mut paren_levels_len22 = 0;\n\
    \    let mut paren_levels_len23 = 0;\n    let mut paren_levels_len24 = 0;\n  \
    \  let mut paren_levels_len25 = 0;\n    let mut paren_levels_len26 = 0;\n    let\
    \ mut paren_levels_len27 = 0;\n    let mut paren_levels_len28 = 0;\n    let mut\
    \ paren_levels_len29 = 0;\n    let mut paren_levels_len30 = 0;\n    let mut paren_levels_len31\
    \ = 0;\n    let mut paren_levels_len32 = 0;\n    let mut paren_levels_len33 =\
    \ 0;\n    let mut paren_levels_len34 = 0;\n    let mut paren_levels_len35 = 0;\n\
    \    let mut paren_levels_len36 = 0;\n    let mut paren_levels_len37 = 0;\n  \
    \  let mut paren_levels_len38 = 0;\n    let mut paren_levels_len39 = 0;\n    let\
    \ mut paren_levels_len40 = 0;\n    let mut paren_levels_len41 = 0;\n    let mut\
    \ paren_levels_len42 = 0;\n    let mut paren_levels_len43 = 0;\n    let mut paren_levels_len44\
    \ = 0;\n    let mut paren_levels_len45 = 0;\n    let mut paren_\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjonv7jbc.rs:54:19\n   |\n\
    54 |     let mut paren_\n   |                   ^ help: add `;` here\n55 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpjonv7jbc.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_max_count\
    \ = 0;\n    let mut paren_level_max_count_index = 0;\n    let mut paren_level_max_count_index2\
    \ = 0;\n    let mut paren_level_max_count_index3 = 0;\n    let mut paren_level_max_count_index4\
    \ = 0;\n    let mut paren_level_max_count_index5 = 0;\n    let mut paren_level_max_count_index6\
    \ = 0;\n    let mut paren_level_max_count_index7 = 0;\n    let mut paren_level_max_count_index8\
    \ = 0;\n    let mut paren_level_max_count_index9 = 0;\n    let mut paren_level_max_count_index10\
    \ = 0;\n    let mut paren_level_max_count_index11 = 0;\n    let mut paren_level_max_count_index12\
    \ = 0;\n    let mut paren_level_max_count_index13 = 0;\n    let mut paren_level_max_count_index14\
    \ = 0;\n    let mut paren_level_max_count_index15 = 0;\n    let mut paren_level_max_count_index16\
    \ = 0;\n    let mut paren_level_max_count_index17 = 0;\n    let mut paren_level_max_count_index18\
    \ = 0;\n    let mut paren_level_max_count_index19 = 0;\n    let mut paren_level_max_count_index20\
    \ = 0;\n    let mut paren_level_max_count_index21 = 0;\n    let mut paren_level_max_count_index22\
    \ = 0;\n    let mut paren_level_max_count_index23 = 0;\n    let mut paren_level_max_count_index24\
    \ = 0;\n    let mut paren_level_max_count_index25 = 0;\n    let mut paren_level_max_count_index26\
    \ = 0;\n    let mut paren_level_max_count_index27 = 0;\n    let mut paren_level_max_count_index28\
    \ = 0;\n    let mut paren_level_max_count_index29 = 0;\n    let mut paren_level_max_count_index30\
    \ = 0;\n    let mut paren_level_max_count_index31 = 0;\n    let mut paren_level_max_count_index32\
    \ = 0;\n    let mut paren_level_max_count_index33 = 0;\n    let mut paren_level_max_count_index34\
    \ = 0;\n    let mut paren_level_max_count_index35 = 0;\n    let mut paren_level_max_count_index36\
    \ = 0;\n    let mut paren_level_max_count_index37 = 0;\n    let mut paren_level_max_count_index38\
    \ = 0;\n    let mut paren_level_max_count_index39 = 0;\n    let mut paren_level_max_count_index40\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8n_0zl5m.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_end = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_end = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_end = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_end = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_end = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_end = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_end = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_end = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_end = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp75o5116q.rs:37:43\n   |\n\
    37 |     let mut paren_levels_stack_top = paren\n   |                        \
    \                   ^ help: add `;` here\n38 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `paren` in this scope\n  --> /tmp/tmp75o5116q.rs:37:38\n\
    \   |\n37 |     let mut paren_levels_stack_top = paren\n   |                 \
    \                     ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp75o5116q.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut level = 0;\n\
    \    let mut paren_level = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpect0b1_p.rs:42:18\n   |\n\
    42 |     let mut paren\n   |                  ^ help: add `;` here\n43 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpect0b1_p.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack = Vec::new();\n\
    \    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_end = paren_string.len();\n    let mut paren_stack_start\
    \ = paren_stack_pos;\n    let mut paren_stack_char = paren_string[paren_stack_pos];\n\
    \    while paren_stack_pos < paren_stack_end {\n        if paren_stack_char ==\
    \ ')' {\n            paren_stack.pop();\n            paren_stack_end = paren_stack_pos;\n\
    \            paren_stack_start = paren_stack_pos;\n            paren_stack_char\
    \ = paren_string[paren_stack_pos];\n            level -= 1;\n        } else if\
    \ paren_stack_char == '(' {\n            paren_stack.push(level);\n          \
    \  paren_stack_pos = paren_stack_end;\n            paren_stack_char = paren_string[paren_stack_pos];\n\
    \            level += 1;\n        } else {\n            paren_stack_pos += 1;\n\
    \            paren_stack_char = paren_string[paren_stack_pos];\n        }\n  \
    \  }\n    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpjcokm4_v.rs:13:32\n   |\n13 |     let mut paren_stack_char = paren_string[paren_stack_pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjcokm4_v.rs:19:32\n   |\n19 |             paren_stack_char = paren_string[paren_stack_pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjcokm4_v.rs:24:32\n   |\n24 |             paren_stack_char = paren_string[paren_stack_pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usi"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    for paren in paren_string.chars() {\n        if\
    \ paren == '(' {\n            paren_stack.push(paren_level);\n            paren_level\
    \ += 1;\n        } else if paren == ')' {\n            paren_level -= 1;\n   \
    \         if paren_level == 0 {\n                paren_stack.push(paren_level);\n\
    \            }\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmp_va8a46f.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_size\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpu6tunj9t.rs:30:71\n   |\n\
    30 |     let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    \   |                                                                       ^\
    \ help: add `;` here\n31 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpu6tunj9t.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppuy3i3h6.rs:50:18\n   |\n\
    50 |     let mut paren\n   |                  ^ help: add `;` here\n51 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmppuy3i3h6.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = vec![];\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len\
    \ = paren_string.chars().count();\n    let mut paren_level_char_pos = 0;\n   \
    \ let mut paren_level_char_len = paren_string.chars().count();\n    let mut paren_level_char_pos\
    \ = 0;\n    let mut paren_level_char_len = paren_string.chars().count();\n   \
    \ let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_string.chars().count();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_string.chars().count();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_string.chars().count();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_string.chars().count();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_string.chars().count();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_string.chars().count();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_string.chars().count();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_string.chars().count();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_string.chars().count();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_string.chars().count();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_string.chars().count();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_string.chars().count();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_string.chars().count();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_string.chars().count();\n\
    \    let mut paren_level_char_pos = 0;\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp5m4gf3jd.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut paren_levels_stack_max_pos\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_max_pos_index = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_max_pos_index2 = 0;\n    let mut paren_levels_stack_max_pos_index3\
    \ = 0;\n    let mut paren_levels_stack_max_pos_index4 = 0;\n    let mut paren_levels_stack_max_pos_index5\
    \ = 0;\n    let mut paren_levels_stack_max_pos_index6 = 0;\n    let mut paren_levels_stack_max_pos_index7\
    \ = 0;\n    let mut paren_levels_stack_max_pos_index8 = 0;\n    let mut paren_levels_stack_max_pos_index9\
    \ = 0;\n    let mut paren_levels_stack_max_pos_index10 = 0;\n    let mut paren_levels_stack_max_pos_index11\
    \ = 0;\n    let mut paren_levels_stack_max_pos_index12 = 0;\n    let mut paren_levels_stack_max_pos_index13\
    \ = 0;\n    let mut paren_levels_stack_max_pos_index14 = 0;\n    let mut paren_levels_stack_max_pos_index15\
    \ = 0;\n    let mut paren_levels_stack_max_pos_index16 = 0;\n    let mut paren_levels_stack_max_pos_index17\
    \ = 0;\n    let mut paren_levels_stack_max_pos_index18 = 0;\n    let mut paren_levels_stack_max_pos_index19\
    \ = 0;\n    let mut paren_levels_stack_max_pos_index20 = 0;\n    let mut paren_levels_stack_max_pos_index21\
    \ = 0;\n    let mut paren_levels_stack_max_pos_index22 = 0;\n    let mut paren_levels_stack_max_pos_index23\
    \ = 0;\n    let mut paren_levels_stack_max_pos_index24 = 0;\n    let mut paren_levels_stack_max_pos_index25\
    \ = 0;\n    let mut paren_levels_stack_max_pos_index26 = 0;\n    let mut paren_levels_stack_max_pos_index27\
    \ = 0;\n    let mut paren_levels_stack_max_pos_index28 = 0;\n    let mut paren_levels_stack_max_pos_index29\
    \ = 0;\n    let mut paren_levels_stack_max_pos_index\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfyra1yn7.rs:43:45\n   |\n\
    43 |     let mut paren_levels_stack_max_pos_index\n   |                      \
    \                       ^ help: add `;` here\n44 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpfyra1yn7.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_levels: Vec<isize> = vec![];\n  \
    \  let mut paren_levels_len: usize = 0;\n    let mut paren_levels_lens: Vec<usize>\
    \ = vec![];\n    let mut paren_levels_lens_len: usize = 0;\n    let mut paren_levels_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_len: usize = 0;\n \
    \   let mut paren_levels_lens_lens_lens: Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens: Vec<usize> = vec![];\n\
    \    let mut paren_levels_lens_lens_lens_lens_len: usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens: Vec<usize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_len: usize\
    \ = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens: Vec<usize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd4atpwuc.rs:28:46\n   |\n\
    28 |     let mut paren_levels_lens_lens_lens_lens_\n   |                     \
    \                         ^ help: add `;` here\n29 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpd4atpwuc.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_curr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_curr\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_curr = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_curr\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_curr = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_curr\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_curr = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_curr\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_curr = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_curr\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_curr = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_curr\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_curr = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7q1j0y7r.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7q1j0y7r.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0usize;\n    let mut paren_level = 0usize;\n\
    \    let mut paren_nesting = 0usize;\n    let mut paren_nesting_level = 0usize;\n\
    \    let mut paren_nesting_nesting = 0usize;\n    let mut paren_nesting_nesting_level\
    \ = 0usize;\n    let mut paren_nesting_nesting_nesting = 0usize;\n    let mut\
    \ paren_nesting_nesting_nesting_level = 0usize;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0usize;\n    let mut paren_nesting_nesting_nesting_level = 0usize;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting = 0usize;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0usize;\n    let mut paren_nesting_nesting_nesting_nesting = 0usize;\n   \
    \ let mut paren_nesting_nesting_nesting_level = 0usize;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0usize;\n    let mut paren_nesting_nesting_nesting_level = 0usize;\n    let\
    \ mut paren_nesting_nesting_nesting = 0usize;\n    let mut paren_nesting_nesting_level\
    \ = 0usize;\n    let mut paren_nesting_nesting = 0usize;\n    let mut paren_nesting_level\
    \ = 0usize;\n    let mut paren_level = 0usize;\n    let mut paren_nesting = 0usize;\n\
    \    let mut paren_nesting_level = 0usize;\n    let mut paren_nesting_nesting\
    \ = 0usize;\n    let mut paren_nesting_nesting_level = 0usize;\n    let mut paren_nesting_nesting_nesting\
    \ = 0usize;\n    let mut paren_nesting_nesting_nesting_level = 0usize;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting = 0usize;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0usize;\n    let mut paren_nesting_nesting_nesting_nesting = 0usize;\n   \
    \ let mut paren_nesting_nesting_nesting_level = 0usize;\n    let mut paren_nesting_nesting_nesting\
    \ = 0usize;\n    let mut paren_nesting_nesting_level = 0usize;\n    let mut paren_nesting_nesting\
    \ = 0usize;\n    let mut paren_nesting_level = 0usize;\n    let mut paren_level\
    \ = 0usize;\n    let mut paren_nest\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr6f_y671.rs:43:23\n   |\n\
    43 |     let mut paren_nest\n   |                       ^ help: add `;` here\n\
    44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpr6f_y671.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_stack = Vec::new();\n\
    \    let mut paren_level_stack_pointer = 0;\n    let mut paren_level_stack_pointer_pointer\
    \ = 0;\n    let mut paren_level_stack_pointer_pointer_pointer = 0;\n    let mut\
    \ paren_level_stack_pointer_pointer_pointer_pointer = 0;\n    let mut paren_level_stack_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    let mut paren_level_stack_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    let mut paren_level_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    let mut paren_level_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    let mut paren_level_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    let mut paren_level_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    let mut paren_level_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    let mut paren_level_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    let mut paren_level_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    let mut paren_level_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    let mut paren_level_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    let mut paren_level_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    let mut paren_level_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    let mut paren_level_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprllracqi.rs:28:118\n   |\n\
    28 |     let mut paren_level_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\n\
    \   |                                                                        \
    \                                              ^ help: add `;` here\n29 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmprllracqi.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_levels_size\
    \ = Vec::new();\n    let mut paren_levels_size_ptr = Vec::new();\n    let mut\
    \ paren_levels_size_max = Vec::new();\n    let mut paren_levels_size_max_ptr =\
    \ Vec::new();\n    let mut paren_levels_size_min = Vec::new();\n    let mut paren_levels_size_min_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_sum = Vec::new();\n    let mut\
    \ paren_levels_size_sum_ptr = Vec::new();\n    let mut paren_levels_size_avg =\
    \ Vec::new();\n    let mut paren_levels_size_avg_ptr = Vec::new();\n    let mut\
    \ paren_levels_size_max = Vec::new();\n    let mut paren_levels_size_max_ptr =\
    \ Vec::new();\n    let mut paren_levels_size_min = Vec::new();\n    let mut paren_levels_size_min_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_sum = Vec::new();\n    let mut\
    \ paren_levels_size_sum_ptr = Vec::new();\n    let mut paren_levels_size_avg =\
    \ Vec::new();\n    let mut paren_levels_size_avg_ptr = Vec::new();\n    let mut\
    \ paren_levels_size_max = Vec::new();\n    let mut paren_levels_size_max_ptr =\
    \ Vec::new();\n    let mut paren_levels_size_min = Vec::new();\n    let mut paren_levels_size_min_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_sum = Vec::new();\n    let mut\
    \ paren_levels_size_sum_ptr = Vec::new();\n    let mut paren_levels_size_avg =\
    \ Vec::new();\n    let mut paren_levels_size_avg_ptr = Vec::new();\n    let mut\
    \ paren_levels_size_max = Vec::new();\n    let mut paren_levels_size_max_ptr =\
    \ Vec::new();\n    let mut paren_levels_size_min = Vec::new();\n    let mut paren_levels_size_min_ptr\
    \ = Vec::new();\n    let mut paren_levels_size_sum = Vec::new();\n    let mut\
    \ paren_levels_size_sum_ptr = Vec::new();\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpx1fnestj.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    for paren in paren_string.chars() {\n        if\
    \ paren == '(' {\n            paren_stack.push(paren_level);\n            paren_level\
    \ += 1;\n        } else if paren == ')' {\n            paren_level -= 1;\n   \
    \         if paren_level == 0 {\n                paren_stack.push(paren_level);\n\
    \            }\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmpnw3splmh.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let \n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpowwhv9kv.rs:38:1\n  \
    \ |\n38 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = 0;\n    let mut paren_levels_ptr = paren_levels_stack.as_mut_ptr();\n    let\
    \ mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_levels_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp41nhnyfv.rs:29:26\n   |\n\
    29 |     let mut paren_levels_\n   |                          ^ help: add `;`\
    \ here\n30 | }\n   | - unexpected token\n\nwarning: type annotations needed\n\
    \  --> /tmp/tmp41nhnyfv.rs:12:53\n   |\n12 |     let mut paren_levels_ptr_end\
    \ = paren_levels_ptr.offset(paren_levels_stack.len());\n   |                 \
    \                                    ^^^^^^\n   |\n   = note: `#[warn(tyvar_behind_raw_pointer)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2018!\n   = note: for more information, see issue\
    \ #46906 <https://github.com/rust-lang/rust/issues/46906>\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp41nhnyfv.rs:12:60\n   |\n12 |     let mut paren_levels_ptr_end\
    \ = paren_levels_ptr.offset(paren_levels_stack.len());\n   |                 \
    \                                           ^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n12 |     let mut paren_levels_ptr_end\
    \ = paren_levels_ptr.offset(paren_levels_stack.len().try_into().unwrap());\n \
    \  |                                                                         \
    \           ++++++++++++++++++++\n\nwarning: type annotations needed\n  --> /tmp/tmp41nhnyfv.rs:13:53\n\
    \   |\n13 |     let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \   |                                                     ^^^^^^\n   |\n   = warning:\
    \ this is accepted in the current edition (Rust 2015) but is a hard error in Rust\
    \ 2018!\n   = note: for more information, see issue #46906 <https://github.com/rust-lang/rust/issues/46906>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp41nhnyfv.rs:13:60\n   |\n13 |\
    \     let mut paren_levels_ptr_end = paren_levels_ptr.offset(paren_levels_stack.len());\n\
    \   |                                                            ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = 0;\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n \
    \   let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr_end;\n    let mut paren_levels_stack_ptr_end_ptr\
    \ = paren_levels_stack_ptr_end;\n    let mut paren_levels_stack_ptr_end_ptr =\
    \ paren_levels_stack_ptr_end;\n    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr_end;\n\
    \    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr_end;\n  \
    \  let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr_end;\n    let\
    \ mut paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr_end;\n    let mut\
    \ paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr_end;\n    let mut paren_levels_stack_ptr_end_ptr\
    \ = paren_levels_stack_ptr_end;\n    let mut paren_levels_stack_ptr_end_ptr =\
    \ paren_levels_stack_ptr_end;\n    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr_end;\n\
    \    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr_end;\n  \
    \  let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr_end;\n    let\
    \ mut paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr_end;\n    let mut\
    \ paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr_end;\n    let mut paren_levels_stack_ptr_end_ptr\
    \ = paren_levels_stack_ptr_end;\n    let mut paren_levels_stack_ptr_end_ptr =\
    \ paren_levels_stack_ptr_end;\n    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr_end;\n\
    \    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr_end;\n  \
    \  let mut paren_levels_stack_ptr_end_\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7jvoj7od.rs:32:40\n   |\n\
    32 |     let mut paren_levels_stack_ptr_end_\n   |                           \
    \             ^ help: add `;` here\n33 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp7jvoj7od.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut paren_count =\
    \ 0;\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n \
    \   let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len = paren_levels;\n\
    \    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len =\
    \ paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_len = paren_levels;\n    let mut paren_levels_len\
    \ = paren_levels;\n    let mut paren_levels_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpp7zrfrun.rs:47:26\n   |\n\
    47 |     let mut paren_levels_\n   |                          ^ help: add `;`\
    \ here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpp7zrfrun.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack = Vec::new();\n\
    \    let mut paren_stack_size = paren_stack.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_end = paren_stack_size;\n    let mut paren_stack_top\
    \ = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n    let\
    \ mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n\
    \    let mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top\
    \ = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n    let\
    \ mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n\
    \    let mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top\
    \ = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n    let\
    \ mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n\
    \    let mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top\
    \ = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n    let\
    \ mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n\
    \    let mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top\
    \ = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n    let\
    \ mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n\
    \    let mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top\
    \ = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n    let\
    \ mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n\
    \    let mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top\
    \ = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n    let\
    \ mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n\
    \    let mut paren_stack_top = paren_stack_size;\n    let mut paren\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4704o093.rs:47:18\n   |\n\
    47 |     let mut paren\n   |                  ^ help: add `;` here\n48 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4704o093.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut paren_depth\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n\
    \    let mut paren_levels_len = 0;\n    let mut paren_levels_len2 = 0;\n    let\
    \ mut paren_levels_len3 = 0;\n    let mut paren_levels_len4 = 0;\n    let mut\
    \ paren_levels_len5 = 0;\n    let mut paren_levels_len6 = 0;\n    let mut paren_levels_len7\
    \ = 0;\n    let mut paren_levels_len8 = 0;\n    let mut paren_levels_len9 = 0;\n\
    \    let mut paren_levels_len10 = 0;\n    let mut paren_levels_len11 = 0;\n  \
    \  let mut paren_levels_len12 = 0;\n    let mut paren_levels_len13 = 0;\n    let\
    \ mut paren_levels_len14 = 0;\n    let mut paren_levels_len15 = 0;\n    let mut\
    \ paren_levels_len16 = 0;\n    let mut paren_levels_len17 = 0;\n    let mut paren_levels_len18\
    \ = 0;\n    let mut paren_levels_len19 = 0;\n    let mut paren_levels_len20 =\
    \ 0;\n    let mut paren_levels_len21 = 0;\n    let mut paren_levels_len22 = 0;\n\
    \    let mut paren_levels_len23 = 0;\n    let mut paren_levels_len24 = 0;\n  \
    \  let mut paren_levels_len25 = 0;\n    let mut paren_levels_len26 = 0;\n    let\
    \ mut paren_levels_len27 = 0;\n    let mut paren_levels_len28 = 0;\n    let mut\
    \ paren_levels_len29 = 0;\n    let mut paren_levels_len30 = 0;\n    let mut paren_levels_len31\
    \ = 0;\n    let mut paren_levels_len32 = 0;\n    let mut paren_levels_len33 =\
    \ 0;\n    let mut paren_levels_len34 = 0;\n    let mut paren_levels_len35 = 0;\n\
    \    let mut paren_levels_len36 = 0;\n    let mut paren_levels_len37 = 0;\n  \
    \  let mut paren_levels_len38 = 0;\n    let mut paren_levels_len39 = 0;\n    let\
    \ mut paren_levels_len40 = 0;\n    let mut paren_levels_len41 = 1;\n    let mut\
    \ paren_levels_len42 = 1;\n    let mut paren_levels_len43 = 1;\n    let mut paren\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4kew4uq9.rs:54:18\n   |\n\
    54 |     let mut paren\n   |                  ^ help: add `;` here\n55 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4kew4uq9.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut paren_depth\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n\
    \    let mut paren_levels_len = 0;\n    let mut paren_levels_len2 = 0;\n    let\
    \ mut paren_levels_len3 = 0;\n    let mut paren_levels_len4 = 0;\n    let mut\
    \ paren_levels_len5 = 0;\n    let mut paren_levels_len6 = 0;\n    let mut paren_levels_len7\
    \ = 0;\n    let mut paren_levels_len8 = 0;\n    let mut paren_levels_len9 = 0;\n\
    \    let mut paren_levels_len10 = 0;\n    let mut paren_levels_len11 = 0;\n  \
    \  let mut paren_levels_len12 = 0;\n    let mut paren_levels_len13 = 0;\n    let\
    \ mut paren_levels_len14 = 0;\n    let mut paren_levels_len15 = 0;\n    let mut\
    \ paren_levels_len16 = 0;\n    let mut paren_levels_len17 = 0;\n    let mut paren_levels_len18\
    \ = 0;\n    let mut paren_levels_len19 = 0;\n    let mut paren_levels_len20 =\
    \ 0;\n    let mut paren_levels_len21 = 0;\n    let mut paren_levels_len22 = 0;\n\
    \    let mut paren_levels_len23 = 0;\n    let mut paren_levels_len24 = 0;\n  \
    \  let mut paren_levels_len25 = 0;\n    let mut paren_levels_len26 = 0;\n    let\
    \ mut paren_levels_len27 = 0;\n    let mut paren_levels_len28 = 0;\n    let mut\
    \ paren_levels_len29 = 0;\n    let mut paren_levels_len30 = 0;\n    let mut paren_levels_len31\
    \ = 0;\n    let mut paren_levels_len32 = 0;\n    let mut paren_levels_len33 =\
    \ 0;\n    let mut paren_levels_len34 = 0;\n    let mut paren_levels_len35 = 0;\n\
    \    let mut paren_levels_len36 = 0;\n    let mut paren_levels_len37 = 0;\n  \
    \  let mut paren_levels_len38 = 0;\n    let mut paren_levels_len39 = 0;\n    let\
    \ mut paren_levels_len40 = 0;\n    let mut paren_levels_len41 = 1;\n    let mut\
    \ paren_levels_len42 = 1;\n    let mut paren_levels_len43 = 1;\n    let mut paren\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpp1tnpoyy.rs:54:18\n   |\n\
    54 |     let mut paren\n   |                  ^ help: add `;` here\n55 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpp1tnpoyy.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char\
    \ = 0;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len\
    \ = paren_level_char.len();\n    let mut paren_level_char_pos = 0;\n    let mut\
    \ paren_level_char_len = paren_level_char.len();\n    let mut paren_level_char_pos\
    \ = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n    let mut\
    \ paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `len` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp8tbnyd57.rs:14:53\n   |\n14 |     let mut paren_level_char_len\
    \ = paren_level_char.len();\n   |                                            \
    \         ^^^\n   |\nhelp: you must specify a type for this binding, like `i32`\n\
    \   |\n12 |     let mut paren_level_char: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0689]: can't call method `len` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp8tbnyd57.rs:16:53\n   |\n16 |     let mut paren_level_char_len\
    \ = paren_level_char.len();\n   |                                            \
    \         ^^^\n   |\nhelp: you must specify a type for this binding, like `i32`\n\
    \   |\n12 |     let mut paren_level_char: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0689]: can't call method `len` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp8tbnyd57.rs:18:53\n   |\n18 |     let mut paren_level_char_len\
    \ = paren_level_char.len();\n   |                                            \
    \         ^^^\n   |\nhelp: you must specify a type for this binding, like `i32`\n\
    \   |\n12 |     let mut paren_level_char: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0689]: can't call method `len` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp8tbnyd57.rs:20:53\n   |\n20 |     let mut paren_level_char_len\
    \ = paren_level_char.len();\n   |                                            \
    \         ^^^\n   |\nhelp: you must specify a type for this binding, like `i32`\n\
    \   |\n12 |     let mut paren_level_char: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0689]: can't call method `len` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp8tbnyd57.rs:22:53\n   |\n22 |     let mut paren_level_char_len\
    \ = paren_level_char.len();\n   |                                            \
    \         ^^^\n   |\nhelp: you must specify a type for this binding, like `i32`\n\
    \   |\n12 |     let mut paren_level_char: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0689]: can't call method `len` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp8tb"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string_index = 0;\n    let mut paren_level_string_len\
    \ = 0;\n    let mut paren_level_string_len_index = 0;\n    let mut paren_level_string_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpm4uqff3v.rs:50:43\n   |\n\
    50 |     let mut paren_level_string_len_len_len\n   |                        \
    \                   ^ help: add `;` here\n51 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmpm4uqff3v.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    for paren in paren_string.chars() {\n        if\
    \ paren == '(' {\n            paren_stack.push(paren_level);\n            paren_level\
    \ += 1;\n        } else if paren == ')' {\n            paren_level -= 1;\n   \
    \         if paren_level == 0 {\n                paren_stack.push(paren_level);\n\
    \            }\n        } else {\n            paren_level += 1;\n        }\n \
    \   }\n    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 1, 2, 3, 2, 3, 4, 5, 4, 4]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp6ho7b738.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_levels: Vec<isize> = vec![];\n  \
    \  let mut paren_levels_len: usize = 0;\n    let mut paren_levels_lens: Vec<usize>\
    \ = vec![];\n    let mut paren_levels_lens_len: usize = 0;\n    let mut paren_levels_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_len: usize = 0;\n \
    \   let mut paren_levels_lens_lens_lens: Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens: Vec<usize> = vec![];\n\
    \    let mut paren_levels_lens_lens_lens_lens_len: usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens: Vec<usize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_len: usize\
    \ = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens: Vec<usize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1plpoohc.rs:28:56\n   |\n\
    28 |     let mut paren_levels_lens_lens_lens_lens_lens_lens_\n   |           \
    \                                             ^ help: add `;` here\n29 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp1plpoohc.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr = paren_levels_stack;\n    let mut paren_levels_stack_ptr_pos\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_size = paren_levels_stack_ptr.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack_ptr + paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_ptr_end_pos = paren_levels_stack_ptr_end;\n  \
    \  let mut paren_levels_stack_ptr_end_size = paren_levels_stack_ptr_end - paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr_end;\n  \
    \  let mut paren_levels_stack_ptr_end_ptr_pos = paren_levels_stack_ptr_end_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_size = paren_levels_stack_ptr_end_ptr\
    \ - paren_levels_stack_ptr_end;\n    let mut paren_levels_stack_ptr_end_ptr_end\
    \ = paren_levels_stack_ptr_end_ptr + paren_levels_stack_ptr_end_size;\n    let\
    \ mut paren_levels_stack_ptr_end_ptr_end_pos = paren_levels_stack_ptr_end_ptr_end;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_size = paren_levels_stack_ptr_end_ptr_end\
    \ - paren_levels_stack_ptr_end_ptr;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr\
    \ = paren_levels_stack_ptr_end_ptr_end;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_pos\
    \ = paren_levels_stack_ptr_end_ptr_end_ptr;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_size\
    \ = paren_levels_stack_ptr_end_ptr_end_ptr - paren_levels_stack_ptr_end_ptr_end;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end = paren_levels_stack_ptr_end_ptr_end_ptr\
    \ + paren_levels_stack_ptr_end_ptr_end_size;\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `usize` to `Vec<_>`\n  --> /tmp/tmpxfwu2t5g.rs:15:65\n\
    \   |\n15 |     let mut paren_levels_stack_ptr_end = paren_levels_stack_ptr +\
    \ paren_levels_stack_size;\n   |                                          ----------------------\
    \ ^ ----------------------- usize\n   |                                      \
    \    |\n   |                                          Vec<_>\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpxfwu2t5g.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_level_count: usize = 0;\n    let\
    \ mut paren_level_max_count: usize = 0;\n    let mut paren_level_max_level: isize\
    \ = 0;\n    let mut paren_level_max_level_count: usize = 0;\n    let mut paren_level_max_level_max_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level: isize = 0;\n    let\
    \ mut paren_level_max_level_max_level_count: usize = 0;\n    let mut paren_level_max_level_max_level_max_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level: isize = 0;\n\
    \    let mut paren_level_max_level_max_level_max_level_count: usize = 0;\n   \
    \ let mut paren_level_max_level_max_level_max_level_max_count: usize = 0;\n  \
    \  let mut paren_level_max_level_max_level_max_level_max_level: isize = 0;\n \
    \   let mut paren_level_max_level_max_level_max_level_max_level_count: usize =\
    \ 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpn8undwe1.rs:33:75\n   |\n\
    33 |     let mut paren_level_max_level_max_level_max_level_max_level_max_level_\n\
    \   |                                                                        \
    \   ^ help: add `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpn8undwe1.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmper53mfx_.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmper53mfx_.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_level_count: usize = 0;\n    let\
    \ mut paren_level_max: usize = 0;\n    let mut paren_level_max_count: usize =\
    \ 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren_level_max_index:\
    \ usize = 0;\n    let mut paren_level_max_index: usize = 0;\n    let mut paren\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuvr9ji8t.rs:49:18\n   |\n\
    49 |     let mut paren\n   |                  ^ help: add `;` here\n50 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpuvr9ji8t.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_end = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n    let mut paren_levels_stack_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_end = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n    let mut paren_levels_stack_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_end = paren_levels_stack.len();\n    let mut paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpir355bh0.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpir355bh0.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_string = paren_string.clone();\n\
    \    let mut paren_level_string = paren_level_string.chars().filter(|c| c != '('\
    \ && c != ')').collect::<String>();\n    let mut paren_level_string = paren_level_string.chars().filter(|c|\
    \ c != '[' && c != ']').collect::<String>();\n    let mut paren_level_string =\
    \ paren_level_string.chars().filter(|c| c != '{' && c != '}').collect::<String>();\n\
    \    let mut paren_level_string = paren_level_string.chars().filter(|c| c != '\
    \ ').collect::<String>();\n    let mut paren_level_string = paren_level_string.chars().filter(|c|\
    \ c != '\\t').collect::<String>();\n    let mut paren_level_string = paren_level_string.chars().filter(|c|\
    \ c != '\\n').collect::<String>();\n    let mut paren_level_string = paren_level_string.chars().filter(|c|\
    \ c != '\\r').collect::<String>();\n    let mut paren_level_string = paren_level_string.chars().filter(|c|\
    \ c != '\\f').collect::<String>();\n    let mut paren_level_string = paren_level_string.chars().filter(|c|\
    \ c != '\\v').collect::<String>();\n    let mut paren_level_string = paren_level_string.chars().filter(|c|\
    \ c != '\\a').collect::<String>();\n    let mut paren_level_string = paren_level_string.chars().filter(|c|\
    \ c != '\\e').collect::<String>();\n    let mut paren_level_string = paren_level_string.chars().filter(|c|\
    \ c != '\\o').collect::<String>();\n    let mut paren_level_string = paren_level_string.chars().filter(|c|\
    \ c != '\\i').collect::<String>();\n    let mut paren_level_string = paren_level_string.chars().filter(|c|\
    \ c != '\\c').collect::<String>();\n    let mut paren_level_string = paren_level_string.chars().filter(|c|\
    \ c != '\\o').collect::<String>();\n    let mut paren_level_string = paren_level_string.chars().filter(\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: unknown character escape: `f`\n  --> /tmp/tmpkwfhe_c2.rs:18:79\n\
    \   |\n18 |     let mut paren_level_string = paren_level_string.chars().filter(|c|\
    \ c != '\\f').collect::<String>();\n   |                                     \
    \                                          ^ unknown character escape\n   |\n\
    \   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n18 |     let mut paren_level_string\
    \ = paren_level_string.chars().filter(|c| c != r\"\\f\").collect::<String>();\n\
    \   |                                                                        \
    \     ~~~~~\n\nerror: unknown character escape: `v`\n  --> /tmp/tmpkwfhe_c2.rs:19:79\n\
    \   |\n19 |     let mut paren_level_string = paren_level_string.chars().filter(|c|\
    \ c != '\\v').collect::<String>();\n   |                                     \
    \                                          ^ unknown character escape\n   |\n\
    \   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n19 |     let mut paren_level_string\
    \ = paren_level_string.chars().filter(|c| c != r\"\\v\").collect::<String>();\n\
    \   |                                                                        \
    \     ~~~~~\n\nerror: unknown character escape: `a`\n  --> /tmp/tmpkwfhe_c2.rs:20:79\n\
    \   |\n20 |     let mut paren_level_string = paren_level_string.chars().filter(|c|\
    \ c != '\\a').collect::<String>();\n   |                                     \
    \                                          ^ unknown character escape\n   |\n\
    \   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n20 |     let mut paren_level_string\
    \ = paren_level_string.chars().fi"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_levels_size\
    \ = paren_stack.len();\n    let mut paren_levels_index = paren_stack.len();\n\
    \    let mut paren_levels_size = paren_stack.len();\n    let mut paren_levels_index\
    \ = paren_stack.len();\n    let mut paren_levels_size = paren_stack.len();\n \
    \   let mut paren_levels_index = paren_stack.len();\n    let mut paren_levels_size\
    \ = paren_stack.len();\n    let mut paren_levels_index = paren_stack.len();\n\
    \    let mut paren_levels_size = paren_stack.len();\n    let mut paren_levels_index\
    \ = paren_stack.len();\n    let mut paren_levels_size = paren_stack.len();\n \
    \   let mut paren_levels_index = paren_stack.len();\n    let mut paren_levels_size\
    \ = paren_stack.len();\n    let mut paren_levels_index = paren_stack.len();\n\
    \    let mut paren_levels_size = paren_stack.len();\n    let mut paren_levels_index\
    \ = paren_stack.len();\n    let mut paren_levels_size = paren_stack.len();\n \
    \   let mut paren_levels_index = paren_stack.len();\n    let mut paren_levels_size\
    \ = paren_stack.len();\n    let mut paren_levels_index = paren_stack.len();\n\
    \    let mut paren_levels_size = paren_stack.len();\n    let mut paren_levels_index\
    \ = paren_stack.len();\n    let mut paren_levels_size = paren_stack.len();\n \
    \   let mut paren_levels_index = paren_stack.len();\n    let mut paren_levels_size\
    \ = paren_stack.len();\n    let mut paren_levels_index = paren_stack.len();\n\
    \    let mut paren_levels_size = paren_stack.len();\n    let mut paren_levels_index\
    \ = paren_stack.len();\n    let mut paren_levels_size = paren_stack.len();\n \
    \   let mut paren_levels_index = paren_stack.len();\n    let mut paren_levels_size\
    \ = paren_stack.len();\n    let mut paren_levels_index = paren_stack.len();\n\
    \    let mut paren_levels_size = paren_stack.len();\n    let mut paren_levels_index\
    \ = paren_stack.len();\n    let mut paren\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt4izhxp9.rs:44:18\n   |\n\
    44 |     let mut paren\n   |                  ^ help: add `;` here\n45 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpt4izhxp9.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack = Vec::new();\n\
    \    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_end = paren_string.len();\n    let mut paren_stack_char\
    \ = paren_string[paren_stack_pos];\n    while paren_stack_pos < paren_stack_end\
    \ {\n        if paren_stack_char == '(' {\n            paren_stack.push(level);\n\
    \            paren_stack_pos += 1;\n            paren_stack_char = paren_string[paren_stack_pos];\n\
    \            level += 1;\n        } else if paren_stack_char == ')' {\n      \
    \      level -= 1;\n            if level == 0 {\n                paren_stack_end\
    \ = paren_stack_pos;\n                paren_stack_char = paren_string[paren_stack_end];\n\
    \            } else {\n                paren_stack_pos += 1;\n               \
    \ paren_stack_char = paren_string[paren_stack_pos];\n            }\n        }\
    \ else {\n            paren_stack_pos += 1;\n            paren_stack_char = paren_string[paren_stack_pos];\n\
    \        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpf_dcobof.rs:12:32\n   |\n12 |     let mut paren_stack_char = paren_string[paren_stack_pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpf_dcobof.rs:17:32\n   |\n17 |             paren_stack_char = paren_string[paren_stack_pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpf_dcobof.rs:23:36\n   |\n23 |                 paren_stack_char\
    \ = paren_string[paren_stack_end];\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclu"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_ptr\
    \ = 0;\n    let mut paren_levels_stack_ptr_max = paren_levels_stack.len();\n \
    \   let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = paren_levels_stack_ptr_max.clone();\n\
    \    let mut paren_levels_stack_ptr_max_ptr = \n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpvizxogtg.rs:32:1\n\
    \   |\n32 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut paren_depth\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level = 0;\n\
    \    let mut paren_levels_len = paren_stack.len();\n    let mut paren_levels_len_ptr\
    \ = paren_levels_len;\n    let mut paren_levels_len_ptr_ptr = paren_levels_len_ptr;\n\
    \    let mut paren_levels_len_ptr_ptr_ptr = paren_levels_len_ptr_ptr;\n    let\
    \ mut paren_levels_len_ptr_ptr_ptr_ptr = paren_levels_len_ptr_ptr_ptr;\n    let\
    \ mut paren_levels_len_ptr_ptr_ptr_ptr_ptr = paren_levels_len_ptr_ptr_ptr_ptr_ptr;\n\
    \    let mut paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr = paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr;\n\
    \    let mut paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr = paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n\
    \    let mut paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n\
    \    let mut paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n\
    \    let mut paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n    let mut\
    \ paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n\
    \    let mut paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n\
    \    let mut paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n\
    \    let mut paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyvx2ut04.rs:25:184\n   |\n\
    25 |     let mut paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    \   |                                                                        \
    \                                                                            \
    \                                    ^ help: add `;` here\n26 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `paren_levels_len_ptr_ptr_ptr_ptr_ptr`\
    \ in this scope\n  --> /tmp/tmpyvx2ut04.rs:16:52\n   |\n16 |     let mut paren_levels_len_ptr_ptr_ptr_ptr_ptr\
    \ = paren_levels_len_ptr_ptr_ptr_ptr_ptr;\n   |                              \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `paren_levels_len_ptr_ptr_ptr_ptr`\n\nerror[E0425]:\
    \ cannot find value `paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr` in this scope\n\
    \  --> /tmp/tmpyvx2ut04.rs:17:56\n   |\n17 |     let mut paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr;\n   |                          \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `paren_levels_len_ptr_ptr_ptr_ptr_ptr`\n\
    \nerror[E0425]: cannot find value `paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr`\
    \ in this scope\n  --> /tmp/tmpyvx2ut04.rs:18:60\n   |\n18 |     let mut paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n   |                      \
    \                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr`\n\
    \nerror[E0425]: cannot find value `paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr`\
    \ in this scope\n  --> /tmp/tmpyvx2ut04.rs:19:64\n   |\n19 |     let mut paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = paren_levels_len_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr;\n   |                  \
    \               "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_count: usize = 0;\n    let mut paren_level_max_count:\
    \ usize = 0;\n    let mut paren_level_max_level: usize = 0;\n    let mut paren_level_max_level_char:\
    \ char = '(';\n    let mut paren_level_max_level_char_pos: usize = 0;\n    let\
    \ mut paren_level_max_level_char_len: usize = 0;\n    let mut paren_level_max_level_char_len_pos:\
    \ usize = 0;\n    let mut paren_level_max_level_char_len_len: usize = 0;\n   \
    \ let mut paren_level_max_level_char_len_pos_len: usize = 0;\n    let mut paren_level_max_level_char_len_pos_pos_len:\
    \ usize = 0;\n    let mut paren_level_max_level_char_pos_len: usize = 0;\n   \
    \ let mut paren_level_max_level_char_pos_pos_len: usize = 0;\n    let mut paren_level_max_level_char_pos_pos_pos_len:\
    \ usize = 0;\n    let mut paren_level_max_level_char_pos_pos_pos_pos_len: usize\
    \ = 0;\n    let mut paren_level_max_level_char_pos_pos_pos_pos_len: usize = 0;\n\
    \    let mut paren_level_max_level_char_pos_pos_pos_pos_pos_len: usize = 0;\n\
    \    let mut paren_level_max_level_char_pos_pos_pos_pos_pos_pos_len: usize = 0;\n\
    \    let mut paren_level_max_level_char_pos_pos_pos_pos_pos_pos_pos_len: usize\
    \ = 0;\n    let mut paren_level_max_level_char_pos_pos_pos_pos_pos_pos_pos_pos_len:\
    \ usize = 0;\n    let mut paren_level_max_level_char_pos_pos_pos_pos_pos_pos_pos_pos_pos_len:\
    \ usize = 0;\n    let mut paren_level_max_level_char_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_len:\
    \ usize = 0;\n    let mut paren_level_max_level_char_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_len:\
    \ usize = 0;\n    let mut paren_level_max_level_char_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_len:\
    \ usize = 0;\n    let mut paren_level_max_level_char_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_len:\
    \ usize = 0;\n    let mut paren_level_max_level_char_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_len:\
    \ usize = 0;\n    let mut paren_level_\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnxe00ala.rs:34:25\n   |\n\
    34 |     let mut paren_level_\n   |                         ^ help: add `;` here\n\
    35 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpnxe00ala.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string_index = 0;\n    let mut paren_level_string_len\
    \ = 0;\n    let mut paren_level_string_len_index = 0;\n    let mut paren_level_string_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\
    \ = 0;\n    let mut paren_level_string_len_len_index = 0;\n    let mut paren_level_string_len_len_len\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcjd9x71h.rs:50:43\n   |\n\
    50 |     let mut paren_level_string_len_len_len\n   |                        \
    \                   ^ help: add `;` here\n51 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmpcjd9x71h.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut paren_count =\
    \ 0;\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n \
    \   let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = 0;\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n \
    \   let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl3cy3ra4.rs:36:48\n   |\n\
    36 |     let mut paren_levels_stack_ptr_end = paren_\n   |                   \
    \                             ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `paren_` in this scope\n  --> /tmp/tmpl3cy3ra4.rs:36:42\n\
    \   |\n36 |     let mut paren_levels_stack_ptr_end = paren_\n   |            \
    \                              ^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpl3cy3ra4.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: usize = 0;\n    let mut paren_level_count: usize = 0;\n    let\
    \ mut paren_level_string: String = String::new();\n    let mut paren_level_string_len:\
    \ usize = 0;\n    let mut paren_level_char: char = 0;\n    let mut paren_level_char_len:\
    \ usize = 0;\n    let mut paren_level_char_pos: usize = 0;\n    let mut paren_level_char_pos_len:\
    \ usize = 0;\n    let mut paren_level_char_pos_len2: usize = 0;\n    let mut paren_level_char_pos_len3:\
    \ usize = 0;\n    let mut paren_level_char_pos_len4: usize = 0;\n    let mut paren_level_char_pos_len5:\
    \ usize = 0;\n    let mut paren_level_char_pos_len6: usize = 0;\n    let mut paren_level_char_pos_len7:\
    \ usize = 0;\n    let mut paren_level_char_pos_len8: usize = 0;\n    let mut paren_level_char_pos_len9:\
    \ usize = 0;\n    let mut paren_level_char_pos_len10: usize = 0;\n    let mut\
    \ paren_level_char_pos_len11: usize = 0;\n    let mut paren_level_char_pos_len12:\
    \ usize = 0;\n    let mut paren_level_char_pos_len13: usize = 0;\n    let mut\
    \ paren_level_char_pos_len14: usize = 0;\n    let mut paren_level_char_pos_len15:\
    \ usize = 0;\n    let mut paren_level_char_pos_len16: usize = 0;\n    let mut\
    \ paren_level_char_pos_len17: usize = 0;\n    let mut paren_level_char_pos_len18:\
    \ usize = 0;\n    let mut paren_level_char_pos_len19: usize = 0;\n    let mut\
    \ paren_level_char_pos_len20: usize = 0;\n    let mut paren_level_char_pos_len21:\
    \ usize = 0;\n    let mut paren_level_char_pos_len22: usize = 0;\n    let mut\
    \ paren_level_char_pos_len23: usize = 0;\n    let mut paren_level_char_pos_len24:\
    \ usize = 0;\n    let mut paren_level_char_pos_len25: usize = 0;\n    let mut\
    \ paren_level_char_pos_len26: usize = 0;\n    let mut paren_level_char_pos_len27:\
    \ usize = 0;\n    let mut paren_level_char_pos_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfn_3yw91.rs:42:34\n   |\n\
    42 |     let mut paren_level_char_pos_\n   |                                 \
    \ ^ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfn_3yw91.rs:12:38\n   |\n12 |     let mut paren_level_char:\
    \ char = 0;\n   |                               ----   ^ expected `char`, found\
    \ `u8`\n   |                               |\n   |                           \
    \    expected due to this\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfn_3yw91.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting = 0;\n\
    \    let mut paren_nesting_level = 0;\n    let mut paren_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nest\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfysf9ku5.rs:40:31\n   |\n\
    40 |     let mut paren_nesting_nest\n   |                               ^ help:\
    \ add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpfysf9ku5.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack = Vec::new();\n\
    \    let mut paren_stack_size = paren_stack.len();\n    let mut paren_stack_top\
    \ = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n    let\
    \ mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n\
    \    let mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top\
    \ = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n    let\
    \ mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n\
    \    let mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top\
    \ = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n    let\
    \ mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n\
    \    let mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top\
    \ = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n    let\
    \ mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n\
    \    let mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top\
    \ = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n    let\
    \ mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n\
    \    let mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top\
    \ = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n    let\
    \ mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n\
    \    let mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top\
    \ = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n    let\
    \ mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n\
    \    let mut paren_stack_top = paren_stack_size;\n    let mut paren_stack_top\
    \ = paren_stack_size;\n    let mut paren_stack_top = paren_stack_size;\n\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprxx633g8.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_levels: Vec<isize> = vec![];\n  \
    \  let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size: isize\
    \ = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n    let mut paren_levels_size:\
    \ isize = 0;\n    let mut paren_levels_size: isize = 0;\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4qwka413.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_levels_size\
    \ = paren_stack.len();\n    let mut paren_levels_sizes = Vec::new();\n    let\
    \ mut paren_levels_sizes_size = paren_levels_sizes.len();\n    let mut paren_levels_sizes_sizes\
    \ = paren_levels_sizes_sizes.len();\n    let mut paren_levels_sizes_sizes_size\
    \ = paren_levels_sizes_sizes_sizes.len();\n    let mut paren_levels_sizes_sizes_sizes_size\
    \ = paren_levels_sizes_sizes_sizes_sizes.len();\n    let mut paren_levels_sizes_sizes_sizes_sizes_size\
    \ = paren_levels_sizes_sizes_sizes_sizes_sizes.len();\n    let mut paren_levels_sizes_sizes_sizes_sizes_sizes_size\
    \ = paren_levels_sizes_sizes_sizes_sizes_sizes_sizes.len();\n    let mut paren_levels_sizes_sizes_sizes_sizes_sizes_sizes_size\
    \ = paren_levels_sizes_sizes_sizes_sizes_sizes_sizes_sizes.len();\n    let mut\
    \ paren_levels_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_size = paren_levels_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes.len();\n\
    \    let mut paren_levels_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_size\
    \ = paren_levels_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes.len();\n\
    \    let mut paren_levels_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_size\
    \ = paren_levels_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes.len();\n\
    \    let mut paren_levels_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_size\
    \ = paren_levels_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes.len();\n\
    \    let mut paren_levels_size\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxrz2mc1o.rs:23:30\n   |\n\
    23 |     let mut paren_levels_size\n   |                              ^ help:\
    \ add `;` here\n24 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `paren_levels_sizes_sizes` in this scope\n  --> /tmp/tmpxrz2mc1o.rs:13:40\n\
    \   |\n13 |     let mut paren_levels_sizes_sizes = paren_levels_sizes_sizes.len();\n\
    \   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^ help: a\
    \ local variable with a similar name exists: `paren_levels_sizes_size`\n\nerror[E0425]:\
    \ cannot find value `paren_levels_sizes_sizes_sizes` in this scope\n  --> /tmp/tmpxrz2mc1o.rs:14:45\n\
    \   |\n14 |     let mut paren_levels_sizes_sizes_size = paren_levels_sizes_sizes_sizes.len();\n\
    \   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_sizes_sizes`\n\
    \nerror[E0425]: cannot find value `paren_levels_sizes_sizes_sizes_sizes` in this\
    \ scope\n  --> /tmp/tmpxrz2mc1o.rs:15:51\n   |\n15 |     let mut paren_levels_sizes_sizes_sizes_size\
    \ = paren_levels_sizes_sizes_sizes_sizes.len();\n   |                        \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `paren_levels_sizes_sizes_size`\n\nerror[E0425]:\
    \ cannot find value `paren_levels_sizes_sizes_sizes_sizes_sizes` in this scope\n\
    \  --> /tmp/tmpxrz2mc1o.rs:16:57\n   |\n16 |     let mut paren_levels_sizes_sizes_sizes_sizes_size\
    \ = paren_levels_sizes_sizes_sizes_sizes_sizes.len();\n   |                  \
    \                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_sizes_sizes_sizes_size`\n\
    \nerror[E0425]: cannot find value `paren_levels_sizes_sizes_sizes_sizes_sizes_sizes`\
    \ in this scope\n  --> /tmp/tmpxrz2mc1o.rs:17:63\n   |\n17 |     let mut paren_levels_sizes_sizes_sizes_sizes_sizes_size\
    \ = paren_levels_sizes_sizes_sizes_sizes_sizes_sizes.len();\n   |            \
    \                                                   ^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut paren_count =\
    \ 0;\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n \
    \   let mut paren_levels_len = paren_levels;\n    let mut paren_levels_ptr = paren_levels_len;\n\
    \    let mut paren_levels_ptr_next = paren_levels_ptr;\n    let mut paren_levels_ptr_next\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_next = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_next = paren_levels_ptr;\n    let mut paren_levels_ptr_next\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_next = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_next = paren_levels_ptr;\n    let mut paren_levels_ptr_next\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_next = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_next = paren_levels_ptr;\n    let mut paren_levels_ptr_next\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_next = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_next = paren_levels_ptr;\n    let mut paren_levels_ptr_next\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_next = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_next = paren_levels_ptr;\n    let mut paren_levels_ptr_next\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_next = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_next = paren_levels_ptr;\n    let mut paren_levels_ptr_next\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_next = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_next = paren_levels_ptr;\n    let mut paren_levels_ptr_next\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_next = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_next = paren_levels_ptr;\n    let mut paren_levels_ptr_next\
    \ = paren_levels_ptr;\n    let mut paren_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpycel8ryb.rs:39:19\n   |\n\
    39 |     let mut paren_\n   |                   ^ help: add `;` here\n40 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpycel8ryb.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = vec![];\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_char_length = 0;\n    let mut paren_level_char_length_count\
    \ = 0;\n    let mut paren_level_char_lengths = vec![];\n    let mut paren_level_char_length:\
    \ usize;\n    let mut paren_level_char_length_count = 0;\n    let mut paren_level_char_lengths\
    \ = vec![];\n    let mut paren_level_char_length: usize;\n    let mut paren_level_char_length_count\
    \ = 0;\n    let mut paren_level_char_lengths = vec![];\n    let mut paren_level_char_length:\
    \ usize;\n    let mut paren_level_char_length_count = 0;\n    let mut paren_level_char_lengths\
    \ = vec![];\n    let mut paren_level_char_length: usize;\n    let mut paren_level_char_length_count\
    \ = 0;\n    let mut paren_level_char_lengths = vec![];\n    let mut paren_level_char_length:\
    \ usize;\n    let mut paren_level_char_length_count = 0;\n    let mut paren_level_char_lengths\
    \ = vec![];\n    let mut paren_level_char_length: usize;\n    let mut paren_level_char_length_count\
    \ = 0;\n    let mut paren_level_char_lengths = vec![];\n    let mut paren_level_char_length:\
    \ usize;\n    let mut paren_level_char_length_count = 0;\n    let mut paren_level_char_lengths\
    \ = vec![];\n    let mut paren_level_char_length: usize;\n    let mut paren_level_char_length_count\
    \ = 0;\n    let mut paren_level_char_lengths = vec![];\n    let mut paren_level_char_length:\
    \ usize;\n    let mut paren_level_char_length_count = 0;\n    let mut paren_level_char_lengths\
    \ = vec![];\n    let mut paren_level_char_length: usize;\n    let mut paren_level_char_length_count\
    \ = 0;\n    let mut paren_level_char_lengths = vec![];\n    let mut paren_level_char_length:\
    \ usize;\n    let mut paren_level_char_length_count = 0;\n    let mut paren_level_char_lengths\
    \ = vec![];\n    let mut paren_level_char_length: usize;\n    let mut paren_level_char_length_count\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxxxejdyu.rs:50:42\n   |\n\
    50 |     let mut paren_level_char_length_count\n   |                         \
    \                 ^ help: add `;` here\n51 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpxxxejdyu.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_level_count: usize = 0;\n    for\
    \ paren in paren_string.chars() {\n        if paren == '(' {\n            paren_stack.push(paren_level);\n\
    \            paren_level_count = 1;\n        } else if paren == ')' {\n      \
    \      paren_level_count = paren_stack.pop();\n            if paren_level_count\
    \ == 0 {\n                paren_level_count = paren_level;\n            }\n  \
    \      }\n        paren_level += paren_level_count;\n    }\n    paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbito94hm.rs:15:33\n   |\n\
    9  |     let mut paren_level_count: usize = 0;\n   |                         \
    \       ----- expected due to this type\n...\n15 |             paren_level_count\
    \ = paren_stack.pop();\n   |                                 ^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbito94hm.rs:17:37\n   |\n9  |     let mut paren_level_count: usize\
    \ = 0;\n   |                                ----- expected due to this type\n\
    ...\n17 |                 paren_level_count = paren_level;\n   |             \
    \                        ^^^^^^^^^^^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbito94hm.rs:20:24\n   |\n20 |         paren_level\
    \ += paren_level_count;\n   |                        ^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot add-assign `usize` to `isize`\n\
    \  --> /tmp/tmpbito94hm.rs:20:21\n   |\n20 |         paren_level += paren_level_count;\n\
    \   |                     ^^ no implementation for `isize += usize`\n   |\n  \
    \ = help: the trait `AddAssign<usize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `AddAssign<Rhs>`:\n             <f32\
    \ as AddAssign<&f32>>\n             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n\
    \             <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n  \
    \           <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n     \
    \        <i16 as AddAssign>\n           and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbito94hm.rs:22:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n22 |     paren_level\n\
    \   |     ^^^^^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len\
    \ = paren_level_chars.len();\n    let mut paren_level_char_pos = 0;\n    let mut\
    \ paren_level_char_len = paren_level_chars.len();\n    let mut paren_level_char_pos\
    \ = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n    let mut\
    \ paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8i7sa7bz.rs:47:30\n   |\n\
    47 |     let mut paren_level_char_\n   |                              ^ help:\
    \ add `;` here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp8i7sa7bz.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    while paren_level_count <\
    \ MAX_NESTING_DEPTH {\n        let mut paren_level_string = paren_string;\n  \
    \      let mut paren_level_string = paren_string;\n        let mut paren_level_string\
    \ = paren_string;\n        let mut paren_level_string = paren_string;\n      \
    \  let mut paren_level_string = paren_string;\n        let mut paren_level_string\
    \ = paren_string;\n        let mut paren_level_string = paren_string;\n      \
    \  let mut paren_level_string = paren_string;\n        let mut paren_level_string\
    \ = paren_string;\n        let mut paren_level_string = paren_string;\n      \
    \  let mut paren_level_string = paren_string;\n        let mut paren_level_string\
    \ = paren_string;\n        let mut paren_level_string = paren_string;\n      \
    \  let mut paren_level_string = paren_string;\n        let mut paren_level_string\
    \ = paren_string;\n        let mut paren_level_string = paren_string;\n      \
    \  let mut paren_level_string = paren_string;\n        let mut paren_level_string\
    \ = paren_string;\n        let mut paren_level_string = paren_string;\n      \
    \  let mut paren_level_string = paren_string;\n        let mut paren_level_string\
    \ = paren_string;\n        let mut paren_level_string = paren_string;\n      \
    \  let mut paren_level_string = paren_string;\n        let mut paren_level_string\
    \ = paren_string;\n        let mut paren_level_string = paren_string;\n      \
    \  let mut paren_level_string = paren_string;\n        let mut paren_level_string\
    \ = paren_string;\n        let mut paren_level_string = paren_string;\n      \
    \  let mut paren_level_string = paren_string;\n        let mut paren_level_string\
    \ = paren_string;\n        let mut paren_level_string = paren_string;\n      \
    \  let mut paren_level_string = paren_string;\n        let mut paren_level_string\
    \ = paren_string;\n        let mut paren_level_string = paren_string;\n      \
    \  let mut paren_level_string = paren_string;\n        let mut paren_level_string\
    \ = paren_string;\n        let mut paren_level_string = paren_string;\n      \
    \  let mu\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp02ncuu65.rs:58:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n12 |     while paren_level_count < MAX_NESTING_DEPTH {\n   |            \
    \                                     - this delimiter might not be properly closed...\n\
    ...\n51 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    58 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp02ncuu65.rs:50:15\n\
    \   |\n50 |         let mu\n   |               ^ help: add `;` here\n51 | }\n\
    \   | - unexpected token\n\nerror[E0425]: cannot find value `MAX_NESTING_DEPTH`\
    \ in this scope\n  --> /tmp/tmp02ncuu65.rs:12:31\n   |\n12 |     while paren_level_count\
    \ < MAX_NESTING_DEPTH {\n   |                               ^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/tmp02ncuu65.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: usize = 0;\n    let mut paren_level_count: usize = 0;\n    let\
    \ mut paren_level_max_count: usize = 0;\n    let mut paren_level_max_level: usize\
    \ = 0;\n    let mut paren_level_max_level_count: usize = 0;\n    let mut paren_level_max_level_max_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level: usize = 0;\n    let\
    \ mut paren_level_max_level_max_level_count: usize = 0;\n    let mut paren_level_max_level_max_level_max_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level: usize = 0;\n\
    \    let mut paren_level_max_level_max_level_max_level_count: usize = 0;\n   \
    \ let mut paren_level_max_level_max_level_max_level_max_count: usize = 0;\n  \
    \  let mut paren_level_max_level_max_level_max_level_max_level: usize = 0;\n \
    \   let mut paren_level_max_level_max_level_max_level_max_level_count: usize =\
    \ 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_count:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ usize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected type, found `}`\n  --> /tmp/tmptowam942.rs:34:1\n   |\n\
    33 |     let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ \n   |         -------------------------------------------------------------------------------------------\
    \ while parsing the type for `mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_count`\n\
    34 | }\n   | ^ expected type\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut paren_level\
    \ = 0;\n    for paren in paren_string.chars() {\n        if paren == '(' {\n \
    \           paren_stack.push(paren_level);\n            paren_level += 1;\n  \
    \      } else if paren == ')' {\n            paren_level -= 1;\n            if\
    \ paren_level == 0 {\n                paren_stack.push(paren_level);\n       \
    \     }\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmpaafamufi.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_indexes: Vec<isize>\
    \ = Vec::new();\n    let mut paren_level_indexes_len = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_indexes = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp036oxn2o.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_iter = paren_string.char_indices().rev();\n \
    \   let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpyjtmmk7w.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    for paren in paren_string.chars()\
    \ {\n        if paren == '(' {\n            paren_stack.push(paren_level);\n \
    \           paren_level += 1;\n            paren_nesting += 1;\n        } else\
    \ if paren == ')' {\n            paren_level -= 1;\n            paren_nesting\
    \ -= 1;\n            if paren_nesting == 0 {\n                paren_stack.push(paren_level);\n\
    \            }\n        } else if paren == ' ' {\n            if paren_nesting\
    \ == 0 {\n                paren_stack.push(paren_level);\n            }\n    \
    \    }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 1, 2, 1, 1, 0]`,\n right: `[2, 3,\
    \ 1, 3]`', /tmp/tmp9hl18amh.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: usize = 0;\n    let mut paren_levels: Vec<isize> = vec![];\n  \
    \  let mut paren_levels_len: usize = 0;\n    let mut paren_levels_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_len: usize = 0;\n    let mut paren_levels_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_len: usize = 0;\n \
    \   let mut paren_levels_lens_lens_lens: Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens: Vec<isize> = vec![];\n\
    \    let mut paren_levels_lens_lens_lens_lens_len: usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_len: usize\
    \ = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpu6a50pgc.rs:28:41\n   |\n\
    28 |     let mut paren_levels_lens_lens_lens_\n   |                          \
    \               ^ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpu6a50pgc.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_count_max = 0;\n    let mut paren_level_char_pos_count_max_index\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index2 = 0;\n    let mut paren_level_char_pos_count_max_index3\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index4 = 0;\n    let mut paren_level_char_pos_count_max_index5\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index6 = 0;\n    let mut paren_level_char_pos_count_max_index7\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index8 = 0;\n    let mut paren_level_char_pos_count_max_index9\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index10 = 0;\n    let mut paren_level_char_pos_count_max_index11\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index12 = 0;\n    let mut paren_level_char_pos_count_max_index13\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index14 = 0;\n    let mut paren_level_char_pos_count_max_index15\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index16 = 0;\n    let mut paren_level_char_pos_count_max_index17\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index18 = 0;\n    let mut paren_level_char_pos_count_max_index19\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index20 = 0;\n    let mut paren_level_char_pos_count_max_index21\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index22 = 0;\n    let mut paren_level_char_pos_count_max_index23\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index24 = 0;\n    let mut paren_level_char_pos_count_max_index25\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index26 = 0;\n    let mut paren_level_char_pos_count_max_index27\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index28 = 0;\n    let mut paren_level_char_pos_count_max_index29\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index30 = 0;\n    let mut paren_level_char_pos_count_max_index31\
    \ = 0;\n    let mut paren_level_char_pos_count_max_index32\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo6766n0u.rs:45:51\n   |\n\
    45 |     let mut paren_level_char_pos_count_max_index32\n   |                \
    \                                   ^ help: add `;` here\n46 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpo6766n0u.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0pwm6tl4.rs:38:11\n   |\n\
    38 |     let mu\n   |           ^ help: add `;` here\n39 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp0pwm6tl4.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_depth: usize = 0;\n    let mut paren_level: usize = 0;\n    let mut paren_levels:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_len: usize = 0;\n    let mut\
    \ paren_levels_lens: Vec<isize> = vec![];\n    let mut paren_levels_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens: Vec<isize> = vec![];\n    let\
    \ mut paren_levels_lens_lens_len: usize = 0;\n    let mut paren_levels_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_len: usize = 0;\n\
    \    let mut paren_levels_lens_lens_lens_lens: Vec<isize> = vec![];\n    let mut\
    \ paren_levels_lens_lens_lens_lens_len: usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_len: usize\
    \ = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_len: usize\
    \ = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpggbxecp4.rs:28:108\n   |\n\
    28 |     let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize\n   |                                                                \
    \                                            ^ help: add `;` here\n29 | }\n  \
    \ | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpggbxecp4.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_stack = Vec::new();\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_len = paren_level_stack.len();\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpew6yz5bq.rs:43:43\n   |\n\
    43 |     let mut paren_level_stack_top = paren_\n   |                        \
    \                   ^ help: add `;` here\n44 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `paren_` in this scope\n  --> /tmp/tmpew6yz5bq.rs:43:37\n\
    \   |\n43 |     let mut paren_level_stack_top = paren_\n   |                 \
    \                    ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpew6yz5bq.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string_index = 0;\n    let mut paren_level_string_len\
    \ = 0;\n    let mut paren_level_string_len_index = 0;\n    let mut paren_level_string_len_len\
    \ = 0;\n    while paren_level_string_index < paren_string.len() {\n        let\
    \ mut paren_level_string = paren_string;\n        let mut paren_level_string_index\
    \ = paren_level_string_len_index;\n        let mut paren_level_string_len = 0;\n\
    \        let mut paren_level_string_len_index = 0;\n        let mut paren_level_string_len_len\
    \ = 0;\n        while paren_level_string_len_index < paren_level_string.len()\
    \ {\n            let mut paren_level_string = paren_string;\n            let mut\
    \ paren_level_string_index = paren_level_string_len_index;\n            let mut\
    \ paren_level_string_len = 0;\n            let mut paren_level_string_len_index\
    \ = 0;\n            let mut paren_level_string_len_len = 0;\n            while\
    \ paren_level_string_len_len < paren_level_string.len() {\n                let\
    \ mut paren_level_string = paren_string;\n                let mut paren_level_string_index\
    \ = paren_level_string_len_index;\n                let mut paren_level_string_len\
    \ = 0;\n                let mut paren_level_string_len_index = 0;\n          \
    \      let mut paren_level_string_len_len = 0;\n                while paren_level_string_len_len\
    \ < paren_level_string.len() {\n                    let mut paren_level_string\
    \ = paren_string;\n                    let mut paren_level_string_index = paren_level_string_len_index;\n\
    \                    let mut paren_level_string_len = 0;\n                   \
    \ let mut paren_level_string_len_index = 0;\n                    let mut paren_level_string_len_len\
    \ = 0;\n                    while paren_level_string_len_len < paren_level_string.len()\
    \ {\n                        let mut paren_level_string = paren_string;\n    \
    \                    let mut paren_level_string_index = paren_level_string_len_index;\n\
    \                        let mut paren_level_string_len = 0;\n               \
    \         let mut paren_level_string_len_index = 0;\n                        let\
    \ mut paren_level_string_len_len = 0;\n                        while paren_level_string_len_len\
    \ < paren_level_string.len() {\n                            let mut paren_level_string\
    \ = paren_string;\n                            let mut paren_level\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpof288e42.rs:55:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n15 |     while paren_level_string_index < paren_string.len() {\n   |    \
    \                                                     - unclosed delimiter\n...\n\
    21 |         while paren_level_string_len_index < paren_level_string.len() {\n\
    \   |                                                                       -\
    \ unclosed delimiter\n...\n27 |             while paren_level_string_len_len <\
    \ paren_level_string.len() {\n   |                                           \
    \                              - unclosed delimiter\n...\n33 |               \
    \  while paren_level_string_len_len < paren_level_string.len() {\n   |       \
    \                                                                      - unclosed\
    \ delimiter\n...\n39 |                     while paren_level_string_len_len <\
    \ paren_level_string.len() {\n   |                                           \
    \                                      - unclosed delimiter\n...\n45 |       \
    \                  while paren_level_string_len_len < paren_level_string.len()\
    \ {\n   |                                                                    \
    \                 - this delimiter might not be properly closed...\n...\n48 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n55 |\
    \ }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpof288e42.rs:47:48\n\
    \   |\n47 |                             let mut paren_level\n   |            \
    \                                    ^ help: add `;` here\n48 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpof288e42.rs:15:5\n  \
    \ |\n6  |   fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                   ---------- expected `Vec<isize>`\
    \ because of return type\n...\n15 | /     while paren_level_string_index < paren_string.len()\
    \ {\n16 | |         let mut paren_level_string = paren_st"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr = Vec::new();\n    let mut paren_levels_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_ptr_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpscdzvkw2.rs:30:112\n   |\n\
    30 |     let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new\n   |                                                           \
    \                                                     ^ help: add `;` here\n31\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpscdzvkw2.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n    let mut\
    \ paren_level: isize = 0;\n    let mut paren_level_count: isize = 0;\n    let\
    \ mut paren_level_string: String = String::new();\n    let mut paren_level_string_len:\
    \ usize = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n   \
    \         paren_stack.push(paren_level);\n            paren_level_string.push(c);\n\
    \            paren_level_string_len += 1;\n            paren_level_count += 1;\n\
    \        } else if c == ')' {\n            paren_level -= 1;\n            if paren_level\
    \ == 0 {\n                paren_stack.push(paren_level);\n                paren_level_string.push(c);\n\
    \                paren_level_string_len += 1;\n                paren_level_count\
    \ += 1;\n            } else {\n                paren_level_string[paren_level_string_len..].push(')');\n\
    \            }\n        }\n    }\n    if paren_level_string.len() != paren_level_string_len\
    \ {\n        return vec![];\n    }\n    paren_stack.push(paren_level);\n    paren_level_string.push(')');\n\
    \    paren_level_string_len += 1;\n    paren_level_count += 1;\n    paren_level_string\n\
    \        .split_whitespace()\n        .map(|s| s.parse().unwrap())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for type `str` in the current\
    \ scope\n  --> /tmp/tmpknjpv5hb.rs:26:62\n   |\n26 |                 paren_level_string[paren_level_string_len..].push(')');\n\
    \   |                                                              ^^^^ method\
    \ not found in `str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = 0;\n    let mut paren_levels_ptr = 0;\n    let mut paren_levels_ptr_end =\
    \ paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_end_ptr_end = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr = paren_levels_ptr;\n  \
    \  let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmptl9s0ob3.rs:29:1\n\
    \   |\n29 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack = Vec::new();\n\
    \    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_char = paren_string[paren_stack_pos];\n    while\
    \ paren_stack_pos < paren_string.len() {\n        if paren_stack_char == ')' {\n\
    \            paren_stack.pop();\n            paren_stack_len -= 1;\n         \
    \   paren_stack_pos += 1;\n            level -= 1;\n        } else if paren_stack_char\
    \ == '(' {\n            paren_stack.push(level);\n            paren_stack_len\
    \ += 1;\n            paren_stack_pos += 1;\n            level += 1;\n        }\
    \ else {\n            paren_stack_pos += 1;\n            paren_stack_char = paren_string[paren_stack_pos];\n\
    \        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmppv8cxmih.rs:11:32\n   |\n11 |     let mut paren_stack_char = paren_string[paren_stack_pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppv8cxmih.rs:25:32\n   |\n25 |             paren_stack_char = paren_string[paren_stack_pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string_index = 0;\n    let mut paren_level_string = paren_string;\n\
    \    while paren_level_string_index < paren_string.len() {\n        let mut paren_level_string\
    \ = paren_string;\n        let mut paren_level_string_index = 0;\n        while\
    \ paren_level_string_index < paren_string.len() {\n            let mut paren_level_string\
    \ = paren_string;\n            let mut paren_level_string_index = 0;\n       \
    \     while paren_level_string_index < paren_string.len() {\n                let\
    \ mut paren_level_string = paren_string;\n                let mut paren_level_string_index\
    \ = 0;\n                while paren_level_string_index < paren_string.len() {\n\
    \                    let mut paren_level_string = paren_string;\n            \
    \        let mut paren_level_string_index = 0;\n                    while paren_level_string_index\
    \ < paren_string.len() {\n                        let mut paren_level_string =\
    \ paren_string;\n                        let mut paren_level_string_index = 0;\n\
    \                        while paren_level_string_index < paren_string.len() {\n\
    \                            let mut paren_level_string = paren_string;\n    \
    \                        let mut paren_level_string_index = 0;\n             \
    \               while paren_level_string_index < paren_string.len() {\n      \
    \                          let mut paren_level_string = paren_string;\n      \
    \                          let mut paren_level_string_index = 0;\n           \
    \                     while paren_level_string_index < paren_string.len() {\n\
    \                                    let mut paren_level_string = paren_string;\n\
    \                                    let mut paren_level_string_index = 0;\n \
    \                                   while paren_level_string_index < paren_string.len()\
    \ {\n                                        let mut paren_level_string = paren_string;\n\
    \                                        let mut paren_level_string_index = 0;\n\
    \                                        while paren_level_string_index < paren_string.len()\
    \ {\n                                            let mut paren_level_string =\
    \ paren_string;\n                                            let mut paren_level_string_index\
    \ = 0;\n                                            while paren_level_string_index\
    \ < paren_string.len() {\n                                                let\
    \ mut paren_level_string = paren_string;\n                                   \
    \             let mut paren_level_string_index = 0;\n                        \
    \                        while paren_level_string_index < paren_string.len() {\n\
    \                                                    let mut paren_level_string\
    \ = paren_string;\n                                                    let mut\
    \ paren_level_string_index = 0;\n                                            \
    \        \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptjahiki0.rs:57:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n13 |     while paren_level_string_index < paren_string.len() {\n   |    \
    \                                                     - unclosed delimiter\n...\n\
    16 |         while paren_level_string_index < paren_string.len() {\n   |     \
    \                                                        - unclosed delimiter\n\
    ...\n19 |             while paren_level_string_index < paren_string.len() {\n\
    \   |                                                                 - unclosed\
    \ delimiter\n...\n22 |                 while paren_level_string_index < paren_string.len()\
    \ {\n   |                                                                    \
    \ - unclosed delimiter\n...\n25 |                     while paren_level_string_index\
    \ < paren_string.len() {\n   |                                               \
    \                          - unclosed delimiter\n...\n28 |                   \
    \      while paren_level_string_index < paren_string.len() {\n   |           \
    \                                                                  - unclosed\
    \ delimiter\n...\n31 |                             while paren_level_string_index\
    \ < paren_string.len() {\n   |                                               \
    \                                  - unclosed delimiter\n...\n34 |           \
    \                      while paren_level_string_index < paren_string.len() {\n\
    \   |                                                                        \
    \             - unclosed delimiter\n...\n37 |                                \
    \     while paren_level_string_index < paren_string.len() {\n   |            \
    \                                                                            \
    \ - unclosed delimiter\n...\n40 |                                         while\
    \ paren_level_string_index < paren_string.len() {\n   |                      \
    \                                                       "
  exit_code: 1
  status: SyntaxError
