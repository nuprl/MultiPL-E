name: HumanEval_11_string_xor
language: rust
results:
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmpzxx5b74e.rs:8:30\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                              ^^^^ method\
    \ not found in `str`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \ --> /tmp/tmpzxx5b74e.rs:8:54\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                                      \
    \                ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n  = help: the following\
    \ other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0bdn31yn.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect::<String>()\n\
    \  |                                           - ^ - char\n  |               \
    \                            |\n  |                                          \
    \ char\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpomm1y0an.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc79ct494.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpc79ct494.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpnicapwwl.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzn3o00s6.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpzn3o00s6.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpz8x1ggm5.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpj4wcf5hg.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for &c in a.chars().zip(b.chars()) {\n       \
    \ res.push_str(&format!(\"{:b}\", c ^ c));\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp03s8gpl8.rs:7:9\n  |\n7 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpegd7xzj9.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .map(|c| if c == '1' { 0 } else {\
    \ 1 })\n        .fold(String::new(), |mut acc, x| {\n            acc.push_str(&x.to_string());\n\
    \            acc\n        })\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfmkubo8p.rs:9:15\n  |\n9 |\
    \         .fold(String::new(), |mut acc, x| {\n  |               ^^^^^^^^^^^^^\n\
    \  |               |\n  |               expected `&str`, found struct `String`\n\
    \  |               help: consider borrowing here: `&String::new()`\n\nerror[E0599]:\
    \ no method named `push_str` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpfmkubo8p.rs:10:17\n   |\n10 |             acc.push_str(&x.to_string());\n\
    \   |                 ^^^^^^^^ method not found in `&str`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a & &b {\n        match c {\n  \
    \          '0' => result.push('0'),\n            '1' => result.push('1'),\n  \
    \          _ => panic!(\"String contains invalid character: {}\", c),\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n \
    \   assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpk0fng89o.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpgzuanu6o.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c.to_digit(16).is_some())\n\
    \        .fold(String::new(), |mut acc, c| {\n            acc.push_str(&c.to_digit(16).unwrap().to_string());\n\
    \            acc\n        })\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpy86vvyzp.rs:9:15\n  |\n9 |\
    \         .fold(String::new(), |mut acc, c| {\n  |               ^^^^^^^^^^^^^\n\
    \  |               |\n  |               expected `&str`, found struct `String`\n\
    \  |               help: consider borrowing here: `&String::new()`\n\nerror[E0599]:\
    \ no method named `push_str` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpy86vvyzp.rs:10:17\n   |\n10 |             acc.push_str(&c.to_digit(16).unwrap().to_string());\n\
    \   |                 ^^^^^^^^ method not found in `&str`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '0' || c == '1')\n\
    \        .collect::<Vec<_>>()\n        .iter()\n        .map(|c| if c == '0' {\
    \ 0 } else { 1 })\n        .fold(0, |x, y| x ^ y)\n        .to_string()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpv5ubc0y7.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpv5ubc0y7.rs:8:35\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \              ^^ no implementation for `&char == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpv5ubc0y7.rs:11:23\n   |\n11 |         .map(|c| if c == '0' { 0\
    \ } else { 1 })\n   |                       ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv5ubc0y7.rs:6:21\n   |\n6  |       a.to_string() + b.to_string()\n\
    \   |  _____________________^\n7  | |         .chars()\n8  | |         .filter(|c|\
    \ c == '0' || c == '1')\n9  | |         .collect::<Vec<_>>()\n...  |\n12 | | \
    \        .fold(0, |x, y| x ^ y)\n13 | |         .to_string()\n   | |____________________^\
    \ expected `&str`, found struct `String`\n   |\nhelp: consider borrowing here\n\
    \   |\n6  ~     a.to_string() + &b.to_string()\n7  +         .chars()\n8  +  \
    \       .filter(|c| c == '0' || c == '1')\n9  +         .collect::<Vec<_>>()\n\
    10 +         .iter()\n11 +         .map(|c| if c == '0' { 0 } else { 1 })\n ...\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n        .to_string()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbyn7g444.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp03bgib9n.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp1zsfm2c6.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpxx026awl.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmp_nbzvzo4.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmp_nbzvzo4.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpb7ty0d_f.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpvz8ow6lr.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].chars().filter(|&x|\
    \ x == b[i..]).collect::<String>());\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpifczxh5v.rs:8:55\n  |\n8 |\
    \         res.push_str(&a[i..].chars().filter(|&x| x == b[i..]).collect::<String>());\n\
    \  |                                                       ^^^^^^ expected `char`,\
    \ found `str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpt3tzi59z.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpt3tzi59z.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n        .to_string()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpm2d4jy68.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmph8nwp2i9.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmph8nwp2i9.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '0' || c == '1')\n\
    \        .collect::<Vec<_>>()\n        .iter()\n        .map(|c| match c {\n \
    \           '0' => '1',\n            '1' => '0',\n            _ => panic!(\"String\
    \ contains invalid character: {}\", c),\n        })\n        .collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp90jneu6o.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp90jneu6o.rs:8:35\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \              ^^ no implementation for `&char == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp90jneu6o.rs:6:21\n\
    \   |\n6  |       a.to_string() + b.to_string()\n   |  _____________________^\n\
    7  | |         .chars()\n8  | |         .filter(|c| c == '0' || c == '1')\n9 \
    \ | |         .collect::<Vec<_>>()\n...  |\n15 | |         })\n16 | |        \
    \ .collect::<String>()\n   | |____________________________^ expected `&str`, found\
    \ struct `String`\n   |\nhelp: consider borrowing here\n   |\n6  ~     a.to_string()\
    \ + &b.to_string()\n7  +         .chars()\n8  +         .filter(|c| c == '0' ||\
    \ c == '1')\n9  +         .collect::<Vec<_>>()\n10 +         .iter()\n11 +   \
    \      .map(|c| match c {\n ...\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i\
    \ ^ b.as_bytes()[i as usize]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwe6s3yok.rs:8:29\n  |\n8 |\
    \         res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n  |               \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u8`\n\nerror[E0277]:\
    \ no implementation for `usize ^ u8`\n --> /tmp/tmpwe6s3yok.rs:8:27\n  |\n8 |\
    \         res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n  |               \
    \            ^ no implementation for `usize ^ u8`\n  |\n  = help: the trait `BitXor<u8>`\
    \ is not implemented for `usize`\n  = help: the following other types implement\
    \ trait `BitXor<Rhs>`:\n            <&'a i128 as BitXor<i128>>\n            <&'a\
    \ i16 as BitXor<i16>>\n            <&'a i32 as BitXor<i32>>\n            <&'a\
    \ i64 as BitXor<i64>>\n            <&'a i8 as BitXor<i8>>\n            <&'a isize\
    \ as BitXor<isize>>\n            <&'a u128 as BitXor<u128>>\n            <&'a\
    \ u16 as BitXor<u16>>\n          and 40 others\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n --> /tmp/tmpwe6s3yok.rs:8:23\n  |\n8 |      \
    \   res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n  |                     \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  |\n\
    \  = help: the trait `Index<usize>` is not implemented for `String`\n  = help:\
    \ the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '0' || c == '1')\n\
    \        .collect::<Vec<_>>()\n        .iter()\n        .map(|c| match c {\n \
    \           '0' => '1',\n            '1' => '0',\n            _ => panic!(\"Invalid\
    \ character in input\"),\n        })\n        .collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpf4ay1d0l.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpf4ay1d0l.rs:8:35\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \              ^^ no implementation for `&char == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf4ay1d0l.rs:6:21\n\
    \   |\n6  |       a.to_string() + b.to_string()\n   |  _____________________^\n\
    7  | |         .chars()\n8  | |         .filter(|c| c == '0' || c == '1')\n9 \
    \ | |         .collect::<Vec<_>>()\n...  |\n15 | |         })\n16 | |        \
    \ .collect::<String>()\n   | |____________________________^ expected `&str`, found\
    \ struct `String`\n   |\nhelp: consider borrowing here\n   |\n6  ~     a.to_string()\
    \ + &b.to_string()\n7  +         .chars()\n8  +         .filter(|c| c == '0' ||\
    \ c == '1')\n9  +         .collect::<Vec<_>>()\n10 +         .iter()\n11 +   \
    \      .map(|c| match c {\n ...\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].chars().filter(|c|\
    \ b[i] == c).collect::<String>());\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp269o4roy.rs:8:49\n\
    \  |\n8 |         res.push_str(&a[i..].chars().filter(|c| b[i] == c).collect::<String>());\n\
    \  |                                                 ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c.is_ascii())\n     \
    \   .fold(String::new(), |mut acc, c| {\n            acc.push_str(&format!(\"\
    {:02x}\", c ^ 0xff));\n            acc\n        })\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcltyog_6.rs:9:15\n  |\n9 |\
    \         .fold(String::new(), |mut acc, c| {\n  |               ^^^^^^^^^^^^^\n\
    \  |               |\n  |               expected `&str`, found struct `String`\n\
    \  |               help: consider borrowing here: `&String::new()`\n\nerror[E0599]:\
    \ no method named `push_str` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpcltyog_6.rs:10:17\n   |\n10 |             acc.push_str(&format!(\"\
    {:02x}\", c ^ 0xff));\n   |                 ^^^^^^^^ method not found in `&str`\n\
    \nerror[E0369]: no implementation for `char ^ {integer}`\n  --> /tmp/tmpcltyog_6.rs:10:47\n\
    \   |\n10 |             acc.push_str(&format!(\"{:02x}\", c ^ 0xff));\n   |  \
    \                                           - ^ ---- {integer}\n   |         \
    \                                    |\n   |                                 \
    \            char\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0369, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmptyq2vcfe.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmphm1klzjz.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '0' || c == '1')\n\
    \        .collect::<Vec<_>>()\n        .iter()\n        .map(|c| match c {\n \
    \           '0' => '1',\n            '1' => '0',\n            _ => panic!(\"Unexpected\
    \ character in input: {}\", c),\n        })\n        .collect::<String>()\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpgjp2izwu.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpgjp2izwu.rs:8:35\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \              ^^ no implementation for `&char == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgjp2izwu.rs:6:21\n\
    \   |\n6  |       a.to_string() + b.to_string()\n   |  _____________________^\n\
    7  | |         .chars()\n8  | |         .filter(|c| c == '0' || c == '1')\n9 \
    \ | |         .collect::<Vec<_>>()\n...  |\n15 | |         })\n16 | |        \
    \ .collect::<String>()\n   | |____________________________^ expected `&str`, found\
    \ struct `String`\n   |\nhelp: consider borrowing here\n   |\n6  ~     a.to_string()\
    \ + &b.to_string()\n7  +         .chars()\n8  +         .filter(|c| c == '0' ||\
    \ c == '1')\n9  +         .collect::<Vec<_>>()\n10 +         .iter()\n11 +   \
    \      .map(|c| match c {\n ...\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c.to_digit(16).is_some())\n\
    \        .fold(String::new(), |mut acc, c| {\n            acc.push_str(&c.to_digit(16).unwrap().to_string());\n\
    \            acc\n        })\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpz0x5cxmx.rs:9:15\n  |\n9 |\
    \         .fold(String::new(), |mut acc, c| {\n  |               ^^^^^^^^^^^^^\n\
    \  |               |\n  |               expected `&str`, found struct `String`\n\
    \  |               help: consider borrowing here: `&String::new()`\n\nerror[E0599]:\
    \ no method named `push_str` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpz0x5cxmx.rs:10:17\n   |\n10 |             acc.push_str(&c.to_digit(16).unwrap().to_string());\n\
    \   |                 ^^^^^^^^ method not found in `&str`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().map(|x|\
    \ if x == b[i] { x } else { 0 }).collect());\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmp3vbbuxlq.rs:8:30\n  |\n8 |         res.push_str(&a[i..].iter().map(|x|\
    \ if x == b[i] { x } else { 0 }).collect());\n  |                            \
    \  ^^^^ method not found in `str`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n --> /tmp/tmp3vbbuxlq.rs:8:53\n  |\n8 |         res.push_str(&a[i..].iter().map(|x|\
    \ if x == b[i] { x } else { 0 }).collect());\n  |                            \
    \                         ^^^^ `String` cannot be indexed by `usize`\n  |\n  =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n  = help: the\
    \ following other types implement trait `Index<Idx>`:\n            <String as\
    \ Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n       \
    \     <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpa39avzol.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect::<String>()\n\
    \  |                                           - ^ - char\n  |               \
    \                            |\n  |                                          \
    \ char\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpq3b6tuze.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpq3b6tuze.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp56bw4z7s.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a.chars()[i\
    \ as usize] ^ &b.chars()[i as usize]);\n    }\n    res\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n --> /tmp/tmp30ja_nts.rs:8:23\n\
    \  |\n8 |         res.push_str(&a.chars()[i as usize] ^ &b.chars()[i as usize]);\n\
    \  |                       ^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `Chars<'_>`\n --> /tmp/tmp30ja_nts.rs:8:48\n  |\n8 |  \
    \       res.push_str(&a.chars()[i as usize] ^ &b.chars()[i as usize]);\n  |  \
    \                                              ^^^^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpn8ni74id.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i\
    \ ^ b.as_bytes()[i as usize]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprj7mum7v.rs:8:29\n  |\n8 |\
    \         res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n  |               \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u8`\n\nerror[E0277]:\
    \ no implementation for `usize ^ u8`\n --> /tmp/tmprj7mum7v.rs:8:27\n  |\n8 |\
    \         res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n  |               \
    \            ^ no implementation for `usize ^ u8`\n  |\n  = help: the trait `BitXor<u8>`\
    \ is not implemented for `usize`\n  = help: the following other types implement\
    \ trait `BitXor<Rhs>`:\n            <&'a i128 as BitXor<i128>>\n            <&'a\
    \ i16 as BitXor<i16>>\n            <&'a i32 as BitXor<i32>>\n            <&'a\
    \ i64 as BitXor<i64>>\n            <&'a i8 as BitXor<i8>>\n            <&'a isize\
    \ as BitXor<isize>>\n            <&'a u128 as BitXor<u128>>\n            <&'a\
    \ u16 as BitXor<u16>>\n          and 40 others\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n --> /tmp/tmprj7mum7v.rs:8:23\n  |\n8 |      \
    \   res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n  |                     \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  |\n\
    \  = help: the trait `Index<usize>` is not implemented for `String`\n  = help:\
    \ the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp4wxi91rt.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpc15c66hp.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result .= if *a != *b { 1 } else { 0 };\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `=`\n --> /tmp/tmp7487ps_h.rs:8:17\n  |\n8 | \
    \        result .= if *a != *b { 1 } else { 0 };\n  |                 ^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n --> /tmp/tmp7487ps_h.rs:8:22\n  |\n8 |\
    \         result .= if *a != *b { 1 } else { 0 };\n  |                      ^^\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmp7487ps_h.rs:8:28\n\
    \  |\n8 |         result .= if *a != *b { 1 } else { 0 };\n  |               \
    \             ^^\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7487ps_h.rs:8:33\n\
    \  |\n8 |         result .= if *a != *b { 1 } else { 0 };\n  |               \
    \                  ^- help: try using a conversion method: `.to_string()`\n  |\
    \                                 |\n  |                                 expected\
    \ struct `String`, found integer\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7487ps_h.rs:8:44\n\
    \  |\n8 |         result .= if *a != *b { 1 } else { 0 };\n  |               \
    \                             ^- help: try using a conversion method: `.to_string()`\n\
    \  |                                            |\n  |                       \
    \                     expected struct `String`, found integer\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for &c in &a { res.push(c); }\n    for &c in &b\
    \ { res.push(c); }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpfn8_0q_u.rs:7:15\n\
    \  |\n7 |     for &c in &a { res.push(c); }\n  |               ^^ `&String` is\
    \ not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpfn8_0q_u.rs:8:15\n\
    \  |\n8 |     for &c in &b { res.push(c); }\n  |               ^^ `&String` is\
    \ not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpamk1ur40.rs:8:21\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpamk1ur40.rs:8:28\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                            ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxkfu6p5p.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpxkfu6p5p.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().map(|x|\
    \ if x == b[i] { x } else { 0 }).collect::<String>());\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmp9oqr9929.rs:8:30\n  |\n8 |         res.push_str(&a[i..].iter().map(|x|\
    \ if x == b[i] { x } else { 0 }).collect::<String>());\n  |                  \
    \            ^^^^ method not found in `str`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n --> /tmp/tmp9oqr9929.rs:8:53\n  |\n8 |      \
    \   res.push_str(&a[i..].iter().map(|x| if x == b[i] { x } else { 0 }).collect::<String>());\n\
    \  |                                                     ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpiske0fti.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '1')\n        .collect::<String>()\n\
    \        .iter()\n        .cloned()\n        .fold(String::new(), |mut acc, c|\
    \ {\n            acc.push_str(&c.to_string());\n            acc\n        })\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp_q5e6bt6.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '1')\n  |                       ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp_q5e6bt6.rs:10:10\n   |\n10 |         .iter()\n   |          ^^^^ method\
    \ not found in `String`\n   |\nhelp: because of the in-memory representation of\
    \ `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \   |\n10 |         .chars()\n   |          ~~~~~\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp2hqrc_4m.rs:8:21\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp2hqrc_4m.rs:8:28\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                            ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&b|\
    \ b == '1').collect::<String>());\n    }\n    for i in 0..b.len() {\n        res.push_str(&b[i..].iter().filter(|&a|\
    \ a == '1').collect::<String>());\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmpkorauran.rs:8:30\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&b|\
    \ b == '1').collect::<String>());\n  |                              ^^^^ method\
    \ not found in `str`\n\nerror[E0599]: no method named `iter` found for type `str`\
    \ in the current scope\n  --> /tmp/tmpkorauran.rs:11:30\n   |\n11 |         res.push_str(&b[i..].iter().filter(|&a|\
    \ a == '1').collect::<String>());\n   |                              ^^^^ method\
    \ not found in `str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmp_n84wuu2.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmp_n84wuu2.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpdq4ku4u2.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpdq4ku4u2.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp2ky4wpn8.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpo8djgeqn.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpomnbm4gt.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpomnbm4gt.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a & &b {\n        if *c != '0' {\n\
    \            result.push(*c);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmp5w8rx94h.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpi_ekxncc.rs:8:21\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpi_ekxncc.rs:8:28\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                            ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].chars().filter(|c|\
    \ b[i] == c).collect::<String>());\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp5pjp_ii3.rs:8:49\n\
    \  |\n8 |         res.push_str(&a[i..].chars().filter(|c| b[i] == c).collect::<String>());\n\
    \  |                                                 ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpom86wtoe.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpeenlx12u.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp9er5ybz2.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a.chars()\n\
    \            .skip(i)\n            .take(b.len())\n            .map(|c| match\
    \ c {\n                b'0' => b'1',\n                b'1' => b'0',\n        \
    \        _ => panic!(\"Unexpected character in input: {}\", c),\n            })\n\
    \            .collect::<String>());\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpej5o04m7.rs:12:17\n   |\n\
    11 |             .map(|c| match c {\n   |                            - this expression\
    \ has type `char`\n12 |                 b'0' => b'1',\n   |                 ^^^^\
    \ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpej5o04m7.rs:13:17\n\
    \   |\n11 |             .map(|c| match c {\n   |                            -\
    \ this expression has type `char`\n12 |                 b'0' => b'1',\n13 |  \
    \               b'1' => b'0',\n   |                 ^^^^ expected `char`, found\
    \ `u8`\n\nerror[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `u8`\n    --> /tmp/tmpej5o04m7.rs:16:14\n     |\n16  \
    \ |             .collect::<String>());\n     |              ^^^^^^^ value of type\
    \ `String` cannot be built from `std::iter::Iterator<Item=u8>`\n     |\n     =\
    \ help: the trait `FromIterator<u8>` is not implemented for `String`\n     = help:\
    \ the following other types implement trait `FromIterator<A>`:\n             \
    \  <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i\
    \ ^ b.as_bytes()[i as usize]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbyrx89aw.rs:8:29\n  |\n8 |\
    \         res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n  |               \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u8`\n\nerror[E0277]:\
    \ no implementation for `usize ^ u8`\n --> /tmp/tmpbyrx89aw.rs:8:27\n  |\n8 |\
    \         res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n  |               \
    \            ^ no implementation for `usize ^ u8`\n  |\n  = help: the trait `BitXor<u8>`\
    \ is not implemented for `usize`\n  = help: the following other types implement\
    \ trait `BitXor<Rhs>`:\n            <&'a i128 as BitXor<i128>>\n            <&'a\
    \ i16 as BitXor<i16>>\n            <&'a i32 as BitXor<i32>>\n            <&'a\
    \ i64 as BitXor<i64>>\n            <&'a i8 as BitXor<i8>>\n            <&'a isize\
    \ as BitXor<isize>>\n            <&'a u128 as BitXor<u128>>\n            <&'a\
    \ u16 as BitXor<u16>>\n          and 40 others\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n --> /tmp/tmpbyrx89aw.rs:8:23\n  |\n8 |      \
    \   res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n  |                     \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  |\n\
    \  = help: the trait `Index<usize>` is not implemented for `String`\n  = help:\
    \ the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdw0jmann.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpdw0jmann.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmple1jnxil.rs:8:30\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                              ^^^^ method\
    \ not found in `str`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \ --> /tmp/tmple1jnxil.rs:8:54\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                                      \
    \                ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n  = help: the following\
    \ other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        if a[i] != b[i]\
    \ {\n            res.push_str(&format!(\"{}\", a[i] ^ b[i]));\n        } else\
    \ {\n            res.push(a[i]);\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp5y1w6ywd.rs:8:12\n\
    \  |\n8 |         if a[i] != b[i] {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp5y1w6ywd.rs:8:20\n\
    \  |\n8 |         if a[i] != b[i] {\n  |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp5y1w6ywd.rs:9:41\n\
    \  |\n9 |             res.push_str(&format!(\"{}\", a[i] ^ b[i]));\n  |      \
    \                                   ^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpp7mwsdxr.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpynbwb3j7.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '0' || c == '1')\n\
    \        .fold(String::new(), |mut acc, c| {\n            acc.push_str(&c.to_string());\n\
    \            acc.push('0');\n            acc\n        })\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpqtj6db39.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpqtj6db39.rs:8:35\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \              ^^ no implementation for `&char == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqtj6db39.rs:6:21\n\
    \   |\n6  |       a.to_string() + b.to_string()\n   |  _____________________^\n\
    7  | |         .chars()\n8  | |         .filter(|c| c == '0' || c == '1')\n9 \
    \ | |         .fold(String::new(), |mut acc, c| {\n...  |\n13 | |         })\n\
    14 | |         .to_string()\n   | |____________________^ expected `&str`, found\
    \ struct `String`\n   |\nhelp: consider borrowing here\n   |\n6  ~     a.to_string()\
    \ + &b.to_string()\n7  +         .chars()\n8  +         .filter(|c| c == '0' ||\
    \ c == '1')\n9  +         .fold(String::new(), |mut acc, c| {\n10 +          \
    \   acc.push_str(&c.to_string());\n11 +             acc.push('0');\n ...\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp8slgpkhh.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp4sm4idcb.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result .push((a ^ b) as char);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpa8_8f6i7.rs:8:25\n\
    \  |\n8 |         result .push((a ^ b) as char);\n  |                       -\
    \ ^ - char\n  |                       |\n  |                       char\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpjeuv4ujh.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for &c in a.chars().zip(b.chars()) {\n       \
    \ if *c != *c {\n            res.push(*c);\n        }\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzoxj644l.rs:7:9\n  |\n7 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        *result += *a ^ *b;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmpg4ruk1mw.rs:8:20\n\
    \  |\n8 |         *result += *a ^ *b;\n  |                    ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n --> /tmp/tmpg4ruk1mw.rs:8:25\n  |\n8 |\
    \         *result += *a ^ *b;\n  |                         ^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp4gseus3u.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for &c in a.chars().zip(b.chars()) {\n       \
    \ res.push_str(c.0);\n        res.push_str(c.1);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkct4s9av.rs:7:9\n  |\n7 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpii3r27du.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpii3r27du.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].chars().filter(|&c|\
    \ c == '1').count() as char);\n    }\n    for i in 0..b.len() {\n        res.push_str(&b[i..].chars().filter(|&c|\
    \ c == '1').count() as char);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpij4n7y87.rs:8:22\n  |\n8 |\
    \         res.push_str(&a[i..].chars().filter(|&c| c == '1').count() as char);\n\
    \  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpij4n7y87.rs:11:22\n\
    \   |\n11 |         res.push_str(&b[i..].chars().filter(|&c| c == '1').count()\
    \ as char);\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0606]: casting `&usize` as `char` is\
    \ invalid\n --> /tmp/tmpij4n7y87.rs:8:22\n  |\n8 |         res.push_str(&a[i..].chars().filter(|&c|\
    \ c == '1').count() as char);\n  |                      ---------------------------------------------^^^^^^^^\n\
    \  |                      |\n  |                      cannot cast `&usize` as\
    \ `char`\n  |                      help: dereference the expression: `*&a[i..].chars().filter(|&c|\
    \ c == '1').count()`\n\nerror[E0606]: casting `&usize` as `char` is invalid\n\
    \  --> /tmp/tmpij4n7y87.rs:11:22\n   |\n11 |         res.push_str(&b[i..].chars().filter(|&c|\
    \ c == '1').count() as char);\n   |                      ---------------------------------------------^^^^^^^^\n\
    \   |                      |\n   |                      cannot cast `&usize` as\
    \ `char`\n   |                      help: dereference the expression: `*&b[i..].chars().filter(|&c|\
    \ c == '1').count()`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0606.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbi7ispxu.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmp51zo0h2e.rs:8:30\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                              ^^^^ method\
    \ not found in `str`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \ --> /tmp/tmp51zo0h2e.rs:8:54\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                                      \
    \                ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n  = help: the following\
    \ other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpex71kdj4.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpiv6sa_xn.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpy8byu491.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpy8byu491.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0cldj6ds.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for &c in &a { res.push(c); }\n    for &c in &b\
    \ { res.push(c); }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpst470y0h.rs:7:15\n\
    \  |\n7 |     for &c in &a { res.push(c); }\n  |               ^^ `&String` is\
    \ not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpst470y0h.rs:8:15\n\
    \  |\n8 |     for &c in &b { res.push(c); }\n  |               ^^ `&String` is\
    \ not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i\
    \ ^ b.as_bytes()[i as usize]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpe9l7kglv.rs:8:29\n  |\n8 |\
    \         res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n  |               \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u8`\n\nerror[E0277]:\
    \ no implementation for `usize ^ u8`\n --> /tmp/tmpe9l7kglv.rs:8:27\n  |\n8 |\
    \         res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n  |               \
    \            ^ no implementation for `usize ^ u8`\n  |\n  = help: the trait `BitXor<u8>`\
    \ is not implemented for `usize`\n  = help: the following other types implement\
    \ trait `BitXor<Rhs>`:\n            <&'a i128 as BitXor<i128>>\n            <&'a\
    \ i16 as BitXor<i16>>\n            <&'a i32 as BitXor<i32>>\n            <&'a\
    \ i64 as BitXor<i64>>\n            <&'a i8 as BitXor<i8>>\n            <&'a isize\
    \ as BitXor<isize>>\n            <&'a u128 as BitXor<u128>>\n            <&'a\
    \ u16 as BitXor<u16>>\n          and 40 others\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n --> /tmp/tmpe9l7kglv.rs:8:23\n  |\n8 |      \
    \   res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n  |                     \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  |\n\
    \  = help: the trait `Index<usize>` is not implemented for `String`\n  = help:\
    \ the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .map(|c| if c == '0' || c == '1'\
    \ { c == '0' ? '1' : '0' } else { c })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `'1'`\n\
    \ --> /tmp/tmpn72vwckh.rs:8:55\n  |\n8 |         .map(|c| if c == '0' || c ==\
    \ '1' { c == '0' ? '1' : '0' } else { c })\n  |                              \
    \                         ^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror[E0277]: a value of type `&str` cannot be built from an iterator over elements\
    \ of type `_`\n    --> /tmp/tmpn72vwckh.rs:9:10\n     |\n9    |         .collect()\n\
    \     |          ^^^^^^^ value of type `&str` cannot be built from `std::iter::Iterator<Item=_>`\n\
    \     |\n     = help: the trait `FromIterator<_>` is not implemented for `&str`\n\
    \     = help: the following other types implement trait `FromIterator<A>`:\n \
    \              <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        if a[i] != b[i]\
    \ {\n            result.push('a');\n        } else {\n            result.push('0');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpfcs5sroo.rs:8:12\n\
    \  |\n8 |         if a[i] != b[i] {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpfcs5sroo.rs:8:20\n\
    \  |\n8 |         if a[i] != b[i] {\n  |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp479ibbty.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].chars().filter(|c|\
    \ b[i..].contains(&c)).collect::<String>());\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpz6bg9_5o.rs:8:65\n\
    \     |\n8    |         res.push_str(&a[i..].chars().filter(|c| b[i..].contains(&c)).collect::<String>());\n\
    \     |                                                        -------- ^^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n     |                             \
    \                           |\n     |                                        \
    \                required by a bound introduced by this call\n     |\n     = help:\
    \ the trait `Fn<(char,)>` is not implemented for `char`\n     = help: the trait\
    \ `Pattern<'a>` is implemented for `char`\n     = note: required because of the\
    \ requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `&&char`\nnote:\
    \ required by a bound in `core::str::<impl str>::contains`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '0' || c == '1')\n\
    \        .fold(String::new(), |mut acc, c| {\n            acc.push_str(&c.to_string());\n\
    \            acc.push('0');\n            acc\n        })\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp1dis4bp7.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp1dis4bp7.rs:8:35\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \              ^^ no implementation for `&char == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1dis4bp7.rs:6:21\n\
    \   |\n6  |       a.to_string() + b.to_string()\n   |  _____________________^\n\
    7  | |         .chars()\n8  | |         .filter(|c| c == '0' || c == '1')\n9 \
    \ | |         .fold(String::new(), |mut acc, c| {\n...  |\n13 | |         })\n\
    14 | |         .to_string()\n   | |____________________^ expected `&str`, found\
    \ struct `String`\n   |\nhelp: consider borrowing here\n   |\n6  ~     a.to_string()\
    \ + &b.to_string()\n7  +         .chars()\n8  +         .filter(|c| c == '0' ||\
    \ c == '1')\n9  +         .fold(String::new(), |mut acc, c| {\n10 +          \
    \   acc.push_str(&c.to_string());\n11 +             acc.push('0');\n ...\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result .= if *a != *b { 1 } else { 0 };\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `=`\n --> /tmp/tmppyz33vx2.rs:8:17\n  |\n8 | \
    \        result .= if *a != *b { 1 } else { 0 };\n  |                 ^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n --> /tmp/tmppyz33vx2.rs:8:22\n  |\n8 |\
    \         result .= if *a != *b { 1 } else { 0 };\n  |                      ^^\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmppyz33vx2.rs:8:28\n\
    \  |\n8 |         result .= if *a != *b { 1 } else { 0 };\n  |               \
    \             ^^\n\nerror[E0308]: mismatched types\n --> /tmp/tmppyz33vx2.rs:8:33\n\
    \  |\n8 |         result .= if *a != *b { 1 } else { 0 };\n  |               \
    \                  ^- help: try using a conversion method: `.to_string()`\n  |\
    \                                 |\n  |                                 expected\
    \ struct `String`, found integer\n\nerror[E0308]: mismatched types\n --> /tmp/tmppyz33vx2.rs:8:44\n\
    \  |\n8 |         result .= if *a != *b { 1 } else { 0 };\n  |               \
    \                             ^- help: try using a conversion method: `.to_string()`\n\
    \  |                                            |\n  |                       \
    \                     expected struct `String`, found integer\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        if a[i] != b[i]\
    \ {\n            result.push('a');\n        } else {\n            result.push('0');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpn5ydwuo_.rs:8:12\n\
    \  |\n8 |         if a[i] != b[i] {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpn5ydwuo_.rs:8:20\n\
    \  |\n8 |         if a[i] != b[i] {\n  |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpradyx_0t.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpcg2x4el7.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '0' || c == '1')\n\
    \        .fold(String::new(), |mut acc, c| {\n            acc.push_str(&c ^ &c.to_string());\n\
    \            acc\n        })\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpdn5knpl9.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpdn5knpl9.rs:8:35\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \              ^^ no implementation for `&char == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdn5knpl9.rs:9:15\n\
    \  |\n9 |         .fold(String::new(), |mut acc, c| {\n  |               ^^^^^^^^^^^^^\n\
    \  |               |\n  |               expected `&str`, found struct `String`\n\
    \  |               help: consider borrowing here: `&String::new()`\n\nerror[E0599]:\
    \ no method named `push_str` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpdn5knpl9.rs:10:17\n   |\n10 |             acc.push_str(&c ^ &c.to_string());\n\
    \   |                 ^^^^^^^^ method not found in `&str`\n\nerror[E0369]: no\
    \ implementation for `&char ^ &String`\n  --> /tmp/tmpdn5knpl9.rs:10:29\n   |\n\
    10 |             acc.push_str(&c ^ &c.to_string());\n   |                    \
    \      -- ^ -------------- &String\n   |                          |\n   |    \
    \                      &char\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a & &b {\n        if *c != '0' {\n\
    \            result.push(*c);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpb7d8ms0j.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result .push((a ^ b) as char);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp8_7ymhyu.rs:8:25\n\
    \  |\n8 |         result .push((a ^ b) as char);\n  |                       -\
    \ ^ - char\n  |                       |\n  |                       char\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpqvf_m468.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp3a4n_x2g.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpgggt_mrz.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpgggt_mrz.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpplo47kqg.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpiyaejg5_.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp17wbipl5.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmplong55zu.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpnk6f7i70.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpj40_x69z.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpj40_x69z.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].chars().filter(|&c|\
    \ b[i..].chars().any(|&c| c == c)).collect::<String>());\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpo_rfb_pd.rs:8:70\n  |\n8 |\
    \         res.push_str(&a[i..].chars().filter(|&c| b[i..].chars().any(|&c| c ==\
    \ c)).collect::<String>());\n  |                                             \
    \                         ^--\n  |                                           \
    \                           ||\n  |                                          \
    \                            |expected due to this\n  |                      \
    \                                                expected `char`, found reference\n\
    \  |                                                                      help:\
    \ did you mean `c`: `&char`\n  |\n  = note:   expected type `char`\n         \
    \ found reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        if a[i] != b[i]\
    \ {\n            res.push_str(&format!(\"{}\", a[i] ^ b[i]));\n        } else\
    \ {\n            res.push_str(&format!(\"{}\", a[i]));\n        }\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpmbjcrcqf.rs:8:12\n\
    \  |\n8 |         if a[i] != b[i] {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpmbjcrcqf.rs:8:20\n\
    \  |\n8 |         if a[i] != b[i] {\n  |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpmbjcrcqf.rs:9:41\n\
    \  |\n9 |             res.push_str(&format!(\"{}\", a[i] ^ b[i]));\n  |      \
    \                                   ^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpvadz4ki_.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpybwea5fb.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp3i1uqkip.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '0' || c == '1')\n\
    \        .collect::<String>()\n        .iter()\n        .map(|c| if c == '0' {\
    \ 0 } else { 1 })\n        .fold(0, |x, y| x ^ y)\n        .to_string()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpxpu5qu3r.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpxpu5qu3r.rs:8:35\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \              ^^ no implementation for `&char == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0599]: no method named `iter` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpxpu5qu3r.rs:10:10\n   |\n\
    10 |         .iter()\n   |          ^^^^ method not found in `String`\n   |\n\
    help: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n   |\n10 |         .chars()\n\
    \   |          ~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpsz2r4602.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpsd5hhwp_.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].chars().filter(|c|\
    \ b[c..].is_empty()).collect::<String>());\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeFrom<&char>`\n\
    \ --> /tmp/tmpjsb7_pbk.rs:8:49\n  |\n8 |         res.push_str(&a[i..].chars().filter(|c|\
    \ b[c..].is_empty()).collect::<String>());\n  |                              \
    \                   ^^^^^^ `String` cannot be indexed by `RangeFrom<&char>`\n\
    \  |\n  = help: the trait `Index<RangeFrom<&char>>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpzc6vptf7.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpthe2771j.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpv490z2an.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        if a[i] != b[i]\
    \ {\n            result.push('a');\n        } else {\n            result.push('0');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpkcm4s7jd.rs:8:12\n\
    \  |\n8 |         if a[i] != b[i] {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpkcm4s7jd.rs:8:20\n\
    \  |\n8 |         if a[i] != b[i] {\n  |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpkiyl5g8h.rs:8:21\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpkiyl5g8h.rs:8:28\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                            ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '0' || c == '1')\n\
    \        .fold(String::new(), |mut acc, c| {\n            acc.push_str(&c ^ &c.to_string());\n\
    \            acc\n        })\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpfw2wjiot.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpfw2wjiot.rs:8:35\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \              ^^ no implementation for `&char == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfw2wjiot.rs:9:15\n\
    \  |\n9 |         .fold(String::new(), |mut acc, c| {\n  |               ^^^^^^^^^^^^^\n\
    \  |               |\n  |               expected `&str`, found struct `String`\n\
    \  |               help: consider borrowing here: `&String::new()`\n\nerror[E0599]:\
    \ no method named `push_str` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpfw2wjiot.rs:10:17\n   |\n10 |             acc.push_str(&c ^ &c.to_string());\n\
    \   |                 ^^^^^^^^ method not found in `&str`\n\nerror[E0369]: no\
    \ implementation for `&char ^ &String`\n  --> /tmp/tmpfw2wjiot.rs:10:29\n   |\n\
    10 |             acc.push_str(&c ^ &c.to_string());\n   |                    \
    \      -- ^ -------------- &String\n   |                          |\n   |    \
    \                      &char\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&b|\
    \ b == '1').collect::<String>());\n    }\n    for i in 0..b.len() {\n        res.push_str(&b[i..].iter().filter(|&a|\
    \ a == '1').collect::<String>());\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmp3h59xpgy.rs:8:30\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&b|\
    \ b == '1').collect::<String>());\n  |                              ^^^^ method\
    \ not found in `str`\n\nerror[E0599]: no method named `iter` found for type `str`\
    \ in the current scope\n  --> /tmp/tmp3h59xpgy.rs:11:30\n   |\n11 |         res.push_str(&b[i..].iter().filter(|&a|\
    \ a == '1').collect::<String>());\n   |                              ^^^^ method\
    \ not found in `str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '1')\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .fold(String::new(), |mut acc, x| {\n            acc.push_str(&x.to_string());\n\
    \            acc\n        })\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmprxmllkz9.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '1')\n  |                       ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprxmllkz9.rs:11:15\n   |\n11 |         .fold(String::new(),\
    \ |mut acc, x| {\n   |               ^^^^^^^^^^^^^\n   |               |\n   |\
    \               expected `&str`, found struct `String`\n   |               help:\
    \ consider borrowing here: `&String::new()`\n\nerror[E0599]: no method named `push_str`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmprxmllkz9.rs:12:17\n\
    \   |\n12 |             acc.push_str(&x.to_string());\n   |                 ^^^^^^^^\
    \ method not found in `&str`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpe0e3xpa7.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpfazqw8cu.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_owned()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp9qat3b21.rs:7:25\n\
    \  |\n7 |         .map(|(a, b)| a ^ b)\n  |                       - ^ - char\n\
    \  |                       |\n  |                       char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '0' || c == '1')\n\
    \        .fold(String::new(), |mut acc, c| {\n            acc.push_str(&c ^ &c.to_string());\n\
    \            acc\n        })\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp7mncz_ny.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp7mncz_ny.rs:8:35\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \              ^^ no implementation for `&char == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7mncz_ny.rs:9:15\n\
    \  |\n9 |         .fold(String::new(), |mut acc, c| {\n  |               ^^^^^^^^^^^^^\n\
    \  |               |\n  |               expected `&str`, found struct `String`\n\
    \  |               help: consider borrowing here: `&String::new()`\n\nerror[E0599]:\
    \ no method named `push_str` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmp7mncz_ny.rs:10:17\n   |\n10 |             acc.push_str(&c ^ &c.to_string());\n\
    \   |                 ^^^^^^^^ method not found in `&str`\n\nerror[E0369]: no\
    \ implementation for `&char ^ &String`\n  --> /tmp/tmp7mncz_ny.rs:10:29\n   |\n\
    10 |             acc.push_str(&c ^ &c.to_string());\n   |                    \
    \      -- ^ -------------- &String\n   |                          |\n   |    \
    \                      &char\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '0' || c == '1')\n\
    \        .fold(String::new(), |mut acc, c| {\n            acc.push_str(&c.to_string());\n\
    \            acc.push('0');\n            acc\n        })\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpsdme0sbj.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpsdme0sbj.rs:8:35\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \              ^^ no implementation for `&char == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdme0sbj.rs:6:21\n\
    \   |\n6  |       a.to_string() + b.to_string()\n   |  _____________________^\n\
    7  | |         .chars()\n8  | |         .filter(|c| c == '0' || c == '1')\n9 \
    \ | |         .fold(String::new(), |mut acc, c| {\n...  |\n13 | |         })\n\
    14 | |         .to_string()\n   | |____________________^ expected `&str`, found\
    \ struct `String`\n   |\nhelp: consider borrowing here\n   |\n6  ~     a.to_string()\
    \ + &b.to_string()\n7  +         .chars()\n8  +         .filter(|c| c == '0' ||\
    \ c == '1')\n9  +         .fold(String::new(), |mut acc, c| {\n10 +          \
    \   acc.push_str(&c.to_string());\n11 +             acc.push('0');\n ...\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpqygn2y6l.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmptpp_4jli.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpsz_swjke.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&b|\
    \ b == '1').collect::<String>());\n    }\n    for i in 0..b.len() {\n        res.push_str(&b[i..].iter().filter(|&a|\
    \ a == '1').collect::<String>());\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmpkekvqq3k.rs:8:30\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&b|\
    \ b == '1').collect::<String>());\n  |                              ^^^^ method\
    \ not found in `str`\n\nerror[E0599]: no method named `iter` found for type `str`\
    \ in the current scope\n  --> /tmp/tmpkekvqq3k.rs:11:30\n   |\n11 |         res.push_str(&b[i..].iter().filter(|&a|\
    \ a == '1').collect::<String>());\n   |                              ^^^^ method\
    \ not found in `str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpz4wgz0rg.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n        .to_owned()\n        .to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp1bklpinz.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpx9bri1pr.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpbl2k7dko.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpbl2k7dko.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp34_wzuve.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in a.chars().zip(b.chars()) {\n    \
    \    *result += if *c != *c { *c } else { 0 };\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoi3fdw_0.rs:7:9\n  |\n7 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        if a[i] != b[i]\
    \ {\n            result.push('a');\n        } else {\n            result.push('0');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpjy1huqkt.rs:8:12\n\
    \  |\n8 |         if a[i] != b[i] {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpjy1huqkt.rs:8:20\n\
    \  |\n8 |         if a[i] != b[i] {\n  |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .map(|c| match c {\n            '0'\
    \ | '1' => c,\n            _ => panic!(\"String contains invalid character: {}\"\
    , c),\n        })\n        .collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbj0gdwmi.rs:6:21\n   |\n\
    6  |       a.to_string() + b.to_string()\n   |  _____________________^\n7  | |\
    \         .chars()\n8  | |         .map(|c| match c {\n9  | |             '0'\
    \ | '1' => c,\n10 | |             _ => panic!(\"String contains invalid character:\
    \ {}\", c),\n11 | |         })\n12 | |         .collect::<String>()\n   | |____________________________^\
    \ expected `&str`, found struct `String`\n   |\nhelp: consider borrowing here\n\
    \   |\n6  ~     a.to_string() + &b.to_string()\n7  +         .chars()\n8  +  \
    \       .map(|c| match c {\n9  +             '0' | '1' => c,\n10 +           \
    \  _ => panic!(\"String contains invalid character: {}\", c),\n11 +         })\n\
    \ ...\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for &c in &a { res += &c ^ &b[c.to_digit(10).unwrap()];\
    \ }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpv6dpmp83.rs:7:15\n\
    \  |\n7 |     for &c in &a { res += &c ^ &b[c.to_digit(10).unwrap()]; }\n  | \
    \              ^^ `&String` is not an iterator\n  |\n  = help: the trait `Iterator`\
    \ is not implemented for `&String`\n  = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i..]).collect::<String>());\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmptds0ax84.rs:8:30\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i..]).collect::<String>());\n  |                              ^^^^ method\
    \ not found in `str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0qyb2ncx.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpqhnviydf.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect::<String>()\n\
    \  |                                           - ^ - char\n  |               \
    \                            |\n  |                                          \
    \ char\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for &c in a.chars().zip(b.chars()) {\n       \
    \ if *c != *c {\n            res.push_str(&format!(\"{:02x}\", *c));\n       \
    \ } else {\n            res.push_str(&format!(\"{:02x}\", *c ^ 1));\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcd3kd26x.rs:7:9\n  |\n7 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpd1hw6wkq.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect::<String>()\n\
    \  |                                           - ^ - char\n  |               \
    \                            |\n  |                                          \
    \ char\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmp9c07tctr.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmp9c07tctr.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpt5xzzg48.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for &c in a.chars().zip(b.chars()) {\n       \
    \ res.push_str(c.0 ^ c.1);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmppy983vne.rs:7:9\n  |\n7 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp_0ie3q6i.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpljygj6xl.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpm1rcvsx8.rs:8:21\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpm1rcvsx8.rs:8:28\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                            ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i\
    \ ^ b.len()]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpp21o_6hu.rs:8:23\n\
    \  |\n8 |         res.push_str(&a[i ^ b.len()]);\n  |                       ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpe3b0iny3.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpe3b0iny3.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpujq7bjjs.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwx6kp4ue.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpwx6kp4ue.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpei5053s7.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp_n8qckot.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp8sls7vdi.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpdb3jg1e6.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '0' || c == '1')\n\
    \        .collect::<Vec<_>>()\n        .iter()\n        .map(|c| if c == '0' {\
    \ 0 } else { 1 })\n        .fold(0, |acc, x| acc ^ x)\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp97fefreo.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp97fefreo.rs:8:35\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \              ^^ no implementation for `&char == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp97fefreo.rs:11:23\n   |\n11 |         .map(|c| if c == '0' { 0\
    \ } else { 1 })\n   |                       ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp97fefreo.rs:6:21\n   |\n6  |       a.to_string() + b.to_string()\n\
    \   |  _____________________^\n7  | |         .chars()\n8  | |         .filter(|c|\
    \ c == '0' || c == '1')\n9  | |         .collect::<Vec<_>>()\n...  |\n12 | | \
    \        .fold(0, |acc, x| acc ^ x)\n13 | |         .to_string()\n   | |____________________^\
    \ expected `&str`, found struct `String`\n   |\nhelp: consider borrowing here\n\
    \   |\n6  ~     a.to_string() + &b.to_string()\n7  +         .chars()\n8  +  \
    \       .filter(|c| c == '0' || c == '1')\n9  +         .collect::<Vec<_>>()\n\
    10 +         .iter()\n11 +         .map(|c| if c == '0' { 0 } else { 1 })\n ...\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpn99s_y15.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpn99s_y15.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpkcmd9cib.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_owned()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmphvpwarv_.rs:7:25\n\
    \  |\n7 |         .map(|(a, b)| a ^ b)\n  |                       - ^ - char\n\
    \  |                       |\n  |                       char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmp5zvvod5b.rs:8:30\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                              ^^^^ method\
    \ not found in `str`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \ --> /tmp/tmp5zvvod5b.rs:8:54\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                                      \
    \                ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n  = help: the following\
    \ other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpqefvupwz.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for &c in &a { res.push(c); }\n    for &c in &b\
    \ { res.push(c); }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmphrtzp1i3.rs:7:15\n\
    \  |\n7 |     for &c in &a { res.push(c); }\n  |               ^^ `&String` is\
    \ not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmphrtzp1i3.rs:8:15\n\
    \  |\n8 |     for &c in &b { res.push(c); }\n  |               ^^ `&String` is\
    \ not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_owned()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp2k967zhm.rs:7:25\n\
    \  |\n7 |         .map(|(a, b)| a ^ b)\n  |                       - ^ - char\n\
    \  |                       |\n  |                       char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpkdbmyi2v.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '0' || c == '1')\n\
    \        .collect::<Vec<_>>()\n        .iter()\n        .map(|c| match c {\n \
    \           '0' => '1',\n            '1' => '0',\n            _ => panic!(\"Unexpected\
    \ character in input: {}\", c),\n        })\n        .collect::<String>()\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpbrqkddkw.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpbrqkddkw.rs:8:35\n\
    \  |\n8 |         .filter(|c| c == '0' || c == '1')\n  |                     \
    \              ^^ no implementation for `&char == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbrqkddkw.rs:6:21\n\
    \   |\n6  |       a.to_string() + b.to_string()\n   |  _____________________^\n\
    7  | |         .chars()\n8  | |         .filter(|c| c == '0' || c == '1')\n9 \
    \ | |         .collect::<Vec<_>>()\n...  |\n15 | |         })\n16 | |        \
    \ .collect::<String>()\n   | |____________________________^ expected `&str`, found\
    \ struct `String`\n   |\nhelp: consider borrowing here\n   |\n6  ~     a.to_string()\
    \ + &b.to_string()\n7  +         .chars()\n8  +         .filter(|c| c == '0' ||\
    \ c == '1')\n9  +         .collect::<Vec<_>>()\n10 +         .iter()\n11 +   \
    \      .map(|c| match c {\n ...\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0z0_5bj6.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmp0z0_5bj6.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp5b9onlyn.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpqccoo6qg.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpqccoo6qg.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_owned()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpvulw64la.rs:7:25\n\
    \  |\n7 |         .map(|(a, b)| a ^ b)\n  |                       - ^ - char\n\
    \  |                       |\n  |                       char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp16y827bf.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpy5vfvk6o.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpd21xaf13.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmp2uruyw78.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmp2uruyw78.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n   \
    \     res.push_str(&format!(\"{:02x}\", a ^ b));\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp5erxpxte.rs:8:43\n\
    \  |\n8 |         res.push_str(&format!(\"{:02x}\", a ^ b));\n  |            \
    \                             - ^ - char\n  |                                \
    \         |\n  |                                         char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2fvkqft8.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmp2fvkqft8.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c != '0')\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| c ^ 1)\n        .collect::<String>()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpqdpt10ej.rs:8:23\n\
    \  |\n8 |         .filter(|c| c != '0')\n  |                       ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0369]:\
    \ no implementation for `&char ^ {integer}`\n  --> /tmp/tmpqdpt10ej.rs:11:20\n\
    \   |\n11 |         .map(|c| c ^ 1)\n   |                  - ^ - {integer}\n \
    \  |                  |\n   |                  &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqdpt10ej.rs:6:21\n   |\n6  |       a.to_string() + b.to_string()\n\
    \   |  _____________________^\n7  | |         .chars()\n8  | |         .filter(|c|\
    \ c != '0')\n9  | |         .collect::<Vec<_>>()\n10 | |         .iter()\n11 |\
    \ |         .map(|c| c ^ 1)\n12 | |         .collect::<String>()\n   | |____________________________^\
    \ expected `&str`, found struct `String`\n   |\nhelp: consider borrowing here\n\
    \   |\n6  ~     a.to_string() + &b.to_string()\n7  +         .chars()\n8  +  \
    \       .filter(|c| c != '0')\n9  +         .collect::<Vec<_>>()\n10 +       \
    \  .iter()\n11 +         .map(|c| c ^ 1)\n ...\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0369.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c.to_digit(16).is_some())\n\
    \        .fold(String::new(), |mut acc, c| {\n            acc.push_str(&c.to_digit(16).unwrap().to_string());\n\
    \            acc\n        })\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpi9tvdzu5.rs:9:15\n  |\n9 |\
    \         .fold(String::new(), |mut acc, c| {\n  |               ^^^^^^^^^^^^^\n\
    \  |               |\n  |               expected `&str`, found struct `String`\n\
    \  |               help: consider borrowing here: `&String::new()`\n\nerror[E0599]:\
    \ no method named `push_str` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpi9tvdzu5.rs:10:17\n   |\n10 |             acc.push_str(&c.to_digit(16).unwrap().to_string());\n\
    \   |                 ^^^^^^^^ method not found in `&str`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpavdv27wk.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmpmmorn5qe.rs:8:30\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                              ^^^^ method\
    \ not found in `str`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \ --> /tmp/tmpmmorn5qe.rs:8:54\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                                      \
    \                ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n  = help: the following\
    \ other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in a.chars().zip(b.chars()) {\n    \
    \    result.push((*c).xor(*c).to_string());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphpc7_89f.rs:7:9\n  |\n7 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpnq856rit.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpnq856rit.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp02wqtwsw.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpdeuilhbe.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoc5nukpz.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpoc5nukpz.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i\
    \ ^ b.len()]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpke62dz7z.rs:8:23\n\
    \  |\n8 |         res.push_str(&a[i ^ b.len()]);\n  |                       ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpp2bs66ms.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmppa4eogc5.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmpw2yna2jx.rs:8:30\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                              ^^^^ method\
    \ not found in `str`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \ --> /tmp/tmpw2yna2jx.rs:8:54\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                                      \
    \                ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n  = help: the following\
    \ other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpgv98tfi0.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect::<String>()\n\
    \  |                                           - ^ - char\n  |               \
    \                            |\n  |                                          \
    \ char\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmphrn7boxr.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmphrn7boxr.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
