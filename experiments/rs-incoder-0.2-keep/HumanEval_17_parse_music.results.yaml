name: HumanEval_17_parse_music
language: rust
results:
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9mkvbk14.rs:63:32\n   |\n\
    63 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9mkvbk14.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxtesjdfk.rs:63:26\n   |\n\
    63 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxtesjdfk.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = music_string.chars().nth(0).unwrap();\n   \
    \ let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length_index47\
    \ = 1;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp656l657s.rs:62:26\n   |\n\
    62 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp656l657s.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().map(|c|\
    \ match c {\n        'o' => 1,\n        'o|' => 2,\n        '.|' => 3,\n     \
    \   _ => 0,\n    });\n    let mut last_note = notes.last().unwrap();\n    notes.iter().for_each(|note|\
    \ {\n        if note != last_note {\n            beats.push(note);\n         \
    \   last_note = note;\n        } else {\n            beats.push(beats.last().unwrap()\
    \ + note);\n        }\n    });\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpmbdlpit4.rs:14:12\n\
    \   |\n14 |         'o|' => 2,\n   |            ^^^^^^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat: isize = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4\
    \ = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n\
    \    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let\
    \ mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut\
    \ current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13\
    \ = 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 =\
    \ 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n\
    \    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n  \
    \  let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let\
    \ mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut\
    \ current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26\
    \ = 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 =\
    \ 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n\
    \    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n  \
    \  let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let\
    \ mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut\
    \ current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39\
    \ = 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 =\
    \ 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n\
    \    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n  \
    \  let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let\
    \ mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut\
    \ current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52\
    \ = 0;\n    let mut current_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgti1u39v.rs:67:21\n   |\n\
    67 |     let mut current_\n   |                     ^ help: add `;` here\n68 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgti1u39v.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.last().unwrap();\n    let mut current_beat = 0;\n    let mut current_note_count\
    \ = 0;\n    for note in notes {\n        if note != current_note {\n         \
    \   beats.push(current_beat);\n            current_beat = 0;\n            current_note_count\
    \ = 0;\n            current_note = note;\n        }\n        current_note_count\
    \ += 1;\n        current_beat += 1;\n    }\n    beats.push(current_beat);\n  \
    \  beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpecjv9si4.rs:17:17\n\
    \   |\n17 |         if note != current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpecjv9si4.rs:21:28\n   |\n13 |     let mut current_note\
    \ = notes.last().unwrap();\n   |                            ---------------------\
    \ expected due to this value\n...\n21 |             current_note = note;\n   |\
    \                            ^^^^ expected `&str`, found `str`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = String::new();\n    let mut\
    \ current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octoctlen\
    \ = 0;\n    let mut current_note_octoctlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpl7a75vf4.rs:68:1\n  \
    \ |\n68 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2 = 0;\n\
    \    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n    let\
    \ mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let mut\
    \ current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut current_note_oct9\
    \ = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11 =\
    \ 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 = 0;\n\
    \    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n  \
    \  let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n    let\
    \ mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let mut\
    \ current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut current_note_oct22\
    \ = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24 =\
    \ 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 = 0;\n\
    \    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n  \
    \  let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n    let\
    \ mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let mut\
    \ current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut current_note_oct35\
    \ = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37 =\
    \ 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 = 0;\n\
    \    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n  \
    \  let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n    let\
    \ mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let mut\
    \ current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut current_note_oct48\
    \ = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50 =\
    \ 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 = 0;\n\
    \    let mut current_note_oct53 = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyzm6jskp.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = music_string.chars().nth(0).unwrap();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length_index47\
    \ = 1;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb2vt_6d_.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_index = 0;\n    let mut current_note_length_value\
    \ = 0;\n    let mut current_note_length_value_index = 0;\n    let mut current_note_length_value_value\
    \ = 0;\n    let mut current_note_length_value_value_index = 0;\n    let mut current_note_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n\n}\n\nfn main() {\n \
    \   let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf5nbmwzg.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7fz6n76z.rs:63:32\n   |\n\
    63 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7fz6n76z.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = music_string.chars().nth(1).unwrap();\n   \
    \ let mut current_note_length = 0;\n    for c in music_string.chars() {\n    \
    \    if c == ' ' {\n            current_note_length = 0;\n        } else {\n \
    \           current_note_length += 1;\n        }\n        if c == current_note\
    \ {\n            current_beat += 1;\n        } else {\n            beats.push(current_beat);\n\
    \            current_beat = 1;\n            current_note = c;\n            current_note_length\
    \ = 1;\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpcacwj2fq.rs:13:56\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().enumerate();\n\
    \    let mut current_note = 0;\n    let mut current_beat = 0;\n    let mut current_note_length\
    \ = 0;\n    for note in notes {\n        match note.value {\n            'o' =>\
    \ { beats.push(current_beat); current_beat = 0; current_note_length = 0; current_note\
    \ = note.index + 1 },\n            'o|' => { beats.push(current_beat); current_beat\
    \ = 0; current_note_length = note.index - current_note; current_note = note.index\
    \ + 1 },\n            '.|' => { beats.push(current_beat); current_beat = 0; current_note_length\
    \ = note.index - current_note; current_note = note.index + 1 },\n            _\
    \ => {}\n        }\n        current_note_length += 1;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp788fbs67.rs:19:16\n\
    \   |\n19 | ...'o|' => { beats.push(current_beat); current_beat = 0; current_note_length\
    \ = note.index - current_note; current_note = note.index + 1 },\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().collect::<Vec<char>>();\n    let mut current_note = 0;\n\
    \    let mut current_beat = 0;\n    let mut current_note_index = 0;\n    let mut\
    \ current_beat_length = 0;\n    while current_note_index < notes.len() {\n   \
    \     let note = notes[current_note_index];\n        if note == 'o' {\n      \
    \      if current_beat_length != 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_beat_length = 0;\n\
    \            }\n            current_note_index += 1;\n        } else if note ==\
    \ 'o|' {\n            if current_beat_length != 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_beat_length = 0;\n\
    \            }\n            current_note_index += 1;\n            current_beat\
    \ += 1;\n        } else if note == '.|' {\n            if current_beat_length\
    \ != 0 {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_beat_length = 0;\n            }\n            current_note_index\
    \ += 1;\n            current_beat += 1;\n            current_beat_length += 1;\n\
    \        } else {\n            current_beat_length += 1;\n        }\n    }\n \
    \   beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp0zxzh403.rs:26:30\n\
    \   |\n26 |         } else if note == 'o|' {\n   |                           \
    \   ^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.split_whitespace();\n\
    \    let mut last_note = notes.last().unwrap();\n    let mut last_beat = 0;\n\
    \    let mut last_beats_length = 0;\n    for note in notes {\n        if note\
    \ == last_note {\n            last_beats_length += 1;\n        } else {\n    \
    \        beats.push(last_beats_length);\n            last_beats_length = 1;\n\
    \            last_beat = 1;\n            last_note = note;\n        }\n    }\n\
    \    beats.push(last_beats_length);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "warning: variable `last_beat` is assigned to, but never used\n  --> /tmp/tmp8exxvu1t.rs:14:13\n\
    \   |\n14 |     let mut last_beat = 0;\n   |             ^^^^^^^^^\n   |\n   =\
    \ note: `#[warn(unused_variables)]` on by default\n   = note: consider using `_last_beat`\
    \ instead\n\nwarning: value assigned to `last_beat` is never read\n  --> /tmp/tmp8exxvu1t.rs:22:13\n\
    \   |\n22 |             last_beat = 1;\n   |             ^^^^^^^^^\n   |\n   =\
    \ note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmp8exxvu1t.rs:12:9\n\
    \   |\n12 |     let mut notes = music_string.split_whitespace();\n   |       \
    \  ----^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n   =\
    \ note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: use of moved value:\
    \ `notes`\n   --> /tmp/tmp8exxvu1t.rs:16:17\n    |\n12  |     let mut notes =\
    \ music_string.split_whitespace();\n    |         --------- move occurs because\
    \ `notes` has type `SplitWhitespace<'_>`, which does not implement the `Copy`\
    \ trait\n13  |     let mut last_note = notes.last().unwrap();\n    |         \
    \                      ------ `notes` moved due to this method call\n...\n16 \
    \ |     for note in notes {\n    |                 ^^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `notes`\n\nerror: aborting due to previous error; 3 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpahi25kk0.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpeslfzd8l.rs:63:11\n   |\n\
    63 |     let mu\n   |           ^ help: add `;` here\n64 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeslfzd8l.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut notes_len: usize = 0;\n    let mut notes_len2:\
    \ usize = 0;\n    let mut notes_len3: usize = 0;\n    let mut notes_len4: usize\
    \ = 0;\n    let mut notes_len5: usize = 0;\n    let mut notes_len6: usize = 0;\n\
    \    let mut notes_len7: usize = 0;\n    let mut notes_len8: usize = 0;\n    let\
    \ mut notes_len9: usize = 0;\n    let mut notes_len10: usize = 0;\n    let mut\
    \ notes_len11: usize = 0;\n    let mut notes_len12: usize = 0;\n    let mut notes_len13:\
    \ usize = 0;\n    let mut notes_len14: usize = 0;\n    let mut notes_len15: usize\
    \ = 0;\n    let mut notes_len16: usize = 0;\n    let mut notes_len17: usize =\
    \ 0;\n    let mut notes_len18: usize = 0;\n    let mut notes_len19: usize = 0;\n\
    \    let mut notes_len20: usize = 0;\n    let mut notes_len21: usize = 0;\n  \
    \  let mut notes_len22: usize = 0;\n    let mut notes_len23: usize = 0;\n    let\
    \ mut notes_len24: usize = 0;\n    let mut notes_len25: usize = 0;\n    let mut\
    \ notes_len26: usize = 0;\n    let mut notes_len27: usize = 0;\n    let mut notes_len28:\
    \ usize = 0;\n    let mut notes_len29: usize = 0;\n    let mut notes_len30: usize\
    \ = 0;\n    let mut notes_len31: usize = 0;\n    let mut notes_len32: usize =\
    \ 0;\n    let mut notes_len33: usize = 0;\n    let mut notes_len34: usize = 0;\n\
    \    let mut notes_len35: usize = 0;\n    let mut notes_len36: usize = 0;\n  \
    \  let mut notes_len37: usize = 0;\n    let mut notes_len38: usize = 0;\n    let\
    \ mut notes_len39: usize = 0;\n    let mut notes_len40: usize = 0;\n    let mut\
    \ notes_len4\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphv0ujqe_.rs:53:23\n   |\n\
    53 |     let mut notes_len4\n   |                       ^ help: add `;` here\n\
    54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphv0ujqe_.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_beats: isize = 0;\n    let mut current_note_index\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpjhz30cod.rs:63:1\n\
    \   |\n63 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut last_note = String::new();\n    let\
    \ mut last_beat = 0;\n    let mut last_beats: isize = 0;\n    let mut last_beats_idx\
    \ = 0;\n    let mut last_beats_idx2 = 0;\n    let mut last_beats_idx3 = 0;\n \
    \   let mut last_beats_idx4 = 0;\n    let mut last_beats_idx5 = 0;\n    let mut\
    \ last_beats_idx6 = 0;\n    let mut last_beats_idx7 = 0;\n    let mut last_beats_idx8\
    \ = 0;\n    let mut last_beats_idx9 = 0;\n    let mut last_beats_idx10 = 0;\n\
    \    let mut last_beats_idx11 = 0;\n    let mut last_beats_idx12 = 0;\n    let\
    \ mut last_beats_idx13 = 0;\n    let mut last_beats_idx14 = 0;\n    let mut last_beats_idx15\
    \ = 0;\n    let mut last_beats_idx16 = 0;\n    let mut last_beats_idx17 = 0;\n\
    \    let mut last_beats_idx18 = 0;\n    let mut last_beats_idx19 = 0;\n    let\
    \ mut last_beats_idx20 = 0;\n    let mut last_beats_idx21 = 0;\n    let mut last_beats_idx22\
    \ = 0;\n    let mut last_beats_idx23 = 0;\n    let mut last_beats_idx24 = 0;\n\
    \    let mut last_beats_idx25 = 0;\n    let mut last_beats_idx26 = 0;\n    let\
    \ mut last_beats_idx27 = 0;\n    let mut last_beats_idx28 = 0;\n    let mut last_beats_idx29\
    \ = 0;\n    let mut last_beats_idx30 = 0;\n    let mut last_beats_idx31 = 0;\n\
    \    let mut last_beats_idx32 = 0;\n    let mut last_beats_idx33 = 0;\n    let\
    \ mut last_beats_idx34 = 0;\n    let mut last_beats_idx35 = 0;\n    let mut last_beats_idx36\
    \ = 0;\n    let mut last_beats_idx37 = 0;\n    let mut last_beats_idx38 = 0;\n\
    \    let mut last_beats_idx39 = 0;\n    let mut last_beats_idx40 = 0;\n    let\
    \ mut last_beats_idx41 = 0;\n    let mut last_beats_idx42 = 0;\n    let mut last_beats_idx43\
    \ = 0;\n    let mut last_beats_idx44 = 0;\n    let mut last_beats_idx45 = 0;\n\
    \    let mut last_beats_idx46 = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpva6lr963.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = music_string.chars().nth(0).unwrap();\n\
    \    let mut current_note_length: isize = 0;\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmph4e6iytr.rs:62:1\n\
    \   |\n62 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_octave: isize = 0;\n    let mut current_note_is_octave = false;\n\
    \    let mut current_note_is_rest = false;\n    for c in music_string.chars()\
    \ {\n        match c {\n            'o' => {\n                if current_note_is_octave\
    \ {\n                    current_octave += 1;\n                    current_note_is_octave\
    \ = false;\n                } else {\n                    current_octave = 0;\n\
    \                    current_note_is_octave = true;\n                }\n     \
    \           beats.push(current_beat);\n                current_beat = 0;\n   \
    \             current_note = String::new();\n                current_note_is_octave\
    \ = false;\n                current_note_is_rest = false;\n            }\n   \
    \         '|' => {\n                if current_note_is_rest {\n              \
    \      current_octave += 1;\n                    current_note_is_rest = false;\n\
    \                } else {\n                    current_octave = 0;\n         \
    \           current_note_is_rest = true;\n                }\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_is_octave = false;\n                current_note_is_rest\
    \ = false;\n            }\n            c => {\n                current_note +=\
    \ c.to_string();\n            }\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2j82hikh.rs:48:33\n   |\n\
    48 |                 current_note += c.to_string();\n   |                    \
    \             ^^^^^^^^^^^^^\n   |                                 |\n   |    \
    \                             expected `&str`, found struct `String`\n   |   \
    \                              help: consider borrowing here: `&c.to_string()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ last_note = notes.last().unwrap();\n    let mut last_beat = 0;\n    let mut\
    \ last_beats: isize = 0;\n    for note in notes {\n        if note == last_note\
    \ {\n            last_beats += 1;\n        } else {\n            beats.push(last_beats);\n\
    \            last_beats = 0;\n            last_beats += 1;\n            last_note\
    \ = note;\n        }\n    }\n    beats.push(last_beats);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmp5luz26ox.rs:17:17\n\
    \   |\n17 |         if note == last_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5luz26ox.rs:23:25\n   |\n13 |     let mut last_note\
    \ = notes.last().unwrap();\n   |                         ---------------------\
    \ expected due to this value\n...\n23 |             last_note = note;\n   |  \
    \                       ^^^^ expected `&str`, found `str`\n   |\n   = note: expected\
    \ reference `&&str`\n              found reference `&str`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().enumerate();\n\
    \    let mut current_note = 0;\n    let mut current_beat = 0;\n    let mut current_note_is_last\
    \ = false;\n    let mut current_beat_is_last = false;\n    for note in notes {\n\
    \        let note = note.0;\n        let beat = note.1 as isize;\n        if note\
    \ == 'o' {\n            if current_note_is_last {\n                beats.push(current_beat);\n\
    \            }\n            current_note_is_last = true;\n            current_beat\
    \ = beat;\n            current_note = 0;\n        } else if note == '|' {\n  \
    \          if current_beat_is_last {\n                beats.push(current_beat);\n\
    \            }\n            current_beat_is_last = true;\n            current_beat\
    \ = beat;\n            current_note = 0;\n        } else if note == '.' {\n  \
    \          if current_beat_is_last {\n                beats.push(current_beat);\n\
    \            }\n            current_beat_is_last = true;\n            current_beat\
    \ = beat;\n            current_note = 0;\n        } else {\n            current_note\
    \ = note;\n            current_note_is_last = false;\n            current_beat_is_last\
    \ = false;\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp2c9ok0f3.rs:19:25\n   |\n19 |         let beat = note.1 as isize;\n\
    \   |                         ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2c9ok0f3.rs:20:20\n\
    \   |\n20 |         if note == 'o' {\n   |                    ^^^ expected `usize`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2c9ok0f3.rs:27:27\n\
    \   |\n27 |         } else if note == '|' {\n   |                           ^^^\
    \ expected `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2c9ok0f3.rs:34:27\n\
    \   |\n34 |         } else if note == '.' {\n   |                           ^^^\
    \ expected `usize`, found `char`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0610.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = music_string.chars().nth(0).unwrap();\n   \
    \ let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpotm_bltd.rs:62:32\n   |\n\
    62 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpotm_bltd.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = music_string.chars().nth(0).unwrap();\n\
    \    let mut current_note_length: isize = 0;\n    let mut last_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut last_note_length: isize = 0;\n    while current_note != last_note\
    \ {\n        if current_note == 'o' {\n            beats.push(current_beat);\n\
    \            current_beat += 4;\n            current_note_length = 4;\n      \
    \      last_note = music_string.chars().nth(1).unwrap();\n            last_note_length\
    \ = 1;\n        } else if current_note == 'o|' {\n            beats.push(current_beat);\n\
    \            current_beat += 2;\n            current_note_length = 2;\n      \
    \      last_note = music_string.chars().nth(1).unwrap();\n            last_note_length\
    \ = 1;\n        } else if current_note == '.|' {\n            beats.push(current_beat);\n\
    \            current_beat += 1;\n            current_note_length = 1;\n      \
    \      last_note = music_string.chars().nth(1).unwrap();\n            last_note_length\
    \ = 1;\n        } else {\n            assert!(current_note == ' ' || current_note\
    \ == '|');\n            current_beat += 1;\n            current_note_length =\
    \ 1;\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpb5b9z96e.rs:24:38\n\
    \   |\n24 |         } else if current_note == 'o|' {\n   |                   \
    \                   ^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    for c in music_string.chars() {\n        if c.is_whitespace() {\n\
    \            continue;\n        }\n        if c.is_ascii() {\n            if c.to_ascii_lowercase()\
    \ == 'o' {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n                current_note_len\
    \ = c.len_utf8();\n            } else {\n                current_note.push_str(&c.to_ascii_lowercase());\n\
    \                current_note_len = c.len_utf8();\n            }\n        } else\
    \ {\n            if c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_len = c.len_utf8();\n            } else {\n    \
    \            current_note.push_str(&c.to_ascii_lowercase());\n               \
    \ current_note_len = c.len_utf8();\n            }\n        }\n    }\n    beats.push(current_beat);\n\
    \    current_beat = 0;\n    current_note = String::new();\n    current_note_len\
    \ = music_string.len_utf8();\n    beats\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvi20auaq.rs:26:39\n   |\n\
    26 |                 current_note.push_str(&c.to_ascii_lowercase());\n   |   \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvi20auaq.rs:36:39\n\
    \   |\n36 |                 current_note.push_str(&c.to_ascii_lowercase());\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror[E0599]: no method named `len_utf8` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpvi20auaq.rs:44:37\n   |\n44 | \
    \    current_note_len = music_string.len_utf8();\n   |                       \
    \              ^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().enumerate().filter(|(_,\
    \ note)| note != 'o');\n    for note in notes {\n        let note = note.0;\n\
    \        let beat = note.chars().enumerate().filter(|(_, beat)| beat != '|').next().unwrap().0;\n\
    \        beats.push(beat);\n    }\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_8kexuyg.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != 'o');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0599]: no method named `chars`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmp_8kexuyg.rs:15:25\n\
    \   |\n15 |         let beat = note.chars().enumerate().filter(|(_, beat)| beat\
    \ != '|').next().unwrap().0;\n   |                         ^^^^^ method not found\
    \ in `usize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ap39srg.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = notes.next();\n    let mut current_beat = 0;\n    while let Some(note)\
    \ = current_note {\n        note = note.to_string();\n        if note == \"o\"\
    \ {\n            beats.push(current_beat);\n            current_beat = 0;\n  \
    \          current_note = notes.next();\n        } else if note == \"o|\" {\n\
    \            beats.push(current_beat);\n            current_beat = 0;\n      \
    \      current_note = notes.next();\n        } else if note == \".|\" {\n    \
    \        beats.push(current_beat);\n            current_beat = 0;\n          \
    \  current_note = notes.next();\n        } else {\n            current_beat +=\
    \ 1;\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `next` found for struct `Vec<&str>` in the\
    \ current scope\n  --> /tmp/tmpz1h50ra5.rs:13:34\n   |\n13 |     let mut current_note\
    \ = notes.next();\n   |                                  ^^^^ method not found\
    \ in `Vec<&str>`\n\nerror[E0599]: no method named `next` found for struct `Vec<&str>`\
    \ in the current scope\n  --> /tmp/tmpz1h50ra5.rs:20:34\n   |\n20 |          \
    \   current_note = notes.next();\n   |                                  ^^^^ method\
    \ not found in `Vec<&str>`\n\nerror[E0599]: no method named `next` found for struct\
    \ `Vec<&str>` in the current scope\n  --> /tmp/tmpz1h50ra5.rs:24:34\n   |\n24\
    \ |             current_note = notes.next();\n   |                           \
    \       ^^^^ method not found in `Vec<&str>`\n\nerror[E0599]: no method named\
    \ `next` found for struct `Vec<&str>` in the current scope\n  --> /tmp/tmpz1h50ra5.rs:28:34\n\
    \   |\n28 |             current_note = notes.next();\n   |                   \
    \               ^^^^ method not found in `Vec<&str>`\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_beats_length = 0;\n    let mut current_notes_length\
    \ = 0;\n    let mut current_notes_length_to_beat = 0;\n    let mut current_notes_length_to_beat_to_beat\
    \ = 0;\n\n    for c in music_string.chars() {\n        if c == 'o' {\n       \
    \     notes.push(current_note);\n            current_note = String::new();\n \
    \           current_beat = 0;\n            current_beats_length = 0;\n       \
    \     current_notes_length = 0;\n            current_notes_length_to_beat = 0;\n\
    \            current_notes_length_to_beat_to_beat = 0;\n        } else if c ==\
    \ '|' {\n            notes.push(current_note);\n            current_note = String::new();\n\
    \            current_beat = 0;\n            current_beats_length = 0;\n      \
    \      current_notes_length = 0;\n            current_notes_length_to_beat = 0;\n\
    \            current_notes_length_to_beat_to_beat = 0;\n        } else if c ==\
    \ '.' {\n            notes.push(current_note);\n            current_note = String::new();\n\
    \            current_beat = 0;\n            current_beats_length = 0;\n      \
    \      current_notes_length = 0;\n            current_notes_length_to_beat = 0;\n\
    \            current_notes_length_to_beat_to_beat = 0;\n        } else {\n   \
    \         current_note.push(c);\n        }\n    }\n\n    for note in notes {\n\
    \        let note_to_beat = note.chars().filter(|c| c == 'o' || c == '|' || c\
    \ == '.').count();\n        let note_to_beat_to_beat = note.chars().filter(|c|\
    \ c == 'o' || c == '|' || c == '.').count() * 4;\n        beats.push(note_to_beat);\n\
    \        beats.push(note_to_beat_to_beat);\n    }\n\n    return beats;\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkrf4arxu.rs:22:24\n   |\n\
    22 |             notes.push(current_note);\n   |                        ^^^^^^^^^^^^\n\
    \   |                        |\n   |                        expected `&str`, found\
    \ struct `String`\n   |                        help: consider borrowing here:\
    \ `&current_note`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkrf4arxu.rs:30:24\n\
    \   |\n30 |             notes.push(current_note);\n   |                      \
    \  ^^^^^^^^^^^^\n   |                        |\n   |                        expected\
    \ `&str`, found struct `String`\n   |                        help: consider borrowing\
    \ here: `&current_note`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkrf4arxu.rs:38:24\n\
    \   |\n38 |             notes.push(current_note);\n   |                      \
    \  ^^^^^^^^^^^^\n   |                        |\n   |                        expected\
    \ `&str`, found struct `String`\n   |                        help: consider borrowing\
    \ here: `&current_note`\n\nerror[E0277]: can't compare `&char` with `char`\n \
    \ --> /tmp/tmpkrf4arxu.rs:51:54\n   |\n51 |         let note_to_beat = note.chars().filter(|c|\
    \ c == 'o' || c == '|' || c == '.').count();\n   |                           \
    \                           ^^ no implementation for `&char == char`\n   |\n \
    \  = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpkrf4arxu.rs:51:66\n   |\n51 |         let\
    \ note_to_beat = note.chars().filter(|c| c == 'o' || c == '|' || c == '.').count();\n\
    \   |                                                                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpkrf4arxu.rs:51:78\n\
    \   |\n51 |         let note_to_beat = note.chars().filter(|c| c == 'o' || c ==\
    \ '|' || c == '.').count();\n   |                                     "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8_g7_mss.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_is_last\
    \ = false;\n    let mut current_note_length_is_first_note = false;\n    let mut\
    \ current_note_length_is_last_note = false;\n    let mut current_note_length_is_first_note_inverse\
    \ = false;\n    let mut current_note_length_is_last_note_inverse = false;\n  \
    \  let mut current_note_length_is_first_note_inverse_chord = false;\n    let mut\
    \ current_note_length_is_last_note_inverse_chord = false;\n    let mut current_note_length_is_first_note_inverse_chord_inverse\
    \ = false;\n    let mut current_note_length_is_last_note_inverse_chord_inverse\
    \ = false;\n    let mut current_note_length_is_first_note_inverse_chord_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_last_note_inverse_chord_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_first_note_inverse_chord_inverse_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_last_note_inverse_chord_inverse_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_first_note_inverse_chord_inverse_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_last_note_inverse_chord_inverse_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_first_note_inverse_chord_inverse_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_last_note_inverse_chord_inverse_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_first_note_inverse_chord_inverse_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_last_note_inverse_chord_inverse_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_first_note_inverse_chord_inverse_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_last_note_inverse_chord_inverse_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_first_note_inverse_chord_inverse_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_last_note_inverse_chord_inverse_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_first_note_inverse_chord_inverse_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_last_note_inverse_chord_inverse_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_first_note_inverse_chord_inverse_inverse_inverse\
    \ = false;\n    let mut current_note_length_is_last_note_inverse_chord_in\n}\n\
    \nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphudhseal.rs:42:62\n   |\n\
    42 |     let mut current_note_length_is_last_note_inverse_chord_in\n   |     \
    \                                                         ^ help: add `;` here\n\
    43 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphudhseal.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2b0wgtaz.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = String::new();\n    let mut\
    \ current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2\
    \ = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n\
    \    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let\
    \ mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut\
    \ current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11\
    \ = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 =\
    \ 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n\
    \    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n  \
    \  let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let\
    \ mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut\
    \ current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24\
    \ = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 =\
    \ 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n\
    \    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n  \
    \  let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let\
    \ mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut\
    \ current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37\
    \ = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 =\
    \ 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n\
    \    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n  \
    \  let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let\
    \ mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut\
    \ current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50\
    \ = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 =\
    \ 0;\n    let mut current_note_oct53\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp__6yzxk6.rs:67:31\n   |\n\
    67 |     let mut current_note_oct53\n   |                               ^ help:\
    \ add `;` here\n68 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp__6yzxk6.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2 = 0;\n\
    \    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n    let\
    \ mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let mut\
    \ current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut current_note_oct9\
    \ = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11 =\
    \ 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 = 0;\n\
    \    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n  \
    \  let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n    let\
    \ mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let mut\
    \ current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut current_note_oct22\
    \ = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24 =\
    \ 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 = 0;\n\
    \    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n  \
    \  let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n    let\
    \ mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let mut\
    \ current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut current_note_oct35\
    \ = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37 =\
    \ 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 = 0;\n\
    \    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n  \
    \  let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n    let\
    \ mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let mut\
    \ current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut current_note_oct48\
    \ = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50 =\
    \ 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 = 0;\n\
    \    let mut current_note_oct53 = 0;\n    let mut current_\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpz01fmfyy.rs:68:21\n   |\n\
    68 |     let mut current_\n   |                     ^ help: add `;` here\n69 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz01fmfyy.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = notes.first();\n    let mut current_beat = 0;\n    while current_note\
    \ != \"\" {\n        notes.remove(current_note);\n        beats.push(current_beat);\n\
    \        current_beat = 0;\n        if notes.len() > 0 {\n            current_note\
    \ = notes.first();\n            current_beat = 1;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprwqaq4be.rs:15:27\n   |\n\
    15 |     while current_note != \"\" {\n   |                           ^^ expected\
    \ enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&&str>`\n\
    \           found reference `&'static str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprwqaq4be.rs:16:22\n   |\n16 |         notes.remove(current_note);\n\
    \   |                      ^^^^^^^^^^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<&&str>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr3wz3p_j.rs:63:26\n   |\n\
    63 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpr3wz3p_j.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_note = music_string.chars().nth(1).unwrap();\n    let mut current_beat\
    \ = 0;\n    let mut current_beat_length = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat = 0;\n    let mut\
    \ current_note_length_to_beat_length_to_beat_length = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpeld5umnm.rs:32:141\n   |\n\
    32 |     let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_\n\
    \   |                                                                        \
    \                                                                     ^ help:\
    \ add `;` here\n33 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpeld5umnm.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_note_len = 0;\n    let mut current_note_beat = 0;\n    let mut current_note_beat_len\
    \ = 0;\n    let mut current_note_octave = 0;\n    let mut current_note_octave_len\
    \ = 0;\n    let mut current_note_octave_sign = 0;\n    let mut current_note_octave_sign_len\
    \ = 0;\n    let mut current_note_octave_sign_index = 0;\n    let mut current_note_octave_sign_index2\
    \ = 0;\n    let mut current_note_octave_sign_index3 = 0;\n    let mut current_note_octave_sign_index4\
    \ = 0;\n    let mut current_note_octave_sign_index5 = 0;\n    let mut current_note_octave_sign_index6\
    \ = 0;\n    let mut current_note_octave_sign_index7 = 0;\n    let mut current_note_octave_sign_index8\
    \ = 0;\n    let mut current_note_octave_sign_index9 = 0;\n    let mut current_note_octave_sign_index10\
    \ = 0;\n    let mut current_note_octave_sign_index11 = 0;\n    let mut current_note_octave_sign_index12\
    \ = 0;\n    let mut current_note_octave_sign_index13 = 0;\n    let mut current_note_octave_sign_index14\
    \ = 0;\n    let mut current_note_octave_sign_index15 = 0;\n    let mut current_note_octave_sign_index16\
    \ = 0;\n    let mut current_note_octave_sign_index17 = 0;\n    let mut current_note_octave_sign_index18\
    \ = 0;\n    let mut current_note_octave_sign_index19 = 0;\n    let mut current_note_octave_sign_index20\
    \ = 0;\n    let mut current_note_octave_sign_index21 = 0;\n    let mut current_note_octave_sign_index22\
    \ = 0;\n    let mut current_note_octave_sign_index23 = 0;\n    let mut current_note_octave_sign_index24\
    \ = 0;\n    let mut current_note_octave_sign_index25 = 0;\n    let mut current_note_octave_sign_index26\
    \ = 0;\n    let mut current_note_octave_sign_index27 = 0;\n    let mut current_note_octave_sign_index28\
    \ = 0;\n    let mut current_note_octave_sign_index29 = 0;\n    let mut current_note_octave_sign_index30\
    \ = 0;\n    let mut current_note_octave_sign_index31 = 0;\n    let mut current_note_octave_sign\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpeoxf1ohl.rs:52:37\n   |\n\
    52 |     let mut current_note_octave_sign\n   |                              \
    \       ^ help: add `;` here\n53 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpeoxf1ohl.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n    let mut current_note\
    \ = 0;\n    let mut current_beat = 0;\n    for note in notes {\n        match\
    \ note {\n            (0, '.') => {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n            }\n            (1, '|') => {\n\
    \                current_note += 1;\n                current_beat = 0;\n     \
    \       }\n            (2, c) => {\n                current_beat += 1;\n     \
    \       }\n            _ => {\n                panic!(\"Unexpected note\");\n\
    \            }\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\
    \nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpeovbfpo1.rs:12:72\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c != '|');\n   |                                                           \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplcoc0fox.rs:63:26\n   |\n\
    63 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplcoc0fox.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_note = String::new();\n    let mut current_beat = 0;\n    let mut\
    \ current_note_length = 0;\n    let mut current_note_length_to_beat = 0;\n   \
    \ let mut current_note_length_to_beat_with_note = 0;\n    let mut current_note_length_to_beat_with_note_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_to_beat_with_note =\
    \ 0;\n    let mut current_note_length_to_beat_with_note_to_beat_with_note_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_to_beat_with_note_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0buhqrwu.rs:32:95\n   |\n\
    32 |     let mut current_note_length_to_beat_with_note_to_beat_with_note_to_beat_with_note_to_beat_\n\
    \   |                                                                        \
    \                       ^ help: add `;` here\n33 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0buhqrwu.rs:10:41\n   |\n10 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------  \
    \                        ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |  \
    \  |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat: isize = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4\
    \ = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n\
    \    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let\
    \ mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut\
    \ current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13\
    \ = 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 =\
    \ 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n\
    \    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n  \
    \  let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let\
    \ mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut\
    \ current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26\
    \ = 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 =\
    \ 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n\
    \    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n  \
    \  let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let\
    \ mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut\
    \ current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39\
    \ = 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 =\
    \ 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n\
    \    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n  \
    \  let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let\
    \ mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut\
    \ current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52\
    \ = 0;\n    let mut current_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfsj3u00b.rs:67:21\n   |\n\
    67 |     let mut current_\n   |                     ^ help: add `;` here\n68 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfsj3u00b.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = 0;\n    let mut current_beat = 0;\n    let mut current_length\
    \ = 0;\n    while current_note != notes.len() {\n        let note = notes[current_note];\n\
    \        if note == \"o\" {\n            beats.push(current_beat);\n         \
    \   current_length += 4;\n            current_beat += 1;\n            current_note\
    \ += 1;\n        } else if note == \"o|\" {\n            beats.push(current_beat);\n\
    \            current_length += 2;\n            current_beat += 1;\n          \
    \  current_note += 1;\n        } else if note == \".|\" {\n            beats.push(current_beat);\n\
    \            current_length += 1;\n            current_beat += 1;\n          \
    \  current_note += 1;\n        } else {\n            panic!(\"Invalid note '{}'\"\
    , note);\n        }\n    }\n    beats.push(current_beat);\n    current_length\
    \ += 1;\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmp2o8q2ac8.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&'static str> = vec![];\n    let mut current_note = String::new();\n\
    \    let mut current_beat = 0;\n    let mut current_octave = 0;\n    let mut current_length\
    \ = 0;\n    let mut current_length_index = 0;\n    let mut current_length_index2\
    \ = 0;\n    let mut current_length_index3 = 0;\n    let mut current_length_index4\
    \ = 0;\n    let mut current_length_index5 = 0;\n    let mut current_length_index6\
    \ = 0;\n    let mut current_length_index7 = 0;\n    let mut current_length_index8\
    \ = 0;\n    let mut current_length_index9 = 0;\n    let mut current_length_index10\
    \ = 0;\n    let mut current_length_index11 = 0;\n    let mut current_length_index12\
    \ = 0;\n    let mut current_length_index13 = 0;\n    let mut current_length_index14\
    \ = 0;\n    let mut current_length_index15 = 0;\n    let mut current_length_index16\
    \ = 0;\n    let mut current_length_index17 = 0;\n    let mut current_length_index18\
    \ = 0;\n    let mut current_length_index19 = 0;\n    let mut current_length_index20\
    \ = 0;\n    let mut current_length_index21 = 0;\n    let mut current_length_index22\
    \ = 0;\n    let mut current_length_index23 = 0;\n    let mut current_length_index24\
    \ = 0;\n    let mut current_length_index25 = 0;\n    let mut current_length_index26\
    \ = 0;\n    let mut current_length_index27 = 0;\n    let mut current_length_index28\
    \ = 0;\n    let mut current_length_index29 = 0;\n    let mut current_length_index30\
    \ = 0;\n    let mut current_length_index31 = 0;\n    let mut current_length_index32\
    \ = 0;\n    let mut current_length_index33 = 0;\n    let mut current_length_index34\
    \ = 0;\n    let mut current_length_index35 = 0;\n    let mut current_length_index36\
    \ = 0;\n    let mut current_length_index37 = 0;\n    let mut current_length_index38\
    \ = 0;\n    let mut current_length_index39 = 0;\n    let mut current_length_index40\
    \ = 0;\n    let mut current_length_index41 = 0;\n    let mut current_length_index42\
    \ = 0;\n    let mut current_length_index43 = 0;\n    let mut current_length_index44\
    \ = 0;\n    let mut current_length_index45 = 0;\n    let mut current_length_index46\
    \ = 0;\n    let mut current_length_index47 = 0;\n    let mut current_length_index48\
    \ = 0;\n    let mut current_length_index49 = 0;\n    let mut current_length_index50\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3ikae5q_.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3ikae5q_.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.first().unwrap();\n    let mut current_beat = 0;\n    let mut current_beats:\
    \ isize = 0;\n    notes.iter().for_each(|note| {\n        if note == current_note\
    \ {\n            current_beats += 1;\n        } else {\n            beats.push(current_beats);\n\
    \            current_beat = 1;\n            current_beats += 1;\n            current_note\
    \ = note;\n        }\n    });\n    beats.push(current_beats);\n    beats\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpirvckgw2.rs:13:42\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.split_whitespace();\n\
    \    let mut current_note = notes.next().unwrap();\n    let mut current_beat =\
    \ 0;\n    while let Some(note) = notes.next() {\n        if note != current_note\
    \ {\n            beats.push(current_beat);\n            current_beat = 0;\n  \
    \          current_note = note;\n        }\n        current_beat += 1;\n    }\n\
    \    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpmq3nsstu.rs:13:41\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = music_string.chars().nth(0).unwrap();\n\
    \    let mut current_note_length = 0;\n    let mut last_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut last_note_length = 0;\n    let mut last_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let mut\
    \ last_note_note_length = 0;\n    let mut last_note_note_beat = 0;\n    let \n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpwoe3_fmu.rs:67:1\n  \
    \ |\n67 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ \n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp3xzipap5.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp52delx7t.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = notes.first().unwrap();\n    let mut current_beat = 0;\n    let\
    \ mut current_note_count = 0;\n    for note in notes {\n        if note != current_note\
    \ {\n            if current_note_count == 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note_count = 0;\n\
    \            }\n            current_note = note;\n            current_note_count\
    \ = 1;\n        } else {\n            current_note_count += 1;\n        }\n  \
    \      current_beat += 1;\n    }\n    beats.push(current_beat);\n    beats\n}\n\
    \nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpnxw6ripn.rs:17:17\n\
    \   |\n17 |         if note != current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnxw6ripn.rs:23:28\n   |\n13 |     let mut current_note\
    \ = notes.first().unwrap();\n   |                            ----------------------\
    \ expected due to this value\n...\n23 |             current_note = note;\n   |\
    \                            ^^^^ expected `&str`, found `str`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2 = 0;\n\
    \    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n    let\
    \ mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let mut\
    \ current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut current_note_oct9\
    \ = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11 =\
    \ 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 = 0;\n\
    \    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n  \
    \  let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n    let\
    \ mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let mut\
    \ current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut current_note_oct22\
    \ = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24 =\
    \ 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 = 0;\n\
    \    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n  \
    \  let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n    let\
    \ mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let mut\
    \ current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut current_note_oct35\
    \ = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37 =\
    \ 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 = 0;\n\
    \    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n  \
    \  let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n    let\
    \ mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let mut\
    \ current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut current_note_oct48\
    \ = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50 =\
    \ 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 = 0;\n\
    \    let mut current_note_oct53 = 0;\n    let mut current_\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4u0__b3t.rs:68:21\n   |\n\
    68 |     let mut current_\n   |                     ^ help: add `;` here\n69 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4u0__b3t.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpndshncbb.rs:64:1\n  \
    \ |\n64 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 1;\n    let mut current_note_length_index42\
    \ = 1;\n    let mut current_note_length_index43 = 1;\n    let mut current_note_length_index44\
    \ = 1;\n    let mut current_note_length_index45 = 1;\n    let mut current_note_length_index46\
    \ = 1;\n    let mut current_note_length_index47 = 1;\n    let mut current_note_length_index\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpexna6876.rs:62:38\n   |\n\
    62 |     let mut current_note_length_index\n   |                             \
    \         ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpexna6876.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = music_string.chars().nth(0).unwrap();\n   \
    \ let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length_index\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8y089_5h.rs:62:38\n   |\n\
    62 |     let mut current_note_length_index\n   |                             \
    \         ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8y089_5h.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = notes.last().unwrap();\n    let mut current_beat = 0;\n    for\
    \ note in notes {\n        if note == current_note {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n        } else {\n            current_beat +=\
    \ 1;\n        }\n        current_note = note;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmp_or9f_q0.rs:16:17\n\
    \   |\n16 |         if note == current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_or9f_q0.rs:22:24\n   |\n13 |     let mut current_note\
    \ = notes.last().unwrap();\n   |                            ---------------------\
    \ expected due to this value\n...\n22 |         current_note = note;\n   |   \
    \                     ^^^^ expected `&str`, found `str`\n   |\n   = note: expected\
    \ reference `&&str`\n              found reference `&str`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, note)| note != '|');\n    let\
    \ mut current_note = 0;\n    let mut current_beat = 0;\n    let mut current_note_len\
    \ = 0;\n    let mut last_note_len = 0;\n    let mut last_note = 0;\n    let mut\
    \ last_beat = 0;\n    let mut last_note_len = 0;\n    let mut last_note = 0;\n\
    \    let mut last_beat = 0;\n    let mut last_note_len = 0;\n    let mut last_note\
    \ = 0;\n    let mut last_beat = 0;\n    let mut last_note_len = 0;\n    let mut\
    \ last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len = 0;\n\
    \    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let \n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpn5ja0827.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: can't compare `&char` with\
    \ `char`\n  --> /tmp/tmpn5ja0827.rs:12:78\n   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_,\
    \ note)| note != '|');\n   |                                                 \
    \                             ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().enumerate().filter(|(_,\
    \ c)| c != '|');\n    for note in notes {\n        if note.1 == notes.len() -\
    \ 1 {\n            beats.push(4);\n        } else {\n            beats.push(note.1\
    \ - note.0);\n        }\n    }\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpiksn0276.rs:12:72\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c != '|');\n   |                                                           \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0599]: no method named `len` found for struct\
    \ `Filter` in the current scope\n  --> /tmp/tmpiksn0276.rs:14:28\n   |\n14 | \
    \        if note.1 == notes.len() - 1 {\n   |                            ^^^ method\
    \ not found in `Filter<Enumerate<Chars<'_>>, [closure@/tmp/tmpiksn0276.rs:12:61:\
    \ 12:78]>`\n\nerror[E0369]: cannot subtract `usize` from `char`\n  --> /tmp/tmpiksn0276.rs:17:31\n\
    \   |\n17 |             beats.push(note.1 - note.0);\n   |                   \
    \     ------ ^ ------ usize\n   |                        |\n   |             \
    \           char\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0369, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = music_string.len();\n  \
    \  let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4q_2ij1g.rs:62:38\n   |\n\
    62 |     let mut current_note_length_index\n   |                             \
    \         ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4q_2ij1g.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = music_string.chars().nth(music_string.len()\
    \ - 1).unwrap();\n    let mut last_note = music_string.chars().nth(music_string.len()\
    \ - 2).unwrap();\n    let mut current_note_count = 0;\n    let mut last_note_count\
    \ = 0;\n    while current_note != last_note {\n        match current_note {\n\
    \            'o' => beats.push(current_beat),\n            'o|' => beats.push(current_beat),\n\
    \            '.|' => beats.push(current_beat),\n            _ => {\n         \
    \       beats.push(current_beat);\n                current_note_count += 1;\n\
    \                current_beat += 1;\n            }\n        }\n        last_note\
    \ = last_note;\n        last_note_count = current_note_count;\n        current_note\
    \ = music_string.chars().nth(music_string.len() - 1).unwrap();\n        current_note_count\
    \ = 0;\n    }\n    beats.push(current_beat);\n    current_note_count += 1;\n \
    \   beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpt24z5llh.rs:20:16\n\
    \   |\n20 |             'o|' => beats.push(current_beat),\n   |              \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|&(_, note)| note != 'o').collect::<Vec<_>>();\n\
    \    let mut current_note = 0;\n    let mut current_beat = 0;\n    let mut current_note_length\
    \ = 0;\n    for note in notes {\n        if note.1 == note.0 {\n            current_note_length\
    \ += 1;\n        } else {\n            current_note_length = 0;\n        }\n \
    \       if note.1 == note.0 {\n            current_note += 1;\n            current_beat\
    \ += 1;\n        } else {\n            current_note = 0;\n            current_beat\
    \ = 0;\n        }\n        beats.push(current_beat);\n    }\n    beats\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6sdijecd.rs:17:22\n   |\n\
    17 |         if note.1 == note.0 {\n   |                      ^^^^^^ expected\
    \ `char`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6sdijecd.rs:22:22\n\
    \   |\n22 |         if note.1 == note.0 {\n   |                      ^^^^^^ expected\
    \ `char`, found `usize`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 1;\n    let mut current_note_length_index42\
    \ = 1;\n    let mut current_note_length_index43 = 1;\n    let mut current_note_length_index44\
    \ = 1;\n    let mut current_note_length_index45 = 1;\n    let mut current_note_length_index46\
    \ = 1;\n    let mut current_note_length_index47 = 1;\n    let mut current_note_length_index48\
    \ = 1;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpzlx20k6z.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = music_string.len();\n  \
    \  let mut current_note_type = String::new();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = musi\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpiyf422x6.rs:54:39\n   |\n\
    54 |     let mut current_note_length = musi\n   |                            \
    \           ^ help: add `;` here\n55 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `musi` in this scope\n  --> /tmp/tmpiyf422x6.rs:54:35\n  \
    \ |\n54 |     let mut current_note_length = musi\n   |                       \
    \            ^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpiyf422x6.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2 = 0;\n\
    \    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n    let\
    \ mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let mut\
    \ current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut current_note_oct9\
    \ = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11 =\
    \ 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 = 0;\n\
    \    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n  \
    \  let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n    let\
    \ mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let mut\
    \ current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut current_note_oct22\
    \ = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24 =\
    \ 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 = 0;\n\
    \    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n  \
    \  let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n    let\
    \ mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let mut\
    \ current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut current_note_oct35\
    \ = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37 =\
    \ 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 = 0;\n\
    \    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n  \
    \  let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n    let\
    \ mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let mut\
    \ current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut current_note_oct48\
    \ = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50 =\
    \ 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 = 0;\n\
    \    let mut current_note_oct53 = 0;\n    let mut current_\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq78lunvm.rs:68:21\n   |\n\
    68 |     let mut current_\n   |                     ^ help: add `;` here\n69 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq78lunvm.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.first().unwrap();\n    let mut current_beat = 0;\n    let mut current_length\
    \ = 0;\n    for note in notes {\n        if note == current_note {\n         \
    \   current_beat += 1;\n            current_length += 1;\n        } else {\n \
    \           beats.push(current_beat);\n            current_beat = 1;\n       \
    \     current_length = 1;\n            current_note = note;\n        }\n    }\n\
    \    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmp50lblle5.rs:17:17\n\
    \   |\n17 |         if note == current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp50lblle5.rs:24:28\n   |\n13 |     let mut current_note\
    \ = notes.first().unwrap();\n   |                            ----------------------\
    \ expected due to this value\n...\n24 |             current_note = note;\n   |\
    \                            ^^^^ expected `&str`, found `str`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ \n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp7fi6th1r.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().collect::<Vec<_>>();\n    let mut current_note = notes.len()\
    \ - 1;\n    let mut current_beat = 0;\n    let mut last_note = notes[current_note];\n\
    \    let mut last_beat = 0;\n    loop {\n        if current_note == 0 {\n    \
    \        notes.pop();\n            current_note = notes.len() - 1;\n         \
    \   current_beat = 0;\n            last_note = notes[current_note];\n        \
    \    last_beat = 0;\n        }\n        let mut beats_count = last_beat;\n   \
    \     if notes[current_note] == '.' {\n            beats_count += 1;\n       \
    \ }\n        if notes[current_note] == 'o' {\n            beats_count += 4;\n\
    \        }\n        if notes[current_note] == 'o|' {\n            beats_count\
    \ += 2;\n        }\n        beats.push(beats_count);\n        last_note = notes[current_note];\n\
    \        last_beat = beats_count;\n        current_note -= 1;\n    }\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpolcxjxmb.rs:32:38\n\
    \   |\n32 |         if notes[current_note] == 'o|' {\n   |                   \
    \                   ^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.last().unwrap();\n    let mut current_beat = 0;\n    let mut current_note_count\
    \ = 0;\n    while current_note != \".\" {\n        if current_note == \"o\" {\n\
    \            beats.push(current_beat);\n            current_beat = 0;\n      \
    \      current_note_count += 1;\n        }\n        if current_note == \"o|\"\
    \ {\n            beats.push(current_beat);\n            current_beat = 0;\n  \
    \          current_note_count += 1;\n        }\n        if current_note == \"\
    .|\" {\n            beats.push(current_beat);\n            current_beat = 0;\n\
    \            current_note_count += 1;\n        }\n        current_note += notes.last().unwrap();\n\
    \        current_beat++;\n    }\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note_count += 1;\n    beats.push(current_beat\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp_h4u7xcx.rs:95:15\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - closing delimiter possibly meant\
    \ for this\n...\n95 |     beats.push(current_beat\n   |               ^ unclosed\
    \ delimiter\n96 | }\n   | ^ mismatched closing delimiter\n\nerror: Rust has no\
    \ postfix increment operator\n  --> /tmp/tmp_h4u7xcx.rs:33:21\n   |\n33 |    \
    \     current_beat++;\n   |                     ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n33 |         { let tmp = current_beat;\
    \ current_beat += 1; tmp };\n   |         +++++++++++             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    33 -         current_beat++;\n33 +         current_beat += 1;\n   | \n\nerror[E0277]:\
    \ can't compare `&str` with `str`\n  --> /tmp/tmp_h4u7xcx.rs:16:24\n   |\n16 |\
    \     while current_note != \".\" {\n   |                        ^^ no implementation\
    \ for `&str == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]:\
    \ can't compare `&str` with `str`\n  --> /tmp/tmp_h4u7xcx.rs:17:25\n   |\n17 |\
    \         if current_note == \"o\" {\n   |                         ^^ no implementation\
    \ for `&str == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut last_note = String::new();\n    let\
    \ mut last_beat = 0;\n    let mut last_beats: isize = 0;\n    let mut last_beats_len\
    \ = 0;\n    let mut last_beats_len2 = 0;\n    let mut last_beats_len3 = 0;\n \
    \   let mut last_beats_len4 = 0;\n    let mut last_beats_len5 = 0;\n    let mut\
    \ last_beats_len6 = 0;\n    let mut last_beats_len7 = 0;\n    let mut last_beats_len8\
    \ = 0;\n    let mut last_beats_len9 = 0;\n    let mut last_beats_len10 = 0;\n\
    \    let mut last_beats_len11 = 0;\n    let mut last_beats_len12 = 0;\n    let\
    \ mut last_beats_len13 = 0;\n    let mut last_beats_len14 = 0;\n    let mut last_beats_len15\
    \ = 0;\n    let mut last_beats_len16 = 0;\n    let mut last_beats_len17 = 0;\n\
    \    let mut last_beats_len18 = 0;\n    let mut last_beats_len19 = 0;\n    let\
    \ mut last_beats_len20 = 0;\n    let mut last_beats_len21 = 0;\n    let mut last_beats_len22\
    \ = 0;\n    let mut last_beats_len23 = 0;\n    let mut last_beats_len24 = 0;\n\
    \    let mut last_beats_len25 = 0;\n    let mut last_beats_len26 = 0;\n    let\
    \ mut last_beats_len27 = 0;\n    let mut last_beats_len28 = 0;\n    let mut last_beats_len29\
    \ = 0;\n    let mut last_beats_len30 = 0;\n    let mut last_beats_len31 = 0;\n\
    \    let mut last_beats_len32 = 0;\n    let mut last_beats_len33 = 0;\n    let\
    \ mut last_beats_len34 = 0;\n    let mut last_beats_len35 = 0;\n    let mut last_beats_len36\
    \ = 0;\n    let mut last_beats_len37 = 0;\n    let mut last_beats_len38 = 0;\n\
    \    let mut last_beats_len39 = 0;\n    let mut last_beats_len40 = 0;\n    let\
    \ mut last_beats_len41 = 0;\n    let mut last_beats_len42 = 0;\n    let mut last_beats_len43\
    \ = 0;\n    let mut last_beats_len44 = 0;\n    let mut last_beats_len45 = 0;\n\
    \    let mut last_beats_len46\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5f3ih1ui.rs:61:29\n   |\n\
    61 |     let mut last_beats_len46\n   |                             ^ help: add\
    \ `;` here\n62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5f3ih1ui.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 1;\n    let mut current_note_length_index42\
    \ = 1;\n    let mut current_note_length_index43 = 1;\n    let mut current_note_length_index44\
    \ = 1;\n    let mut current_note_length_index45 = 1;\n    let mut current_note_length_index46\
    \ = 1;\n    let mut current_note_length_index47 = 1;\n    let mut current_note_length_index\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyfprj9sh.rs:62:38\n   |\n\
    62 |     let mut current_note_length_index\n   |                             \
    \         ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyfprj9sh.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = String::new();\n    let mut\
    \ current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2\
    \ = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n\
    \    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let\
    \ mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut\
    \ current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11\
    \ = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 =\
    \ 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n\
    \    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n  \
    \  let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let\
    \ mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut\
    \ current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24\
    \ = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 =\
    \ 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n\
    \    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n  \
    \  let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let\
    \ mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut\
    \ current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37\
    \ = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 =\
    \ 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n\
    \    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n  \
    \  let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let\
    \ mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut\
    \ current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50\
    \ = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 =\
    \ 0;\n    let mut current_note_oct53\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpiq1js6xl.rs:67:31\n   |\n\
    67 |     let mut current_note_oct53\n   |                               ^ help:\
    \ add `;` here\n68 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpiq1js6xl.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_is_even\
    \ = true;\n    let mut current_note_length_is_odd = true;\n    let mut current_note_length_is_odd_or_even\
    \ = true;\n    let mut current_note_length_is_odd_or_even = false;\n    let mut\
    \ current_note_length_is_odd_or_even = false;\n    let mut current_note_length_is_odd\
    \ = false;\n    let mut current_note_length_is_even = false;\n    let mut current_note_length_is_odd\
    \ = true;\n    let mut current_note_length_is_even = true;\n    let mut current_note_length_is_odd_or_even\
    \ = true;\n    let mut current_note_length_is_odd_or_even = false;\n    let mut\
    \ current_note_length_is_odd_or_even = false;\n    let mut current_note_length_is_odd\
    \ = false;\n    let mut current_note_length_is_even = false;\n    let mut current_note_length_is_odd\
    \ = true;\n    let mut current_note_length_is_even = true;\n    let mut current_note_length_is_odd_or_even\
    \ = true;\n    let mut current_note_length_is_odd_or_even = false;\n    let mut\
    \ current_note_length_is_odd_or_even = false;\n    let mut current_note_length_is_odd\
    \ = false;\n    let mut current_note_length_is_even = false;\n    let mut current_note_length_is_odd\
    \ = true;\n    let mut current_note_length_is_even = true;\n    let mut current_note_length_is_odd_or_even\
    \ = true;\n    let mut current_note_length_is_odd_or_even = false;\n    let mut\
    \ current_note_length_is_odd_or_even = false;\n    let mut current_note_length_is_odd\
    \ = false;\n    let mut current_note_length_is_even = false;\n    let mut current_note_length_is_odd\
    \ = true;\n    let mut current_note_length_is_even = true;\n    let mut current_note_length_is_odd_or_even\
    \ = true;\n    let mut current_note_length_is_odd_or_even = false;\n    let mut\
    \ current_note_length_is_odd_or_even = false;\n    let mut current_note_length_is_odd\
    \ = false;\n    let mut current_note_length_is_even = false;\n    let mut current_note_length_is_odd\
    \ = true;\n    let mut current_note_length_is_even = true;\n    let mut current_note_length_is_odd_or_even\
    \ = true;\n    let mut current_note_length_is_odd_or_even = false;\n    let mut\
    \ current_note_length_is_odd_or_even = false;\n    let mut current_note_length_is_od\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpabsrxpi6.rs:56:38\n   |\n\
    56 |     let mut current_note_length_is_od\n   |                             \
    \         ^ help: add `;` here\n57 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpabsrxpi6.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate();\n    let mut current_note = 0;\n    let\
    \ mut current_beat = 0;\n    let mut current_note_length = 0;\n    let mut last_note\
    \ = -1;\n    let mut last_beat = -1;\n    let mut last_note_length = -1;\n   \
    \ let mut last_note_length = 0;\n    let mut last_note_length = 0;\n    let mut\
    \ last_note_length = 0;\n    let mut last_note_length = 0;\n    let mut last_note_length\
    \ = 0;\n    let mut last_note_length = 0;\n    let mut last_note_length = 0;\n\
    \    let mut last_note_length = 0;\n    let mut last_note_length = 0;\n    let\
    \ mut last_note_length = 0;\n    let mut last_note_length = 0;\n    let mut last_note_length\
    \ = 0;\n    let mut last_note_length = 0;\n    let mut last_note_length = 0;\n\
    \    let mut last_note_length = 0;\n    let mut last_note_length = 0;\n    let\
    \ mut last_note_length = 0;\n    let mut last_note_length = 0;\n    let mut last_note_length\
    \ = 0;\n    let mut last_note_length = 0;\n    let mut last_note_length = 0;\n\
    \    let mut last_note_length = 0;\n    let mut last_note_length = 0;\n    let\
    \ mut last_note_length = 0;\n    let mut last_note_length = 0;\n    let mut last_note_length\
    \ = 0;\n    let mut last_note_length = 0;\n    let mut last_note_length = 0;\n\
    \    let mut last_note_length = 0;\n    let mut last_note_length = 0;\n    let\
    \ mut last_note_length = 0;\n    let mut last_note_length = 0;\n    let mut last_note_length\
    \ = 0;\n    let mut last_note_length = 0;\n    let mut last_note_length = 0;\n\
    \    let mut last_note_length = 0;\n    let mut last_note_length = 0;\n    let\
    \ mut last_note_length = 0;\n    let mut last_note_length = 0;\n    let mut last_note_length\
    \ = 0;\n    let mut last_note_length = 0;\n    let mut last_note_length = 0;\n\
    \    let mut last_note_length = 0;\n    let mut last_note_length = 0;\n    let\
    \ mut last_note_length = 0;\n    let mut last_note_length = 0;\n    let mut last_note_length\
    \ = 0;\n    let mut last_note_length = 0;\n    let mut last_note_length = 0;\n\
    \    let mut last_note_length = 0;\n    let mut last_note_length = 0;\n    let\
    \ mut last_note_length = 0;\n    let mut last_note_length = 0;\n    let mut last_note_length\
    \ = 0;\n    let mut last_note_length = 0;\n    let mut \n}\n\nfn main() {\n  \
    \  let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpjyf71h6c.rs:75:1\n\
    \   |\n75 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_char = 0;\n    let mut last_note_len = 0;\n \
    \   let mut last_note_char = 0;\n    let mut last_note = 0;\n    let mut last_note_char_index\
    \ = 0;\n    let mut last_note_char_index2 = 0;\n    let mut last_note_char_index3\
    \ = 0;\n    let mut last_note_char_index4 = 0;\n    let mut last_note_char_index5\
    \ = 0;\n    let mut last_note_char_index6 = 0;\n    let mut last_note_char_index7\
    \ = 0;\n    let mut last_note_char_index8 = 0;\n    let mut last_note_char_index9\
    \ = 0;\n    let mut last_note_char_index10 = 0;\n    let mut last_note_char_index11\
    \ = 0;\n    let mut last_note_char_index12 = 0;\n    let mut last_note_char_index13\
    \ = 0;\n    let mut last_note_char_index14 = 0;\n    let mut last_note_char_index15\
    \ = 0;\n    let mut last_note_char_index16 = 0;\n    let mut last_note_char_index17\
    \ = 0;\n    let mut last_note_char_index18 = 0;\n    let mut last_note_char_index19\
    \ = 0;\n    let mut last_note_char_index20 = 0;\n    let mut last_note_char_index21\
    \ = 0;\n    let mut last_note_char_index22 = 0;\n    let mut last_note_char_index23\
    \ = 0;\n    let mut last_note_char_index24 = 0;\n    let mut last_note_char_index25\
    \ = 0;\n    let mut last_note_char_index26 = 0;\n    let mut last_note_char_index27\
    \ = 0;\n    let mut last_note_char_index28 = 0;\n    let mut last_note_char_index29\
    \ = 0;\n    let mut last_note_char_index30 = 0;\n    let mut last_note_char_index31\
    \ = 0;\n    let mut last_note_char_index32 = 0;\n    let mut last_note_char_index33\
    \ = 0;\n    let mut last_note_char_index34 = 0;\n    let mut last_note_char_index35\
    \ = 0;\n    let mut last_note_char_index36 = 0;\n    let mut last_note_char_index37\
    \ = 0;\n    let mut last_note_char_index38 = 0;\n    let mut last_note_char_index39\
    \ = 0;\n    let mut last_note_char_index40 = 0;\n    let mut last_note_char_index41\
    \ = 0;\n    let mut last_note_char_index42 = 0;\n    let mut last_note_char_index43\
    \ = 0;\n    let mut last_note_char_index44 = 0;\n    let mut last_note_char_index45\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprs5tx2f5.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, note)| note != 'o').collect::<Vec<_>>();\n\
    \    let mut current_beat = 0;\n    for note in notes {\n        note = note.to_string();\n\
    \        if note.len() == 1 {\n            beats.push(current_beat);\n       \
    \     current_beat += 1;\n        } else {\n            if note[0] == 'o' {\n\
    \                beats.push(current_beat);\n                current_beat += 1;\n\
    \            } else {\n                if note[0] == '|' {\n                 \
    \   beats.push(current_beat);\n                    current_beat += 1;\n      \
    \          } else {\n                    panic!(\"Invalid note format\");\n  \
    \              }\n            }\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpsel442xt.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != 'o').collect::<Vec<_>>();\n   |                                    \
    \                                          ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0599]: `(usize,\
    \ char)` doesn't implement `std::fmt::Display`\n  --> /tmp/tmpsel442xt.rs:15:21\n\
    \   |\n15 |         note = note.to_string();\n   |                     ^^^^^^^^^\
    \ `(usize, char)` cannot be formatted with the default formatter\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `(usize, char): std::fmt::Display`\n\
    \           which is required by `(usize, char): ToString`\n\nerror[E0599]: no\
    \ method named `len` found for tuple `(usize, char)` in the current scope\n  -->\
    \ /tmp/tmpsel442xt.rs:16:17\n   |\n16 |         if note.len() == 1 {\n   |   \
    \              ^^^ method not found in `(usize, char)`\n\nerror[E0608]: cannot\
    \ index into a value of type `(usize, char)`\n  --> /tmp/tmpsel442xt.rs:20:16\n\
    \   |\n20 |             if note[0] == 'o' {\n   |                ^^^^^^^ help:\
    \ to access tuple elements, use: `note.0`\n\nerror[E0608]: cannot index into a\
    \ value of type `(usize, char)`\n  --> /tmp/tmpsel442xt.rs:24:20\n   |\n24 | \
    \                if note[0] == '|' {\n   |                    ^^^^^^^ help: to\
    \ access tuple elements, use: `note.0`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.last().unwrap();\n    let mut current_beat = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_with_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_beat_with_beat = 0;\n   \
    \ let mut current_note_length_to_beat_with_beat_with_beat_with_beat = 0;\n   \
    \ let mut current_note_length_to_beat_with_beat_with_beat_with_beat_with_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_beat_with_beat_with_beat_with_beat_with_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpukxkd63s.rs:30:126\n   |\n\
    30 |     let mut current_note_length_to_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_beat_with_\n\
    \   |                                                                        \
    \                                                      ^ help: add `;` here\n\
    31 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukxkd63s.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2lszmmzl.rs:63:26\n   |\n\
    63 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2lszmmzl.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = music_string.chars().nth(0).unwrap();\n\
    \    for note in music_string.chars().skip(1) {\n        if note == current_note\
    \ {\n            current_beat += 1;\n        } else {\n            beats.push(current_beat);\n\
    \            current_beat = 1;\n            current_note = note;\n        }\n\
    \    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpznyraq_z.rs:13:56\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2 = 0;\n\
    \    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n    let\
    \ mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let mut\
    \ current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut current_note_oct9\
    \ = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11 =\
    \ 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 = 0;\n\
    \    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n  \
    \  let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n    let\
    \ mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let mut\
    \ current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut current_note_oct22\
    \ = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24 =\
    \ 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 = 0;\n\
    \    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n  \
    \  let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n    let\
    \ mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let mut\
    \ current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut current_note_oct35\
    \ = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37 =\
    \ 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 = 0;\n\
    \    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n  \
    \  let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n    let\
    \ mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let mut\
    \ current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut current_note_oct48\
    \ = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50 =\
    \ 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 = 0;\n\
    \    let mut current_note_oct53 = 0;\n    let mut current_\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvdw5siea.rs:68:21\n   |\n\
    68 |     let mut current_\n   |                     ^ help: add `;` here\n69 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvdw5siea.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n    let mut last_note\
    \ = notes.next().unwrap().0;\n    let mut last_beat = 0;\n    notes.for_each(|(_,\
    \ note)| {\n        if note == '|' {\n            beats.push(last_beat);\n   \
    \         last_beat = 0;\n        } else {\n            last_beat = last_beat\
    \ + 1;\n        }\n        last_note = note;\n    });\n    beats.push(last_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_swnjlc0.rs:12:72\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c != '|');\n   |                                                           \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_swnjlc0.rs:22:21\n\
    \   |\n13 |     let mut last_note = notes.next().unwrap().0;\n   |           \
    \              ----------------------- expected due to this value\n...\n22 | \
    \        last_note = note;\n   |                     ^^^^ expected `usize`, found\
    \ `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.first().unwrap();\n    let mut current_beat = 0;\n    let mut current_length\
    \ = 0;\n    while current_note != \"\" {\n        let mut current_length = current_note.len();\n\
    \        if current_length == 1 {\n            beats.push(current_beat);\n   \
    \         current_beat = 0;\n            current_note = notes.next();\n      \
    \  } else {\n            let mut current_beat = current_beat + 1;\n          \
    \  if current_length == 2 {\n                beats.push(current_beat);\n     \
    \           current_beat = 0;\n                current_note = notes.next();\n\
    \            } else {\n                let mut current_beat = current_beat + 1;\n\
    \                if current_length == 3 {\n                    beats.push(current_beat);\n\
    \                    current_beat = 0;\n                    current_note = notes.next();\n\
    \                } else {\n                    let mut current_beat = current_beat\
    \ + 1;\n                    if current_length == 4 {\n                       \
    \ beats.push(current_beat);\n                        current_beat = 0;\n     \
    \                   current_note = notes.next();\n                    } else {\n\
    \                        let mut current_beat = current_beat + 1;\n          \
    \              if current_length == 5 {\n                            beats.push(current_beat);\n\
    \                            current_beat = 0;\n                            current_note\
    \ = notes.next();\n                        } else {\n                        \
    \    let mut current_beat = current_beat + 1;\n                            if\
    \ current_length == 6 {\n                                beats.push(current_beat);\n\
    \                                current_beat = 0;\n                         \
    \       current_note = notes.next();\n                            } else {\n \
    \                               let mut current_beat = current_beat + 1;\n   \
    \                             if current_length == 7 {\n                     \
    \               beats.push(current_beat);\n                                  \
    \  current_beat = 0;\n                                    current_note = notes.next();\n\
    \                                } else {\n                                  \
    \  let mut current_beat = current_beat + 1;\n                                \
    \    if current_length == 8 {\n                                        beats.push(current_beat);\n\
    \                                        current_beat = 0;\n                 \
    \                       current_note = notes.next();\n                       \
    \             } else {\n                                        let mut current_beat\
    \ = current_beat + 1;\n                                        if current_length\
    \ == 9 {\n                                            beats.push(current_beat);\n\
    \                                            current_beat = 0;\n             \
    \                               current_note = notes.next();\n               \
    \                         } else {\n                                         \
    \   let mut current_beat = current_beat + 1;\n                               \
    \             if current_length == 10 {\n                                    \
    \            beats.push(current_beat);\n                                     \
    \           current_beat = 0;\n                                              \
    \  current_note = notes.next();\n                                            }\
    \ else {\n                                                let mut current_beat\
    \ = current_beat + 1;\n                                                if current_length\
    \ == 11 {\n                                                    beats.push(current_beat);\n\
    \                                                    current_beat\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpc8xbrl7g.rs:90:3\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n16 |\
    \     while current_note != \"\" {\n   |                              - unclosed\
    \ delimiter\n...\n22 |         } else {\n   |                - unclosed delimiter\n\
    ...\n28 |             } else {\n   |                    - unclosed delimiter\n\
    ...\n34 |                 } else {\n   |                        - unclosed delimiter\n\
    ...\n40 |                     } else {\n   |                            - unclosed\
    \ delimiter\n...\n46 |                         } else {\n   |                \
    \                - unclosed delimiter\n...\n52 |                             }\
    \ else {\n   |                                    - unclosed delimiter\n...\n\
    58 |                                 } else {\n   |                          \
    \              - unclosed delimiter\n...\n64 |                               \
    \      } else {\n   |                                            - unclosed delimiter\n\
    ...\n70 |                                         } else {\n   |             \
    \                                   - unclosed delimiter\n...\n76 |          \
    \                                   } else {\n   |                           \
    \                         - unclosed delimiter\n77 |                         \
    \                        let mut current_beat = current_beat + 1;\n78 |      \
    \                                           if current_length == 11 {\n   |  \
    \                                                                       - this\
    \ delimiter might not be properly closed...\n...\n81 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n90 | }\n   |   ^\n\nerror[E0277]:\
    \ can't compare `&str` with `str`\n  --> /tmp/tmpc8xbrl7g.rs:16:24\n   |\n16 |\
    \     while current_note != \"\" {\n   |                        ^^ no implementation\
    \ for `&str == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2 = 0;\n\
    \    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n    let\
    \ mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let mut\
    \ current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut current_note_oct9\
    \ = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11 =\
    \ 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 = 0;\n\
    \    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n  \
    \  let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n    let\
    \ mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let mut\
    \ current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut current_note_oct22\
    \ = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24 =\
    \ 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 = 0;\n\
    \    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n  \
    \  let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n    let\
    \ mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let mut\
    \ current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut current_note_oct35\
    \ = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37 =\
    \ 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 = 0;\n\
    \    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n  \
    \  let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n    let\
    \ mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let mut\
    \ current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut current_note_oct48\
    \ = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50 =\
    \ 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 = 0;\n\
    \    let mut current_note_oct53 = 0;\n    let mut current_note_\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt5cmtah0.rs:68:26\n   |\n\
    68 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpt5cmtah0.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = music_string.chars().nth(0).unwrap();\n   \
    \ let mut current_beats = 1;\n    let mut current_notes = 1;\n    let mut current_notes_beats\
    \ = 1;\n    let mut current_notes_beats_notes = 1;\n    let mut current_notes_beats_notes_beats\
    \ = 1;\n    let mut current_notes_beats_notes_beats_notes = 1;\n    let mut current_notes_beats_notes_beats_notes_beats\
    \ = 1;\n    let mut current_notes_beats_notes_beats_notes_beats_notes = 1;\n \
    \   let mut current_notes_beats_notes_beats_notes_beats_notes_beats = 1;\n   \
    \ let mut current_notes_beats_notes_beats_notes_beats_notes_beats_notes = 1;\n\
    \    let mut current_notes_beats_notes_beats_notes_beats_notes_beats_notes = 1;\n\
    \    let mut current_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats\
    \ = 1;\n    let mut current_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes\
    \ = 1;\n    let mut current_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats\
    \ = 1;\n    let mut current_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes\
    \ = 1;\n    let mut current_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes\
    \ = 1;\n    let mut current_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats\
    \ = 1;\n    let mut current_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes\
    \ = 1;\n    let mut current_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats\
    \ = 1;\n    let mut current_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes\
    \ = 1;\n    let mut current_notes_beats_\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph9f_x0zv.rs:34:33\n   |\n\
    34 |     let mut current_notes_beats_\n   |                                 ^\
    \ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph9f_x0zv.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut last_note\
    \ = notes.last().unwrap();\n    let mut last_beat = 0;\n    notes.iter().for_each(|note|\
    \ {\n        if note != last_note {\n            beats.push(last_beat);\n    \
    \        last_beat = 0;\n        }\n        last_beat = last_beat + 1;\n     \
    \   last_note = note;\n    });\n    beats.push(last_beat);\n    beats\n}\n\nfn\
    \ main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpy5_qeurp.rs:13:38\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2 = 0;\n\
    \    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n    let\
    \ mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let mut\
    \ current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut current_note_oct9\
    \ = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11 =\
    \ 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 = 0;\n\
    \    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n  \
    \  let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n    let\
    \ mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let mut\
    \ current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut current_note_oct22\
    \ = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24 =\
    \ 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 = 0;\n\
    \    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n  \
    \  let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n    let\
    \ mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let mut\
    \ current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut current_note_oct35\
    \ = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37 =\
    \ 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 = 0;\n\
    \    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n  \
    \  let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n    let\
    \ mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let mut\
    \ current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut current_note_oct48\
    \ = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50 =\
    \ 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 = 0;\n\
    \    let mut current_note_oct53 = 0;\n    let mut current_\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_kbdgzr6.rs:68:21\n   |\n\
    68 |     let mut current_\n   |                     ^ help: add `;` here\n69 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_kbdgzr6.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_value\
    \ = 0;\n    let mut current_note_length_value_next = 0;\n    let mut current_note_length_value_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next = 0;\n    let mut\
    \ current_note_length_value_next_next_next_next = 0;\n    let mut current_note_length_value_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next =\
    \ 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0j6li6je.rs:40:94\n   |\n\
    40 |     let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_\n\
    \   |                                                                        \
    \                      ^ help: add `;` here\n41 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0j6li6je.rs:10:41\n   |\n10 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------  \
    \                        ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |  \
    \  |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_value\
    \ = 0;\n    let mut current_note_length_value_next = 0;\n    let mut current_note_length_value_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next = 0;\n    let mut\
    \ current_note_length_value_next_next_next_next = 0;\n    let mut current_note_length_value_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next =\
    \ 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7b0ce2l9.rs:40:94\n   |\n\
    40 |     let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_\n\
    \   |                                                                        \
    \                      ^ help: add `;` here\n41 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7b0ce2l9.rs:10:41\n   |\n10 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------  \
    \                        ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |  \
    \  |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 1;\n    let mut current_note_length_index42\
    \ = 1;\n    let mut current_note_length_index43 = 1;\n    let mut current_note_length_index44\
    \ = 1;\n    let mut current_note_length_index45 = 1;\n    let mut current_note_length_index46\
    \ = 1;\n    let mut current_note_length_index47 = 1;\n    let mut current_note_length_index\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmy2b0kuv.rs:62:38\n   |\n\
    62 |     let mut current_note_length_index\n   |                             \
    \         ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmy2b0kuv.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_beat = 0;\n    let mut current_note_beat_len\
    \ = 0;\n    let mut current_note_octave = 0;\n    let mut current_note_octave_len\
    \ = 0;\n    let mut current_note_octave_bpm = 0.0;\n    let mut current_note_octave_bpm_len\
    \ = 0;\n    let mut current_note_octave_bpm_bpm = 0.0;\n    let mut current_note_octave_bpm_bpm_len\
    \ = 0;\n    let mut current_note_octave_bpm_bpm_octave = 0.0;\n    let mut current_note_octave_bpm_bpm_octave_len\
    \ = 0;\n    let mut current_note_octave_bpm_bpm_octave_bpm = 0.0;\n    let mut\
    \ current_note_octave_bpm_bpm_octave_bpm_len = 0;\n    let mut current_note_octave_bpm_bpm_octave_bpm_octave\
    \ = 0.0;\n    let mut current_note_octave_bpm_bpm_octave_bpm_octave_len = 0;\n\
    \    let mut current_note_octave_bpm_bpm_octave_bpm_octave_bpm = 0.0;\n    let\
    \ mut current_note_octave_bpm_bpm_octave_bpm_octave_bpm_len = 0;\n    let mut\
    \ current_note_octave_bpm_bpm_octave_bpm_octave_bpm_octave = 0.0;\n    let mut\
    \ current_note_octave_bpm_bpm_octave_bpm_octave_bpm_octave_len = 0;\n    let mut\
    \ current_note_octave_bpm_bpm_octave_bpm_octave_bpm_octave_bpm = 0.0;\n    let\
    \ mut current_note_octave_bpm_bpm_octave_bpm_octave_bpm_octave_bpm_len = 0;\n\
    \    let mut current_note_octave_bpm_bpm_octave_bpm_octave_bpm_octave_bpm_octave\
    \ = 0.0;\n    let mut current_note_octave_bpm_bpm_octave_bpm_octave_bpm_octave_bpm_octave_len\
    \ = 0;\n    let mut current_note_octave_bpm_bpm_octave_bpm_octave_bpm_octave_bpm_octave_bpm\
    \ = \n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp94m4naye.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = music_string.chars().nth(0).unwrap();\n   \
    \ let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length_index47\
    \ = 1;\n    let mut current_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgb50hqdw.rs:62:21\n   |\n\
    62 |     let mut current_\n   |                     ^ help: add `;` here\n63 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgb50hqdw.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_len = music_string.len();\n    while current_note_len\
    \ > 0 {\n        let mut note_len = current_note_len;\n        let mut note_char\
    \ = music_string[current_note_len..];\n        while note_char.len() > 0 {\n \
    \           let mut note_char = note_char.chars().nth(note_len - 1).unwrap();\n\
    \            if note_char == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat += 4;\n                current_note = String::new();\n\
    \                current_note_len = note_len;\n            } else if note_char\
    \ == 'o|' {\n                beats.push(current_beat);\n                current_beat\
    \ += 2;\n                current_note = String::new();\n                current_note_len\
    \ = note_len;\n            } else if note_char == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat += 1;\n                current_note = String::new();\n\
    \                current_note_len = note_len;\n            } else {\n        \
    \        current_note.push(note_char);\n            }\n            note_len -=\
    \ 1;\n        }\n        current_note_len = note_len;\n    }\n    beats\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp11tca4tr.rs:26:39\n\
    \   |\n26 |             } else if note_char == 'o|' {\n   |                  \
    \                     ^^^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    for c in music_string\
    \ {\n        if c == 'o' {\n            if current_note != \"\" {\n          \
    \      beats.push(current_beat);\n                current_beat = 0;\n        \
    \        current_note = String::new();\n                current_note_length =\
    \ 0;\n                current_note_length_index = 0;\n            }\n        }\
    \ else if c == '|' {\n            if current_note != \"\" {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = 0;\n                current_note_length_index\
    \ = 0;\n            }\n        } else if c == '.' {\n            if current_note\
    \ != \"\" {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n                current_note_length\
    \ = 0;\n                current_note_length_index = 0;\n            }\n      \
    \  } else {\n            current_note.push(c);\n            current_note_length\
    \ += 1;\n        }\n        if current_note_length_index == current_note_length\
    \ {\n            current_beat += 1;\n            current_note_length_index = 0;\n\
    \        }\n        current_note_length_index += 1;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpmop6adut.rs:16:14\n\
    \   |\n16 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.clone();\n    let mut current_beat = 0;\n    let mut current_beats_length\
    \ = 0;\n    while current_note.is_not_empty() {\n        let note = current_note.clone();\n\
    \        if note == \"o\" {\n            beats.push(current_beat);\n         \
    \   current_beat += 4;\n            current_beats_length += 4;\n            current_note.pop();\n\
    \        } else if note == \"o|\" {\n            beats.push(current_beat);\n \
    \           current_beat += 2;\n            current_beats_length += 2;\n     \
    \       current_note.pop();\n        } else if note == \".|\" {\n            beats.push(current_beat);\n\
    \            current_beat += 1;\n            current_beats_length += 1;\n    \
    \        current_note.pop();\n        } else {\n            panic!(\"Unknown note\
    \ '{}'\", note);\n        }\n    }\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_not_empty` found for struct `Vec<&str>`\
    \ in the current scope\n  --> /tmp/tmpn5y73tyq.rs:16:24\n   |\n16 |     while\
    \ current_note.is_not_empty() {\n   |                        ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_empty`\n\nerror[E0277]:\
    \ can't compare `Vec<&str>` with `&str`\n  --> /tmp/tmpn5y73tyq.rs:18:17\n   |\n\
    18 |         if note == \"o\" {\n   |                 ^^ no implementation for\
    \ `Vec<&str> == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `Vec<&str>`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as\
    \ PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n         \
    \    <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0277]: can't compare\
    \ `Vec<&str>` with `&str`\n  --> /tmp/tmpn5y73tyq.rs:23:24\n   |\n23 |       \
    \  } else if note == \"o|\" {\n   |                        ^^ no implementation\
    \ for `Vec<&str> == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not\
    \ implemented for `Vec<&str>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0277]: can't compare\
    \ `Vec<&str>` with `&str`\n  --> /tmp/tmpn5y73tyq.rs:28:24\n   |\n28 |       \
    \  } else if note == \".|\" {\n   |                        ^^ no implementation\
    \ for `Vec<&str> == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not\
    \ implemented for `Vec<&str>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_note = String::new();\n    let mut current_beat = 0;\n    let mut current_length\
    \ = 0;\n    for c in music_string.chars() {\n        if c.is_ascii() {\n     \
    \       if c.to_ascii_uppercase() == 'O' {\n                if current_note.is_empty()\
    \ {\n                    current_note = c.to_ascii_lowercase();\n            \
    \        current_beat = 0;\n                    current_length = 4;\n        \
    \        } else {\n                    current_length += 1;\n                }\n\
    \            } else if c.to_ascii_uppercase() == '|' {\n                if current_note.is_empty()\
    \ {\n                    current_note = c.to_ascii_lowercase();\n            \
    \        current_beat = 0;\n                    current_length = 2;\n        \
    \        } else {\n                    current_length += 1;\n                }\n\
    \            } else if c.to_ascii_uppercase() == '.' {\n                if current_note.is_empty()\
    \ {\n                    current_note = c.to_ascii_lowercase();\n            \
    \        current_beat = 0;\n                    current_length = 1;\n        \
    \        } else {\n                    current_length += 1;\n                }\n\
    \            } else {\n                println!(\"Unknown note {}\", c);\n   \
    \         }\n        } else {\n            println!(\"Unknown character {}\",\
    \ c);\n        }\n    }\n    if current_note.is_empty() {\n        println!(\"\
    Empty note\");\n    }\n    beats.push(current_beat);\n    beats.push(current_length);\n\
    \    beats.push(current_note.len());\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpejtduyax.rs:19:36\n   |\n\
    12 |     let mut current_note = String::new();\n   |                         \
    \   ------------- expected due to this value\n...\n19 |                     current_note\
    \ = c.to_ascii_lowercase();\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \                  |\n   |                                    expected struct\
    \ `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpejtduyax.rs:27:36\n\
    \   |\n12 |     let mut current_note = String::new();\n   |                  \
    \          ------------- expected due to this value\n...\n27 |               \
    \      current_note = c.to_ascii_lowercase();\n   |                          \
    \          ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                    |\n   |                             \
    \       expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpejtduyax.rs:35:36\n   |\n12 |     let mut current_note = String::new();\n\
    \   |                            ------------- expected due to this value\n...\n\
    35 |                     current_note = c.to_ascii_lowercase();\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                    |\n   |    \
    \                                expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpejtduyax.rs:53:16\n   |\n53 |     beats.push(current_note.len());\n\
    \   |                ^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n53 |     beats.push(current_note.len().try_into().unwrap());\n\
    \   |                                  ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate();\n    let mut current_note = 0;\n    let\
    \ mut current_beat = 0;\n    let mut current_beats_left = 0;\n    let mut last_note\
    \ = notes.next();\n    loop {\n        if current_note == 0 {\n            current_beats_left\
    \ = 0;\n            current_beat = 0;\n        }\n        let note = notes.next();\n\
    \        let note = note.expect(\"No more notes\");\n        let note = note.expect(\"\
    No more notes\");\n        let note = note.expect(\"No more notes\");\n      \
    \  let note = note.expect(\"No more notes\");\n        let note = note.expect(\"\
    No more notes\");\n        let note = note.expect(\"No more notes\");\n      \
    \  let note = note.expect(\"No more notes\");\n        let note = note.expect(\"\
    No more notes\");\n        let note = note.expect(\"No more notes\");\n      \
    \  let note = note.expect(\"No more notes\");\n        let note = note.expect(\"\
    No more notes\");\n        let note = note.expect(\"No more notes\");\n      \
    \  let note = note.expect(\"No more notes\");\n        let note = note.expect(\"\
    No more notes\");\n        let note = note.expect(\"No more notes\");\n      \
    \  let note = note.expect(\"No more notes\");\n        let note = note.expect(\"\
    No more notes\");\n        let note = note.expect(\"No more notes\");\n      \
    \  let note = note.expect(\"No more notes\");\n        let note = note.expect(\"\
    No more notes\");\n        let note = note.expect(\"No more notes\");\n      \
    \  let note = note.expect(\"No more notes\");\n        let note = note.expect(\"\
    No more notes\");\n        let note = note.expect(\"No more notes\");\n      \
    \  let note = note.expect(\"No more notes\");\n        let note = note.expect(\"\
    No more notes\");\n        let note = note.expect(\"No more notes\");\n      \
    \  let note = note.expect(\"No more notes\");\n        let note = note.expect(\"\
    No more notes\");\n        let note = note.expect(\"No more notes\");\n      \
    \  let note = note.expect(\"No more notes\");\n        let note = note.expect(\"\
    No more notes\");\n        let note = note.expect(\"No more notes\");\n      \
    \  let note = note.expect(\"No more notes\");\n        let note = note.expect(\"\
    No more notes\");\n        let note = note.expect(\"\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp70s4e77l.rs:67:61\n\
    \   |\n67 |       assert_eq!(candidate(String::from(\"o| .| o| .| o o| o o|\"\
    )), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n   |  _____________________________________________________________^\n\
    68 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjadba97j.rs:63:26\n   |\n\
    63 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjadba97j.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = music_string.chars().nth(0).unwrap();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp72r2tbif.rs:63:1\n  \
    \ |\n63 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_note_length: isize = 0;\n    for c in music_string.chars()\
    \ {\n        if c == current_note {\n            current_note_length += 1;\n \
    \       } else {\n            if current_note_length > 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note_length = 0;\n\
    \            }\n            current_note = c;\n            current_note_length\
    \ = 1;\n        }\n        current_beat += 1;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpiurapckh.rs:13:56\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, note)| note != '|');\n    for\
    \ note in notes {\n        note.1.push(note.0);\n    }\n    for note in notes\
    \ {\n        let note_string = note.1.join(\"\");\n        if note_string.len()\
    \ == 1 {\n            beats.push(1);\n        } else {\n            let beat =\
    \ note_string.chars().enumerate().filter(|(_, beat)| beat != '|').next().unwrap().1;\n\
    \            beats.push(beat);\n        }\n    }\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpe_x2609f.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != '|');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0599]: no method named `push`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpe_x2609f.rs:14:16\n\
    \   |\n14 |         note.1.push(note.0);\n   |                ^^^^ method not\
    \ found in `char`\n\nerror[E0599]: no method named `join` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpe_x2609f.rs:17:34\n   |\n17 |         let\
    \ note_string = note.1.join(\"\");\n   |                                  ^^^^\
    \ method not found in `char`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 1;\n    let mut current_note_length_index42\
    \ = 1;\n    let mut current_note_length_index43 = 1;\n    let mut current_note_length_index44\
    \ = 1;\n    let mut current_note_length_index45 = 1;\n    let mut current_note_length_index46\
    \ = 1;\n    let mut current_note_length_index47 = 1;\n    let mut current_note_length_index\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpn5iylghc.rs:62:38\n   |\n\
    62 |     let mut current_note_length_index\n   |                             \
    \         ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn5iylghc.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat: isize = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_octlen = 0;\n    let mut current_note_octoctlen = 0;\n    let mut\
    \ current_note_octoctlenlen = 0;\n    let mut current_note_octlenlenlen = 0;\n\
    \    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n    let mut current_note_octlenlenlen = 0;\n    let mut current_note_octlenlenlen\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe4jkj_e5.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = notes.first().unwrap();\n    let mut current_beat = 0;\n    let\
    \ mut current_note_count = 0;\n    let mut last_note_count = 0;\n    let mut last_beat\
    \ = 0;\n    let mut last_note = notes.last().unwrap();\n    while current_note\
    \ != last_note {\n        if current_note == \"o\" {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note_count += 1;\n       \
    \     last_note_count = current_note_count;\n            last_beat = current_beat;\n\
    \            current_note_count = 0;\n            current_note = notes.next();\n\
    \        } else if current_note == \"o|\" {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note_count += 1;\n       \
    \     last_note_count = current_note_count;\n            last_beat = current_beat;\n\
    \            current_note_count = 0;\n            current_note = notes.next();\n\
    \        } else if current_note == \".|\" {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note_count += 1;\n       \
    \     last_note_count = current_note_count;\n            last_beat = current_beat;\n\
    \            current_note_count = 0;\n            current_note = notes.next();\n\
    \        } else {\n            current_beat += 1;\n            current_note_count\
    \ = 0;\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmpkg60up7o.rs:20:25\n\
    \   |\n20 |         if current_note == \"o\" {\n   |                         ^^\
    \ no implementation for `&str == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&str>` for `&&str`\n\nerror[E0599]: no method named `next`\
    \ found for struct `Vec<&str>` in the current scope\n  --> /tmp/tmpkg60up7o.rs:27:34\n\
    \   |\n27 |             current_note = notes.next();\n   |                   \
    \               ^^^^ method not found in `Vec<&str>`\n\nerror[E0277]: can't compare\
    \ `&str` with `str`\n  --> /tmp/tmpkg60up7o.rs:28:32\n   |\n28 |         } else\
    \ if current_note == \"o|\" {\n   |                                ^^ no implementation\
    \ for `&str == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0599]:\
    \ no method named `next` found for struct `Vec<&str>` in the current scope\n \
    \ --> /tmp/tmpkg60up7o.rs:35:34\n   |\n35 |             current_note = notes.next();\n\
    \   |   "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = 0;\n    for c in music_string {\n        if c == 'o' {\n            if current_note\
    \ != String::new() {\n                beats.push(current_beat);\n            \
    \    current_beat = 0;\n                current_note = String::new();\n      \
    \      }\n            current_note_length = 0;\n            current_note.push_str(&c);\n\
    \        } else if c == '|' {\n            if current_note != String::new() {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n            }\n            current_note_length\
    \ = 1;\n            current_note.push_str(&c);\n        } else if c == '.' {\n\
    \            if current_note != String::new() {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            }\n            current_note_length = 2;\n            current_note.push_str(&c);\n\
    \        } else {\n            current_note.push_str(&c);\n            current_note_length\
    \ += 1;\n        }\n        current_beat += 1;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp0r4j518h.rs:15:14\n\
    \   |\n15 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmp0r4j518h.rs:15:9\n   |\n15 |     for c in music_string {\n   |     \
    \    ^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp0r4j518h.rs:15:14\n    |\n15  |     for c in music_string {\n    | \
    \             ^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n\
    \    = help: the trait `Sized` is not implemented for `str`\nnote: required by\
    \ a bound in `Option`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmp0r4j518h.rs:15:5\n    |\n15  |\
    \ /     for c in music_string {\n16  | |         if c == 'o' {\n17  | |      \
    \       if current_note != String::new() {\n18  | |                 beats.push(current_beat);\n\
    ...   |\n44  | |         current_beat += 1;\n45  | |     }\n    | |_____^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `None`\n\nerror[E0277]:\
    \ can't compare `str` with `char`\n  --> /tmp/tmp0r4j518h.rs:16:14\n   |\n16 |\
    \         if c == 'o' {\n   |              ^^ no implementation for `str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `str`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<C"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_note = String::new();\n    let mut current_beat = 0;\n    let mut current_beats_length\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_note_is_last\
    \ = false;\n    let mut current_note_length_is_last = false;\n    let mut current_note_length_is_last_is_even\
    \ = false;\n    let mut current_note_length_is_last_is_odd = false;\n    let mut\
    \ current_note_length_is_last_is_even = false;\n    let mut current_note_length_is_last_is_odd\
    \ = false;\n    let mut current_note_length_is_last_is_even = false;\n    let\
    \ mut current_note_length_is_last_is_odd = false;\n    let mut current_note_length_is_last_is_even\
    \ = false;\n    let mut current_note_length_is_last_is_odd = false;\n    let mut\
    \ current_note_length_is_last_is_even = false;\n    let mut current_note_length_is_last_is_odd\
    \ = false;\n    let mut current_note_length_is_last_is_even = false;\n    let\
    \ mut current_note_length_is_last_is_odd = false;\n    let mut current_note_length_is_last_is_even\
    \ = false;\n    let mut current_note_length_is_last_is_odd = false;\n    let mut\
    \ current_note_length_is_last_is_even = false;\n    let mut current_note_length_is_last_is_odd\
    \ = false;\n    let mut current_note_length_is_last_is_even = false;\n    let\
    \ mut current_note_length_is_last_is_odd = false;\n    let mut current_note_length_is_last_is_even\
    \ = false;\n    let mut current_note_length_is_last_is_odd = false;\n    let mut\
    \ current_note_length_is_last_is_even = false;\n    let mut current_note_length_is_last_is_odd\
    \ = false;\n    let mut current_note_length_is_last_is_even = false;\n    let\
    \ mut current_note_length_is_last_is_odd = false;\n    let mut current_note_length_is_last_is_even\
    \ = false;\n    let mut current_note_length_is_last_is_odd = false;\n    let mut\
    \ current_note_length_is_last_is_even = false;\n    let mut current_note_length_is_last_is_odd\
    \ = false;\n    let mut current_note_length_is_last_is_even = false;\n    let\
    \ mut current_note_length_is_last_is_odd = false;\n    let mut current_note_length_is_last_is_even\
    \ = false;\n    let mut current_note_length_is_last_is_odd = false;\n    let mut\
    \ current_note_length_is_last_is_even = false;\n    let mut current_note_length_is_last_is_odd\
    \ = false;\n    let mut current_note_length_is_last_is_even = false;\n    let\
    \ mut current_note_length_is_last_is_odd = false;\n    let mut current_note_length_is_last_is_even\
    \ = false;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgtkts190.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = String::new();\n    let mut\
    \ current_note_len = 0;\n    for c in music_string.chars() {\n        if c.is_ascii()\
    \ {\n            if c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_len = c.len_utf8();\n            } else if c.to_ascii_lowercase()\
    \ == 'o|' {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n                current_note_len\
    \ = c.len_utf8();\n            } else if c.to_ascii_lowercase() == '.|' {\n  \
    \              beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_len\
    \ = c.len_utf8();\n            } else {\n                current_note.push(c);\n\
    \                current_note_len = c.len_utf8();\n            }\n        } else\
    \ {\n            if current_note.len() == 0 {\n                println!(\"Invalid\
    \ music string\");\n                return beats;\n            }\n           \
    \ if c.is_ascii() {\n                if c.to_ascii_lowercase() == 'o' {\n    \
    \                beats.push(current_beat);\n                    current_beat =\
    \ 0;\n                    current_note = String::new();\n                    current_note_len\
    \ = c.len_utf8();\n                } else if c.to_ascii_lowercase() == 'o|' {\n\
    \                    beats.push(current_beat);\n                    current_beat\
    \ = 0;\n                    current_note = String::new();\n                  \
    \  current_note_len = c.len_utf8();\n                } else if c.to_ascii_lowercase()\
    \ == '.|' {\n                    beats.push(current_beat);\n                 \
    \   current_beat = 0;\n                    current_note = String::new();\n   \
    \                 current_note_len = c.len_utf8();\n                } else {\n\
    \                    current_note.push(c);\n                    current_note_len\
    \ = c.len_utf8();\n                }\n            } else {\n                if\
    \ current_note.len() == 0 {\n                    println!(\"Invalid music string\"\
    );\n                    return beats;\n                }\n                if c.is_ascii()\
    \ {\n                    if c.to_ascii_lowercase() == 'o' {\n                \
    \        beats.push(current_beat);\n                        current_beat = 0;\n\
    \                        current_note = String::new();\n                     \
    \   current_note_len = c.len_utf8();\n                    } else if c.to_ascii_lowercase()\
    \ == 'o|' {\n                        beats.push(current_beat);\n             \
    \           current_beat = 0;\n                        current_note = String::new();\n\
    \                        current_note_len = c.len_utf8();\n                  \
    \  } else if c.to_ascii_lowercase() == '.|' {\n                        beats.push(current_beat);\n\
    \                        current_beat = 0;\n                        \n}\n\nfn\
    \ main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpqnyn5_x_.rs:22:52\n\
    \   |\n22 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.last().unwrap();\n    let mut current_beat = 0;\n    let mut current_note_length\
    \ = 0;\n    while current_note != \".\" {\n        if current_note == \"o\" {\n\
    \            beats.push(current_beat);\n            current_beat = 0;\n      \
    \      current_note_length = 4;\n        }\n        if current_note == \"o|\"\
    \ {\n            beats.push(current_beat);\n            current_beat = 0;\n  \
    \          current_note_length = 2;\n        }\n        if current_note == \"\
    .|\" {\n            beats.push(current_beat);\n            current_beat = 0;\n\
    \            current_note_length = 1;\n        }\n        current_note += notes.last().unwrap();\n\
    \        current_beat += current_note_length;\n        notes.pop();\n    }\n \
    \   beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmpzqblic1w.rs:16:24\n\
    \   |\n16 |     while current_note != \".\" {\n   |                        ^^\
    \ no implementation for `&str == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]: can't compare `&str`\
    \ with `str`\n  --> /tmp/tmpzqblic1w.rs:17:25\n   |\n17 |         if current_note\
    \ == \"o\" {\n   |                         ^^ no implementation for `&str == str`\n\
    \   |\n   = help: the trait `PartialEq<str>` is not implemented for `&str`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]:\
    \ can't compare `&str` with `str`\n  --> /tmp/tmpzqblic1w.rs:22:25\n   |\n22 |\
    \         if current_note == \"o|\" {\n   |                         ^^ no implementation\
    \ for `&str == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdbrezh88.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate();\n    let mut last_note = notes.next();\n\
    \    let mut last_beat = 0;\n    let mut last_beats_length = 0;\n    while let\
    \ Some(note) = last_note {\n        let mut beats_length = 0;\n        while let\
    \ Some(beat) = note.next() {\n            beats_length += beat;\n            last_beats_length\
    \ += beat;\n        }\n        beats.push(beats_length);\n        last_beat =\
    \ note;\n        last_beats_length = beats_length;\n        last_note = notes.next();\n\
    \    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `next` found for tuple `(usize, char)` in\
    \ the current scope\n  --> /tmp/tmpkkz71kd5.rs:18:37\n   |\n18 |         while\
    \ let Some(beat) = note.next() {\n   |                                     ^^^^\
    \ method not found in `(usize, char)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkkz71kd5.rs:23:21\n   |\n14 |     let mut last_beat = 0;\n   |     \
    \                    - expected due to this value\n...\n23 |         last_beat\
    \ = note;\n   |                     ^^^^ expected integer, found tuple\n   |\n\
    \   = note: expected type `{integer}`\n             found tuple `(usize, char)`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_note_len = 0;\n    let mut current_note_beat = 0;\n    let mut current_note_beat_len\
    \ = 0;\n    let mut current_note_octave = 0;\n    let mut current_note_octave_len\
    \ = 0;\n    let mut current_note_octave_sign = 0;\n    let mut current_note_octave_sign_len\
    \ = 0;\n    let mut current_note_octave_octave = 0;\n    let mut current_note_octave_octave_len\
    \ = 0;\n    let mut current_note_octave_octave_sign = 0;\n    let mut current_note_octave_octave_sign_len\
    \ = 0;\n    let mut current_note_octave_octave_octave = 0;\n    let mut current_note_octave_octave_octave_len\
    \ = 0;\n    let mut current_note_octave_octave_octave_sign = 0;\n    let mut current_note_octave_octave_sign_len\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave = 0;\n    let mut\
    \ current_note_octave_octave_octave_len = 0;\n    let mut current_note_octave_octave_octave_sign\
    \ = 0;\n    let mut current_note_octave_octave_sign_len = 0;\n    let mut current_note_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_len = 0;\n    let mut current_note_octave_octave_octave_sign\
    \ = 0;\n    let mut current_note_octave_octave_sign_len = 0;\n    let mut current_note_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_len = 0;\n    let mut current_note_octave_octave_octave_sign\
    \ = 0;\n    let mut current_note_octave_octave_sign_len = 0;\n    let mut current_note_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_len = 0;\n    let mut current_note_octave_octave_octave_sign\
    \ = 0;\n    let mut current_note_octave_octave_sign_len = 0;\n    let mut current_note_octave_octave_octave_octave\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2je8wkvf.rs:46:11\n   |\n\
    46 |     let mu\n   |           ^ help: add `;` here\n47 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2je8wkvf.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_index\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_value = 0;\n    let mut current_note_length_value_index\
    \ = 0;\n    let mut current_note_length_value_value = 0;\n    let mut current_note_length_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpltmc1vj8.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate();\n    let mut current_note = 0;\n    let\
    \ mut current_beat = 0;\n    let mut current_note_length = 0;\n    let mut current_beat_length\
    \ = 0;\n    let mut current_note_length_to_beats = HashMap::new();\n    let mut\
    \ current_beat_length_to_notes = HashMap::new();\n    let mut current_note_to_beats\
    \ = HashMap::new();\n    let mut current_note_to_notes = HashMap::new();\n   \
    \ let mut current_note_to_lengths = HashMap::new();\n    let mut current_note_to_lengths_to_beats\
    \ = HashMap::new();\n    let mut current_note_to_lengths_to_notes = HashMap::new();\n\
    \    let mut current_note_to_lengths_to_lengths = HashMap::new();\n    let mut\
    \ current_note_to_lengths_to_lengths_to_beats = HashMap::new();\n    let mut current_note_to_lengths_to_lengths_to_notes\
    \ = HashMap::new();\n    let mut current_note_to_lengths_to_lengths_to_lengths\
    \ = HashMap::new();\n    let mut current_note_to_lengths_to_lengths_to_lengths_to_beats\
    \ = HashMap::new();\n    let mut current_note_to_lengths_to_lengths_to_lengths_to_notes\
    \ = HashMap::new();\n    let mut current_note_to_lengths_to_lengths_to_lengths_to_lengths\
    \ = HashMap::new();\n    let mut current_note_to_lengths_to_lengths_to_lengths_to_lengths_to_beats\
    \ = HashMap::new();\n    let mut current_note_to_lengths_to_lengths_to_lengths_to_lengths_to_notes\
    \ = HashMap::new();\n    let mut current_note_to_lengths_to_lengths_to_lengths_to_lengths_to_lengths\
    \ = HashMap::new();\n    let mut current_note_to_lengths_to_lengths_to_lengths_to_lengths_to_beats\
    \ = HashMap::new();\n    let mut current_note_to_lengths_to_lengths_to_lengths_to_lengths_to_notes\
    \ = HashMap::new();\n    let mut current_note_to_lengths_to_lengths_to_lengths_to_lengths_to_lengths\
    \ = HashMap::new();\n    let mut current_note_to_lengths_to_lengths_to_lengths_to_lengths_to_lengths_to_beats\
    \ = HashMap::new();\n    let mut current_note_to_lengths_to_lengths_to_lengths_to_lengths_to_lengths_to_notes\
    \ = HashMap::new();\n    let mut current_note_to_lengths_to_lengths_to_lengths_to_lengths_to_lengths_to_lengths\
    \ = HashMap::new();\n    let mut current_note_to_lengths_to_lengths_to_lengths_to_lengths_to_lengths_to_beats\
    \ = Hash\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp81h_5p10.rs:40:96\n   |\n\
    40 |     let mut current_note_to_lengths_to_lengths_to_lengths_to_lengths_to_lengths_to_beats\
    \ = Hash\n   |                                                               \
    \                                 ^ help: add `;` here\n41 | }\n   | - unexpected\
    \ token\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n\
    \  --> /tmp/tmp81h_5p10.rs:17:44\n   |\n17 |     let mut current_note_length_to_beats\
    \ = HashMap::new();\n   |                                            ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashMap`\n  --> /tmp/tmp81h_5p10.rs:18:44\n   |\n18 |  \
    \   let mut current_beat_length_to_notes = HashMap::new();\n   |             \
    \                               ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp81h_5p10.rs:19:37\n\
    \   |\n19 |     let mut current_note_to_beats = HashMap::new();\n   |        \
    \                             ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp81h_5p10.rs:20:37\n\
    \   |\n20 |     let mut current_note_to_notes = HashMap::new();\n   |        \
    \                             ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp81h_5p10.rs:21:39\n\
    \   |\n21 |     let mut current_note_to_lengths = HashMap::new();\n   |      \
    \                                 ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp81h_"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl8m32u7f.rs:63:11\n   |\n\
    63 |     let mu\n   |           ^ help: add `;` here\n64 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl8m32u7f.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    for c in music_string {\n        if c == 'o' {\n            if current_note_len\
    \ > 0 {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note.clear();\n                current_note_len\
    \ = 0.0;\n            }\n        } else if c == '|' {\n            if current_note_len\
    \ > 0 {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note.clear();\n                current_note_len\
    \ = 0.0;\n            }\n            current_note_len += 1;\n        } else if\
    \ c == '.' {\n            if current_note_len > 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note.clear();\n  \
    \              current_note_len = 0.0;\n            }\n            current_note_len\
    \ += 1;\n        } else {\n            current_note.push(c);\n            current_note_len\
    \ = c.len_utf8();\n        }\n    }\n    if current_note_len > 0 {\n        beats.push(current_beat);\n\
    \    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpxtj9mdwo.rs:15:14\n\
    \   |\n15 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxtj9mdwo.rs:21:36\n   |\n14 |     let mut current_note_len\
    \ = 0;\n   |                                - expected due to this value\n...\n\
    21 |                 current_note_len = 0.0;\n   |                           \
    \         ^^^ expected integer, found floating-point number\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxtj9mdwo.rs:28:36\n   |\n14 |     let mut current_note_len\
    \ = 0;\n   |                                - expected due to this value\n...\n\
    28 |                 current_note_len = 0.0;\n   |                           \
    \         ^^^ expected integer, found floating-point number\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxtj9mdwo.rs:36:36\n   |\n14 |     let mut current_note_len\
    \ = 0;\n   |                                - expected due to this value\n...\n\
    36 |                 current_note_len = 0.0;\n   |                           \
    \         ^^^ expected integer, found floating-point number\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().enumerate().filter(|(_,\
    \ note)| note != '|');\n    let mut current_note = 0;\n    let mut current_beat\
    \ = 0;\n    for note in notes {\n        match note {\n            'o' => beats.push(current_beat),\n\
    \            'o|' => beats.push(current_beat),\n            '.|' => beats.push(current_beat),\n\
    \            _ => {\n                beats.push(current_beat);\n             \
    \   current_beat = 0;\n                current_note += 1;\n            }\n   \
    \     }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n \
    \   let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpzmdg2v0p.rs:18:16\n\
    \   |\n18 |             'o|' => beats.push(current_beat),\n   |              \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, c)| c != '|').collect::<Vec<_>>();\n\
    \    let mut current_note = 0;\n    let mut current_beat = 0;\n    let mut last_note\
    \ = -1;\n    let mut last_beat = -1;\n    for note in notes {\n        let note\
    \ = note.0;\n        let beat = note.parse::<isize>().unwrap();\n        if note\
    \ != '.' {\n            if note != 'o' {\n                if note != 'o|' {\n\
    \                    current_note += 1;\n                }\n                else\
    \ {\n                    current_note += 2;\n                }\n            }\n\
    \            else {\n                current_note += 4;\n            }\n     \
    \   }\n        else {\n            if note == 'o' {\n                if last_note\
    \ == -1 {\n                    last_note = current_note;\n                   \
    \ last_beat = current_beat;\n                }\n                else {\n     \
    \               beats.push(current_beat - last_beat);\n                    last_beat\
    \ = current_beat;\n                }\n                current_note = 0;\n    \
    \            current_beat = 0;\n            }\n            else {\n          \
    \      if last_note == -1 {\n                    last_note = current_note;\n \
    \                   last_beat = current_beat;\n                }\n           \
    \     else {\n                    beats.push(current_beat - last_beat);\n    \
    \                last_beat = current_beat;\n                }\n              \
    \  current_note = 0;\n                current_beat = 0;\n            }\n     \
    \   }\n    }\n    beats.push(current_beat - last_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmph8onwi23.rs:22:31\n\
    \   |\n22 |                 if note != 'o|' {\n   |                          \
    \     ^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 1;\n    let mut current_note_length_index42\
    \ = 1;\n    let mut current_note_length_index43 = 1;\n    let mut current_note_length_index44\
    \ = 1;\n    let mut current_note_length_index45 = 1;\n    let mut current_note_length_index46\
    \ = 1;\n    let mut current_note_length_index47 = 1;\n    let mut current_\n}\n\
    \nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7ujd_92y.rs:62:21\n   |\n\
    62 |     let mut current_\n   |                     ^ help: add `;` here\n63 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ujd_92y.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = music_string.chars().nth(0).unwrap();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprfhsmbcf.rs:61:32\n   |\n\
    61 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprfhsmbcf.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_char = 0;\n    let mut current_note_char_len\
    \ = 0;\n    let mut current_note_char_value = 0;\n    let mut current_note_char_next_value\
    \ = 0;\n    let mut current_note_char_next_len = 0;\n    let mut current_note_char_next_char\
    \ = 0;\n    let mut current_note_char_next_char_len = 0;\n    let mut current_note_char_next_char_next_value\
    \ = 0;\n    let mut current_note_char_next_char_next_len = 0;\n    let mut current_note_char_next_char_next_char\
    \ = 0;\n    let mut current_note_char_next_char_next_char_len = 0;\n    let mut\
    \ current_note_char_next_char_next_char_next_value = 0;\n    let mut current_note_char_next_char_next_char_next_len\
    \ = 0;\n    let mut current_note_char_next_char_next_char_next_char = 0;\n   \
    \ let mut current_note_char_next_char_next_char_next_char_len = 0;\n    let mut\
    \ current_note_char_next_char_next_char_next_char_next_value = 0;\n    let mut\
    \ current_note_char_next_char_next_char_next_char_next_len = 0;\n    let mut current_note_char_next_char_next_char_next_char_next_char_len\
    \ = 0;\n    let mut current_note_char_next_char_next_char_next_char_next_char_next_value\
    \ = 0;\n    let mut current_note_char_next_char_next_char_next_char_next_char_next_len\
    \ = 0;\n    let mut current_note_char_next_char_next_char_next_char_next_char_next_char_len\
    \ = 0;\n    let mut current_note_char_next_char_next_char_next_char_next_char_next_char_next_value\
    \ = 0;\n    let mut current_note_char_next_char_next_char_next_char_next_char_next_char_next_len\
    \ = 0;\n    let mut current_note_char_next_char_next_char_next_char_next_char_next_char_next_char_len\
    \ = 0;\n    let mut current_note_char_next_char_next_char_next_char_next_char_next_char_next_char_next_value\
    \ = 0;\n    let mut current_note_char_next_char_next_char_next_char_next_char_next_char_next_char_next_char_len\
    \ = 0;\n    let mut current_note_char_next_char_next_char_next_char_next_char_next_char_next_char_next_char_len\
    \ = 0;\n    let mut current_note_char_next_char_next_char_next_char_next_char_next_char_next_char_next_char_next_value\
    \ = 0;\n    let mut current_note_char_next_char_next_char_next_char_next_char_next_char_next_char_next_char_next_char_len\
    \ = 0;\n    let mut current_note_char_next_char_next_char_next_char_next_char_next_char_next_char_next_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3tdyahs4.rs:44:96\n   |\n\
    44 |     let mut current_note_char_next_char_next_char_next_char_next_char_next_char_next_char_next_\n\
    \   |                                                                        \
    \                        ^ help: add `;` here\n45 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3tdyahs4.rs:10:41\n   |\n10 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------  \
    \                        ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |  \
    \  |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = music_string.chars().nth(0).unwrap();\n   \
    \ for c in music_string.chars().skip(1) {\n        if c == '|' {\n           \
    \ beats.push(current_beat);\n            current_beat = 0;\n            current_note\
    \ = c.unwrap();\n        } else {\n            current_beat += 1;\n        }\n\
    \    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp41yo5b1u.rs:18:30\n   |\n18 |             current_note\
    \ = c.unwrap();\n   |                              ^^^^^^ method not found in\
    \ `char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat = 0;\n    let mut\
    \ current_note_length_to_beat_length_to_beat_length = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_kscrdjz.rs:32:146\n   |\n\
    32 |     let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_\n\
    \   |                                                                        \
    \                                                                          ^ help:\
    \ add `;` here\n33 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_kscrdjz.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    for\
    \ c in music_string.chars() {\n        if c == 'o' {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \      } else if c == '|' {\n            current_beat = current_beat + 1;\n  \
    \      } else if c == '.' {\n            current_note.push_str(&current_beat);\n\
    \            current_beat = 0;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6j899ue_.rs:22:35\n   |\n\
    22 |             current_note.push_str(&current_beat);\n   |                 \
    \                  ^^^^^^^^^^^^^ expected `str`, found `isize`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2 = 0;\n\
    \    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n    let\
    \ mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let mut\
    \ current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut current_note_oct9\
    \ = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11 =\
    \ 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 = 0;\n\
    \    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n  \
    \  let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n    let\
    \ mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let mut\
    \ current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut current_note_oct22\
    \ = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24 =\
    \ 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 = 0;\n\
    \    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n  \
    \  let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n    let\
    \ mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let mut\
    \ current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut current_note_oct35\
    \ = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37 =\
    \ 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 = 0;\n\
    \    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n  \
    \  let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n    let\
    \ mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let mut\
    \ current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut current_note_oct48\
    \ = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50 =\
    \ 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 = 0;\n\
    \    let mut current_note_oct53 = 0;\n    let mut current_note_\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7akj47lq.rs:68:26\n   |\n\
    68 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7akj47lq.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note_index = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpwmn7sap0.rs:63:1\n\
    \   |\n63 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_value = 0;\n \
    \   let mut current_note_length = 0;\n    let mut current_note_length_value =\
    \ 0;\n    let mut current_note_length_value2 = 0;\n    let mut current_note_length_value3\
    \ = 0;\n    let mut current_note_length_value4 = 0;\n    let mut current_note_length_value5\
    \ = 0;\n    let mut current_note_length_value6 = 0;\n    let mut current_note_length_value7\
    \ = 0;\n    let mut current_note_length_value8 = 0;\n    let mut current_note_length_value9\
    \ = 0;\n    let mut current_note_length_value10 = 0;\n    let mut current_note_length_value11\
    \ = 0;\n    let mut current_note_length_value12 = 0;\n    let mut current_note_length_value13\
    \ = 0;\n    let mut current_note_length_value14 = 0;\n    let mut current_note_length_value15\
    \ = 0;\n    let mut current_note_length_value16 = 0;\n    let mut current_note_length_value17\
    \ = 0;\n    let mut current_note_length_value18 = 0;\n    let mut current_note_length_value19\
    \ = 0;\n    let mut current_note_length_value20 = 0;\n    let mut current_note_length_value21\
    \ = 0;\n    let mut current_note_length_value22 = 0;\n    let mut current_note_length_value23\
    \ = 0;\n    let mut current_note_length_value24 = 0;\n    let mut current_note_length_value25\
    \ = 0;\n    let mut current_note_length_value26 = 0;\n    let mut current_note_length_value27\
    \ = 0;\n    let mut current_note_length_value28 = 0;\n    let mut current_note_length_value29\
    \ = 0;\n    let mut current_note_length_value30 = 0;\n    let mut current_note_length_value31\
    \ = 0;\n    let mut current_note_length_value32 = 0;\n    let mut current_note_length_value33\
    \ = 0;\n    let mut current_note_length_value34 = 0;\n    let mut current_note_length_value35\
    \ = 0;\n    let mut current_note_length_value36 = 0;\n    let mut current_note_length_value37\
    \ = 0;\n    let mut current_note_length_value38 = 0;\n    let mut current_note_length_value39\
    \ = 0;\n    let mut current_note_length_value40 = 0;\n    let mut current_note_length_value41\
    \ = 0;\n    let mut current_note_length_value42 = 0;\n    let mut current_note_length_value43\
    \ = 0;\n    let mut current_note_length_value44 = 0;\n    let mut current_note_length_value45\
    \ = 0;\n    let mut current_note_length_value46 = 0;\n    let mut current_note_length_value47\
    \ = 0;\n    let mut current_note_length_value48\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpy9hthfsr.rs:63:40\n   |\n\
    63 |     let mut current_note_length_value48\n   |                           \
    \             ^ help: add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy9hthfsr.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.last().unwrap();\n    let mut current_beat = 0;\n    let mut current_beats:\
    \ isize = 0;\n    let mut current_notes: isize = 0;\n    for note in notes {\n\
    \        if note != current_note {\n            beats.push(current_beats);\n \
    \           current_beats = 0;\n            current_note = note;\n           \
    \ current_notes += 1;\n        }\n        current_beats += 1;\n        current_beats\
    \ += 1;\n    }\n    beats.push(current_beats);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpw827hfxu.rs:18:17\n\
    \   |\n18 |         if note != current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw827hfxu.rs:21:28\n   |\n13 |     let mut current_note\
    \ = notes.last().unwrap();\n   |                            ---------------------\
    \ expected due to this value\n...\n21 |             current_note = note;\n   |\
    \                            ^^^^ expected `&str`, found `str`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2 = 0;\n\
    \    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n    let\
    \ mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let mut\
    \ current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut current_note_oct9\
    \ = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11 =\
    \ 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 = 0;\n\
    \    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n  \
    \  let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n    let\
    \ mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let mut\
    \ current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut current_note_oct22\
    \ = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24 =\
    \ 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 = 0;\n\
    \    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n  \
    \  let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n    let\
    \ mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let mut\
    \ current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut current_note_oct35\
    \ = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37 =\
    \ 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 = 0;\n\
    \    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n  \
    \  let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n    let\
    \ mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let mut\
    \ current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut current_note_oct48\
    \ = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50 =\
    \ 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 = 0;\n\
    \    let mut current_note_oct53 = 0;\n    let mut current_\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6bt7hwnq.rs:68:21\n   |\n\
    68 |     let mut current_\n   |                     ^ help: add `;` here\n69 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6bt7hwnq.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 1;\n    let mut current_note_length_index42\
    \ = 1;\n    let mut current_note_length_index43 = 1;\n    let mut current_note_length_index44\
    \ = 1;\n    let mut current_note_length_index45 = 1;\n    let mut current_note_length_index46\
    \ = 1;\n    let mut current_note_length_index47 = 1;\n    let mut current_note_length_index48\
    \ = 1;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp79hk3kk2.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.last().unwrap();\n    let mut current_beat = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut last_note = notes.last().unwrap();\n    let mut last_beat\
    \ = 0;\n    let mut last_note_length = 0;\n    while notes.len() > 0 {\n     \
    \   let note = notes.last().unwrap();\n        if note == current_note {\n   \
    \         current_beat += 1;\n            current_note_length += 1;\n        }\
    \ else {\n            beats.push(current_beat);\n            current_beat = 0;\n\
    \            current_note_length = 0;\n            current_note = note;\n    \
    \    }\n        notes.pop();\n    }\n    beats.push(current_beat);\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "warning: variable `current_note_length` is assigned to, but never used\n\
    \  --> /tmp/tmp0qi1hrpu.rs:15:13\n   |\n15 |     let mut current_note_length =\
    \ 0;\n   |             ^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_current_note_length` instead\n\n\
    warning: unused variable: `last_note`\n  --> /tmp/tmp0qi1hrpu.rs:16:13\n   |\n\
    16 |     let mut last_note = notes.last().unwrap();\n   |             ^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_last_note`\n\n\
    warning: unused variable: `last_beat`\n  --> /tmp/tmp0qi1hrpu.rs:17:13\n   |\n\
    17 |     let mut last_beat = 0;\n   |             ^^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_last_beat`\n\nwarning: unused variable: `last_note_length`\n\
    \  --> /tmp/tmp0qi1hrpu.rs:18:13\n   |\n18 |     let mut last_note_length = 0;\n\
    \   |             ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with\
    \ an underscore: `_last_note_length`\n\nwarning: variable does not need to be\
    \ mutable\n  --> /tmp/tmp0qi1hrpu.rs:16:9\n   |\n16 |     let mut last_note =\
    \ notes.last().unwrap();\n   |         ----^^^^^^^^^\n   |         |\n   |   \
    \      help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmp0qi1hrpu.rs:17:9\n\
    \   |\n17 |     let mut last_beat = 0;\n   |         ----^^^^^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n\nwarning: variable does not need\
    \ to be mutable\n  --> /tmp/tmp0qi1hrpu.rs:18:9\n   |\n18 |     let mut last_note_length\
    \ = 0;\n   |         ----^^^^^^^^^^^^^^^^\n   |         |\n   |         help:\
    \ remove this `mut`\n\nerror[E0502]: cannot borrow `notes` as mutable because\
    \ it is also borrowed as immutable\n  --> /tmp/tmp0qi1hrpu.rs:30:9\n   |\n13 |\
    \     let mut current_note = notes.last().unwrap();\n   |                    \
    \        ------------ immutable borrow occurs here\n...\n21 |         if note\
    \ == current_note {\n   |                    ------------ immutable borrow later\
    \ used here\n...\n30 |         notes.pop();\n   |     "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().enumerate().filter(|(_,\
    \ note)| note != '|');\n    for note in notes {\n        let mut beat = 0;\n \
    \       let mut note = note.unwrap();\n        note = note.chars().enumerate().filter(|(_,\
    \ char)| char != 'o').count();\n        if note == 0 {\n            beat += 1;\n\
    \        } else {\n            beat += note / 4;\n            note = note % 4;\n\
    \        }\n        beats.push(beat);\n    }\n    beats\n}\n\nfn main() {\n  \
    \  let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpam5eh4p8.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != '|');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0599]: no method named `unwrap`\
    \ found for tuple `(usize, char)` in the current scope\n  --> /tmp/tmpam5eh4p8.rs:15:29\n\
    \   |\n15 |         let mut note = note.unwrap();\n   |                      \
    \       ^^^^^^ method not found in `(usize, char)`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = music_string.chars().nth(0).unwrap();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa7sa6m12.rs:61:40\n   |\n\
    61 |     let mut current_note_length_index47\n   |                           \
    \             ^ help: add `;` here\n62 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa7sa6m12.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_len = 0;\n   \
    \ let mut current_note_char = 0;\n    let mut current_note_char_len = 0;\n   \
    \ let mut current_note_char_index = 0;\n    let mut current_note_char_index2 =\
    \ 0;\n    let mut current_note_char_index3 = 0;\n    let mut current_note_char_index4\
    \ = 0;\n    let mut current_note_char_index5 = 0;\n    let mut current_note_char_index6\
    \ = 0;\n    let mut current_note_char_index7 = 0;\n    let mut current_note_char_index8\
    \ = 0;\n    let mut current_note_char_index9 = 0;\n    let mut current_note_char_index10\
    \ = 0;\n    let mut current_note_char_index11 = 0;\n    let mut current_note_char_index12\
    \ = 0;\n    let mut current_note_char_index13 = 0;\n    let mut current_note_char_index14\
    \ = 0;\n    let mut current_note_char_index15 = 0;\n    let mut current_note_char_index16\
    \ = 0;\n    let mut current_note_char_index17 = 0;\n    let mut current_note_char_index18\
    \ = 0;\n    let mut current_note_char_index19 = 0;\n    let mut current_note_char_index20\
    \ = 0;\n    let mut current_note_char_index21 = 0;\n    let mut current_note_char_index22\
    \ = 0;\n    let mut current_note_char_index23 = 0;\n    let mut current_note_char_index24\
    \ = 0;\n    let mut current_note_char_index25 = 0;\n    let mut current_note_char_index26\
    \ = 0;\n    let mut current_note_char_index27 = 0;\n    let mut current_note_char_index28\
    \ = 0;\n    let mut current_note_char_index29 = 0;\n    let mut current_note_char_index30\
    \ = 0;\n    let mut current_note_char_index31 = 0;\n    let mut current_note_char_index32\
    \ = 0;\n    let mut current_note_char_index33 = 0;\n    let mut current_note_char_index34\
    \ = 0;\n    let mut current_note_char_index35 = 0;\n    let mut current_note_char_index36\
    \ = 0;\n    let mut current_note_char_index37 = 0;\n    let mut current_note_char_index38\
    \ = 0;\n    let mut current_note_char_index39 = 0;\n    let mut current_note_char_index40\
    \ = 0;\n    let mut current_note_char_index41 = 0;\n    let mut current_note_char_index42\
    \ = 0;\n    let mut current_note_char_index43 = 0;\n    let mut current_note_char_index44\
    \ = 0;\n    let mut current_note_char_index45 = 0;\n    let mut current_note_char_index46\
    \ = 0;\n    let mut current_note_char_index47\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp29k00per.rs:63:38\n   |\n\
    63 |     let mut current_note_char_index47\n   |                             \
    \         ^ help: add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp29k00per.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = 0;\n    for c in music_string {\n        if c == 'o' {\n            if current_note_length\
    \ == 0 {\n                println!(\"Invalid music string\");\n              \
    \  return beats;\n            }\n            beats.push(current_beat);\n     \
    \       current_beat = 0;\n            current_note = String::new();\n       \
    \     current_note_length = 0;\n        } else if c == '|' {\n            if current_note_length\
    \ == 0 {\n                println!(\"Invalid music string\");\n              \
    \  return beats;\n            }\n            beats.push(current_beat);\n     \
    \       current_beat = 0;\n            current_note = String::new();\n       \
    \     current_note_length = 0;\n        } else if c == '.' {\n            current_note_length\
    \ += 1;\n        } else {\n            current_note += c;\n        }\n    }\n\
    \    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpnqdykbr8.rs:15:14\n\
    \   |\n15 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ can't compare `&str` with `char`\n  --> /tmp/tmpnqdykbr8.rs:16:14\n   |\n16\
    \ |         if c == 'o' {\n   |              ^^ no implementation for `&str ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpnqdykbr8.rs:25:21\n   |\n25 |         } else\
    \ if c == '|' {\n   |                     ^^ no implementation for `&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpnqdykbr8.rs:34:21\n   |\n34 |         } else\
    \ if c == '.' {\n   |                     ^^ no implementation for `&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the follow"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_is_even\
    \ = false;\n    let mut current_note_length_is_odd = false;\n    let mut current_note_is_even\
    \ = false;\n    let mut current_note_is_odd = false;\n    let mut current_note_is_last_note\
    \ = false;\n    let mut current_note_is_last_note_in_chord = false;\n    let mut\
    \ current_note_is_chord = false;\n    let mut current_note_is_chord_in_chord =\
    \ false;\n    let mut current_note_is_chord_in_chord_in_chord = false;\n    let\
    \ mut current_note_is_chord_in_chord_in_chord_in_chord = false;\n    let mut current_note_is_chord_in_chord_in_chord_in_chord_in_chord\
    \ = false;\n    let mut current_note_is_chord_in_chord_in_chord_in_chord_in_chord_in_chord\
    \ = false;\n    let mut current_note_is_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord\
    \ = false;\n    let mut current_note_is_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord\
    \ = false;\n    let mut current_note_is_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord\
    \ = false;\n    let mut current_note_is_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord\
    \ = false;\n    let mut current_note_is_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord\
    \ = false;\n    let mut current_note_is_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord\
    \ = false;\n    let mut current_note_is_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord\
    \ = false;\n    let mut current_note_is_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord\
    \ = false;\n    let mut current_note_is_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7pn2mpfe.rs:36:89\n   |\n\
    36 |     let mut current_note_is_chord_in_chord_in_chord_in_chord_in_chord_in_chord_in_chord_\n\
    \   |                                                                        \
    \                 ^ help: add `;` here\n37 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7pn2mpfe.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|&(_, c)| c != '|').collect::<Vec<_>>();\n\
    \    let mut current_note = 0;\n    let mut last_note = 0;\n    for note in notes\
    \ {\n        if note.1 == '.' {\n            beats.push(current_note);\n     \
    \       current_note = 0;\n            last_note = note.0;\n        } else {\n\
    \            current_note += 1;\n        }\n    }\n    beats.push(current_note);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmps00i6esi.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_beat = 0;\n    let mut current_note_beat_len\
    \ = 0;\n    let mut current_note_octave = 0;\n    let mut current_note_octave_len\
    \ = 0;\n    let mut current_note_octave_sign = 0;\n    let mut current_note_octave_sign_len\
    \ = 0;\n    let mut current_note_octave_octave = 0;\n    let mut current_note_octave_octave_len\
    \ = 0;\n    let mut current_note_octave_octave_sign = 0;\n    let mut current_note_octave_octave_sign_len\
    \ = 0;\n    let mut current_note_octave_octave_octave = 0;\n    let mut current_note_octave_octave_octave_len\
    \ = 0;\n    let mut current_note_octave_octave_octave_sign = 0;\n    let mut current_note_octave_octave_sign_len\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave = 0;\n    let mut\
    \ current_note_octave_octave_octave_len = 0;\n    let mut current_note_octave_octave_octave_sign\
    \ = 0;\n    let mut current_note_octave_octave_sign_len = 0;\n    let mut current_note_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_len = 0;\n    let mut current_note_octave_octave_octave_sign\
    \ = 0;\n    let mut current_note_octave_octave_sign_len = 0;\n    let mut current_note_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_len = 0;\n    let mut current_note_octave_octave_octave_sign\
    \ = 0;\n    let mut current_note_octave_octave_sign_len = 0;\n    let mut current_note_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_len = 0;\n    let mut current_note_octave_octave_octave_sign\
    \ = 0;\n    let mut current_note_octave_octave_sign_len = 0;\n    let mut current_note_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphmm6trhn.rs:46:26\n   |\n\
    46 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n47 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmphmm6trhn.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    for c in music_string {\n\
    \        if c == 'o' {\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note = String::new();\n        } else if c == '|'\
    \ {\n            current_beat += 1;\n        } else if c == '.' {\n          \
    \  beats.push(current_beat);\n            current_beat = 0;\n            current_note\
    \ = String::new();\n        } else {\n            current_note += c;\n       \
    \ }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpyg1mqej0.rs:14:14\n\
    \   |\n14 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ can't compare `&str` with `char`\n  --> /tmp/tmpyg1mqej0.rs:15:14\n   |\n15\
    \ |         if c == 'o' {\n   |              ^^ no implementation for `&str ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpyg1mqej0.rs:19:21\n   |\n19 |         } else\
    \ if c == '|' {\n   |                     ^^ no implementation for `&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpyg1mqej0.rs:21:21\n   |\n21 |         } else\
    \ if c == '.' {\n   |                     ^^ no implementation for `&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the follow"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_octlen = 0;\n\
    \    let mut current_note_octlen_index = 0;\n    let mut current_note_octlen_index2\
    \ = 0;\n    let mut current_note_octlen_index3 = 0;\n    let mut current_note_octlen_index4\
    \ = 0;\n    let mut current_note_octlen_index5 = 0;\n    let mut current_note_octlen_index6\
    \ = 0;\n    let mut current_note_octlen_index7 = 0;\n    let mut current_note_octlen_index8\
    \ = 0;\n    let mut current_note_octlen_index9 = 0;\n    let mut current_note_octlen_index10\
    \ = 0;\n    let mut current_note_octlen_index11 = 0;\n    let mut current_note_octlen_index12\
    \ = 0;\n    let mut current_note_octlen_index13 = 0;\n    let mut current_note_octlen_index14\
    \ = 0;\n    let mut current_note_octlen_index15 = 0;\n    let mut current_note_octlen_index16\
    \ = 0;\n    let mut current_note_octlen_index17 = 0;\n    let mut current_note_octlen_index18\
    \ = 0;\n    let mut current_note_octlen_index19 = 0;\n    let mut current_note_octlen_index20\
    \ = 0;\n    let mut current_note_octlen_index21 = 0;\n    let mut current_note_octlen_index22\
    \ = 0;\n    let mut current_note_octlen_index23 = 0;\n    let mut current_note_octlen_index24\
    \ = 0;\n    let mut current_note_octlen_index25 = 0;\n    let mut current_note_octlen_index26\
    \ = 0;\n    let mut current_note_octlen_index27 = 0;\n    let mut current_note_octlen_index28\
    \ = 0;\n    let mut current_note_octlen_index29 = 0;\n    let mut current_note_octlen_index30\
    \ = 0;\n    let mut current_note_octlen_index31 = 0;\n    let mut current_note_octlen_index32\
    \ = 0;\n    let mut current_note_octlen_index33 = 0;\n    let mut current_note_octlen_index34\
    \ = 0;\n    let mut current_note_octlen_index35 = 0;\n    let mut current_note_octlen_index36\
    \ = 0;\n    let mut current_note_octlen_index37 = 0;\n    let mut current_note_octlen_index38\
    \ = 0;\n    let mut current_note_octlen_index39 = 0;\n    let mut current_note_octlen_index40\
    \ = 0;\n    let mut current_note_octlen_index41 = 0;\n    let mut current_note_octlen_index\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprbwzdj4e.rs:58:38\n   |\n\
    58 |     let mut current_note_octlen_index\n   |                             \
    \         ^ help: add `;` here\n59 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprbwzdj4e.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = notes.last().unwrap();\n    let mut current_beat = 0;\n    let\
    \ mut current_note_count = 0;\n    let mut current_note_length = 0;\n    let mut\
    \ current_note_octave = 0;\n    let mut current_note_duration = 0;\n    let mut\
    \ current_note_octave_duration = 0;\n    let mut current_note_octave_duration_index\
    \ = 0;\n    let mut current_note_octave_duration_index2 = 0;\n    let mut current_note_octave_duration_index3\
    \ = 0;\n    let mut current_note_octave_duration_index4 = 0;\n    let mut current_note_octave_duration_index5\
    \ = 0;\n    let mut current_note_octave_duration_index6 = 0;\n    let mut current_note_octave_duration_index7\
    \ = 0;\n    let mut current_note_octave_duration_index8 = 0;\n    let mut current_note_octave_duration_index9\
    \ = 0;\n    let mut current_note_octave_duration_index10 = 0;\n    let mut current_note_octave_duration_index11\
    \ = 0;\n    let mut current_note_octave_duration_index12 = 0;\n    let mut current_note_octave_duration_index13\
    \ = 0;\n    let mut current_note_octave_duration_index14 = 0;\n    let mut current_note_octave_duration_index15\
    \ = 0;\n    let mut current_note_octave_duration_index16 = 0;\n    let mut current_note_octave_duration_index17\
    \ = 0;\n    let mut current_note_octave_duration_index18 = 0;\n    let mut current_note_octave_duration_index19\
    \ = 0;\n    let mut current_note_octave_duration_index20 = 0;\n    let mut current_note_octave_duration_index21\
    \ = 0;\n    let mut current_note_octave_duration_index22 = 0;\n    let mut current_note_octave_duration_index23\
    \ = 0;\n    let mut current_note_octave_duration_index24 = 0;\n    let mut current_note_octave_duration_index25\
    \ = 0;\n    let mut current_note_octave_duration_index26 = 0;\n    let mut current_note_octave_duration_index27\
    \ = 0;\n    let mut current_note_octave_duration_index28 = 0;\n    let mut current_note_octave_duration_index29\
    \ = 0;\n    let mut current_note_octave_duration_index30 = 0;\n    let mut current_note_octave_duration_index31\
    \ = 0;\n    let mut current_note_octave_duration_index32 = 0;\n    let mu\n}\n\
    \nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptcgb1mto.rs:52:11\n   |\n\
    52 |     let mu\n   |           ^ help: add `;` here\n53 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptcgb1mto.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = music_string.chars().nth(1).unwrap();\n\
    \    for c in music_string.chars() {\n        if c == ' ' {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n        } else {\n            if c == '|' {\n\
    \                current_beat += 1;\n            } else {\n                current_beat\
    \ += 1;\n                current_note += 1;\n            }\n        }\n    }\n\
    \    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `char`\n  --> /tmp/tmp0yhsgjmy.rs:23:17\n   |\n23 |                 current_note\
    \ += 1;\n   |                 ------------^^^^^\n   |                 |\n   |\
    \                 cannot use `+=` on type `char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.last().unwrap();\n    let mut current_beat = 0;\n    for note in notes\
    \ {\n        if note != current_note {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = note;\n        }\n\
    \        current_beat += 1;\n    }\n    beats.push(current_beat);\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpivkmdkcc.rs:16:17\n\
    \   |\n16 |         if note != current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpivkmdkcc.rs:19:28\n   |\n13 |     let mut current_note\
    \ = notes.last().unwrap();\n   |                            ---------------------\
    \ expected due to this value\n...\n19 |             current_note = note;\n   |\
    \                            ^^^^ expected `&str`, found `str`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpew7m1cfy.rs:63:26\n   |\n\
    63 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpew7m1cfy.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_octlen = 0;\n\
    \    let mut current_note_octstring = \"\";\n    let mut current_note_octstringlen\
    \ = 0;\n    let mut current_note_octstringlen2 = 0;\n    let mut current_note_octstringlen3\
    \ = 0;\n    let mut current_note_octstringlen4 = 0;\n    let mut current_note_octstringlen5\
    \ = 0;\n    let mut current_note_octstringlen6 = 0;\n    let mut current_note_octstringlen7\
    \ = 0;\n    let mut current_note_octstringlen8 = 0;\n    let mut current_note_octstringlen9\
    \ = 0;\n    let mut current_note_octstringlen10 = 0;\n    let mut current_note_octstringlen11\
    \ = 0;\n    let mut current_note_octstringlen12 = 0;\n    let mut current_note_octstringlen13\
    \ = 0;\n    let mut current_note_octstringlen14 = 0;\n    let mut current_note_octstringlen15\
    \ = 0;\n    let mut current_note_octstringlen16 = 0;\n    let mut current_note_octstringlen17\
    \ = 0;\n    let mut current_note_octstringlen18 = 0;\n    let mut current_note_octstringlen19\
    \ = 0;\n    let mut current_note_octstringlen20 = 0;\n    let mut current_note_octstringlen21\
    \ = 0;\n    let mut current_note_octstringlen22 = 0;\n    let mut current_note_octstringlen23\
    \ = 0;\n    let mut current_note_octstringlen24 = 0;\n    let mut current_note_octstringlen25\
    \ = 0;\n    let mut current_note_octstringlen26 = 0;\n    let mut current_note_octstringlen27\
    \ = 0;\n    let mut current_note_octstringlen28 = 0;\n    let mut current_note_octstringlen29\
    \ = 0;\n    let mut current_note_octstringlen30 = 0;\n    let mut current_note_octstringlen31\
    \ = 0;\n    let mut current_note_octstringlen32 = 0;\n    let mut current_note_octstringlen33\
    \ = 0;\n    let mut current_note_octstringlen34 = 0;\n    let mut current_note_octstringlen35\
    \ = 0;\n    let mut current_note_octstringlen36 = 0;\n    let mut current_note_octstringlen37\
    \ = 0;\n    let mut current_note_octstringlen38 = 0;\n    let mut current_note_octstringlen39\
    \ = 0;\n    let mut current_note_octstringlen40 = 0;\n    let mut current_note_octstringlen41\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaatkbue9.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    for c in music_string {\n        if c == 'o' {\n            if current_note\
    \ != 0 {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = 0;\n            }\n            current_note_length\
    \ = 0;\n        } else if c == '|' {\n            if current_note != 0 {\n   \
    \             beats.push(current_beat);\n                current_beat = 0;\n \
    \               current_note = 0;\n            }\n            current_note_length\
    \ = 1;\n        } else if c == '.' {\n            if current_note != 0 {\n   \
    \             beats.push(current_beat);\n                current_beat = 0;\n \
    \               current_note = 0;\n            }\n            current_note_length\
    \ = 2;\n        } else {\n            if current_note != 0 {\n               \
    \ beats.push(current_beat);\n                current_beat = 0;\n             \
    \   current_note = 0;\n            }\n            current_note_length = 1;\n \
    \           current_note += 1;\n        }\n        current_beat += 1;\n    }\n\
    \    beats.push(current_beat);\n    current_beat = 0;\n    current_note = 0;\n\
    \    current_note_length = 0;\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp8duxoju5.rs:15:14\n\
    \   |\n15 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_note = String::new();\n    let mut current_beat = 0;\n    let mut current_beats_length\
    \ = 0;\n    let mut current_length = 0;\n    for c in music_string.chars() {\n\
    \        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n \
    \               if current_beat == 0 {\n                    current_beats_length\
    \ = 4;\n                } else {\n                    current_beats_length +=\
    \ current_beat;\n                }\n                current_beat = 0;\n      \
    \          current_length = current_beats_length;\n                current_note\
    \ = String::new();\n            } else if c.to_ascii_lowercase() == 'o|' {\n \
    \               if current_beat == 0 {\n                    current_beats_length\
    \ = 2;\n                } else {\n                    current_beats_length +=\
    \ current_beat;\n                }\n                current_beat = 0;\n      \
    \          current_length = current_beats_length;\n                current_note\
    \ = String::new();\n            } else if c.to_ascii_lowercase() == '.|' {\n \
    \               if current_beat == 0 {\n                    current_beats_length\
    \ = 1;\n                } else {\n                    current_beats_length +=\
    \ current_beat;\n                }\n                current_beat = 0;\n      \
    \          current_length = current_beats_length;\n                current_note\
    \ = String::new();\n            } else {\n                current_note.push(c);\n\
    \            }\n        } else {\n            if current_beat == 0 {\n       \
    \         current_beats_length = 1;\n            } else {\n                current_beats_length\
    \ += current_beat;\n            }\n            current_beat = 0;\n           \
    \ current_length = current_beats_length;\n            current_note = String::new();\n\
    \        }\n        current_beat += 1;\n    }\n    beats.push(current_length);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp358n7_wm.rs:27:52\n\
    \   |\n27 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2 = 0;\n\
    \    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n    let\
    \ mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let mut\
    \ current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut current_note_oct9\
    \ = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11 =\
    \ 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 = 0;\n\
    \    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n  \
    \  let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n    let\
    \ mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let mut\
    \ current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut current_note_oct22\
    \ = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24 =\
    \ 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 = 0;\n\
    \    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n  \
    \  let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n    let\
    \ mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let mut\
    \ current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut current_note_oct35\
    \ = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37 =\
    \ 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 = 0;\n\
    \    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n  \
    \  let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n    let\
    \ mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let mut\
    \ current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut current_note_oct48\
    \ = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50 =\
    \ 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 = 0;\n\
    \    let mut current_note_oct53 = 0;\n    let mut current_note_\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf9kt5kjp.rs:68:26\n   |\n\
    68 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpf9kt5kjp.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2\
    \ = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n\
    \    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let\
    \ mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut\
    \ current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11\
    \ = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 =\
    \ 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n\
    \    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n  \
    \  let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let\
    \ mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut\
    \ current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24\
    \ = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 =\
    \ 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n\
    \    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n  \
    \  let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let\
    \ mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut\
    \ current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37\
    \ = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 =\
    \ 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n\
    \    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n  \
    \  let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let\
    \ mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut\
    \ current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50\
    \ = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 =\
    \ 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprxj5alv7.rs:67:26\n   |\n\
    67 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n68 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprxj5alv7.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzxh3c4wm.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7i_b5i_i.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beat = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_notes_per_beats_per_note = music_\n}\n\nfn main() {\n   \
    \ let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppvexflff.rs:36:54\n   |\n\
    36 |     let mut current_notes_per_beats_per_note = music_\n   |             \
    \                                         ^ help: add `;` here\n37 | }\n   | -\
    \ unexpected token\n\nerror[E0425]: cannot find value `music_` in this scope\n\
    \  --> /tmp/tmppvexflff.rs:36:48\n   |\n36 |     let mut current_notes_per_beats_per_note\
    \ = music_\n   |                                                ^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppvexflff.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note_index = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpdaq554d3.rs:63:1\n\
    \   |\n63 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = 0;\n    for c in music_string {\n        if c == 'o' {\n            if current_note_length\
    \ != 0 {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n                current_note_length\
    \ = 0;\n            }\n        } else if c == '|' {\n            current_note_length\
    \ += 1;\n        } else if c == '.' {\n            current_beat += 1;\n      \
    \  } else {\n            current_note += c;\n        }\n    }\n    beats.push(current_beat);\n\
    \    current_beat = 0;\n    current_note = String::new();\n    current_note_length\
    \ = 0;\n    for c in music_string {\n        if c == 'o' {\n            if current_note_length\
    \ != 0 {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n                current_note_length\
    \ = 0;\n            }\n        } else if c == '|' {\n            current_note_length\
    \ += 1;\n        } else if c == '.' {\n            current_beat += 1;\n      \
    \  } else {\n            current_note += c;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpghcod55t.rs:15:14\n\
    \   |\n15 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ can't compare `&str` with `char`\n  --> /tmp/tmpghcod55t.rs:16:14\n   |\n16\
    \ |         if c == 'o' {\n   |              ^^ no implementation for `&str ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpghcod55t.rs:23:21\n   |\n23 |         } else\
    \ if c == '|' {\n   |                     ^^ no implementation for `&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpghcod55t.rs:25:21\n   |\n25 |         } else\
    \ if c == '.' {\n   |                     ^^ no implementation for `&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the follow"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    for c in music_string {\n        if c == 'o' {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \          current_note_len = String::new();\n        } else if c == '|' {\n \
    \           beats.push(current_beat);\n            current_beat = 0;\n       \
    \     current_note.push_str(current_note_len);\n            current_note_len =\
    \ String::new();\n        } else if c.is_whitespace() {\n            current_note.push_str(current_note_len);\n\
    \            current_note_len = String::new();\n        } else {\n           \
    \ current_note.push_str(&c.to_string());\n            current_note_len = c.len();\n\
    \        }\n    }\n    beats.push(current_beat);\n    current_beat = 0;\n    current_note.push_str(current_note_len);\n\
    \    current_note_len = String::new();\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpx1jhjrnt.rs:15:14\n\
    \   |\n15 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx1jhjrnt.rs:20:32\n   |\n14 |     let mut current_note_len\
    \ = 0;\n   |                                - expected due to this value\n...\n\
    20 |             current_note_len = String::new();\n   |                     \
    \           ^^^^^^^^^^^^^ expected integer, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx1jhjrnt.rs:24:35\n   |\n24 |             current_note.push_str(current_note_len);\n\
    \   |                                   ^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx1jhjrnt.rs:25:32\n\
    \   |\n14 |     let mut current_note_len = 0;\n   |                          \
    \      - expected due to this value\n...\n25 |             current_note_len =\
    \ String::new();\n   |                                ^^^^^^^^^^^^^ expected integer,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx1jhjrnt.rs:27:35\n\
    \   |\n27 |             current_note.push_str(current_note_len);\n   |       \
    \                            ^^^^^^^^^^^^^^^^ expected `&str`, found integer\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpx1jhjrnt.rs:28:32\n   |\n14 |\
    \     let mut current_note_len = 0;\n   |                                - expected\
    \ due to this value\n...\n28 |             current_note_len = String::new();\n\
    \   |                                ^^^^^^^^^^^^^ expected integer, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx1jhjrnt.rs:36:27\n\
    \   |\n36 |     current_note.push_str(current_note_len);\n   |               \
    \            ^^^^^^^^^^^^^^^^ expected `&str`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx1jhjrnt.rs:37:24\n   |\n14 |     let mut current_note_"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgwvf5kp0.rs:63:26\n   |\n\
    63 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpgwvf5kp0.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = music_string.chars().nth(music_string.len()\
    \ - 1).unwrap();\n    let mut current_note_length = 0;\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfosogdok.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfosogdok.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqxnj2i5g.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut last_note = String::new();\n    let\
    \ mut last_beat = 0;\n    let mut last_beats: isize = 0;\n    let mut last_beats_note\
    \ = 0;\n    let mut last_beats_notes: isize = 0;\n    let mut last_beats_notes_beat\
    \ = 0;\n    let mut last_beats_notes_beats: isize = 0;\n    let mut last_beats_notes_beats_note\
    \ = 0;\n    let mut last_beats_notes_beats_notes: isize = 0;\n    let mut last_beats_notes_beats_notes_beat\
    \ = 0;\n    let mut last_beats_notes_beats_notes_beats: isize = 0;\n    let mut\
    \ last_beats_notes_beats_notes_beats_note = 0;\n    let mut last_beats_notes_beats_notes_beats_notes:\
    \ isize = 0;\n    let mut last_beats_notes_beats_notes_beats_notes_beat = 0;\n\
    \    let mut last_beats_notes_beats_notes_beats_notes_beats: isize = 0;\n    let\
    \ mut last_beats_notes_beats_notes_beats_notes_beats_note = 0;\n    let mut last_beats_notes_beats_notes_beats_notes_beats_notes:\
    \ isize = 0;\n    let mut last_beats_notes_beats_notes_beats_notes_beats_notes_beat\
    \ = 0;\n    let mut last_beats_notes_beats_notes_beats_notes_beats_notes_beats:\
    \ isize = 0;\n    let mut last_beats_notes_beats_notes_beats_notes_beats_notes_beats_note\
    \ = 0;\n    let mut last_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes:\
    \ isize = 0;\n    let mut last_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beat\
    \ = 0;\n    let mut last_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats:\
    \ isize = 0;\n    let mut last_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_note\
    \ = 0;\n    let mut last_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes_beats_notes:\
    \ isize = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp6zpvls9y.rs:39:1\n\
    \   |\n39 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = 0;\n    for c in music_string {\n        if c.is_whitespace() {\n        \
    \    continue;\n        }\n        if c == 'o' {\n            if current_note.is_empty()\
    \ {\n                println!(\"Error: music string contains invalid note!\");\n\
    \                return beats;\n            }\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \          current_note_length = 0;\n            continue;\n        }\n      \
    \  if c == '|' {\n            if current_note.is_empty() {\n                println!(\"\
    Error: music string contains invalid note!\");\n                return beats;\n\
    \            }\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note = String::new();\n            current_note_length\
    \ = 0;\n            continue;\n        }\n        if c.is_digit() {\n        \
    \    current_beat += 1;\n            current_note += c;\n            current_note_length\
    \ += 1;\n            continue;\n        }\n        if c.is_ascii(127) {\n    \
    \        current_note += c;\n            current_note_length += 1;\n         \
    \   continue;\n        }\n        println!(\"Error: music string contains invalid\
    \ note!\");\n        return beats;\n    }\n    beats.push(current_beat);\n   \
    \ beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp5rmjutzc.rs:15:14\n\
    \   |\n15 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_note_len = 0;\n    for c in music_string.chars() {\n    \
    \    if c == current_note {\n            current_note_len += 1;\n        } else\
    \ {\n            beats.push(current_beat);\n            current_beat = 0;\n  \
    \          current_note = c.unwrap();\n            current_note_len = 1;\n   \
    \     }\n        current_beat += current_note_len;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp0psr6d3j.rs:21:30\n   |\n21 |             current_note\
    \ = c.unwrap();\n   |                              ^^^^^^ method not found in\
    \ `char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwdwpp7ex.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n \
    \   let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp04fm4oic.rs:63:1\n\
    \   |\n63 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_note_length = 0;\n    let mut current_note_length_to_beat: isize\
    \ = 0;\n    let mut current_note_length_to_beat_to_beat: isize = 0;\n    let mut\
    \ current_note_length_to_beat_to_beat_to_beat: isize = 0;\n    let mut current_note_length_to_beat_to_beat_to_beat_to_beat:\
    \ isize = 0;\n    let mut current_note_length_to_beat_to_beat_to_beat_to_beat_to_beat:\
    \ isize = 0;\n    let mut current_note_length_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat:\
    \ isize = 0;\n    let mut current_note_length_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat:\
    \ isize = 0;\n    let mut current_note_length_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat:\
    \ isize = 0;\n    let mut current_note_length_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat:\
    \ isize = 0;\n    let mut current_note_length_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat:\
    \ isize = 0;\n    let mut current_note_length_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat:\
    \ isize = 0;\n    let mut current_note_length_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat:\
    \ isize = 0;\n    let mut current_note_length_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat:\
    \ isize = 0;\n    let mut current_note_length_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat:\
    \ isize = 0;\n    let mut current_note_length_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat:\
    \ isize = 0;\n    let mut current_note_length_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat:\
    \ isize = 0;\n    let mut current_note_length_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat_to_beat:\
    \ isize = 0;\n    let mut current_note_length_to_beat_to_beat_to_\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvmqskxp2.rs:32:52\n   |\n\
    32 |     let mut current_note_length_to_beat_to_beat_to_\n   |               \
    \                                     ^ help: add `;` here\n33 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvmqskxp2.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().enumerate();\n\
    \    let mut current_note = 0;\n    let mut last_note = 0;\n    let mut last_beat\
    \ = 0;\n    let mut last_beats = 0;\n    let mut last_beats_after_note = 0;\n\
    \    let mut last_beats_after_notes = 0;\n    let mut last_beats_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes = 0;\n    let mut last_beats_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes_after_note =\
    \ 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo77z2ilk.rs:34:246\n   |\n\
    34 |     let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_\n\
    \   |                                                                        \
    \                                                                            \
    \                                                                            \
    \                      ^ help: add `;` here\n35 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo77z2ilk.rs:10:41\n   |\n10 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------  \
    \                        ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |  \
    \  |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps8lvb5pb.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate();\n    let mut current_note = 0;\n    let\
    \ mut current_beat = 0;\n    loop {\n        let note = notes.next().unwrap();\n\
    \        let beat = note.1.to_digit(10).unwrap();\n        if note == notes.next()\
    \ {\n            note = notes.next().unwrap();\n            beat = note.1.to_digit(10).unwrap();\n\
    \        }\n        if note == notes.next() {\n            note = notes.next().unwrap();\n\
    \            beat = note.1.to_digit(10).unwrap();\n        }\n        if note\
    \ == notes.next() {\n            note = notes.next().unwrap();\n            beat\
    \ = note.1.to_digit(10).unwrap();\n        }\n        if note == notes.next()\
    \ {\n            note = notes.next().unwrap();\n            beat = note.1.to_digit(10).unwrap();\n\
    \        }\n        if note == notes.next() {\n            note = notes.next().unwrap();\n\
    \            beat = note.1.to_digit(10).unwrap();\n        }\n        if note\
    \ == notes.next() {\n            note = notes.next().unwrap();\n            beat\
    \ = note.1.to_digit(10).unwrap();\n        }\n        if note == notes.next()\
    \ {\n            note = notes.next().unwrap();\n            beat = note.1.to_digit(10).unwrap();\n\
    \        }\n        if note == notes.next() {\n            note = notes.next().unwrap();\n\
    \            beat = note.1.to_digit(10).unwrap();\n        }\n        if note\
    \ == notes.next() {\n            note = notes.next().unwrap();\n            beat\
    \ = note.1.to_digit(10).unwrap();\n        }\n        if note == notes.next()\
    \ {\n            note = notes.next().unwrap();\n            beat = note.1.to_digit(10).unwrap();\n\
    \        }\n        if note == notes.next() {\n            note = notes.next().unwrap();\n\
    \            beat = note.1.to_digit(10).unwrap();\n        }\n        if note\
    \ == notes.next() {\n            note = notes.next().unwrap();\n            beat\
    \ = note.1.to_digit(10).unwrap();\n        }\n        if note == notes.next()\
    \ {\n            note = notes.next().unwrap();\n            beat = note.1.to_digit(10).unwrap();\n\
    \        }\n        if note == notes.next() {\n            note = notes.next().unwrap();\n\
    \            beat\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpb4lneedp.rs:82:3\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n15 |\
    \     loop {\n   |          - unclosed delimiter\n...\n70 |         if note ==\
    \ notes.next() {\n   |                                 - this delimiter might\
    \ not be properly closed...\n...\n73 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n82 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb4lneedp.rs:18:20\n   |\n18 |         if note == notes.next()\
    \ {\n   |                    ^^^^^^^^^^^^ expected tuple, found enum `Option`\n\
    \   |\n   = note: expected tuple `(usize, char)`\n               found enum `Option<(usize,\
    \ char)>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb4lneedp.rs:22:20\n\
    \   |\n22 |         if note == notes.next() {\n   |                    ^^^^^^^^^^^^\
    \ expected tuple, found enum `Option`\n   |\n   = note: expected tuple `(usize,\
    \ char)`\n               found enum `Option<(usize, char)>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb4lneedp.rs:26:20\n   |\n26 |         if note == notes.next()\
    \ {\n   |                    ^^^^^^^^^^^^ expected tuple, found enum `Option`\n\
    \   |\n   = note: expected tuple `(usize, char)`\n               found enum `Option<(usize,\
    \ char)>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb4lneedp.rs:30:20\n\
    \   |\n30 |         if note == notes.next() {\n   |                    ^^^^^^^^^^^^\
    \ expected tuple, found enum `Option`\n   |\n   = note: expected tuple `(usize,\
    \ char)`\n               found enum `Option<(usize, char)>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb4lneedp.rs:34:20\n   |\n34 |         if note == notes.next()\
    \ {\n   |                    ^^^^^^^^^^^^ expected tuple, found enum `Option`\n\
    \   |\n   = note: expected tuple `(usize, char)`\n               found enum `Option<(usize,\
    \ char)>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb4lneedp.rs:38:20\n\
    \   |\n38 |         if note == notes.next() {\n   |                    ^^^^^^^^^^^^\
    \ expected tuple, f"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_octlen = 0;\n\
    \    let mut current_note_octlen2 = 0;\n    let mut current_note_octlen3 = 0;\n\
    \    let mut current_note_octlen4 = 0;\n    let mut current_note_octlen5 = 0;\n\
    \    let mut current_note_octlen6 = 0;\n    let mut current_note_octlen7 = 0;\n\
    \    let mut current_note_octlen8 = 0;\n    let mut current_note_octlen9 = 0;\n\
    \    let mut current_note_octlen10 = 0;\n    let mut current_note_octlen11 = 0;\n\
    \    let mut current_note_octlen12 = 0;\n    let mut current_note_octlen13 = 0;\n\
    \    let mut current_note_octlen14 = 0;\n    let mut current_note_octlen15 = 0;\n\
    \    let mut current_note_octlen16 = 0;\n    let mut current_note_octlen17 = 0;\n\
    \    let mut current_note_octlen18 = 0;\n    let mut current_note_octlen19 = 0;\n\
    \    let mut current_note_octlen20 = 0;\n    let mut current_note_octlen21 = 0;\n\
    \    let mut current_note_octlen22 = 0;\n    let mut current_note_octlen23 = 0;\n\
    \    let mut current_note_octlen24 = 0;\n    let mut current_note_octlen25 = 0;\n\
    \    let mut current_note_octlen26 = 0;\n    let mut current_note_octlen27 = 0;\n\
    \    let mut current_note_octlen28 = 0;\n    let mut current_note_octlen29 = 0;\n\
    \    let mut current_note_octlen30 = 0;\n    let mut current_note_octlen31 = 0;\n\
    \    let mut current_note_octlen32 = 0;\n    let mut current_note_octlen33 = 0;\n\
    \    let mut current_note_octlen34 = 0;\n    let mut current_note_octlen35 = 0;\n\
    \    let mut current_note_octlen36 = 0;\n    let mut current_note_octlen37 = 0;\n\
    \    let mut current_note_octlen38 = 0;\n    let mut current_note_octlen39 = 0;\n\
    \    let mut current_note_octlen40 = 0;\n    let mut current_note_octlen41 = 1;\n\
    \    let mut current_note_octlen42 = 1;\n    let mut current_note_octlen43 = 1;\n\
    \    let mut current_note_octlen44 = 1;\n    let mut current_note_octlen45 = 1;\n\
    \    let mut current_note_octlen46 = 1;\n    let mut current_note_oct\n}\n\nfn\
    \ main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcciio_6w.rs:62:29\n   |\n\
    62 |     let mut current_note_oct\n   |                             ^ help: add\
    \ `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcciio_6w.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_beats_length = 0;\n    let mut current_length\
    \ = 0;\n    let mut current_notes_length = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_notes_length = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_notes_length = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note = String::new();\n    let mut current_notes_length =\
    \ 0;\n    let mut current_note_length = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_notes_length = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note = String::new();\n    let mut current_notes_length =\
    \ 0;\n    let mut current_note_length = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_notes_length = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note = String::new();\n    let mut current_notes_length =\
    \ 0;\n    let mut current_note_length = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_notes_length = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note = String::new();\n    let mut current_notes_length =\
    \ 0;\n    let mut current_note_length = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_notes_length = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note = String::new();\n    let mut current_notes_length =\
    \ 0;\n    let mut current_note_length = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_notes_length = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note = String::new();\n    let mut current_notes_length =\
    \ 0;\n    let mut current_note_length = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_notes_length = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note = String::new();\n    let mut current_notes_length =\
    \ 0;\n    let mut current_note_length = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_notes_length = 0;\n    let mut current_note_length = 0;\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp82lsucde.rs:65:11\n   |\n\
    65 |     let mu\n   |           ^ help: add `;` here\n66 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp82lsucde.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_octlen = 0;\n\
    \    let mut current_note_octoct = 0;\n    let mut current_note_octoctlen = 0;\n\
    \    let mut current_note_octoctoct = 0;\n    let mut current_note_octoctlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4w4lt7mk.rs:67:32\n   |\n\
    67 |     let mut current_note_octoct\n   |                                ^ help:\
    \ add `;` here\n68 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4w4lt7mk.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat: isize = 0;\n    let mut current_note = music_string.chars().nth(1).unwrap();\n\
    \    beats.push(current_beat);\n    while current_note != ' ' {\n        if current_note\
    \ == 'o' {\n            beats.push(current_beat);\n            current_beat +=\
    \ 4;\n        } else if current_note == 'o|' {\n            beats.push(current_beat);\n\
    \            current_beat += 2;\n        } else if current_note == '.|' {\n  \
    \          beats.push(current_beat);\n            current_beat = 1;\n        }\
    \ else {\n            current_beat += 1;\n        }\n        current_note = music_string.chars().nth(1).unwrap();\n\
    \    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmphgjuii91.rs:19:38\n\
    \   |\n19 |         } else if current_note == 'o|' {\n   |                   \
    \                   ^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, note)| note != 'o').collect::<Vec<_>>();\n\
    \    let mut current_note = 0;\n    let mut current_beat = 0;\n    for note in\
    \ notes {\n        if note == 'o' {\n            beats.push(current_beat);\n \
    \           current_beat = 0;\n            current_note++;\n        } else {\n\
    \            current_beat++;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpgkpg81wu.rs:19:25\n\
    \   |\n19 |             current_note++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n19 |         \
    \    { let tmp = current_note; current_note += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n19 -             current_note++;\n19\
    \ +             current_note += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpgkpg81wu.rs:21:25\n   |\n21 |             current_beat++;\n\
    \   |                         ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n21 |             { let tmp = current_beat; current_beat\
    \ += 1; tmp };\n   |             +++++++++++             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    21 -             current_beat++;\n21 +             current_beat += 1;\n   | \n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgkpg81wu.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != 'o').collect::<Vec<_>>();\n   |                                    \
    \                                          ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgkpg81wu.rs:16:20\n   |\n16 |         if note == 'o' {\n\
    \   |                    ^^^ expected tuple, found `char`\n   |\n   = note: expected\
    \ tuple `(usize, char)`\n               found type `char`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = String::new();\n    let mut\
    \ current_note_length = 0;\n    let mut current_note_length_to_beat = 0;\n   \
    \ let mut current_note_to_beat = 0;\n    let mut current_note_to_beat_length =\
    \ 0;\n    let mut current_note_to_beat_length_to_beat = 0;\n    let mut current_note_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_to_beat_length_to_beat_length_to_beat = 0;\n\
    \    let mut current_note_to_beat_length_to_beat_length_to_beat_length = 0;\n\
    \    let mut current_note_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphkpz543a.rs:33:130\n   |\n\
    33 |     let mut current_note_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\n\
    \   |                                                                        \
    \                                                          ^ help: add `;` here\n\
    34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphkpz543a.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2na5s3a2.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_octlen = 0;\n\
    \    let mut current_note_octoct = 0;\n    let mut current_note_octoctlen = 0;\n\
    \    let mut current_note_octoctoct = 0;\n    let mut current_note_octoctlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octlen =\
    \ 0;\n    let mut current_note_oct\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpku0jq2ny.rs:67:29\n   |\n\
    67 |     let mut current_note_oct\n   |                             ^ help: add\
    \ `;` here\n68 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpku0jq2ny.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = notes.first().unwrap();\n    let mut current_beat = 0;\n    let\
    \ mut current_note_beat = 0;\n    let mut current_note_length = 0;\n    let mut\
    \ current_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter2 = 0;\n    let mut current_note_length_to_beat_counter3\
    \ = 0;\n    let mut current_note_length_to_beat_counter4 = 0;\n    let mut current_note_length_to_beat_counter5\
    \ = 0;\n    let mut current_note_length_to_beat_counter6 = 0;\n    let mut current_note_length_to_beat_counter7\
    \ = 0;\n    let mut current_note_length_to_beat_counter8 = 0;\n    let mut current_note_length_to_beat_counter9\
    \ = 0;\n    let mut current_note_length_to_beat_counter10 = 0;\n    let mut current_note_length_to_beat_counter11\
    \ = 0;\n    let mut current_note_length_to_beat_counter12 = 0;\n    let mut current_note_length_to_beat_counter13\
    \ = 0;\n    let mut current_note_length_to_beat_counter14 = 0;\n    let mut current_note_length_to_beat_counter15\
    \ = 0;\n    let mut current_note_length_to_beat_counter16 = 0;\n    let mut current_note_length_to_beat_counter17\
    \ = 0;\n    let mut current_note_length_to_beat_counter18 = 0;\n    let mut current_note_length_to_beat_counter19\
    \ = 0;\n    let mut current_note_length_to_beat_counter20 = 0;\n    let mut current_note_length_to_beat_counter21\
    \ = 0;\n    let mut current_note_length_to_beat_counter22 = 0;\n    let mut current_note_length_to_beat_counter23\
    \ = 0;\n    let mut current_note_length_to_beat_counter24 = 0;\n    let mut current_note_length_to_beat_counter25\
    \ = 0;\n    let mut current_note_length_to_beat_counter26 = 0;\n    let mut current_note_length_to_beat_counter27\
    \ = 0;\n    let mut current_note_length_to_beat_counter28 = 0;\n    let mut current_note_length_to_beat_counter29\
    \ = 0;\n    let mut current_note_length_to_beat_counter30 = 0;\n    let mut current_note_length_to_beat_counter31\
    \ = 0;\n    let mut current_note_length_to_beat_counter32 = 0;\n    let mut current_note_length_to_beat_counter33\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjfln7mkb.rs:51:32\n   |\n\
    51 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjfln7mkb.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.first().unwrap();\n    let mut current_beat = 0;\n    let mut current_note_beat\
    \ = 0;\n    let mut current_note_duration = 0;\n    while notes.len() > 0 {\n\
    \        let mut note_duration = 0;\n        let mut note = notes.first().unwrap();\n\
    \        notes.remove(0);\n        if note == \"o\" {\n            note_duration\
    \ = current_note_duration;\n            current_note_duration = 0;\n         \
    \   current_note = note;\n            current_note_beat = 0;\n            current_beat\
    \ = 0;\n        } else if note == \"o|\" {\n            note_duration = current_note_duration\
    \ / 2;\n            current_note_duration = 0;\n            current_note = note;\n\
    \            current_note_beat = 0;\n            current_beat = 0;\n        }\
    \ else if note == \".|\" {\n            note_duration = current_note_duration;\n\
    \            current_note_duration = 0;\n            current_note = note;\n  \
    \          current_note_beat = 0;\n            current_beat = 0;\n        } else\
    \ {\n            current_note_duration += 1;\n            current_note_beat +=\
    \ 1;\n        }\n        beats.push(current_note_beat);\n        notes.remove(0);\n\
    \    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmp7dcpirk0.rs:21:17\n\
    \   |\n21 |         if note == \"o\" {\n   |                 ^^ no implementation\
    \ for `&str == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]:\
    \ can't compare `&str` with `str`\n  --> /tmp/tmp7dcpirk0.rs:27:24\n   |\n27 |\
    \         } else if note == \"o|\" {\n   |                        ^^ no implementation\
    \ for `&str == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]:\
    \ can't compare `&str` with `str`\n  --> /tmp/tmp7dcpirk0.rs:33:24\n   |\n33 |\
    \         } else if note == \".|\" {\n   |                        ^^ no implementation\
    \ for `&str == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialE"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_note_length = 0;\n    let mut last_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut last_note_length = 0;\n    let mut last_note_length_to_beat = 0;\n\
    \    let mut last_note_length_to_beat_length = 0;\n    let mut last_note_length_to_beat_length_to_beat\
    \ = 0;\n    let mut last_note_length_to_beat_length_to_beat_length = 0;\n    let\
    \ mut last_note_length_to_beat_length_to_beat_length_to_beat = 0;\n    let mut\
    \ last_note_length_to_beat_length_to_beat_length_to_beat_length = 0;\n    let\
    \ mut last_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat =\
    \ 0;\n    let mut last_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut last_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut last_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut last_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut last_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut last_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut last_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut last_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut last_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut last_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut last_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmtroe2_6.rs:34:119\n   |\n\
    34 |     let mut last_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\n\
    \   |                                                                        \
    \                                               ^ help: add `;` here\n35 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmtroe2_6.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxal3oca_.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_len = 0;\n   \
    \ let mut current_note_char = 0;\n    let mut current_note_char_len = 0;\n   \
    \ let mut current_note_char_is_dot = 0;\n    let mut current_note_char_is_dot_len\
    \ = 0;\n    let mut current_note_char_is_dot_dot = 0;\n    let mut current_note_char_is_dot_dot_len\
    \ = 0;\n    let mut current_note_char_is_dot_dot_dot = 0;\n    let mut current_note_char_is_dot_dot_dot_len\
    \ = 0;\n    let mut current_note_char_is_dot_dot_dot_dot = 0;\n    let mut current_note_char_is_dot_dot_dot_dot_len\
    \ = 0;\n    let mut current_note_char_is_dot_dot_dot_dot_dot = 0;\n    let mut\
    \ current_note_char_is_dot_dot_dot_dot_dot_len = 0;\n    let mut current_note_char_is_dot_dot_dot_dot_dot_dot\
    \ = 0;\n    let mut current_note_char_is_dot_dot_dot_dot_dot_dot_len = 0;\n  \
    \  let mut current_note_char_is_dot_dot_dot_dot_dot_dot_dot = 0;\n    let mut\
    \ current_note_char_is_dot_dot_dot_dot_dot_dot_dot_len = 0;\n    let mut current_note_char_is_dot_dot_dot_dot_dot_dot_dot_dot\
    \ = 0;\n    let mut current_note_char_is_dot_dot_dot_dot_dot_dot_dot_dot_len =\
    \ 0;\n    let mut current_note_char_is_dot_dot_dot_dot_dot_dot_dot_dot_dot = 0;\n\
    \    let mut current_note_char_is_dot_dot_dot_dot_dot_dot_dot_dot_dot_len = 0;\n\
    \    let mut current_note_char_is_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot = 0;\n\
    \    let mut current_note_char_is_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_len\
    \ = 0;\n    let mut current_note_char_is_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot\
    \ = 0;\n    let mut current_note_char_is_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_len\
    \ = 0;\n    let mut current_note_char_is_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot\
    \ = 0;\n    let mut current_note_char_is_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_len\
    \ = 0;\n    let mut current_note_char_is_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot\
    \ = 0;\n    let mut current_note_char_is_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_len\
    \ = 0;\n    let mut current_note_char_is_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot\
    \ = 0;\n    let mut current_note_char_is_dot_dot_dot_dot_\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqnhkvc3s.rs:44:50\n   |\n\
    44 |     let mut current_note_char_is_dot_dot_dot_dot_\n   |                 \
    \                                 ^ help: add `;` here\n45 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqnhkvc3s.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = notes.first().unwrap();\n    let mut current_beat = 0;\n    let\
    \ mut current_note_length = 0;\n    for note in notes {\n        if note == current_note\
    \ {\n            current_beat += 1;\n            current_note_length += 1;\n \
    \       } else {\n            beats.push(current_beat);\n            current_beat\
    \ = 1;\n            current_note_length = 1;\n            current_note = note;\n\
    \        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmped_be_6r.rs:17:17\n\
    \   |\n17 |         if note == current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmped_be_6r.rs:24:28\n   |\n13 |     let mut current_note\
    \ = notes.first().unwrap();\n   |                            ----------------------\
    \ expected due to this value\n...\n24 |             current_note = note;\n   |\
    \                            ^^^^ expected `&str`, found `str`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 1;\n    let mut current_note_length_index42\
    \ = 1;\n    let mut current_note_length_index43 = 1;\n    let mut current_note_length_index44\
    \ = 1;\n    let mut current_note_length_index45 = 1;\n    let mut current_note_length_index46\
    \ = 1;\n    let mut current_note_length_index47 = 1;\n    let mut current_note_length_index48\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6m1wou02.rs:62:40\n   |\n\
    62 |     let mut current_note_length_index48\n   |                           \
    \             ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6m1wou02.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_note_len = 0;\n    let mut last_note_len = 0;\n    let mut last_note\
    \ = String::new();\n    let mut last_note_len = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = String::new();\n    let mut last_note_len = 0;\n\
    \    let mut last_note = String::new();\n    let mut last_note_len = 0;\n    let\
    \ mut last_note = String::new();\n    let mut last_note_len = 0;\n    let mut\
    \ last_note = String::new();\n    let mut last_note_len = 0;\n    let mut last_note\
    \ = String::new();\n    let mut last_note_len = 0;\n    let mut last_note = String::new();\n\
    \    let mut last_note_len = 0;\n    let mut last_note = String::new();\n    let\
    \ mut last_note_len = 0;\n    let mut last_note = String::new();\n    let mut\
    \ last_note_len = 0;\n    let mut last_note = String::new();\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = String::new();\n    let mut last_note_len = 0;\n\
    \    let mut last_note = String::new();\n    let mut last_note_len = 0;\n    let\
    \ mut last_note = String::new();\n    let mut last_note_len = 0;\n    let mut\
    \ last_note = String::new();\n    let mut last_note_len = 0;\n    let mut last_note\
    \ = String::new();\n    let mut last_note_len = 0;\n    let mut last_note = String::new();\n\
    \    let mut last_note_len = 0;\n    let mut last_note = String::new();\n    let\
    \ mut last_note_len = 0;\n    let mut last_note = String::new();\n    let mut\
    \ last_note_len = 0;\n    let mut last_note = String::new();\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = String::new();\n    let mut last_note_len = 0;\n\
    \    let mut last_note = String::new();\n    let mut last_note_len = 0;\n    let\
    \ mut last_note = String::new();\n    let mut last_note_len = 0;\n    let mut\
    \ last_note = String::new();\n    let mut last_note_len = 0;\n    let mut last_note\
    \ = String::new();\n    let mut last_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppoezv0xj.rs:64:18\n   |\n\
    64 |     let mut last_\n   |                  ^ help: add `;` here\n65 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppoezv0xj.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_note_count = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_length_count = 0;\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let \n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpnnjj5t7c.rs:63:1\n  \
    \ |\n63 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = notes.clone();\n    let mut current_beat = 0;\n    let mut current_length\
    \ = 0;\n    while current_note.is_not_empty() {\n        let note = current_note.remove(0);\n\
    \        match note {\n            \"o\" => {\n                beats.push(current_beat);\n\
    \                current_beat += 4;\n                current_length += 4;\n  \
    \          }\n            \"o|\" => {\n                beats.push(current_beat);\n\
    \                current_beat += 2;\n                current_length += 2;\n  \
    \          }\n            \".|\" => {\n                beats.push(current_beat);\n\
    \                current_beat += 1;\n                current_length += 1;\n  \
    \          }\n            _ => {\n                println!(\"Invalid note: {:?}\"\
    , note);\n                panic!(\"Invalid note\");\n            }\n        }\n\
    \    }\n    beats.push(current_beat);\n    current_beat += current_length;\n \
    \   beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_not_empty` found for struct `Vec<&str>`\
    \ in the current scope\n  --> /tmp/tmpjxhpx74a.rs:16:24\n   |\n16 |     while\
    \ current_note.is_not_empty() {\n   |                        ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_empty`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_note = String::new();\n    let mut current_beat = 0;\n    let mut current_beats_length\
    \ = 0;\n    let mut current_notes_length = 0;\n    for c in music_string.chars()\
    \ {\n        if c == 'o' {\n            if current_notes_length != 0 {\n     \
    \           beats.push(current_beats_length);\n                current_beats_length\
    \ = 0;\n            }\n            current_note = String::new();\n           \
    \ current_beat = 0;\n            current_notes_length = 0;\n        } else if\
    \ c == '|' {\n            if current_notes_length != 0 {\n                beats.push(current_beats_length);\n\
    \                current_beats_length = 0;\n            }\n            current_note\
    \ = String::new();\n            current_beat = 0;\n            current_notes_length\
    \ = 0;\n        } else if c == ' ' {\n            if current_notes_length != 0\
    \ {\n                beats.push(current_beats_length);\n                current_beats_length\
    \ = 0;\n            }\n            current_note = String::new();\n           \
    \ current_beat = 0;\n            current_notes_length = 0;\n        } else {\n\
    \            current_note.push(c);\n            current_notes_length += 1;\n \
    \       }\n        current_beat += 1;\n    }\n    beats.push(current_beats_length);\n\
    \    current_beats_length = 0;\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmp43cvif1g.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_char = 0;\n    let mut current_note_char_len\
    \ = 0;\n    let mut current_note_char_value = 0;\n    let mut current_note_char_next\
    \ = 0;\n    let mut current_note_char_next2 = 0;\n    let mut current_note_char_next3\
    \ = 0;\n    let mut current_note_char_next4 = 0;\n    let mut current_note_char_next5\
    \ = 0;\n    let mut current_note_char_next6 = 0;\n    let mut current_note_char_next7\
    \ = 0;\n    let mut current_note_char_next8 = 0;\n    let mut current_note_char_next9\
    \ = 0;\n    let mut current_note_char_next10 = 0;\n    let mut current_note_char_next11\
    \ = 0;\n    let mut current_note_char_next12 = 0;\n    let mut current_note_char_next13\
    \ = 0;\n    let mut current_note_char_next14 = 0;\n    let mut current_note_char_next15\
    \ = 0;\n    let mut current_note_char_next16 = 0;\n    let mut current_note_char_next17\
    \ = 0;\n    let mut current_note_char_next18 = 0;\n    let mut current_note_char_next19\
    \ = 0;\n    let mut current_note_char_next20 = 0;\n    let mut current_note_char_next21\
    \ = 0;\n    let mut current_note_char_next22 = 0;\n    let mut current_note_char_next23\
    \ = 0;\n    let mut current_note_char_next24 = 0;\n    let mut current_note_char_next25\
    \ = 0;\n    let mut current_note_char_next26 = 0;\n    let mut current_note_char_next27\
    \ = 0;\n    let mut current_note_char_next28 = 0;\n    let mut current_note_char_next29\
    \ = 0;\n    let mut current_note_char_next30 = 0;\n    let mut current_note_char_next31\
    \ = 0;\n    let mut current_note_char_next32 = 0;\n    let mut current_note_char_next33\
    \ = 0;\n    let mut current_note_char_next34 = 0;\n    let mut current_note_char_next35\
    \ = 0;\n    let mut current_note_char_next36 = 0;\n    let mut current_note_char_next37\
    \ = 0;\n    let mut current_note_char_next38 = 0;\n    let mut current_note_char_next39\
    \ = 0;\n    let mut current_note_char_next40 = 0;\n    let mut current_note_char_next41\
    \ = 0;\n    let mut current_note_char_next42 = 0;\n    let mut current_note_char_next43\
    \ = 0;\n    let mut current_note_char_next44 = 0;\n    let mut current_note_char_next45\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpt9hox1ce.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo_d_6ra_.rs:62:40\n   |\n\
    62 |     let mut current_note_length_index48\n   |                           \
    \             ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo_d_6ra_.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note_index = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_value\
    \ = 0;\n    let mut current_note_length_value_length = 0;\n    let mut current_note_length_value_length_index\
    \ = 0;\n    let mut current_note_length_value_length_value = 0;\n    let mut current_note_length_value_length_value_index\
    \ = 0;\n    let mut current_note_length_value_length_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq06i2qhd.rs:52:57\n   |\n\
    52 |     let mut current_note_length_value_length_value_value\n   |          \
    \                                               ^ help: add `;` here\n53 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq06i2qhd.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_beats_length = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat = 0;\n    let mut\
    \ current_note_length_to_beat_length_to_beat_length = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzuoi5i9o.rs:34:146\n   |\n\
    34 |     let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_\n\
    \   |                                                                        \
    \                                                                          ^ help:\
    \ add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzuoi5i9o.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2 = 0;\n\
    \    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n    let\
    \ mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let mut\
    \ current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut current_note_oct9\
    \ = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11 =\
    \ 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 = 0;\n\
    \    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n  \
    \  let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n    let\
    \ mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let mut\
    \ current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut current_note_oct22\
    \ = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24 =\
    \ 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 = 0;\n\
    \    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n  \
    \  let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n    let\
    \ mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let mut\
    \ current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut current_note_oct35\
    \ = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37 =\
    \ 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 = 0;\n\
    \    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n  \
    \  let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n    let\
    \ mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let mut\
    \ current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut current_note_oct48\
    \ = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50 =\
    \ 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 = 0;\n\
    \    let mut current_note_oct53 = 0;\n    let mut current_\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgi7kfxc1.rs:68:21\n   |\n\
    68 |     let mut current_\n   |                     ^ help: add `;` here\n69 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgi7kfxc1.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = music_string.chars().nth(0).unwrap();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length_index47\
    \ = 1;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptfw9tk57.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&'static str> = vec![];\n    let mut current_note = String::new();\n\
    \    let mut current_beat = 0;\n    let mut current_octave = 0;\n    let mut current_length\
    \ = 0;\n\n    for c in music_string.chars() {\n        if c.is_whitespace() {\n\
    \            continue;\n        }\n        if c.is_ascii_digit() {\n         \
    \   current_length += 1;\n            current_beat += 1;\n            current_octave\
    \ += 1;\n            current_note = c.to_string();\n        } else {\n       \
    \     if current_note != \"\" {\n                notes.push(current_note);\n \
    \               current_note = String::new();\n            }\n            current_length\
    \ += 1;\n            current_beat += 1;\n            current_octave += 1;\n  \
    \      }\n    }\n    notes.push(current_note);\n    notes.sort_by_key(|&x| x.chars().count());\n\
    \    for note in notes {\n        beats.push(current_beat);\n        current_beat\
    \ = 0;\n        current_octave = 0;\n        current_length = 0;\n    }\n    beats.sort_by_key(|&x|\
    \ x.chars().count());\n    beats.reverse();\n    beats.dedup();\n    beats.reverse();\n\
    \    beats.dedup();\n    beats.reverse();\n    beats.dedup();\n    beats.reverse();\n\
    \    beats.dedup();\n    beats.reverse();\n    beats.dedup();\n    beats.reverse();\n\
    \    beats.dedup();\n    beats.reverse();\n    beats.dedup();\n    beats.reverse();\n\
    \    beats.dedup();\n    beats.reverse();\n    beats.dedup();\n    beats.reverse();\n\
    \    beats.dedup();\n    beats.reverse();\n    beats.dedup();\n    beats.reverse();\n\
    \    beats.dedup();\n    beats.reverse();\n    beats.dedup();\n    beats.reverse();\n\
    \    beats.dedup();\n    beats.reverse();\n    beats.dedup();\n    beats.reverse();\n\
    \    beats.dedup();\n    beats.reverse();\n    beats.dedup();\n    beats.reverse();\n\
    \    beats.dedup();\n    beats.reverse();\n    beats.dedup();\n    beats.reverse();\n\
    \    beats.dedup();\n    beats.reverse();\n    beats.dedup();\n    beats.reverse();\n\
    \    beats.ded\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6snvyszn.rs:29:28\n   |\n\
    29 |                 notes.push(current_note);\n   |                         \
    \   ^^^^^^^^^^^^\n   |                            |\n   |                    \
    \        expected `&str`, found struct `String`\n   |                        \
    \    help: consider borrowing here: `&current_note`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6snvyszn.rs:37:16\n   |\n37 |     notes.push(current_note);\n\
    \   |                ^^^^^^^^^^^^\n   |                |\n   |               \
    \ expected `&str`, found struct `String`\n   |                help: consider borrowing\
    \ here: `&current_note`\n\nerror[E0599]: no method named `chars` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmp6snvyszn.rs:45:30\n   |\n45 |  \
    \   beats.sort_by_key(|&x| x.chars().count());\n   |                         \
    \     ^^^^^ method not found in `isize`\n\nerror[E0609]: no field `ded` on type\
    \ `Vec<isize>`\n  --> /tmp/tmp6snvyszn.rs:89:11\n   |\n89 |     beats.ded\n  \
    \ |           ^^^ unknown field\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, note)| note != 'o').collect::<Vec<_>>();\n\
    \    let mut current_beat = 0;\n    for note in notes {\n        if note == 'o'\
    \ {\n            beats.push(current_beat);\n            current_beat += 4;\n \
    \       } else {\n            beats.push(current_beat);\n            current_beat\
    \ += 2;\n        }\n    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_3yzg_86.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != 'o').collect::<Vec<_>>();\n   |                                    \
    \                                          ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_3yzg_86.rs:15:20\n   |\n15 |         if note == 'o' {\n\
    \   |                    ^^^ expected tuple, found `char`\n   |\n   = note: expected\
    \ tuple `(usize, char)`\n               found type `char`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().enumerate().filter(|(_,\
    \ note)| note != 'o').collect::<Vec<_>>();\n    let mut last_note = notes.len()\
    \ - 1;\n    let mut last_beat = 0;\n    for note in notes {\n        if note ==\
    \ 'o' {\n            beats.push(last_beat);\n            last_beat = 0;\n    \
    \    } else {\n            last_beat = last_beat + 1;\n        }\n    }\n    beats.push(last_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpg30q039d.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != 'o').collect::<Vec<_>>();\n   |                                    \
    \                                          ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg30q039d.rs:16:20\n   |\n16 |         if note == 'o' {\n\
    \   |                    ^^^ expected tuple, found `char`\n   |\n   = note: expected\
    \ tuple `(usize, char)`\n               found type `char`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.first().unwrap();\n    let mut current_beat = 0;\n    let mut current_note_length\
    \ = 0;\n    for note in notes {\n        if note == current_note {\n         \
    \   current_beat += 1;\n            current_note_length += 1;\n        } else\
    \ {\n            beats.push(current_beat);\n            current_beat = 1;\n  \
    \          current_note_length = 1;\n            current_note = note;\n      \
    \  }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmplpif228f.rs:17:17\n\
    \   |\n17 |         if note == current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplpif228f.rs:24:28\n   |\n13 |     let mut current_note\
    \ = notes.first().unwrap();\n   |                            ----------------------\
    \ expected due to this value\n...\n24 |             current_note = note;\n   |\
    \                            ^^^^ expected `&str`, found `str`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note_index = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_value\
    \ = 0;\n    let mut current_note_length_value_index = 0;\n    let mut current_note_length_value_value\
    \ = 0;\n    let mut current_note_length_value_value_index = 0;\n    let mut current_note_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_u3ir2qa.rs:55:21\n   |\n\
    55 |     let mut current_\n   |                     ^ help: add `;` here\n56 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_u3ir2qa.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().enumerate();\n\
    \    let mut current_note = 0;\n    let mut current_beat = 0;\n    loop {\n  \
    \      let note = notes.next()\n            .expect(\"music string should contain\
    \ at least one note\");\n        let note = note.1.to_digit(10).unwrap();\n  \
    \      if note == '.' {\n            note = notes.next()\n                .expect(\"\
    music string should contain at least one note\");\n            note = note.1.to_digit(10).unwrap();\n\
    \        }\n        if note == 'o' {\n            note = notes.next()\n      \
    \          .expect(\"music string should contain at least one note\");\n     \
    \       note = note.1.to_digit(10).unwrap();\n        }\n        if note == '|'\
    \ {\n            note = notes.next()\n                .expect(\"music string should\
    \ contain at least one note\");\n            note = note.1.to_digit(10).unwrap();\n\
    \        }\n        if note == '#' {\n            note = notes.next()\n      \
    \          .expect(\"music string should contain at least one note\");\n     \
    \       note = note.1.to_digit(10).unwrap();\n        }\n        if note == 'b'\
    \ {\n            note = notes.next()\n                .expect(\"music string should\
    \ contain at least one note\");\n            note = note.1.to_digit(10).unwrap();\n\
    \        }\n        if note == '#' {\n            note = notes.next()\n      \
    \          .expect(\"music string should contain at least one note\");\n     \
    \       note = note.1.to_digit(10).unwrap();\n        }\n        if note == 'b'\
    \ {\n            note = notes.next()\n                .expect(\"music string should\
    \ contain at least one note\");\n            note = note.1.to_digit(10).unwrap();\n\
    \        }\n        if note == '#' {\n            note = notes.next()\n      \
    \          .expect(\"music string should contain at least one note\");\n     \
    \       note = note.1.to_digit(10).unwrap();\n        }\n        if note == 'b'\
    \ {\n            note = notes.next()\n                .expect(\"music string should\
    \ contain at least one note\");\n            note = note.1.to_digit(10).unwrap();\n\
    \        }\n        if note == '#' {\n            note = notes.next()\n      \
    \          .expect(\"music string should contain at least one note\");\n     \
    \       note = note.1.to_digit(10).unwrap();\n        }\n        if note == 'b'\
    \ {\n            note = notes.next()\n                .expect(\"music \n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpslpt0qmz.rs:80:61\n\
    \   |\n80 |       assert_eq!(candidate(String::from(\"o| .| o| .| o o| o o|\"\
    )), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n   |  _____________________________________________________________^\n\
    81 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut notes_len: usize = 0;\n    let mut current_note\
    \ = String::new();\n    let mut current_note_len = String::new();\n    let mut\
    \ current_beat = String::new();\n    let mut current_beat_len = String::new();\n\
    \    let mut current_note_len: usize = 0;\n    let mut current_note_len: usize\
    \ = 0;\n    let mut current_beat: usize = 0;\n    let mut current_beat: usize\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note =\
    \ String::new();\n    let mut current_note = String::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_note = String::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_note = String::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_note = String::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_note = String::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_note = String::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_note = String::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_note = String::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_note = String::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_note = String::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_note = String::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_note = String::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_note = String::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_note = String::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_note = String::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_note = String::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_note = String::new();\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgyp0gaa6.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, note)| note != 'o');\n    for\
    \ note in notes {\n        note = note.unwrap();\n        if note == 'o' {\n \
    \           beats.push(4);\n        } else {\n            let mut beat = 1;\n\
    \            let mut last_note = note;\n            while note != last_note {\n\
    \                beat *= 4;\n                beats.push(beat);\n             \
    \   last_note = note;\n                note = notes.next();\n            }\n \
    \       }\n    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpa8dhq0ig.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != 'o');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0599]: no method named `unwrap`\
    \ found for tuple `(usize, char)` in the current scope\n  --> /tmp/tmpa8dhq0ig.rs:14:21\n\
    \   |\n14 |         note = note.unwrap();\n   |                     ^^^^^^ method\
    \ not found in `(usize, char)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa8dhq0ig.rs:15:20\n\
    \   |\n15 |         if note == 'o' {\n   |                    ^^^ expected tuple,\
    \ found `char`\n   |\n   = note: expected tuple `(usize, char)`\n            \
    \   found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa8dhq0ig.rs:24:24\n\
    \   |\n13 |     for note in notes {\n   |         ---- expected due to the type\
    \ of this binding\n...\n24 |                 note = notes.next();\n   |      \
    \                  ^^^^^^^^^^^^ expected tuple, found enum `Option`\n   |\n  \
    \ = note: expected tuple `(usize, char)`\n               found enum `Option<(usize,\
    \ char)>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnlhxnm8e.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_octlen = 0;\n\
    \    let mut current_note_octoctlen = 0;\n    let mut current_note_octoctlen2\
    \ = 0;\n    let mut current_note_octlen3 = 0;\n    let mut current_note_octlen4\
    \ = 0;\n    let mut current_note_octlen5 = 0;\n    let mut current_note_octlen6\
    \ = 0;\n    let mut current_note_octlen7 = 0;\n    let mut current_note_octlen8\
    \ = 0;\n    let mut current_note_octlen9 = 0;\n    let mut current_note_octlen10\
    \ = 0;\n    let mut current_note_octlen11 = 0;\n    let mut current_note_octlen12\
    \ = 0;\n    let mut current_note_octlen13 = 0;\n    let mut current_note_octlen14\
    \ = 0;\n    let mut current_note_octlen15 = 0;\n    let mut current_note_octlen16\
    \ = 0;\n    let mut current_note_octlen17 = 0;\n    let mut current_note_octlen18\
    \ = 0;\n    let mut current_note_octlen19 = 0;\n    let mut current_note_octlen20\
    \ = 0;\n    let mut current_note_octlen21 = 0;\n    let mut current_note_octlen22\
    \ = 0;\n    let mut current_note_octlen23 = 0;\n    let mut current_note_octlen24\
    \ = 0;\n    let mut current_note_octlen25 = 0;\n    let mut current_note_octlen26\
    \ = 0;\n    let mut current_note_octlen27 = 0;\n    let mut current_note_octlen28\
    \ = 0;\n    let mut current_note_octlen29 = 0;\n    let mut current_note_octlen30\
    \ = 0;\n    let mut current_note_octlen31 = 0;\n    let mut current_note_octlen32\
    \ = 0;\n    let mut current_note_octlen33 = 0;\n    let mut current_note_octlen34\
    \ = 0;\n    let mut current_note_octlen35 = 0;\n    let mut current_note_octlen36\
    \ = 0;\n    let mut current_note_octlen37 = 0;\n    let mut current_note_octlen38\
    \ = 0;\n    let mut current_note_octlen39 = 0;\n    let mut current_note_octlen40\
    \ = 0;\n    let mut current_note_octlen41 = 0;\n    let mut current_note_octlen42\
    \ = 0;\n    let mut current_note_octlen43 = 0;\n    let mut current_note_octlen44\
    \ = 0;\n    let mut current_note_octlen45 = 0;\n    let mut current_note_octlen46\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp5j5fxr2u.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
