name: HumanEval_141_file_name_check
language: rust
results:
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name[dot_pos - 1] == '0' {\n\
    \        return String::from(\"No\");\n    }\n    if file_name[dot_pos - 1] ==\
    \ '9' {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos\
    \ - 1] != '.' {\n        return String::from(\"No\");\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n        return String::from(\"No\");\n    }\n    if\
    \ file_name.chars().any(|c| !c.is_ascii_lowercase()) {\n        return String::from(\"\
    No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_uppercase()) {\n \
    \       return String::from(\"No\");\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c != 'a' || c != 'z' || c != 'A' || c != 'Z') {\n  \
    \      return String::from(\"No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_lowercase()\
    \ || c != 'a' || c != 'z' || c != 'A' || c != 'Z') {\n        return String::from(\"\
    No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_uppercase() || c !=\
    \ 'A' || c != 'Z') {\n        return String::from(\"No\");\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_lowercase() || c != 'a' || c != 'z' || c != 'A' || c != 'Z') {\n\
    \        return String::from(\"No\");\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_uppercase() || c != 'A' || c != 'Z') {\n        return String::from(\"\
    No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_lowercase() || c !=\
    \ 'a' || c != 'z' || c != 'A' || c != 'Z') {\n        return String::from(\"No\"\
    );\n    }\n    if file_name.chars().any(|c| !c.is_ascii_uppercase() || c != 'A'\
    \ || c != 'Z') {\n        return String::from(\"No\");\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_lowercase() || c != 'a' || c != 'z' || c != 'A' || c != 'Z') {\n\
    \        return String::from(\"No\");\n    }\n    if file_name.chars().any(|c|\
    \ \n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpbsq1nel2.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected expression, found `)`\n \
    \ --> /tmp/tmpbsq1nel2.rs:62:1\n   |\n62 | }\n   | ^ expected expression\n\nerror:\
    \ mismatched closing delimiter: `}`\n  --> /tmp/tmpbsq1nel2.rs:61:29\n   |\n13\
    \ | fn file_name_check(file_name: String) -> String {\n   |                  \
    \                               - closing delimiter possibly meant for this\n\
    ...\n61 |     if file_name.chars().any(|c| \n   |                            \
    \ ^ unclosed delimiter\n62 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpbsq1nel2.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n\
    \  --> /tmp/tmpbsq1nel2.rs:19:26\n   |\n19 |     if file_name[dot_pos - 1] ==\
    \ '0' {\n   |                  ------- ^ - {integer}\n   |                  |\n\
    \   |                  Option<usize>\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `Option<usize>`\n  --> /tmp/tmpbsq1nel2.rs:22:26\n   |\n22 |     if file_name[dot_pos\
    \ - 1] == '9' {\n   |                  ------- ^ - {integer}\n   |           \
    \       |\n   |                  Option<usize>\n\nerror[E0369]: cannot subtract\
    \ `{integer}` from `Option<usize>`\n  --> /tmp/tmpbsq1nel2.rs:25:26\n   |\n25\
    \ |     if file_name[dot_pos - 1] != '.' {\n   |                  ------- ^ -\
    \ {integer}\n   |                  |\n   |                  Option<usize>\n\n\
    error[E0599]: no method named `is_ascii_letter` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpbsq1nel2.rs:28:37\n   |\n28 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n   |                                     ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a sim"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return \"No\";\n    }\n    let mut dot_pos_end = dot_pos + 1;\n    let mut\
    \ dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter = false;\n  \
    \  let mut dot_pos_end_letter = false;\n    while dot_pos_start != dot_pos_end\
    \ {\n        if dot_pos_start == 0 {\n            dot_pos_start_letter = true;\n\
    \        }\n        if dot_pos_end == file_name.len() {\n            dot_pos_end_letter\
    \ = true;\n        }\n        if dot_pos_start_letter && dot_pos_end_letter {\n\
    \            break;\n        }\n        if file_name[dot_pos_start] >= 'a' &&\
    \ file_name[dot_pos_start] <= 'z' {\n            dot_pos_start++;\n          \
    \  dot_pos_start_letter = true;\n        }\n        if file_name[dot_pos_end]\
    \ >= 'a' && file_name[dot_pos_end] <= 'z' {\n            dot_pos_end--;\n    \
    \        dot_pos_end_letter = true;\n        }\n        dot_pos_start++;\n   \
    \     dot_pos_end--;\n    }\n    if dot_pos_start_letter && dot_pos_end_letter\
    \ {\n        return \"No\";\n    }\n    if dot_pos_start == dot_pos_end {\n  \
    \      return \"No\";\n    }\n    if dot_pos_start == 0 || dot_pos_end == file_name.len()\
    \ {\n        return \"No\";\n    }\n    if dot_pos_start > dot_pos_end {\n   \
    \     return \"No\";\n    }\n    if dot_pos_start < 3 || dot_pos_end > file_name.len()\
    \ {\n        return \"No\";\n    }\n    if file_name[dot_pos_start - 1] >= '0'\
    \ && file_name[dot_pos_start - 1] <= '9' {\n        return \"No\";\n    }\n  \
    \  if file_name[dot_pos_end - 1] >= '0' && file_name[dot_pos_end - 1] <= '9' {\n\
    \        return \"No\";\n    }\n    if file_name[dot_pos_start - 1] != '.' ||\
    \ file_name[dot_pos_end - 1] != '.' {\n        return \"No\";\n    }\n    if file_name[dot_pos_start\
    \ - 1] != '.' {\n        return \"No\";\n    }\n    if file_name[dot_pos_end -\
    \ 1] != '.' {\n        return \"No\";\n    }\n    if file_name[dot_pos_start -\
    \ 1] != file_name[dot_pos_end - 1] {\n        return \"No\";\n    }\n    return\
    \ \"Yes\";\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpytv8_ocz.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmpytv8_ocz.rs:34:26\n   |\n34 |             dot_pos_start++;\n  \
    \ |                          ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n34 |             { let tmp = dot_pos_start; dot_pos_start\
    \ += 1; tmp };\n   |             +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    34 -             dot_pos_start++;\n34 +             dot_pos_start += 1;\n   |\
    \ \n\nerror: expected expression, found `;`\n  --> /tmp/tmpytv8_ocz.rs:38:26\n\
    \   |\n38 |             dot_pos_end--;\n   |                          ^ expected\
    \ expression\n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpytv8_ocz.rs:41:22\n\
    \   |\n41 |         dot_pos_start++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n41 |         { let tmp\
    \ = dot_pos_start; dot_pos_start += 1; tmp };\n   |         +++++++++++      \
    \        ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n41 -         dot_pos_start++;\n41 +    \
    \     dot_pos_start += 1;\n   | \n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpytv8_ocz.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpytv8_ocz.rs:17:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n17 |         return \"No\";\n   |    \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \               |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpytv8_ocz.rs:19:35\n\
    \   |\n19 |     let mut dot"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    \n    if file_name.len() < 3 {\n        return\
    \ \"No\";\n    }\n    \n    if file_name[dot_pos - 1] != char::from_u32(97).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 2] != char::from_u32(65).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 3] != char::from_u32(97).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 4] != char::from_u32(65).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 5] != char::from_u32(97).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 6] != char::from_u32(65).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 7] != char::from_u32(97).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 8] != char::from_u32(65).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 9] != char::from_u32(97).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 10] != char::from_u32(65).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 11] != char::from_u32(97).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 12] != char::from_u32(65).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 13] != char::from_u32(97).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 14] != char::from_u32(65).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 15] != char::from_u32(97).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 16] != char::from_u32(65).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 17] != char::from_u32(97).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 18] != char::from_u32(65).unwrap()\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 19] != char\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp5wzmrh4f.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ { \n   |     -- unexpected token\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp5wzmrh4f.rs:97:1\n\
    \   |\n96 |     if file_name[dot_pos - 19] != char\n   |     -- this `if` expression\
    \ has a condition, but no block\n97 | }\n   | ^ expected `{`\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp5wzmrh4f.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos { \n   |                           ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5wzmrh4f.rs:17:16\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n17 |         return \"No\";\n   |                ^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                |\n   |             \
    \   expected struct `String`, found `&str`\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `Option<usize>`\n  --> /tmp/tmp5wzmrh4f.rs:24:26\n   |\n24 |     if file_name[dot_pos\
    \ - 1] != char::from_u32(97).unwrap() {\n   |                  ------- ^ - {integer}\n\
    \   |                  |\n   |                  Option<usize>\n\nerror[E0369]:\
    \ cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmp5wzmrh4f.rs:28:26\n\
    \   |\n28 |     if file_name[dot_pos - 2] != char::from_u32(65).unwrap() {\n \
    \  |                  ------- ^ - {integer}\n   |                  |\n   |   \
    \               Option<usize>\n\nerror[E0369]: cannot subtract `{integer}` from\
    \ `Option<usize>`\n  --> /tmp/tmp5wzmrh4f.rs:32:26\n   |\n32 |     if file_name[dot_pos\
    \ - 3] != char::from_u32(97).unwrap() {\n   |                  ------- ^ - {integer}\n\
    \   |                  |\n   |                  Option<usize>\n\nerror[E0369]:\
    \ cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmp5wzmrh4f.rs:36:"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    if\
    \ file_name.len() > 3 {\n        file_name.truncate(3);\n    }\n    if file_name.contains(\"\
    .\") {\n        file_name.truncate(file_name.rfind('.'));\n    }\n    if file_name.starts_with(\"\
    a\") || file_name.starts_with(\"A\") {\n        file_name.truncate(0);\n    }\n\
    \    if file_name.ends_with(\"txt\") || file_name.ends_with(\"exe\") || file_name.ends_with(\"\
    dll\") {\n        file_name.truncate(file_name.len());\n    }\n    file_name\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzud8x76c.rs:19:28\n   |\n\
    19 |         file_name.truncate(file_name.rfind('.'));\n   |                 \
    \           ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n\
    \   = note: expected type `usize`\n              found enum `Option<usize>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name_chars = file_name.chars();\n    let\
    \ mut dot_pos = file_name_chars.find_first_of('.');\n    let mut dot_pos_end =\
    \ file_name_chars.find_first_not_of('.', dot_pos);\n    let mut dot_pos_start\
    \ = dot_pos;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end_valid\
    \ = false;\n    let mut dot_pos_start_end_invalid = false;\n    let mut dot_pos_start_valid\
    \ = false;\n    let mut dot_pos_start_invalid = false;\n    let mut dot_pos_end_valid\
    \ = false;\n    let mut dot_pos_end_invalid = false;\n    let mut dot_pos_valid\
    \ = false;\n    let mut dot_pos_invalid = false;\n    let mut dot_pos_start_end_valid\
    \ = false;\n    let mut dot_pos_start_end_invalid = false;\n    let mut dot_pos_start_valid\
    \ = false;\n    let mut dot_pos_start_invalid = false;\n    let mut dot_pos_end_valid\
    \ = false;\n    let mut dot_pos_end_invalid = false;\n    let mut dot_pos_valid\
    \ = false;\n    let mut dot_pos_invalid = false;\n    let mut dot_pos_start_end_valid\
    \ = false;\n    let mut dot_pos_start_end_invalid = false;\n    let mut dot_pos_start_valid\
    \ = false;\n    let mut dot_pos_start_invalid = false;\n    let mut dot_pos_end_valid\
    \ = false;\n    let mut dot_pos_end_invalid = false;\n    let mut dot_pos_valid\
    \ = false;\n    let mut dot_pos_invalid = false;\n    let mut dot_pos_start_end_valid\
    \ = false;\n    let mut dot_pos_start_end_invalid = false;\n    let mut dot_pos_start_valid\
    \ = false;\n    let mut dot_pos_start_invalid = false;\n    let mut dot_pos_end_valid\
    \ = false;\n    let mut dot_pos_end_invalid = false;\n    let mut dot_pos_valid\
    \ = false;\n    let mut dot_pos_invalid = false;\n    let mut dot_pos_start_end_valid\
    \ = false;\n    let mut dot_pos_start_end_invalid = false;\n    let mut dot_pos_start_valid\
    \ = false;\n    let mut dot_pos_start_invalid = false;\n    let mut dot_pos_end_valid\
    \ = false;\n    let mut dot_pos_end_invalid = false;\n    let mut dot_pos_valid\
    \ = false;\n    let mut dot_pos_invalid = false;\n    let mut dot_pos_start_end_valid\
    \ = false;\n    let mut dot_pos_start_end_invalid = false;\n    let mut dot_pos_start_valid\
    \ = false;\n    let mut dot_pos_start_invalid = false;\n    let mut dot_pos_end_valid\
    \ = false;\n    let mut dot_pos_end_invalid = false;\n    let mut dot_pos_valid\
    \ = false;\n    let mut dot_pos_invalid = false;\n    let mut dot_pos_start_end_valid\
    \ = false;\n    let mu\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmponlpmz4v.rs:68:11\n   |\n\
    68 |     let mu\n   |           ^ help: add `;` here\n69 | }\n   | - unexpected\
    \ token\n\nerror[E0599]: no method named `find_first_of` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmponlpmz4v.rs:15:39\n   |\n15 |     let mut\
    \ dot_pos = file_name_chars.find_first_of('.');\n   |                        \
    \               ^^^^^^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `find_first_not_of` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmponlpmz4v.rs:16:43\n   |\n16 |     let mut dot_pos_end =\
    \ file_name_chars.find_first_not_of('.', dot_pos);\n   |                     \
    \                      ^^^^^^^^^^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmponlpmz4v.rs:13:42\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |    ---------------                       ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter =\
    \ dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = \n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpnk9ga6gm.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected expression, found `}`\n \
    \ --> /tmp/tmpnk9ga6gm.rs:59:1\n   |\n59 | }\n   | ^ expected expression\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpnk9ga6gm.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpnk9ga6gm.rs:19:35\n   |\n19 |     let mut dot_pos_end = dot_pos\
    \ + 1;\n   |                           ------- ^ - {integer}\n   |           \
    \                |\n   |                           Option<usize>\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpnk9ga6gm.rs:20:37\n\
    \   |\n20 |     let mut dot_pos_start = dot_pos + 1;\n   |                   \
    \          ------- ^ - {integer}\n   |                             |\n   |   \
    \                          Option<usize>\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    \n    if file_name.len() < 3 {\n \
    \       return String::from(\"No\");\n    }\n    \n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n        return String::from(\"No\");\n    }\n    \n\
    \    if file_name.chars().any(|c| !c.is_ascii_letter() || c != 'a' && c != 'z')\
    \ {\n        return String::from(\"No\");\n    }\n    \n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c != 'A' && c != 'Z') {\n        return String::from(\"\
    No\");\n    }\n    \n    if file_name.chars().any(|c| !c.is_ascii_letter() ||\
    \ c != '0' && c != '9') {\n        return String::from(\"No\");\n    }\n    \n\
    \    if file_name.chars().any(|c| !c.is_ascii_letter() || c != 'a' && c != 'z'\
    \ || c != 'A' && c != 'Z' || c != '0' && c != '9') {\n        return String::from(\"\
    No\");\n    }\n    \n    if file_name.chars().any(|c| !c.is_ascii_letter() ||\
    \ c != 'a' && c != 'z' || c != 'A' && c != 'Z' || c != '0' && c != '9' || c !=\
    \ '.') {\n        return String::from(\"No\");\n    }\n    \n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c != 'a' && c != 'z' || c != 'A' && c != 'Z' || c !=\
    \ '0' && c != '9' || c != '.' || c != 'txt' || c != 'exe' || c != 'dll') {\n \
    \       return String::from(\"No\");\n    }\n    \n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c != 'a' && c != 'z' || c != 'A' && c != 'Z' || c !=\
    \ '0' && c != '9' || c != '.' || c != 'txt' || c != 'exe' || c != 'dll') {\n \
    \       return String::from(\"No\");\n    }\n    \n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c != 'a' && c != 'z' || c != 'A' && c != 'Z' || c !=\
    \ '0' && c != '9' || c != '.' || c != 'txt' || c != 'exe' || c != 'dll') {\n \
    \       return String::from(\"No\");\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpt73lz4d_.rs:48:147\n\
    \   |\n48 | ... != 'A' && c != 'Z' || c != '0' && c != '9' || c != '.' || c !=\
    \ 'txt' || c != 'exe' || c != 'dll') {\n   |                                 \
    \                                   ^^^^^\n   |\nhelp: if you meant to write a\
    \ `str` literal, use double quotes\n   |\n48 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c != 'a' && c != 'z' || c != 'A' && c != 'Z' || c !=\
    \ '0' && c != '9' || c != '.' || c != \"txt\" || c != 'exe' || c != 'dll') {\n\
    \   |                                                                        \
    \                                                                           ~~~~~\n\
    \nerror: character literal may only contain one codepoint\n  --> /tmp/tmpt73lz4d_.rs:48:161\n\
    \   |\n48 | ...= 'Z' || c != '0' && c != '9' || c != '.' || c != 'txt' || c !=\
    \ 'exe' || c != 'dll') {\n   |                                               \
    \                     ^^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n48 |     if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c != 'a' && c != 'z' || c != 'A' && c != 'Z' || c != '0' && c != '9' || c\
    \ != '.' || c != 'txt' || c != \"exe\" || c != 'dll') {\n   |                \
    \                                                                            \
    \                                                                     ~~~~~\n\n\
    error: character literal may only contain one codepoint\n  --> /tmp/tmpt73lz4d_.rs:48:175\n\
    \   |\n48 | ...'0' && c != '9' || c != '.' || c != 'txt' || c != 'exe' || c !=\
    \ 'dll') {\n   |                                                             \
    \       ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n48 |     if file_name.chars().any(|c| !c.is_ascii_letter() || c != 'a'\
    \ && c != 'z' || c != 'A' && c != 'Z' || c != '0' && c != '9' || c != '.' || c\
    \ != 'txt' || c != 'exe' || c != \"dll\") {\n   |                            \
    \                                                                            \
    \                          "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    \n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    \n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_4\
    \ = file_name.find('.')\n    if dot_pos_4 == String::npos {\n        return String::from(\"\
    No\");\n    }\n    \n    let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5\
    \ == String::npos {\n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_pos_6 = file_name.find('.')\n    if dot_pos_6 == String::npos {\n  \
    \      return String::from(\"No\");\n    }\n    \n    let mut dot_pos_7 = file_name.find('.')\n\
    \    if dot_pos_7 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    \n    let mut dot_pos_8 = file_name.find('.')\n    if dot_pos_8 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_9\
    \ = file_name.find('.')\n    if dot_pos_9 == String::npos {\n        return String::from(\"\
    No\");\n    }\n    \n    let mut dot_pos_10 = file_name.find('.')\n    if dot_pos_10\
    \ == String::npos {\n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos {\n\
    \        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    \n    let mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 ==\
    \ String::npos {\n        return String::from(\"No\");\n    }\n    \n    let mut\
    \ dot_pos_14 = file_name.find('.')\n    if dot_pos_14 == String::npos {\n    \
    \    return String::from(\"No\");\n    }\n    \n    let mut dot_pos_15 = file_name.find('.')\n\
    \    if dot_pos_15 == String::npos {\n        return String::from(\"\n}\n\nfn\
    \ main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmpi3z5ey_o.rs:93:40\n\
    \   |\n93 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n   --> /tmp/tmpi3z5ey_o.rs:106:56\n    |\n106\
    \ |     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n    |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmpi3z5ey_o.rs:117:63\n\
    \    |\n117 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    118 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.clone();\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n        return\
    \ \"No\";\n    }\n    let mut dot_pos_2 = file_name.find('.')\n    if dot_pos_2\
    \ == String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_3 = file_name.find('.')\n\
    \    if dot_pos_3 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_4 = file_name.find('.')\n    if dot_pos_4 == String::npos {\n      \
    \  return \"No\";\n    }\n    let mut dot_pos_5 = file_name.find('.')\n    if\
    \ dot_pos_5 == String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_6\
    \ = file_name.find('.')\n    if dot_pos_6 == String::npos {\n        return \"\
    No\";\n    }\n    let mut dot_pos_7 = file_name.find('.')\n    if dot_pos_7 ==\
    \ String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_8 = file_name.find('.')\n\
    \    if dot_pos_8 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_9 = file_name.find('.')\n    if dot_pos_9 == String::npos {\n      \
    \  return \"No\";\n    }\n    let mut dot_pos_10 = file_name.find('.')\n    if\
    \ dot_pos_10 == String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_11\
    \ = file_name.find('.')\n    if dot_pos_11 == String::npos {\n        return \"\
    No\";\n    }\n    let mut dot_pos_12 = file_name.find('.')\n    if dot_pos_12\
    \ == String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_13 = file_name.find('.')\n\
    \    if dot_pos_13 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_14 = file_name.find('.')\n    if dot_pos_14 == String::npos {\n    \
    \    return \"No\";\n    }\n    let mut dot_pos_15 = file_name.find('.')\n   \
    \ if dot_pos_15 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_16 = file_name.find('.')\n    if dot_pos_16 == String::npos {\n    \
    \    return \"No\";\n    }\n    let mut dot_pos_17 = file_name.find('.')\n   \
    \ if dot_pos_17 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_18 = file_name.find('.')\n    if dot_pos_18 == String::npos {\n    \
    \    return \"No\";\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpj3bjynhx.rs:116:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n84  |  \
    \   if dot_pos_18 == String::npos {\n    |                                   -\
    \ this delimiter might not be properly closed...\n85  |         return \"No\"\
    ;\n86  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    116 | }\n    |   ^\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpj3bjynhx.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpj3bjynhx.rs:19:44\n   |\n19 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n20 |  \
    \   if dot_pos_2 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpj3bjynhx.rs:23:44\n   |\n23 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n24 |     if dot_pos_3 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpj3bjynhx.rs:27:44\n\
    \   |\n27 |     let mut dot_pos_4 = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n28 |     if dot_pos_4 == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpj3bjynhx.rs:31:44\n   |\n31 |     let mut dot_pos_5 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n32 |  \
    \   if dot_pos_5 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpj3bjynhx.rs:35:44\n   |\n35 |     let\
    \ mut dot_pos_6 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n36 |     if dot_pos_6 == String::npos {\n   |\
    \     -- unexpect"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name_chars = file_name.chars();\n    let\
    \ mut dot_index = file_name_chars.find_first_of(\".\");\n    let mut dot_chars\
    \ = file_name_chars.substring_from(dot_index);\n    let mut dot_chars_len = dot_chars.len();\n\
    \    let mut dot_chars_char = dot_chars.chars();\n    let mut dot_chars_char_len\
    \ = dot_chars_char.len();\n    let mut dot_chars_char_char = dot_chars_char.chars();\n\
    \    let mut dot_chars_char_char_len = dot_chars_char_char.len();\n    let mut\
    \ dot_chars_char_char_char = dot_chars_char_char.chars();\n    let mut dot_chars_char_char_char_len\
    \ = dot_chars_char_char_char.len();\n    let mut dot_chars_char_char_char_char\
    \ = dot_chars_char_char_char.chars();\n    let mut dot_chars_char_char_char_char_len\
    \ = dot_chars_char_char_char_char.len();\n    let mut dot_chars_char_char_char_char_char\
    \ = dot_chars_char_char_char_char.chars();\n    let mut dot_chars_char_char_char_char_char_len\
    \ = dot_chars_char_char_char_char_char.len();\n    let mut dot_chars_char_char_char_char_char_char\
    \ = dot_chars_char_char_char_char_char.chars();\n    let mut dot_chars_char_char_char_char_char_char_len\
    \ = dot_chars_char_char_char_char_char_char.len();\n    let mut dot_chars_char_char_char_char_char_char_char\
    \ = dot_chars_char_char_char_char_char_char_char.chars();\n    let mut dot_chars_char_char_char_char_char_char_char_len\
    \ = dot_chars_char_char_char_char_char_char_char.len();\n    let mut dot_chars_char_char_char_char_char_char_char_char\
    \ = dot_chars_char_char_char_char_char_char_char_char.chars();\n    let mut dot_chars_char_char_char_char_char_char_char_char_len\
    \ = dot_chars_char_char_char_char_char_char_char_char_char.len();\n    let mut\
    \ dot_chars_char_char_char_char_char_char_char_char_char = dot_chars_char_char_char_char_char_char_char_char_char_char.chars();\n\
    \    let mut dot_chars_char_char_char_char_char_char_char_char_char_len = dot_chars_char_char_char_char_char_char_char_char_char_char.len();\n\
    \    let mut dot_chars_char_char_char_char_char_char_char_char_char_char = dot_chars_char_char_char_char_char_char_char_char_char_char_char.chars();\n\
    \    let mut \n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpjfu69zoq.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected identifier\n\nerror[E0425]: cannot find value `dot_chars_char_char_char_char_char_char_char`\
    \ in this scope\n  --> /tmp/tmpjfu69zoq.rs:30:60\n   |\n30 |     let mut dot_chars_char_char_char_char_char_char_char\
    \ = dot_chars_char_char_char_char_char_char_char.chars();\n   |              \
    \                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `dot_chars_char_char_char_char_char_char_len`\n\
    \nerror[E0425]: cannot find value `dot_chars_char_char_char_char_char_char_char_char`\
    \ in this scope\n  --> /tmp/tmpjfu69zoq.rs:32:65\n   |\n32 |     let mut dot_chars_char_char_char_char_char_char_char_char\
    \ = dot_chars_char_char_char_char_char_char_char_char.chars();\n   |         \
    \                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `dot_chars_char_char_char_char_char_char_char_len`\n\
    \nerror[E0425]: cannot find value `dot_chars_char_char_char_char_char_char_char_char_char`\
    \ in this scope\n  --> /tmp/tmpjfu69zoq.rs:33:69\n   |\n33 |     let mut dot_chars_char_char_char_char_char_char_char_char_len\
    \ = dot_chars_char_char_char_char_char_char_char_char_char.len();\n   |      \
    \                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `dot_chars_char_char_char_char_char_char_char_char`\n\
    \nerror[E0425]: cannot find value `dot_chars_char_char_char_char_char_char_char_char_char_char`\
    \ in this scope\n  --> /tmp/tmpjfu69zoq.rs:34:70\n   |\n34 |     let mut dot_chars_char_char_char_char_char_char_char_char_char\
    \ = dot_chars_char_char_char_char_char_char_char_char_char_char.chars();\n   |\
    \                                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `dot_chars_char_cha"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name_chars = file_name.chars();\n    let\
    \ mut dot_pos = file_name_chars.next().unwrap().unwrap();\n    let mut dot_pos_next\
    \ = dot_pos.unwrap();\n    let mut dot_pos_next = dot_pos_next.unwrap();\n   \
    \ let mut dot_pos_next = dot_pos_next.unwrap();\n    let mut dot_pos_next = dot_pos_next.unwrap();\n\
    \    let mut dot_pos_next = dot_pos_next.unwrap();\n    let mut dot_pos_next =\
    \ dot_pos_next.unwrap();\n    let mut dot_pos_next = dot_pos_next.unwrap();\n\
    \    let mut dot_pos_next = dot_pos_next.unwrap();\n    let mut dot_pos_next =\
    \ dot_pos_next.unwrap();\n    let mut dot_pos_next = dot_pos_next.unwrap();\n\
    \    let mut dot_pos_next = dot_pos_next.unwrap();\n    let mut dot_pos_next =\
    \ dot_pos_next.unwrap();\n    let mut dot_pos_next = dot_pos_next.unwrap();\n\
    \    let mut dot_pos_next = dot_pos_next.unwrap();\n    let mut dot_pos_next =\
    \ dot_pos_next.unwrap();\n    let mut dot_pos_next = dot_pos_next.unwrap();\n\
    \    let mut dot_pos_next = dot_pos_next.unwrap();\n    let mut dot_pos_next =\
    \ dot_pos_next.unwrap();\n    let mut dot_pos_next = dot_pos_next.unwrap();\n\
    \    let mut dot_pos_next = dot_pos_next.unwrap();\n    let mut dot_pos_next =\
    \ dot_pos_next.unwrap();\n    let mut dot_pos_next = dot_pos_next.unwrap();\n\
    \    let mut dot_pos_next = dot_pos_next.unwrap();\n    let mut dot_pos_next =\
    \ dot_pos_next.unwrap();\n    let mut dot_pos_next = dot_pos_next.unwrap();\n\
    \    let mut dot_pos_next = dot_pos_next.unwrap();\n    let mut dot_pos_next =\
    \ dot_pos_next.unwrap();\n    let mut dot_pos_next = dot_pos_next.unwrap();\n\
    \    let mut dot_pos_next = dot_pos_next.unwrap();\n    let mut dot_pos_next =\
    \ dot_pos_next.unwrap();\n    let mut dot_pos_next = dot_pos_next.unwrap();\n\
    \    let mut dot_pos_next = dot_pos_next.unwrap();\n    let mut dot_pos_next =\
    \ dot_pos_next.unwrap();\n    let mut dot_pos_next = dot_pos_next.unwrap();\n\
    \    let mut dot_pos_next = dot_pos_next.unwrap();\n    let mut dot_pos_next =\
    \ dot_pos_next.unwrap();\n    let mut dot_pos_next = dot_pos_next.unwrap();\n\
    \    let mut dot_pos_next = dot_pos_next.unwrap();\n    let mut dot_pos_next =\
    \ dot_pos_next.unwrap();\n    let mut dot_pos_next = dot_pos_next.unwrap();\n\
    \    let mut dot_pos_next = \n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpgaqc4u3s.rs:57:1\n\
    \   |\n57 | }\n   | ^ expected expression\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpgaqc4u3s.rs:15:55\n\
    \   |\n15 |     let mut dot_pos = file_name_chars.next().unwrap().unwrap();\n\
    \   |                                                       ^^^^^^ method not\
    \ found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter =\
    \ dot_pos_start;\n    while dot_pos_start < dot_pos_end {\n        let mut dot_pos_start_letter\
    \ = dot_pos_start;\n        if file_name[dot_pos_start_letter] >= 'a' && file_name[dot_pos_start_letter]\
    \ <= 'z' {\n            dot_pos_start_letter += 1;\n        }\n        if file_name[dot_pos_start_letter]\
    \ >= 'A' && file_name[dot_pos_start_letter] <= 'Z' {\n            dot_pos_start_letter\
    \ += 1;\n        }\n        if dot_pos_start_letter > dot_pos_end {\n        \
    \    return String::from(\"No\");\n        }\n    }\n    if dot_pos_start == dot_pos_end\
    \ {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos_start]\
    \ == '.' {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos_start]\
    \ != '0' && file_name[dot_pos_start] != '1' {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos_start] == '0' {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos_start] == '1' {\n        return String::from(\"\
    Yes\");\n    }\n    return String::from(\"No\");\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp_blhgvgh.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmp_blhgvgh.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n  --> /tmp/tmp_blhgvgh.rs:19:35\n   |\n19 |\
    \     let mut dot_pos_end = dot_pos + 1;\n   |                           -------\
    \ ^ - {integer}\n   |                           |\n   |                      \
    \     Option<usize>\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmp_blhgvgh.rs:20:37\n   |\n20 |     let mut dot_pos_start = dot_pos\
    \ + 1;\n   |                             ------- ^ - {integer}\n   |         \
    \                    |\n   |                             Option<usize>\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    \n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    \n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_4\
    \ = file_name.find('.')\n    if dot_pos_4 == String::npos {\n        return String::from(\"\
    No\");\n    }\n    \n    let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5\
    \ == String::npos {\n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_pos_6 = file_name.find('.')\n    if dot_pos_6 == String::npos {\n  \
    \      return String::from(\"No\");\n    }\n    \n    let mut dot_pos_7 = file_name.find('.')\n\
    \    if dot_pos_7 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    \n    let mut dot_pos_8 = file_name.find('.')\n    if dot_pos_8 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_9\
    \ = file_name.find('.')\n    if dot_pos_9 == String::npos {\n        return String::from(\"\
    No\");\n    }\n    \n    let mut dot_pos_10 = file_name.find('.')\n    if dot_pos_10\
    \ == String::npos {\n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos {\n\
    \        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    \n    let mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 ==\
    \ String::npos {\n        return String::from(\"No\");\n    }\n    \n    let mut\
    \ dot_pos_14 = file_name.find('.')\n    if dot_pos_14 == String::npos {\n    \
    \    return String::from(\"No\");\n    }\n    \n    let mut dot_pos_15 = file_name.find('.')\n\
    \    if dot_pos_15 == String::npos {\n        return String::from(\"\n}\n\nfn\
    \ main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmp2z7jueph.rs:93:40\n\
    \   |\n93 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n   --> /tmp/tmp2z7jueph.rs:106:56\n    |\n106\
    \ |     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n    |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmp2z7jueph.rs:117:63\n\
    \    |\n117 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    118 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\n  \
    \      return String::from(\"No\");\n    }\n    if dot_index == 0 {\n        return\
    \ String::from(\"No\");\n    }\n    if dot_index > 0 {\n        let mut first_letter\
    \ = file_name[dot_index - 1 as usize].to_string();\n        if first_letter !=\
    \ \"a\" && first_letter != \"A\" && first_letter != \"b\" && first_letter != \"\
    B\" && first_letter != \"c\" && first_letter != \"C\" && first_letter != \"d\"\
    \ && first_letter != \"D\" && first_letter != \"e\" && first_letter != \"E\" &&\
    \ first_letter != \"f\" && first_letter != \"F\" && first_letter != \"g\" && first_letter\
    \ != \"G\" && first_letter != \"h\" && first_letter != \"H\" && first_letter !=\
    \ \"i\" && first_letter != \"I\" && first_letter != \"j\" && first_letter != \"\
    J\" && first_letter != \"k\" && first_letter != \"K\" && first_letter != \"l\"\
    \ && first_letter != \"L\" && first_letter != \"m\" && first_letter != \"M\" &&\
    \ first_letter != \"n\" && first_letter != \"N\" && first_letter != \"o\" && first_letter\
    \ != \"O\" && first_letter != \"p\" && first_letter != \"P\" && first_letter !=\
    \ \"q\" && first_letter != \"Q\" && first_letter != \"r\" && first_letter != \"\
    R\" && first_letter != \"s\" && first_letter != \"S\" && first_letter != \"t\"\
    \ && first_letter != \"T\" && first_letter != \"u\" && first_letter != \"U\" &&\
    \ first_letter != \"v\" && first_letter != \"V\" && first_letter != \"w\" && first_letter\
    \ != \"W\" && first_letter != \"x\" && first_letter != \"X\" && first_letter !=\
    \ \"y\" && first_letter != \"Y\" && first_letter != \"z\" && first_letter != \"\
    Z\" {\n            return String::from(\"No\");\n        }\n    }\n    return\
    \ String::from(\"Yes\");\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpwj5j5j7y.rs:15:44\n\
    \   |\n15 |     let mut dot_index = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n16 |     if dot_index == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpwj5j5j7y.rs:16:29\n\
    \   |\n16 |     if dot_index == String::npos {\n   |                         \
    \    ^^^^ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwj5j5j7y.rs:19:21\n   |\n19 |     if dot_index == 0 {\n\
    \   |                     ^ expected enum `Option`, found integer\n   |\n   =\
    \ note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n19 |     if dot_index == Some(0)\
    \ {\n   |                     +++++ +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwj5j5j7y.rs:22:20\n   |\n22 |     if dot_index > 0 {\n   |         \
    \           ^ expected enum `Option`, found integer\n   |\n   = note: expected\
    \ enum `Option<usize>`\n              found type `{integer}`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n22 |     if dot_index > Some(0) {\n   |    \
    \                +++++ +\n\nerror[E0369]: cannot subtract `usize` from `Option<usize>`\n\
    \  --> /tmp/tmpwj5j5j7y.rs:23:52\n   |\n23 |         let mut first_letter = file_name[dot_index\
    \ - 1 as usize].to_string();\n   |                                          ---------\
    \ ^ ---------- usize\n   |                                          |\n   |  \
    \                                        Option<usize>\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0369,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return \"No\";\n    }\n    let mut dot_pos_end = dot_pos + 1;\n    let mut\
    \ dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter = true;\n   \
    \ let mut dot_pos_end_letter = true;\n    while dot_pos_start < dot_pos_end {\n\
    \        let mut dot_pos_start_letter = dot_pos_start.is_ascii_letter();\n   \
    \     let mut dot_pos_end_letter = dot_pos_end.is_ascii_letter();\n        if\
    \ dot_pos_start_letter && dot_pos_end_letter {\n            if dot_pos_start ==\
    \ dot_pos_end {\n                return \"No\";\n            }\n            if\
    \ dot_pos_start == dot_pos_start + 1 {\n                return \"No\";\n     \
    \       }\n            if dot_pos_start == dot_pos_end - 1 {\n               \
    \ return \"No\";\n            }\n            if dot_pos_start == dot_pos_start\
    \ + 2 {\n                return \"No\";\n            }\n            if dot_pos_start\
    \ == dot_pos_end - 2 {\n                return \"No\";\n            }\n      \
    \      if dot_pos_start == dot_pos_start + 3 {\n                return \"No\"\
    ;\n            }\n            if dot_pos_start == dot_pos_end - 3 {\n        \
    \        return \"No\";\n            }\n            if dot_pos_start == dot_pos_start\
    \ + 4 {\n                return \"No\";\n            }\n            if dot_pos_start\
    \ == dot_pos_end - 4 {\n                return \"No\";\n            }\n      \
    \      if dot_pos_start == dot_pos_start + 5 {\n                return \"No\"\
    ;\n            }\n            if dot_pos_start == dot_pos_end - 5 {\n        \
    \        return \"No\";\n            }\n            if dot_pos_start == dot_pos_start\
    \ + 6 {\n                return \"No\";\n            }\n            if dot_pos_start\
    \ == dot_pos_end - 6 {\n                return \"No\";\n            }\n      \
    \      if dot_pos_start == dot_pos_start + 7 {\n                return \"No\"\
    ;\n            }\n            if dot_pos_start == dot_pos_end - 7 {\n        \
    \        return \"No\";\n            }\n            if dot_pos_start == dot_pos_start\
    \ + 8 {\n                return \"No\";\n            }\n            if dot_pos_start\
    \ == dot_pos_end - 8 {\n                return \"No\";\n            }\n      \
    \      if dot_pos_start == dot_pos_start + 9 {\n                return \"No\"\
    ;\n            }\n            if dot_pos_start == dot_pos_end - 9 {\n        \
    \        return \"No\";\n            }\n            if dot_pos_start == dot_pos_start\
    \ + 10 {\n                return \"No\";\n            }\n            if dot_pos_start\
    \ == dot_pos_end - 10 {\n                return \"No\";\n            }\n     \
    \       if dot_pos_start == dot_pos_start + 11 {\n                return \"No\"\
    ;\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9_t9kdeh.rs:122:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n23  |  \
    \   while dot_pos_start < dot_pos_end {\n    |                               \
    \        - unclosed delimiter\n...\n26  |         if dot_pos_start_letter && dot_pos_end_letter\
    \ {\n    |                                                       - unclosed delimiter\n\
    ...\n90  |             if dot_pos_start == dot_pos_start + 11 {\n    |       \
    \                                             - this delimiter might not be properly\
    \ closed...\n91  |                 return \"No\";\n92  | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n122 | }\n    |   ^\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp9_t9kdeh.rs:15:42\n   |\n15 |     let\
    \ mut dot_pos = file_name.find('.')\n   |                                    \
    \      ^ help: add `;` here\n16 |     if dot_pos == String::npos {\n   |     --\
    \ unexpected token\n\nerror[E0599]: no function or associated item named `npos`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp9_t9kdeh.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9_t9kdeh.rs:17:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n17 |         return \"No\";\n   |    \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \               |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp9_t9kdeh.rs:19:35\n\
    \   |\n19 |     let mut dot_pos_end = dot_pos + 1;\n   |                     \
    \      ------- ^ - {integer}\n   |                           |\n   |         \
    \                  Option<usize>\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/t"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut counter = 0;\n    let mut is_valid = true;\n\
    \    let mut first_letter: char;\n    let mut dot_index: usize;\n    let mut dot_count:\
    \ usize;\n    let mut dot_after_dot: String;\n    for c in file_name.chars() {\n\
    \        if counter > 3 {\n            is_valid = false;\n            break;\n\
    \        }\n        if c < 'a' || c > 'z' {\n            is_valid = false;\n \
    \           break;\n        }\n        if c != first_letter {\n            is_valid\
    \ = false;\n            break;\n        }\n        counter += 1;\n    }\n    if\
    \ !is_valid {\n        return \"No\";\n    }\n    dot_index = file_name.find('.')\n\
    \    if dot_index == -1 {\n        return \"No\";\n    }\n    dot_count = file_name.len();\n\
    \    dot_after_dot = file_name[dot_index..];\n    if dot_count != 3 {\n      \
    \  return \"No\";\n    }\n    if dot_after_dot != \"txt\" && dot_after_dot !=\
    \ \"exe\" && dot_after_dot != \"dll\" {\n        return \"No\";\n    }\n    return\
    \ \"Yes\";\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmprken8ht_.rs:38:36\n\
    \   |\n38 |     dot_index = file_name.find('.')\n   |                        \
    \            ^ help: add `;` here\n39 |     if dot_index == -1 {\n   |     --\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprken8ht_.rs:36:16\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n36 |         return \"No\";\n   |                ^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                |\n   |             \
    \   expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprken8ht_.rs:38:17\n   |\n17 |     let mut dot_index: usize;\n \
    \  |                        ----- expected due to this type\n...\n38 |     dot_index\
    \ = file_name.find('.')\n   |                 ^^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found enum `Option`\n   |\n   = note: expected type `usize`\n              found\
    \ enum `Option<usize>`\n\nerror[E0600]: cannot apply unary operator `-` to type\
    \ `usize`\n  --> /tmp/tmprken8ht_.rs:39:21\n   |\n39 |     if dot_index == -1\
    \ {\n   |                     ^^\n   |                     |\n   |           \
    \          cannot apply unary operator `-`\n   |                     help: you\
    \ may have meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note:\
    \ unsigned values cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprken8ht_.rs:43:21\n\
    \   |\n19 |     let mut dot_after_dot: String;\n   |                         \
    \   ------ expected due to this type\n...\n43 |     dot_after_dot = file_name[dot_index..];\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                     |\n   |                   \
    \  expected struct `String`, found `str`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0600.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\n  \
    \      return String::from(\"No\");\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ {\n        return String\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpbox63ncz.rs:112:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n80  |  \
    \   if dot_index == String::npos {\n    |                                  - this\
    \ delimiter might not be properly closed...\n81  |         return String\n82 \
    \ | }\n    | - ...as it matches this but it has different indentation\n...\n112\
    \ | }\n    |   ^\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpbox63ncz.rs:15:44\n\
    \   |\n15 |     let mut dot_index = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n16 |     if dot_index == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpbox63ncz.rs:19:44\n   |\n19 |     let mut dot_index = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n20 |  \
    \   if dot_index == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpbox63ncz.rs:23:44\n   |\n23 |     let\
    \ mut dot_index = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n24 |     if dot_index == String::npos {\n   |\
    \     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpbox63ncz.rs:27:44\n\
    \   |\n27 |     let mut dot_index = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n28 |     if dot_index == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpbox63ncz.rs:31:44\n   |\n31 |     let mut dot_index = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n32 |  \
    \   if dot_index == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpbox63ncz.rs:35:44\n   |\n35 |     let\
    \ mut dot_index = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n36 |     if dot_index == String::npos {\n   |\
    \     -- une"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name.len() < 3 {\n       \
    \ return String::from(\"No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter())\
    \ {\n        return String::from(\"No\");\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_lowercase()) {\n        return String::from(\"No\");\n    }\n  \
    \  if file_name.chars().any(|c| !c.is_ascii_uppercase()) {\n        return String::from(\"\
    No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_punctuation()) {\n\
    \        return String::from(\"No\");\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_digit()) {\n        return String::from(\"No\");\n    }\n    if\
    \ file_name.chars().any(|c| !c.is_ascii_symbol()) {\n        return String::from(\"\
    No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_whitespace()) {\n\
    \        return String::from(\"No\");\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_control()) {\n        return String::from(\"No\");\n    }\n    if\
    \ file_name.chars().any(|c| !c.is_ascii_graph()) {\n        return String::from(\"\
    No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_newline()) {\n   \
    \     return String::from(\"No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_horizontal_tab())\
    \ {\n        return String::from(\"No\");\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_vertical_tab()) {\n        return String::from(\"No\");\n    }\n\
    \    if file_name.chars().any(|c| !c.is_ascii_tab()) {\n        return String::from(\"\
    No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_formfeed()) {\n  \
    \      return String::from(\"No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_return())\
    \ {\n        return String::from(\"No\");\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_newline()) {\n        return String::from(\"No\");\n    }\n    if\
    \ file_name.chars().any(|c| !c.is_ascii_horizontal_tab()) {\n        return String::from(\"\
    No\");\n    }\n    if file_name.chars().any(|\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpj4qdqudn.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `|`, found `)`\n  --> /tmp/tmpj4qdqudn.rs:74:1\n\
    \   |\n73 |     if file_name.chars().any(|\n   |                             \
    \  - expected `|`\n74 | }\n   | ^ unexpected token\n\nerror: mismatched closing\
    \ delimiter: `}`\n  --> /tmp/tmpj4qdqudn.rs:73:29\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                                 -\
    \ closing delimiter possibly meant for this\n...\n73 |     if file_name.chars().any(|\n\
    \   |                             ^ unclosed delimiter\n74 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0599]: no function or associated item named `npos`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpj4qdqudn.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0599]: no method\
    \ named `is_ascii_letter` found for type `char` in the current scope\n  --> /tmp/tmpj4qdqudn.rs:22:37\n\
    \   |\n22 |     if file_name.chars().any(|c| !c.is_ascii_letter()) {\n   |   \
    \                                  ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_symbol`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpj4qdqudn.rs:37:37\n\
    \   |\n37 |     if file_name.chars().any(|c| !c.is_ascii_symbol()) {\n   |   \
    \                                  ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_graph`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpj4qdqudn.rs:46:37\n\
    \   |\n46 |     if file_name.chars().any(|c| !c.is_ascii_graph()) {\n   |    \
    \                                 ^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0599]: no m"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut counter = 0;\n    let mut is_valid = false;\n\
    \    for c in file_name.chars() {\n        if c < '0' || c > '9' {\n         \
    \   counter = counter + 1;\n        } else {\n            counter = 0;\n     \
    \   }\n        if counter > 3 {\n            is_valid = false;\n            break;\n\
    \        }\n        if c != '.' {\n            is_valid = false;\n           \
    \ break;\n        }\n        if file_name.chars().nth(1).unwrap() != c {\n   \
    \         is_valid = false;\n            break;\n        }\n        if file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'a' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'b' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'c' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'd' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'e' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'f' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'g' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'h' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'i' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'j' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'k' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'l' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'm' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'n' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'o' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'p' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'q' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'r' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 's' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 't' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'u' &&\n            file_name.chars().nth(1).unwrap().to_ascii_lowercase()\
    \ != 'v' &&\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmph9y60rd9.rs:86:3\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n16 |     for\
    \ c in file_name.chars() {\n   |                                - this delimiter\
    \ might not be properly closed...\n...\n56 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n86 | }\n   |   ^\n\nerror: expected expression,\
    \ found `}`\n  --> /tmp/tmph9y60rd9.rs:56:1\n   |\n56 | }\n   | ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph9y60rd9.rs:13:42\n   |\n13 |\
    \ fn file_name_check(file_name: String) -> String {\n   |    --------------- \
    \                      ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name : String = \"\";\n    let mut dot_count\
    \ : usize = 0;\n    let mut first_letter : char;\n    let mut dot_letter : char;\n\
    \    let mut dot_dot_letter : char;\n    let mut dot_dot_dot_letter : char;\n\
    \    let mut dot_dot_dot_dot_letter : char;\n    let mut dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_letter : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_letter : char;\n    let\
    \ mut dot_dot_dot_dot_dot_dot_dot_dot_dot_letter : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter : char;\n\
    \    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter : char;\n    let\
    \ mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter : char;\n    let\
    \ mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter : char;\n   \
    \ let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter : char;\n\
    \    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpikbbuevk.rs:41:77\n   |\n\
    41 |     let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_\n\
    \   |                                                                        \
    \     ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpikbbuevk.rs:14:34\n   |\n14 |     let mut file_name : String\
    \ = \"\";\n   |                         ------   ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                         |        |\n   |      \
    \                   |        expected struct `String`, found `&str`\n   |    \
    \                     expected due to this\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpikbbuevk.rs:13:42\n   |\n13 | fn file_name_check(file_name: String)\
    \ -> String {\n   |    ---------------                       ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos = dot_pos + 1;\n \
    \   let mut dot_pos_2 = file_name.find('.')\n    while dot_pos_2 != String::npos\
    \ {\n        if dot_pos_2 > dot_pos {\n            return String::from(\"No\"\
    );\n        }\n        if file_name[dot_pos_2] != 'a' && file_name[dot_pos_2]\
    \ != 'A' && file_name[dot_pos_2] != 'b' && file_name[dot_pos_2] != 'B' && file_name[dot_pos_2]\
    \ != 'c' && file_name[dot_pos_2] != 'C' && file_name[dot_pos_2] != 'd' && file_name[dot_pos_2]\
    \ != 'D' && file_name[dot_pos_2] != 'e' && file_name[dot_pos_2] != 'E' && file_name[dot_pos_2]\
    \ != 'f' && file_name[dot_pos_2] != 'F' && file_name[dot_pos_2] != 'g' && file_name[dot_pos_2]\
    \ != 'G' && file_name[dot_pos_2] != 'h' && file_name[dot_pos_2] != 'H' && file_name[dot_pos_2]\
    \ != 'i' && file_name[dot_pos_2] != 'I' && file_name[dot_pos_2] != 'j' && file_name[dot_pos_2]\
    \ != 'J' && file_name[dot_pos_2] != 'k' && file_name[dot_pos_2] != 'K' && file_name[dot_pos_2]\
    \ != 'l' && file_name[dot_pos_2] != 'L' && file_name[dot_pos_2] != 'm' && file_name[dot_pos_2]\
    \ != 'M' && file_name[dot_pos_2] != 'n' && file_name[dot_pos_2] != 'N' && file_name[dot_pos_2]\
    \ != 'o' && file_name[dot_pos_2] != 'O' && file_name[dot_pos_2] != 'p' && file_name[dot_pos_2]\
    \ != 'P' && file_name[dot_pos_2] != 'q' && file_name[dot_pos_2] != 'Q' && file_name[dot_pos_2]\
    \ != 'r' && file_name[dot_pos_2] != 'R' && file_name[dot_pos_2] != 's' && file_name[dot_pos_2]\
    \ != 'S' && file_name[dot_pos_2] != 't' && file_name[dot_pos_2] != 'T' && file_name[dot_pos_2]\
    \ != 'u' && file_name[dot_pos_2] != 'U' && file_name[dot_pos_2] != 'v' && file_name[dot_pos_2]\
    \ != 'V' && file_name[dot_pos_2] != 'w' && file_name[dot_pos_2] != 'W' && file_name[dot_pos_2]\
    \ != 'x' && file_name[dot_pos_2] != 'X' && file_name[dot_pos_2] != 'y' && file_name[dot_pos_2]\
    \ != 'Y' && file_name[dot_pos_2] != 'z' && file_name[dot_pos_2] != 'Z' {\n   \
    \         return String::\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpqfag561j.rs:57:3\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n21 |     while\
    \ dot_pos_2 != String::npos {\n   |                                     - unclosed\
    \ delimiter\n...\n25 |         if file_name[dot_pos_2] != 'a' && file_name[dot_pos_2]\
    \ != 'A' && file_name[dot_pos_2] != 'b' && file_name[dot_pos_2] != 'B' && file_name[dot_pos_2]\
    \ != 'c' && file_name[dot_pos_2] != 'C' && file_name[dot_pos_2] != 'd' && file_name[dot_pos_2]\
    \ != 'D' && file_name[dot_pos_2] != 'e' && file_name[dot_pos_2] != 'E' && file_name[dot_pos_2]\
    \ != 'f' && file_name[dot_pos_2] != 'F' && file_name[dot_pos_2] != 'g' && file_name[dot_pos_2]\
    \ != 'G' && file_name[dot_pos_2] != 'h' && file_name[dot_pos_2] != 'H' && file_name[dot_pos_2]\
    \ != 'i' && file_name[dot_pos_2] != 'I' && file_name[dot_pos_2] != 'j' && file_name[dot_pos_2]\
    \ != 'J' && file_name[dot_pos_2] != 'k' && file_name[dot_pos_2] != 'K' && file_name[dot_pos_2]\
    \ != 'l' && file_name[dot_pos_2] != 'L' && file_name[dot_pos_2] != 'm' && file_name[dot_pos_2]\
    \ != 'M' && file_name[dot_pos_2] != 'n' && file_name[dot_pos_2] != 'N' && file_name[dot_pos_2]\
    \ != 'o' && file_name[dot_pos_2] != 'O' && file_name[dot_pos_2] != 'p' && file_name[dot_pos_2]\
    \ != 'P' && file_name[dot_pos_2] != 'q' && file_name[dot_pos_2] != 'Q' && file_name[dot_pos_2]\
    \ != 'r' && file_name[dot_pos_2] != 'R' && file_name[dot_pos_2] != 's' && file_name[dot_pos_2]\
    \ != 'S' && file_name[dot_pos_2] != 't' && file_name[dot_pos_2] != 'T' && file_name[dot_pos_2]\
    \ != 'u' && file_name[dot_pos_2] != 'U' && file_name[dot_pos_2] != 'v' && file_name[dot_pos_2]\
    \ != 'V' && file_name[dot_pos_2] != 'w' && file_name[dot_pos_2] != 'W' && file_name[dot_pos_2]\
    \ != 'x' && file_name[dot_pos_2] != 'X' && file_name[dot_pos_2] != 'y' && file_name[dot_pos_2]\
    \ != 'Y' && file_name[dot_pos_2] != 'z' && file_name[dot_pos_2] != 'Z' {\n   |\
    \                                                                            \
    \               "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos { \n \
    \       return \"No\"\n    }\n    if file_name[dot_index - 1] != '.' {\n     \
    \   return \"No\"\n    }\n    let mut first_letter = file_name[dot_index - 2];\n\
    \    if first_letter != 'a' && first_letter != 'A' {\n        return \"No\"\n\
    \    }\n    if file_name[dot_index - 3] != '.' {\n        return \"No\"\n    }\n\
    \    if file_name[dot_index - 4] != 'txt' && file_name[dot_index - 4] != 'exe'\
    \ && file_name[dot_index - 4] != 'dll' {\n        return \"No\"\n    }\n    return\
    \ \"Yes\"\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpzlvgfetu.rs:29:36\n\
    \   |\n29 |     if file_name[dot_index - 4] != 'txt' && file_name[dot_index -\
    \ 4] != 'exe' && file_name[dot_index - 4] != 'dll' {\n   |                   \
    \                 ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use\
    \ double quotes\n   |\n29 |     if file_name[dot_index - 4] != \"txt\" && file_name[dot_index\
    \ - 4] != 'exe' && file_name[dot_index - 4] != 'dll' {\n   |                 \
    \                   ~~~~~\n\nerror: character literal may only contain one codepoint\n\
    \  --> /tmp/tmpzlvgfetu.rs:29:73\n   |\n29 |     if file_name[dot_index - 4] !=\
    \ 'txt' && file_name[dot_index - 4] != 'exe' && file_name[dot_index - 4] != 'dll'\
    \ {\n   |                                                                    \
    \     ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n29 |     if file_name[dot_index - 4] != 'txt' && file_name[dot_index -\
    \ 4] != \"exe\" && file_name[dot_index - 4] != 'dll' {\n   |                 \
    \                                                        ~~~~~\n\nerror: character\
    \ literal may only contain one codepoint\n  --> /tmp/tmpzlvgfetu.rs:29:110\n \
    \  |\n29 |     if file_name[dot_index - 4] != 'txt' && file_name[dot_index - 4]\
    \ != 'exe' && file_name[dot_index - 4] != 'dll' {\n   |                      \
    \                                                                            \
    \            ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n29 |     if file_name[dot_index - 4] != 'txt' && file_name[dot_index\
    \ - 4] != 'exe' && file_name[dot_index - 4] != \"dll\" {\n   |               \
    \                                                                            \
    \                   ~~~~~\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpzlvgfetu.rs:15:44\n\
    \   |\n15 |     let mut dot_index = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n16 |     if dot_index == String::npos\
    \ { \n   |     -- unexpected token\n\nerror[E0599]: no function or associated\
    \ item named"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.len() > 3 {\n        return \"No\";\n\
    \    }\n    if file_name.len() == 0 {\n        return \"No\";\n    }\n    if file_name.len()\
    \ == 1 {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_lowercase())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_uppercase())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_digit())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c.is_ascii_lowercase() || c.is_ascii_uppercase() || c.is_ascii_digit()) {\n\
    \        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c.is_ascii_lowercase() || c.is_ascii_uppercase() || c.is_ascii_digit() ||\
    \ c == '.') {\n        return \"No\";\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_lowercase() || c.is_ascii_uppercase() ||\
    \ c.is_ascii_digit() || c == '.' || c == '_') {\n        return \"No\";\n    }\n\
    \    if file_name.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_lowercase()\
    \ || c.is_ascii_uppercase() || c.is_ascii_digit() || c == '.' || c == '_' || c\
    \ == '-') {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c.is_ascii_lowercase() || c.is_ascii_uppercase() || c.is_ascii_digit() ||\
    \ c == '.' || c == '_' || c == '-' || c == '.' || c == '-') {\n        return\
    \ \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_lowercase()\
    \ || c.is_ascii_uppercase() || c.is_ascii_digit() || c == '.' || c == '_' || c\
    \ == '-' || c == '.' || c == '-' || c == '-') {\n        return \"No\";\n    }\n\
    \    if file_name.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_lowercase()\
    \ || c.is_ascii_uppercase() || c.is_ascii_digit() || c == '.' || c == '_' || c\
    \ == '-' || c == '.' || c == '-' || c == '-' || c == '-') {\n        return \"\
    No\";\n    }\n    if file_name.\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp9uzyhlen.rs:57:1\n   |\n57\
    \ | }\n   | ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp9uzyhlen.rs:57:1\n\
    \   |\n56 |     if file_name.\n   |     -- this `if` expression has a condition,\
    \ but no block\n57 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9uzyhlen.rs:15:16\n   |\n13 | fn file_name_check(file_name: String)\
    \ -> String {\n   |                                          ------ expected `String`\
    \ because of return type\n14 |     if file_name.len() > 3 {\n15 |         return\
    \ \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0599]: no method named `is_ascii_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp9uzyhlen.rs:23:37\n   |\n23 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n   |                                     ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmp9uzyhlen.rs:35:37\n   |\n35 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_lowercase() || c.is_ascii_uppercase() ||\
    \ c.is_ascii_digit()) {\n   |                                     ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmp9uzyhlen.rs:38:37\n   |\n38 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_lowercase() || c.is_ascii_uppercase() ||\
    \ c.is_ascii_digit() || c == '...\n   |                                     ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmp9uzyhlen.rs:41:37\n   |\n41 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_lowercase() || c.is_ascii_uppercase()"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_4 = file_name.find('.')\n\
    \    if dot_pos_4 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_6 = file_name.find('.')\n\
    \    if dot_pos_6 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_7 = file_name.find('.')\n    if dot_pos_7 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_8 = file_name.find('.')\n\
    \    if dot_pos_8 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_14 = file_name.find('.')\n\
    \    if dot_pos_14 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_16 = file_name.find('.')\n\
    \    if dot_pos_16 == String::npos {\n\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp69c7qkt6.rs:108:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n76  |  \
    \   if dot_pos_16 == String::npos {\n    |                                   -\
    \ this delimiter might not be properly closed...\n77  | \n78  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n108 | }\n    |   ^\n\n\
    error: expected `;`, found keyword `if`\n  --> /tmp/tmp69c7qkt6.rs:15:42\n   |\n\
    15 |     let mut dot_pos = file_name.find('.')\n   |                         \
    \                 ^ help: add `;` here\n16 |     if dot_pos == String::npos {\n\
    \   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmp69c7qkt6.rs:19:44\n   |\n19 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n20 |  \
    \   if dot_pos_2 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp69c7qkt6.rs:23:44\n   |\n23 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n24 |     if dot_pos_3 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp69c7qkt6.rs:27:44\n\
    \   |\n27 |     let mut dot_pos_4 = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n28 |     if dot_pos_4 == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmp69c7qkt6.rs:31:44\n   |\n31 |     let mut dot_pos_5 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n32 |  \
    \   if dot_pos_5 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp69c7qkt6.rs:35:44\n   |\n35 |     let\
    \ mut dot_pos_6 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n36 |     if dot_pos_6 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: exp"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name.len() > 3 {\n       \
    \ return String::from(\"No\");\n    }\n    if file_name.len() == 3 {\n       \
    \ if file_name[0] < 'a' || file_name[0] > 'z' {\n            return String::from(\"\
    No\");\n        }\n    }\n    if file_name[dot_pos - 1] != '.' {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name[dot_pos - 1] != '.' && file_name[dot_pos\
    \ - 1] != 'txt' && file_name[dot_pos - 1] != 'exe' && file_name[dot_pos - 1] !=\
    \ 'dll' {\n        return String::from(\"No\");\n    }\n    return String::from(\"\
    Yes\");\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpjtzmsl8d.rs:30:67\n\
    \   |\n30 |     if file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] !=\
    \ 'txt' && file_name[dot_pos - 1] != 'exe' && file_name[dot_pos - 1] != '...\n\
    \   |                                                                   ^^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    30 |     if file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] != \"txt\"\
    \ && file_name[dot_pos - 1] != 'exe' && file_name[dot_pos - 1] != 'dll' {\n  \
    \ |                                                                   ~~~~~\n\n\
    error: character literal may only contain one codepoint\n  --> /tmp/tmpjtzmsl8d.rs:30:102\n\
    \   |\n30 |     if file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] !=\
    \ 'txt' && file_name[dot_pos - 1] != 'exe' && file_name[dot_pos - 1] != '...\n\
    \   |                                                                        \
    \                              ^^^^^\n   |\nhelp: if you meant to write a `str`\
    \ literal, use double quotes\n   |\n30 |     if file_name[dot_pos - 1] != '.'\
    \ && file_name[dot_pos - 1] != 'txt' && file_name[dot_pos - 1] != \"exe\" && file_name[dot_pos\
    \ - 1] != 'dll' {\n   |                                                      \
    \                                                ~~~~~\n\nerror: character literal\
    \ may only contain one codepoint\n  --> /tmp/tmpjtzmsl8d.rs:30:137\n   |\n30 |\
    \ ...&& file_name[dot_pos - 1] != 'exe' && file_name[dot_pos - 1] != 'dll' {\n\
    \   |                                                                    ^^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    30 |     if file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] != 'txt' &&\
    \ file_name[dot_pos - 1] != 'exe' && file_name[dot_pos - 1] != \"dll\" {\n   |\
    \                                                                            \
    \                                                             ~~~~~\n\nerror:\
    \ expected `;`, found keyword `if`\n  --> /tmp/tmpjtzmsl8d.rs:15:42\n   |\n15\
    \ |     let mut dot_pos = file_name.find('.')"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos;\n \
    \   dot_pos_end += 1;\n    while dot_pos_end < file_name.len() {\n        let\
    \ mut dot_pos_start = dot_pos;\n        dot_pos_start += 1;\n        if file_name[dot_pos_start]\
    \ >= 'a' && file_name[dot_pos_start] <= 'z' {\n            dot_pos_start += 1;\n\
    \        }\n        if file_name[dot_pos_start] >= 'A' && file_name[dot_pos_start]\
    \ <= 'Z' {\n            dot_pos_start += 1;\n        }\n        if file_name[dot_pos_start]\
    \ == '.' {\n            break;\n        }\n    }\n    if dot_pos_start == dot_pos\
    \ {\n        return String::from(\"No\");\n    }\n    if dot_pos_start == dot_pos_end\
    \ {\n        return String::from(\"Yes\");\n    }\n    if dot_pos_start < dot_pos_end\
    \ {\n        return String::from(\"Yes\");\n    }\n    return String::from(\"\
    No\");\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpfiupdaz3.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0425]: cannot find value `dot_pos_start`\
    \ in this scope\n  --> /tmp/tmpfiupdaz3.rs:34:8\n   |\n34 |     if dot_pos_start\
    \ == dot_pos {\n   |        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `dot_pos_start` in this scope\n  --> /tmp/tmpfiupdaz3.rs:37:8\n\
    \   |\n37 |     if dot_pos_start == dot_pos_end {\n   |        ^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `dot_pos_start` in this\
    \ scope\n  --> /tmp/tmpfiupdaz3.rs:40:8\n   |\n40 |     if dot_pos_start < dot_pos_end\
    \ {\n   |        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no function\
    \ or associated item named `npos` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpfiupdaz3.rs:16:27\n   |\n16 |     if dot_pos == String::npos {\n\
    \   |                           ^^^^ function or associated item not found in\
    \ `String`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `Option<usize>`\n  --> /tmp/tmpfiupdaz3.rs:20:5\n   |\n20 |     dot_pos_end\
    \ += 1;\n   |     -----------^^^^^\n   |     |\n   |     cannot use `+=` on type\
    \ `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfiupdaz3.rs:21:25\n\
    \   |\n21 |     while dot_pos_end < file_name.len() {\n   |                  \
    \       ^^^^^^^^^^^^^^^ expected enum `Option`, found `usize`\n   |\n   = note:\
    \ expected enum `Option<usize>`\n              found type `usize`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n21 |     while dot_pos_end < Some(file_name.len())\
    \ {\n   |                         +++++               +\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `Option<usize>`\n  --> /tmp/tmpfiupdaz3.rs:23:9\n\
    \   |\n23 |         dot_pos_start += 1;\n   |         -------------^^^^^\n   |\
    \         |\n   |         cannot use `+=` on type `Option<usize>`\n\nerror[E0277]:\
    \ the type"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return \"No\";\n    }\n    let mut dot_pos_str = file_name.chars().take(dot_pos).collect::<Vec<_>>();\n\
    \    let mut dot_pos_str = dot_pos_str.iter().filter(|&x| x >= 'a' && x <= 'z').collect::<Vec<_>>();\n\
    \    let mut dot_pos_str = dot_pos_str.iter().filter(|&x| x >= 'A' && x <= 'Z').collect::<Vec<_>>();\n\
    \    if dot_pos_str.len() != 1 || dot_pos_str[0] != 'a' || dot_pos_str[0] != 'A'\
    \ {\n        return \"No\";\n    }\n    \n    let mut dot_pos_str = file_name.chars().take(dot_pos).collect::<Vec<_>>();\n\
    \    let mut dot_pos_str = dot_pos_str.iter().filter(|&x| x >= '0' && x <= '9').collect::<Vec<_>>();\n\
    \    if dot_pos_str.len() != 1 || dot_pos_str[0] != '0' || dot_pos_str[0] != '9'\
    \ {\n        return \"No\";\n    }\n    \n    if dot_pos_str[0] == dot_pos_str[1]\
    \ {\n        return \"No\";\n    }\n    \n    if dot_pos_str[0] < dot_pos_str[1]\
    \ {\n        return \"No\";\n    }\n    \n    if dot_pos_str[0] > dot_pos_str[1]\
    \ {\n        return \"Yes\";\n    }\n    \n    return \"Yes\";\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpw_y7ack6.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpw_y7ack6.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw_y7ack6.rs:17:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n17 |         return \"No\";\n   |    \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \               |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw_y7ack6.rs:19:50\n   |\n19 |\
    \     let mut dot_pos_str = file_name.chars().take(dot_pos).collect::<Vec<_>>();\n\
    \   |                                                  ^^^^^^^ expected `usize`,\
    \ found enum `Option`\n   |\n   = note: expected type `usize`\n              found\
    \ enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_y7ack6.rs:20:63\n\
    \   |\n20 |     let mut dot_pos_str = dot_pos_str.iter().filter(|&x| x >= 'a'\
    \ && x <= 'z').collect::<Vec<_>>();\n   |                                    \
    \                           ^^^\n   |                                        \
    \                       |\n   |                                              \
    \                 expected `&char`, found `char`\n   |                       \
    \                                        help: consider borrowing here: `&'a'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw_y7ack6.rs:20:75\n   |\n20 |\
    \     let mut dot_pos_str = dot_pos_str.iter().filter(|&x| x >= 'a' && x <= 'z').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \   ^^^\n   |      "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_pos_2 = file_name.find('.')\n    if\
    \ dot_pos_2 == String::npos { \n        return \"No\";\n    }\n    let mut dot_pos_3\
    \ = file_name.find('.')\n    if dot_pos_3 == String::npos { \n        return \"\
    No\";\n    }\n    if dot_pos_2 > dot_pos_3 {\n        return \"No\";\n    }\n\
    \    if dot_pos > dot_pos_2 {\n        return \"No\";\n    }\n    if file_name[dot_pos\
    \ - 1] != String::from_char('0').unwrap() {\n        return \"No\";\n    }\n \
    \   if file_name[dot_pos - 2] != String::from_char('0').unwrap() {\n        return\
    \ \"No\";\n    }\n    if file_name[dot_pos - 3] != String::from_char('0').unwrap()\
    \ {\n        return \"No\";\n    }\n    if file_name[dot_pos_2 - 1] != String::from_char('0').unwrap()\
    \ {\n        return \"No\";\n    }\n    if file_name[dot_pos_2 - 2] != String::from_char('0').unwrap()\
    \ {\n        return \"No\";\n    }\n    if file_name[dot_pos_2 - 3] != String::from_char('0').unwrap()\
    \ {\n        return \"No\";\n    }\n    if file_name[dot_pos_3 - 1] != String::from_char('0').unwrap()\
    \ {\n        return \"No\";\n    }\n    if file_name[dot_pos_3] != String::from_char('0').unwrap()\
    \ {\n        return \"No\";\n    }\n    if file_name[dot_pos_3 + 1] != String::from_char('0').unwrap()\
    \ {\n        return \"No\";\n    }\n    if file_name[dot_pos_3 + 1] != String::from_char('0').unwrap()\
    \ {\n        return \"No\";\n    }\n    if file_name[dot_pos_3 + 1] != String::from_char('0').unwrap()\
    \ {\n        return \"No\";\n    }\n    if file_name[dot_pos_3 + 1] != String::from_char('0').unwrap()\
    \ {\n        return \"No\";\n    }\n    if file_name[dot_pos_3 + 1] != String::from_char('0').unwrap()\
    \ {\n        return \"No\";\n    }\n    if file_name[dot_pos_3 + 1] != String::from_char('0').unwrap()\
    \ {\n        return \"No\";\n    }\n    if file_name[dot_pos_3 + 1] != String::from_char('0').unwrap()\
    \ {\n        return \"No\";\n    }\n    if file_name[dot_pos_3 + 1] != String::from_char('0').unwrap()\
    \ {\n        return \"No\";\n    }\n    if file_name[dot_pos_3 + 1] != String::\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp5bdeao8u.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ { \n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmp5bdeao8u.rs:19:44\n   |\n19 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n20 |  \
    \   if dot_pos_2 == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp5bdeao8u.rs:23:44\n   |\n23 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n24 |     if dot_pos_3 == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected identifier, found `}`\n  --> /tmp/tmp5bdeao8u.rs:82:1\n\
    \   |\n82 | }\n   | ^ expected identifier\n\nerror[E0599]: no function or associated\
    \ item named `npos` found for struct `String` in the current scope\n  --> /tmp/tmp5bdeao8u.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos { \n   |                          \
    \ ^^^^ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5bdeao8u.rs:17:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n17 |         return \"No\";\n   |    \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \               |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0599]: no function or associated item named `npos` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp5bdeao8u.rs:20:29\n   |\n20 |     if dot_pos_2\
    \ == String::npos { \n   |                             ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0599]: no function or associated item named\
    \ `npos` found for struct `String` in the current scope\n  --> /tmp/tmp5bdeao8u.rs:24:29\n\
    \   |\n24 |     if dot_pos_3 == String::npos { \n   |             "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    \n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    \n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_4\
    \ = file_name.find('.')\n    if dot_pos_4 == String::npos {\n        return String::from(\"\
    No\");\n    }\n    \n    let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5\
    \ == String::npos {\n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_pos_6 = file_name.find('.')\n    if dot_pos_6 == String::npos {\n  \
    \      return String::from(\"No\");\n    }\n    \n    let mut dot_pos_7 = file_name.find('.')\n\
    \    if dot_pos_7 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    \n    let mut dot_pos_8 = file_name.find('.')\n    if dot_pos_8 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_9\
    \ = file_name.find('.')\n    if dot_pos_9 == String::npos {\n        return String::from(\"\
    No\");\n    }\n    \n    let mut dot_pos_10 = file_name.find('.')\n    if dot_pos_10\
    \ == String::npos {\n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos {\n\
    \        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    \n    let mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 ==\
    \ String::npos {\n        return String::from(\"No\");\n    }\n    \n    let mut\
    \ dot_pos_14 = file_name.find('.')\n    if dot_pos_14 == String::npos {\n    \
    \    return String::from(\"No\");\n    }\n    \n    let mut dot_pos_15 = file_name.find('.')\n\
    \    if dot_pos_15 == String::npos {\n        return String::from(\"\n}\n\nfn\
    \ main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmpjtli3fy_.rs:93:40\n\
    \   |\n93 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n   --> /tmp/tmpjtli3fy_.rs:106:56\n    |\n106\
    \ |     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n    |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmpjtli3fy_.rs:117:63\n\
    \    |\n117 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    118 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name.len() < 3 {\n       \
    \ return String::from(\"No\");\n    }\n    if file_name[dot_pos - 1] != String::from('0')\
    \ && file_name[dot_pos - 1] != String::from('9') {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos - 2] != String::from('0') && file_name[dot_pos\
    \ - 2] != String::from('9') {\n        return String::from(\"No\");\n    }\n \
    \   if file_name[dot_pos - 3] != String::from('0') && file_name[dot_pos - 3] !=\
    \ String::from('9') {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos\
    \ - 4] != String::from('0') && file_name[dot_pos - 4] != String::from('9') {\n\
    \        return String::from(\"No\");\n    }\n    if file_name[dot_pos - 5] !=\
    \ String::from('0') && file_name[dot_pos - 5] != String::from('9') {\n       \
    \ return String::from(\"No\");\n    }\n    if file_name[dot_pos - 6] != String::from('0')\
    \ && file_name[dot_pos - 6] != String::from('9') {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos - 7] != String::from('0') && file_name[dot_pos\
    \ - 7] != String::from('9') {\n        return String::from(\"No\");\n    }\n \
    \   if file_name[dot_pos - 8] != String::from('0') && file_name[dot_pos - 8] !=\
    \ String::from('9') {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos\
    \ - 9] != String::from('0') && file_name[dot_pos - 9] != String::from('9') {\n\
    \        return String::from(\"No\");\n    }\n    if file_name[dot_pos - 10] !=\
    \ String::from('0') && file_name[dot_pos - 10] != String::from('9') {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name[dot_pos - 11] != String::from('0')\
    \ && file_name[dot_pos - 11] != String::from('9') {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos - 12] != String::from('0') && file_name[dot_pos\
    \ - 12] != String::from('\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpt53fzb3e.rs:55:96\n\
    \   |\n55 |     if file_name[dot_pos - 12] != String::from('0') && file_name[dot_pos\
    \ - 12] != String::from('\n   |                                              \
    \                                                  ^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    if file_name.len() > 3 {\n        return \"No\"\
    ;\n    }\n    if file_name.len() == 3 {\n        if file_name[0] < 'a' || file_name[0]\
    \ > 'z' {\n            return \"No\";\n        }\n        if file_name[1] < 'a'\
    \ || file_name[1] > 'z' {\n            return \"No\";\n        }\n    }\n    if\
    \ dot_pos == 0 {\n        return \"No\";\n    }\n    if dot_pos == file_name.len()\
    \ - 1 {\n        if file_name[dot_pos] != 'txt' || file_name[dot_pos] != 'exe'\
    \ || file_name[dot_pos] != 'dll' {\n            return \"No\";\n        }\n  \
    \  }\n    return \"Yes\";\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpdwkx15hj.rs:34:34\n\
    \   |\n34 |         if file_name[dot_pos] != 'txt' || file_name[dot_pos] != 'exe'\
    \ || file_name[dot_pos] != 'dll' {\n   |                                  ^^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    34 |         if file_name[dot_pos] != \"txt\" || file_name[dot_pos] != 'exe' ||\
    \ file_name[dot_pos] != 'dll' {\n   |                                  ~~~~~\n\
    \nerror: character literal may only contain one codepoint\n  --> /tmp/tmpdwkx15hj.rs:34:65\n\
    \   |\n34 |         if file_name[dot_pos] != 'txt' || file_name[dot_pos] != 'exe'\
    \ || file_name[dot_pos] != 'dll' {\n   |                                     \
    \                            ^^^^^\n   |\nhelp: if you meant to write a `str`\
    \ literal, use double quotes\n   |\n34 |         if file_name[dot_pos] != 'txt'\
    \ || file_name[dot_pos] != \"exe\" || file_name[dot_pos] != 'dll' {\n   |    \
    \                                                             ~~~~~\n\nerror:\
    \ character literal may only contain one codepoint\n  --> /tmp/tmpdwkx15hj.rs:34:96\n\
    \   |\n34 |         if file_name[dot_pos] != 'txt' || file_name[dot_pos] != 'exe'\
    \ || file_name[dot_pos] != 'dll' {\n   |                                     \
    \                                                           ^^^^^\n   |\nhelp:\
    \ if you meant to write a `str` literal, use double quotes\n   |\n34 |       \
    \  if file_name[dot_pos] != 'txt' || file_name[dot_pos] != 'exe' || file_name[dot_pos]\
    \ != \"dll\" {\n   |                                                         \
    \                                       ~~~~~\n\nerror: expected `;`, found keyword\
    \ `if`\n  --> /tmp/tmpdwkx15hj.rs:15:42\n   |\n15 |     let mut dot_pos = file_name.find('.')\n\
    \   |                                          ^ help: add `;` here\n16 |    \
    \ if dot_pos == String::npos { \n   |     -- unexpected token\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpdwkx15hj.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos { \n   |    "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name_chars = file_name.to_chars();\n \
    \   let mut dot_index = file_name_chars.iter().position(|&c| c == '.').unwrap();\n\
    \    let mut dot_chars = file_name_chars.iter().take(dot_index).collect::<Vec<_>>();\n\
    \    let mut dot_index = dot_chars.iter().position(|&c| c == '.').unwrap();\n\
    \    let mut dot_chars = dot_chars.iter().take(dot_index).collect::<Vec<_>>();\n\
    \    let mut dot_index = dot_chars.iter().position(|&c| c == '.').unwrap();\n\
    \    let mut dot_chars = dot_chars.iter().take(dot_index).collect::<Vec<_>>();\n\
    \    let mut dot_index = dot_chars.iter().position(|&c| c == '.').unwrap();\n\
    \    let mut dot_chars = dot_chars.iter().take(dot_index).collect::<Vec<_>>();\n\
    \    let mut dot_index = dot_chars.iter().position(|&c| c == '.').unwrap();\n\
    \    let mut dot_chars = dot_chars.iter().take(dot_index).collect::<Vec<_>>();\n\
    \    let mut dot_index = dot_chars.iter().position(|&c| c == '.').unwrap();\n\
    \    let mut dot_chars = dot_chars.iter().take(dot_index).collect::<Vec<_>>();\n\
    \    let mut dot_index = dot_chars.iter().position(|&c| c == '.').unwrap();\n\
    \    let mut dot_chars = dot_chars.iter().take(dot_index).collect::<Vec<_>>();\n\
    \    let mut dot_index = dot_chars.iter().position(|&c| c == '.').unwrap();\n\
    \    let mut dot_chars = dot_chars.iter().take(dot_index).collect::<Vec<_>>();\n\
    \    let mut dot_index = dot_chars.iter().position(|&c| c == '.').unwrap();\n\
    \    let mut dot_chars = dot_chars.iter().take(dot_index).collect::<Vec<_>>();\n\
    \    let mut dot_index = dot_chars.iter().position(|&c| c == '.').unwrap();\n\
    \    let mut dot_chars = dot_chars.iter().take(dot_index).collect::<Vec<_>>();\n\
    \    let mut dot_index = dot_chars.iter().position(|&c| c == '.').unwrap();\n\
    \    let mut dot_chars = dot_chars.iter().take(dot_index).\n}\n\nfn main() {\n\
    \    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp4cm86m_5.rs:37:1\n   |\n37\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp4cm86m_5.rs:36:58\n\
    \   |\n36 |     let mut dot_chars = dot_chars.iter().take(dot_index).\n   |  \
    \                                                        ^ help: add `;` here\n\
    37 | }\n   | - unexpected token\n\nerror[E0599]: no method named `to_chars` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp4cm86m_5.rs:14:41\n\
    \   |\n14 |     let mut file_name_chars = file_name.to_chars();\n   |        \
    \                                 ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `chars`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4cm86m_5.rs:13:42\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos = dot_pos + 1;\n \
    \   let mut dot_pos_end = file_name.find('.')\n    while dot_pos_end != String::npos\
    \ && dot_pos_end > dot_pos {\n        dot_pos_end = dot_pos_end - 1;\n    }\n\
    \    if dot_pos_end == String::npos {\n        return String::from(\"No\");\n\
    \    }\n    let mut dot_pos_start = dot_pos;\n    let mut dot_pos_end = dot_pos_end;\n\
    \    while dot_pos_end != String::npos && dot_pos_end > dot_pos_start {\n    \
    \    dot_pos_end = dot_pos_end - 1;\n    }\n    if dot_pos_end == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_start =\
    \ dot_pos_start + 1;\n    let mut dot_pos_end = dot_pos_end;\n    while dot_pos_end\
    \ != String::npos && dot_pos_end > dot_pos_start {\n        dot_pos_end = dot_pos_end\
    \ - 1;\n    }\n    if dot_pos_end == String::npos {\n        return String::from(\"\
    No\");\n    }\n    let mut dot_pos_start = dot_pos_start + 1;\n    let mut dot_pos_end\
    \ = dot_pos_end;\n    while dot_pos_end != String::npos && dot_pos_end > dot_pos_start\
    \ {\n        dot_pos_end = dot_pos_end - 1;\n    }\n    if dot_pos_end == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_start =\
    \ dot_pos_start + 1;\n    let mut dot_pos_end = dot_pos_end;\n    while dot_pos_end\
    \ != String::npos && dot_pos_end > dot_pos_start {\n        dot_pos_end = dot_pos_end\
    \ - 1;\n    }\n    if dot_pos_end == String::npos {\n        return String::from(\"\
    No\");\n    }\n    let mut dot_pos_start = dot_pos_start + 1;\n    let mut dot_pos_end\
    \ = dot_pos_end;\n    while dot_pos_end != String::npos && dot_pos_end > dot_pos_start\
    \ {\n        dot_pos_end = dot_pos_end - 1;\n    }\n    if dot_pos_end == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_start =\
    \ dot_pos_start + 1;\n    let mut dot_pos_end = dot_pos_end;\n    while dot_pos_end\
    \ != String::npos && dot_pos_end > dot_pos_start {\n        dot_pos_\n}\n\nfn\
    \ main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8l1q8f8e.rs:101:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n69  |  \
    \   while dot_pos_end != String::npos && dot_pos_end > dot_pos_start {\n    |\
    \                                                                      - this\
    \ delimiter might not be properly closed...\n70  |         dot_pos_\n71  | }\n\
    \    | - ...as it matches this but it has different indentation\n...\n101 | }\n\
    \    |   ^\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp8l1q8f8e.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `while`\n\
    \  --> /tmp/tmp8l1q8f8e.rs:20:46\n   |\n20 |     let mut dot_pos_end = file_name.find('.')\n\
    \   |                                              ^ help: add `;` here\n21 |\
    \     while dot_pos_end != String::npos && dot_pos_end > dot_pos {\n   |     -----\
    \ unexpected token\n\nerror[E0425]: cannot find value `dot_pos_` in this scope\n\
    \  --> /tmp/tmp8l1q8f8e.rs:70:9\n   |\n70 |         dot_pos_\n   |         ^^^^^^^^\
    \ help: a local variable with a similar name exists: `dot_pos`\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp8l1q8f8e.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmp8l1q8f8e.rs:19:31\n   |\n19 |     let mut dot_pos = dot_pos + 1;\n\
    \   |                       ------- ^ - {integer}\n   |                      \
    \ |\n   |                       Option<usize>\n\nerror[E0599]: no function or\
    \ associated item named `npos` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp8l1q8f8e.rs:21:34\n   |\n21 |     while dot_pos_end != String::npos\
    \ && dot_pos_end > dot_pos {\n   |         "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name_chars = file_name.chars();\n    let\
    \ mut dot_pos = file_name_chars.next().unwrap().unwrap();\n    let mut dot_pos_end\
    \ = dot_pos.unwrap();\n    let mut dot_pos_start = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = \n}\n\n\
    fn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpbyupxrq_.rs:57:1\n\
    \   |\n57 | }\n   | ^ expected expression\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpbyupxrq_.rs:15:55\n\
    \   |\n15 |     let mut dot_pos = file_name_chars.next().unwrap().unwrap();\n\
    \   |                                                       ^^^^^^ method not\
    \ found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut counter = 0;\n    let mut dot_counter = 0;\n\
    \    let mut first_letter_counter = 0;\n    let mut last_letter_counter = 0;\n\
    \    let mut first_letter_counter2 = 0;\n    let mut last_letter_counter2 = 0;\n\
    \    let mut first_letter_counter3 = 0;\n    let mut last_letter_counter3 = 0;\n\
    \    let mut first_letter_counter4 = 0;\n    let mut last_letter_counter4 = 0;\n\
    \    let mut first_letter_counter5 = 0;\n    let mut last_letter_counter5 = 0;\n\
    \    let mut first_letter_counter6 = 0;\n    let mut last_letter_counter6 = 0;\n\
    \    let mut first_letter_counter7 = 0;\n    let mut last_letter_counter7 = 0;\n\
    \    let mut first_letter_counter8 = 0;\n    let mut last_letter_counter8 = 0;\n\
    \    let mut first_letter_counter9 = 0;\n    let mut last_letter_counter9 = 0;\n\
    \    let mut first_letter_counter10 = 0;\n    let mut last_letter_counter10 =\
    \ 0;\n    let mut first_letter_counter11 = 0;\n    let mut last_letter_counter11\
    \ = 0;\n    let mut first_letter_counter12 = 0;\n    let mut last_letter_counter12\
    \ = 0;\n    let mut first_letter_counter13 = 0;\n    let mut last_letter_counter13\
    \ = 0;\n    let mut first_letter_counter14 = 0;\n    let mut last_letter_counter14\
    \ = 0;\n    let mut first_letter_counter15 = 0;\n    let mut last_letter_counter15\
    \ = 0;\n    let mut first_letter_counter16 = 0;\n    let mut last_letter_counter16\
    \ = 0;\n    let mut first_letter_counter17 = 0;\n    let mut last_letter_counter17\
    \ = 0;\n    let mut first_letter_counter18 = 0;\n    let mut last_letter_counter18\
    \ = 0;\n    let mut first_letter_counter19 = 0;\n    let mut last_letter_counter19\
    \ = 0;\n    let mut first_letter_counter20 = 0;\n    let mut last_letter_counter20\
    \ = 0;\n    let mut first_letter_counter21 = 0;\n    let mut last_letter_counter21\
    \ = 0;\n    let mut first_letter_counter22 = 0;\n    let mut last_letter_counter22\
    \ = 0;\n    let mut first_letter_counter23 = 0;\n    let mut last_letter_counter23\
    \ = 0;\n    let mut first_letter_counter24 = 0;\n    let mut last_letter_counter24\
    \ = 0;\n    let mut first_letter_counter25 = 0;\n    let mut last_letter_counter25\
    \ = 0;\n    let mut first_letter_counter26 = 0;\n    let mut last_letter_counter26\
    \ = 0;\n    let mut first_letter_counter27 = 0;\n    let mut last_letter_counter27\
    \ = 0;\n    let mut first_letter_counter28 = 0;\n    let mut last_letter_counter28\
    \ = 0;\n    let mut first_letter_\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw4vomkus.rs:72:26\n   |\n\
    72 |     let mut first_letter_\n   |                          ^ help: add `;`\
    \ here\n73 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpw4vomkus.rs:13:42\n   |\n13 | fn file_name_check(file_name: String)\
    \ -> String {\n   |    ---------------                       ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    \n    let mut dot_pos = file_name.find('.')\n \
    \   if dot_pos == String::npos { \n        return \"No\";\n    }\n    \n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    \n    let mut dot_pos = file_name.find('.')\n \
    \   if dot_pos == String::npos { \n        return \"No\";\n    }\n    \n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    \n    let mut dot_pos = file_name.find('.')\n \
    \   if dot_pos == String::npos { \n        return \"No\";\n    }\n    \n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    \n    let mut dot_pos = file_name.find('.')\n \
    \   if dot_pos == String::npos { \n        return \"No\";\n    }\n    \n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    \n    let mut dot_pos = file_name.find('.')\n \
    \   if dot_pos == String::npos { \n        return \"No\";\n    }\n    \n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    \n    let mut dot_pos = file_name.find('.')\n \
    \   if dot_pos == String::npos { \n        return \"No\";\n    }\n    \n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    \n    let mut dot_pos = file_name.find('.')\n \
    \   if dot_pos == String::npos { \n        return \"No\";\n    }\n    \n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    \n    let mut dot_pos = file_name.find('.')\n \
    \   if dot_pos == String::npos { \n        return \"No\";\n    }\n    \n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    \n    let mut dot_pos = file_name.find('.')\n \
    \   if dot_pos == String::npos { \n        return \"No\";\n    }\n\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpdurbuppw.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ { \n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpdurbuppw.rs:20:42\n   |\n20 |     let mut dot_pos = file_name.find('.')\n\
    \   |                                          ^ help: add `;` here\n21 |    \
    \ if dot_pos == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpdurbuppw.rs:25:42\n   |\n25 |     let\
    \ mut dot_pos = file_name.find('.')\n   |                                    \
    \      ^ help: add `;` here\n26 |     if dot_pos == String::npos { \n   |    \
    \ -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpdurbuppw.rs:30:42\n\
    \   |\n30 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n31 |     if dot_pos == String::npos\
    \ { \n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpdurbuppw.rs:35:42\n   |\n35 |     let mut dot_pos = file_name.find('.')\n\
    \   |                                          ^ help: add `;` here\n36 |    \
    \ if dot_pos == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpdurbuppw.rs:40:42\n   |\n40 |     let\
    \ mut dot_pos = file_name.find('.')\n   |                                    \
    \      ^ help: add `;` here\n41 |     if dot_pos == String::npos { \n   |    \
    \ -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpdurbuppw.rs:45:42\n\
    \   |\n45 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n46 |     if dot_pos == String::npos\
    \ { \n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpdurbuppw.rs:50:42\n   |\n50 |     let mut dot_pos = file_name.find('.')\n\
    \   |                                          ^ help: add `;` here\n51 |    \
    \ if dot_pos == String::npos {"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    if dot_pos == 0 {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name[dot_pos - 1] != String::from('0')\
    \ && file_name[dot_pos - 1] != String::from('9') {\n        return String::from(\"\
    No\");\n    }\n    if dot_pos == file_name.len() - 1 {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos - 1] != String::from('.') {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name[dot_pos - 2] != String::from('a'..'z')\
    \ && file_name[dot_pos - 2] != String::from('A'..'Z') {\n        return String::from(\"\
    No\");\n    }\n    if dot_pos == 0 {\n        return String::from(\"No\");\n \
    \   }\n    if file_name[dot_pos - 2] != String::from('.') {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos - 1] != String::from('a'..'z') && file_name[dot_pos\
    \ - 1] != String::from('A'..'Z') {\n        return String::from(\"No\");\n   \
    \ }\n    if dot_pos == file_name.len() - 1 {\n        return String::from(\"No\"\
    );\n    }\n    if file_name[dot_pos - 2] != String::from('.') {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name[dot_pos - 1] != String::from('a'..'z')\
    \ && file_name[dot_pos - 1] != String::from('A'..'Z') {\n        return String::from(\"\
    No\");\n    }\n    if dot_pos == file_name.len() - 2 {\n        return String::from(\"\
    Yes\");\n    }\n    if file_name[dot_pos - 2] != String::from('txt'..'exe'..'dll')\
    \ {\n        return String::from(\"No\");\n    }\n    return String::from(\"Yes\"\
    );\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpp67wk25c.rs:55:47\n\
    \   |\n55 |     if file_name[dot_pos - 2] != String::from('txt'..'exe'..'dll')\
    \ {\n   |                                               ^^^^^\n   |\nhelp: if\
    \ you meant to write a `str` literal, use double quotes\n   |\n55 |     if file_name[dot_pos\
    \ - 2] != String::from(\"txt\"..'exe'..'dll') {\n   |                        \
    \                       ~~~~~\n\nerror: character literal may only contain one\
    \ codepoint\n  --> /tmp/tmpp67wk25c.rs:55:54\n   |\n55 |     if file_name[dot_pos\
    \ - 2] != String::from('txt'..'exe'..'dll') {\n   |                          \
    \                            ^^^^^\n   |\nhelp: if you meant to write a `str`\
    \ literal, use double quotes\n   |\n55 |     if file_name[dot_pos - 2] != String::from('txt'..\"\
    exe\"..'dll') {\n   |                                                      ~~~~~\n\
    \nerror: character literal may only contain one codepoint\n  --> /tmp/tmpp67wk25c.rs:55:61\n\
    \   |\n55 |     if file_name[dot_pos - 2] != String::from('txt'..'exe'..'dll')\
    \ {\n   |                                                             ^^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    55 |     if file_name[dot_pos - 2] != String::from('txt'..'exe'..\"dll\") {\n\
    \   |                                                             ~~~~~\n\nerror:\
    \ expected `;`, found keyword `if`\n  --> /tmp/tmpp67wk25c.rs:15:42\n   |\n15\
    \ |     let mut dot_pos = file_name.find('.')\n   |                          \
    \                ^ help: add `;` here\n16 |     if dot_pos == String::npos {\n\
    \   |     -- unexpected token\n\nerror: expected one of `)`, `,`, `.`, `?`, or\
    \ an operator, found `..`\n  --> /tmp/tmpp67wk25c.rs:55:59\n   |\n55 |     if\
    \ file_name[dot_pos - 2] != String::from('txt'..'exe'..'dll') {\n   |        \
    \                                                   -^\n   |                 \
    \                                          |\n   |                           \
    \                                expected one of `)`, `,`, `.`, `?`, or an operator\n\
    \   |                              "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name.len() > 3 {\n       \
    \ return String::from(\"No\");\n    }\n    if file_name.len() == 3 {\n       \
    \ if file_name[0] < 'a' || file_name[0] > 'z' {\n            return String::from(\"\
    No\");\n        }\n        if file_name[1] < 'a' || file_name[1] > 'z' {\n   \
    \         return String::from(\"No\");\n        }\n    }\n    if dot_pos == 0\
    \ {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos - 1]\
    \ < 'a' || file_name[dot_pos - 1] > 'z' {\n        return String::from(\"No\"\
    );\n    }\n    if file_name[dot_pos] != 'txt' && file_name[dot_pos] != 'exe' &&\
    \ file_name[dot_pos] != 'dll' {\n        return String::from(\"No\");\n    }\n\
    \    return String::from(\"Yes\");\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp2zwm345t.rs:36:30\n\
    \   |\n36 |     if file_name[dot_pos] != 'txt' && file_name[dot_pos] != 'exe'\
    \ && file_name[dot_pos] != 'dll' {\n   |                              ^^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    36 |     if file_name[dot_pos] != \"txt\" && file_name[dot_pos] != 'exe' && file_name[dot_pos]\
    \ != 'dll' {\n   |                              ~~~~~\n\nerror: character literal\
    \ may only contain one codepoint\n  --> /tmp/tmp2zwm345t.rs:36:61\n   |\n36 |\
    \     if file_name[dot_pos] != 'txt' && file_name[dot_pos] != 'exe' && file_name[dot_pos]\
    \ != 'dll' {\n   |                                                           \
    \  ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n36 |     if file_name[dot_pos] != 'txt' && file_name[dot_pos] != \"exe\"\
    \ && file_name[dot_pos] != 'dll' {\n   |                                     \
    \                        ~~~~~\n\nerror: character literal may only contain one\
    \ codepoint\n  --> /tmp/tmp2zwm345t.rs:36:92\n   |\n36 |     if file_name[dot_pos]\
    \ != 'txt' && file_name[dot_pos] != 'exe' && file_name[dot_pos] != 'dll' {\n \
    \  |                                                                         \
    \                   ^^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n36 |     if file_name[dot_pos] != 'txt' && file_name[dot_pos]\
    \ != 'exe' && file_name[dot_pos] != \"dll\" {\n   |                          \
    \                                                                  ~~~~~\n\nerror:\
    \ expected `;`, found keyword `if`\n  --> /tmp/tmp2zwm345t.rs:15:42\n   |\n15\
    \ |     let mut dot_pos = file_name.find('.')\n   |                          \
    \                ^ help: add `;` here\n16 |     if dot_pos == String::npos {\n\
    \   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmp2zwm345t.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    if\
    \ file_name.len() > 3 {\n        file_name.truncate(3);\n    }\n    if file_name.contains('.')\
    \ {\n        file_name.truncate(file_name.rfind('.'));\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n        file_name.truncate(0);\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_lowercase()) {\n        file_name.truncate(0);\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_uppercase()) {\n        file_name.truncate(0);\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_digit()) {\n        file_name.truncate(0);\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_lowercase() || c.is_ascii_uppercase() ||\
    \ c.is_digit()) {\n        file_name.truncate(0);\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_lowercase() || c.is_ascii_uppercase() ||\
    \ c.is_digit() || c == '.') {\n        file_name.truncate(0);\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_lowercase() || c.is_ascii_uppercase() ||\
    \ c.is_digit() || c == '.' || c == '_') {\n        file_name.truncate(0);\n  \
    \  }\n    if file_name.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_lowercase()\
    \ || c.is_ascii_uppercase() || c.is_digit() || c == '.' || c == '_' || c == '-')\
    \ {\n        file_name.truncate(0);\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c.is_ascii_lowercase() || c.is_ascii_uppercase() || c.is_digit() || c ==\
    \ '.' || c == '_' || c == '-' || c == '.' || c == '-') {\n        file_name.truncate(0);\n\
    \    }\n    if file_name.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_lowercase()\
    \ || c.is_ascii_uppercase() || c.is_digit() || c == '.' || c == '_' || c == '-'\
    \ || c == '.' || c == '-' || c == '-' || c == '-') {\n        file_name.truncate(0);\n\
    \    }\n    if file_name.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_lowercase()\
    \ || c.is_ascii_uppercase() || c.is_digit() || c == '.' || c == '_' || c == '-'\
    \ || c\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpgs1jfeeh.rs:52:1\n   |\n\
    51 |     if file_name.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_lowercase()\
    \ || c.is_ascii_uppercase() || c.is_digit() || c == '.' || ...\n   |     -- this\
    \ `if` expression has a condition, but no block\n52 | }\n   | ^ expected `{`\n\
    \nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpgs1jfeeh.rs:51:29\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n51 |     if file_name.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_lowercase()\
    \ || c.is_ascii_uppercase() || c.is_digit() || c == '.' || ...\n   |         \
    \                    ^ unclosed delimiter\n52 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgs1jfeeh.rs:19:28\n   |\n19 |\
    \         file_name.truncate(file_name.rfind('.'));\n   |                    \
    \        ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n  \
    \ = note: expected type `usize`\n              found enum `Option<usize>`\n\n\
    error[E0599]: no method named `is_ascii_letter` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpgs1jfeeh.rs:21:37\n   |\n21 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n   |                                     ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpgs1jfeeh.rs:30:37\n\
    \    |\n30  |     if file_name.chars().any(|c| !c.is_digit()) {\n    |       \
    \                              ^^^^^^^^- supplied 0 arguments\n    |         \
    \                            |\n    |                                     expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no\
    \ method named `is_ascii_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmpgs1jfeeh.rs:33:37\n   |\n33 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_lowercase() || c.is_ascii_uppercase() ||\
    \ c.is_digit()) {\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_4 = file_name.find('.')\n\
    \    if dot_pos_4 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_6 = file_name.find('.')\n\
    \    if dot_pos_6 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_7 = file_name.find('.')\n    if dot_pos_7 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_8 = file_name.find('.')\n\
    \    if dot_pos_8 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_14 = file_name.find('.')\n\
    \    if dot_pos_14 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_16 = file_name.find('.')\n\
    \    if dot_pos_16 == String::npos {\n\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpd53_6oub.rs:108:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n76  |  \
    \   if dot_pos_16 == String::npos {\n    |                                   -\
    \ this delimiter might not be properly closed...\n77  | \n78  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n108 | }\n    |   ^\n\n\
    error: expected `;`, found keyword `if`\n  --> /tmp/tmpd53_6oub.rs:15:42\n   |\n\
    15 |     let mut dot_pos = file_name.find('.')\n   |                         \
    \                 ^ help: add `;` here\n16 |     if dot_pos == String::npos {\n\
    \   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmpd53_6oub.rs:19:44\n   |\n19 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n20 |  \
    \   if dot_pos_2 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpd53_6oub.rs:23:44\n   |\n23 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n24 |     if dot_pos_3 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpd53_6oub.rs:27:44\n\
    \   |\n27 |     let mut dot_pos_4 = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n28 |     if dot_pos_4 == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpd53_6oub.rs:31:44\n   |\n31 |     let mut dot_pos_5 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n32 |  \
    \   if dot_pos_5 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpd53_6oub.rs:35:44\n   |\n35 |     let\
    \ mut dot_pos_6 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n36 |     if dot_pos_6 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: exp"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_char: char;\n    let mut last_char: char;\n\
    \    let mut dot_count: usize;\n    let mut dot_pos: usize;\n    let mut dot_pos_2:\
    \ usize;\n    let mut dot_pos_3: usize;\n    let mut dot_pos_4: usize;\n    let\
    \ mut dot_pos_5: usize;\n    let mut dot_pos_6: usize;\n    let mut dot_pos_7:\
    \ usize;\n    let mut dot_pos_8: usize;\n    let mut dot_pos_9: usize;\n    let\
    \ mut dot_pos_10: usize;\n    let mut dot_pos_11: usize;\n    let mut dot_pos_12:\
    \ usize;\n    let mut dot_pos_13: usize;\n    let mut dot_pos_14: usize;\n   \
    \ let mut dot_pos_15: usize;\n    let mut dot_pos_16: usize;\n    let mut dot_pos_17:\
    \ usize;\n    let mut dot_pos_18: usize;\n    let mut dot_pos_19: usize;\n   \
    \ let mut dot_pos_20: usize;\n    let mut dot_pos_21: usize;\n    let mut dot_pos_22:\
    \ usize;\n    let mut dot_pos_23: usize;\n    let mut dot_pos_24: usize;\n   \
    \ let mut dot_pos_25: usize;\n    let mut dot_pos_26: usize;\n    let mut dot_pos_27:\
    \ usize;\n    let mut dot_pos_28: usize;\n    let mut dot_pos_29: usize;\n   \
    \ let mut dot_pos_30: usize;\n    let mut dot_pos_31: usize;\n    let mut dot_pos_32:\
    \ usize;\n    let mut dot_pos_33: usize;\n    let mut dot_pos_34: usize;\n   \
    \ let mut dot_pos_35: usize;\n    let mut dot_pos_36: usize;\n    let mut dot_pos_37:\
    \ usize;\n    let mut dot_pos_38: usize;\n    let mut dot_pos_39: usize;\n   \
    \ let mut dot_pos_40: usize;\n    let mut dot_pos_41: usize;\n    let mut dot_pos_42:\
    \ usize;\n    let mut dot_pos_43: usize;\n    let mut dot_pos_44: usize;\n   \
    \ let mut dot_pos_45: usize;\n    let mut dot_pos_46: usize;\n    let mut dot_pos_47:\
    \ usize;\n    let mut dot_pos_48: usize;\n    let mut dot_pos_49: usize;\n   \
    \ let \n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmppvq803qh.rs:67:1\n  \
    \ |\n67 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name.len() < 3 {\n       \
    \ return String::from(\"No\");\n    }\n    if file_name[dot_pos - 1] != String::from('0')\
    \ && file_name[dot_pos - 1] != String::from('1') {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos - 2] != String::from('a') && file_name[dot_pos\
    \ - 2] != String::from('A') {\n        return String::from(\"No\");\n    }\n \
    \   if file_name[dot_pos - 3] != String::from('t') && file_name[dot_pos - 3] !=\
    \ String::from('T') {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos\
    \ - 4] != String::from('e') && file_name[dot_pos - 4] != String::from('E') {\n\
    \        return String::from(\"No\");\n    }\n    if file_name[dot_pos - 5] !=\
    \ String::from('s') && file_name[dot_pos - 5] != String::from('S') {\n       \
    \ return String::from(\"No\");\n    }\n    if file_name[dot_pos - 6] != String::from('d')\
    \ && file_name[dot_pos - 6] != String::from('D') {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos - 7] != String::from('l') && file_name[dot_pos\
    \ - 7] != String::from('L') {\n        return String::from(\"No\");\n    }\n \
    \   if file_name[dot_pos - 8] != String::from('h') && file_name[dot_pos - 8] !=\
    \ String::from('H') {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos\
    \ - 9] != String::from('o') && file_name[dot_pos - 9] != String::from('O') {\n\
    \        return String::from(\"No\");\n    }\n    if file_name[dot_pos - 10] !=\
    \ String::from('x') && file_name[dot_pos - 10] != String::from('X') {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name[dot_pos - 11] != String::from('r')\
    \ && file_name[dot_pos - 11] != String::from('R') {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos - 12] != String::from('u') && file_name[dot_pos\
    \ - 12] != String::from('U') {\n\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpuzklilgd.rs:87:3\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n55 |     if\
    \ file_name[dot_pos - 12] != String::from('u') && file_name[dot_pos - 12] != String::from('U')\
    \ {\n   |                                                                    \
    \                                 - this delimiter might not be properly closed...\n\
    56 | \n57 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n87 | }\n   |   ^\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpuzklilgd.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpuzklilgd.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot subtract\
    \ `{integer}` from `Option<usize>`\n  --> /tmp/tmpuzklilgd.rs:22:26\n   |\n22\
    \ |     if file_name[dot_pos - 1] != String::from('0') && file_name[dot_pos -\
    \ 1] != String::from('1') {\n   |                  ------- ^ - {integer}\n   |\
    \                  |\n   |                  Option<usize>\n\nerror[E0369]: cannot\
    \ subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpuzklilgd.rs:22:73\n\
    \   |\n22 |     if file_name[dot_pos - 1] != String::from('0') && file_name[dot_pos\
    \ - 1] != String::from('1') {\n   |                                          \
    \                       ------- ^ - {integer}\n   |                          \
    \                                       |\n   |                              \
    \                                   Option<usize>\n\nerror[E0369]: cannot subtract\
    \ `{integer}` from `Option<usize>`\n  --> /tmp/tmpuzklilgd.rs:25:26\n   |\n25\
    \ |     if file_name[dot_pos - 2] != String::from('a') && file_name[dot_pos -\
    \ 2] != St"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name.len() < 3 {\n       \
    \ return String::from(\"No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter())\
    \ {\n        return String::from(\"No\");\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_lowercase()) {\n        return String::from(\"No\");\n    }\n  \
    \  if file_name.chars().any(|c| !c.is_ascii_uppercase()) {\n        return String::from(\"\
    No\");\n    }\n    if file_name.chars().any(|c| !c.is_digit()) {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c != '.') {\n        return String::from(\"No\");\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_lowercase() || c != 'a' || c != 'z') {\n        return String::from(\"\
    No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_uppercase() || c !=\
    \ 'A' || c != 'Z') {\n        return String::from(\"No\");\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_digit() || c != '0' || c != '9') {\n        return String::from(\"No\"\
    );\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter() || c != '.' ||\
    \ file_name.chars().any(|c| !c.is_ascii_lowercase() || c != 'a' || c != 'z') ||\
    \ file_name.chars().any(|c| !c.is_ascii_uppercase() || c != 'A' || c != 'Z') ||\
    \ file_name.chars().any(|c| !c.is_digit() || c != '0' || c != '9')) {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c != '.' || file_name.chars().any(|c| !c.is_ascii_lowercase() || c != 'a'\
    \ || c != 'z') || file_name.chars().any(|c| !c.is_ascii_uppercase() || c != 'A'\
    \ || c != 'Z') || file_name.chars().any(|c| !c.is_digit() || c != '0' || c !=\
    \ '9') || file_name.chars().any(|c| !c.is_ascii_letter() || c != '.' || file_name.chars().any(|c|\
    \ !c.is_\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpscp6_nz6.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpscp6_nz6.rs:50:1\n\
    \   |\n49 |     if file_name.chars().any(|c| !c.is_ascii_letter() || c != '.'\
    \ || file_name.chars().any(|c| !c.is_ascii_lowercase() || c != 'a' || c !...\n\
    \   |     -- this `if` expression has a condition, but no block\n50 | }\n   |\
    \ ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpscp6_nz6.rs:49:377\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n49 |     if file_name.chars().any(|c| !c.is_ascii_letter() || c !=\
    \ '.' || file_name.chars().any(|c| !c.is_ascii_lowercase() || c != 'a' || c !=\
    \ 'z') || file_name.chars().any(|c| !c.is_ascii_uppercase() || c != 'A' || c !=\
    \ 'Z') || file_name.chars().any(|c| !c.is_digit() || c != '0' || c != '9') ||\
    \ file_name.chars().any(|c| !c.is_ascii_letter() || c != '.' || file_name.chars().any(|c|...\n\
    \   |                                                                        \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \ ^ unclosed delimiter\n50 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpscp6_nz6.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0599]: no method named `is_ascii_letter` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpscp6_nz6.rs:22:37\n   |\n\
    22 |     if file_nam"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_pos_end = dot_pos + 1;\n    let mut\
    \ dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    while dot_pos_start != dot_pos_end {\n        let mut dot_pos_start_letter\
    \ = dot_pos_start;\n        let mut dot_pos_end_letter = dot_pos_end;\n      \
    \  while dot_pos_start_letter != dot_pos_end_letter {\n            let mut dot_pos_start_letter\
    \ = dot_pos_start_letter + 1;\n            let mut dot_pos_end_letter = dot_pos_end_letter\
    \ + 1;\n            if dot_pos_start_letter > dot_pos_end_letter {\n         \
    \       return \"No\";\n            }\n            if dot_pos_start_letter < 'a'\
    \ || dot_pos_start_letter > 'z' {\n                return \"No\";\n          \
    \  }\n            if dot_pos_end_letter > 'z' {\n                return \"No\"\
    ;\n            }\n            if dot_pos_end_letter < 'a' || dot_pos_end_letter\
    \ > 'z' {\n                return \"No\";\n            }\n        }\n        dot_pos_start\
    \ = dot_pos_start + 1;\n        dot_pos_end_letter = dot_pos_start + 1;\n    }\n\
    \    if dot_pos_start == dot_pos_end {\n        return \"No\";\n    }\n    if\
    \ dot_pos_start < 'a' || dot_pos_start > 'z' {\n        return \"No\";\n    }\n\
    \    if dot_pos_end > 'z' {\n        return \"No\";\n    }\n    if dot_pos_end\
    \ < 'a' || dot_pos_end > 'z' {\n        return \"No\";\n    }\n    return \"Yes\"\
    ;\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpef5ab6g7.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ { \n   |     -- unexpected token\n\nerror[E0599]: no function or associated\
    \ item named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpef5ab6g7.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos { \n   |                          \
    \ ^^^^ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpef5ab6g7.rs:17:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n17 |         return \"No\";\n   |    \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \               |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpef5ab6g7.rs:19:35\n\
    \   |\n19 |     let mut dot_pos_end = dot_pos + 1;\n   |                     \
    \      ------- ^ - {integer}\n   |                           |\n   |         \
    \                  Option<usize>\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpef5ab6g7.rs:20:37\n   |\n20 |     let mut dot_pos_start = dot_pos\
    \ + 1;\n   |                             ------- ^ - {integer}\n   |         \
    \                    |\n   |                             Option<usize>\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\n  \
    \      return String::from(\"No\");\n    }\n    if dot_index > 0 {\n        dot_index\
    \ -= 1;\n    }\n    if file_name.len() < 3 {\n        return String::from(\"No\"\
    );\n    }\n    let mut first_letter = String::from(\"a\");\n    let mut last_letter\
    \ = String::from(\"z\");\n    let mut first_letter_found = false;\n    let mut\
    \ last_letter_found = false;\n    for letter in file_name.chars() {\n        if\
    \ letter == first_letter {\n            if !first_letter_found {\n           \
    \     first_letter_found = true;\n            }\n        } else {\n          \
    \  if !last_letter_found {\n                last_letter_found = true;\n      \
    \      }\n        }\n    }\n    if first_letter_found && last_letter_found {\n\
    \        return String::from(\"Yes\");\n    }\n    return String::from(\"No\"\
    );\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmprherk903.rs:15:44\n\
    \   |\n15 |     let mut dot_index = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n16 |     if dot_index == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmprherk903.rs:16:29\n\
    \   |\n16 |     if dot_index == String::npos {\n   |                         \
    \    ^^^^ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprherk903.rs:19:20\n   |\n19 |     if dot_index > 0 {\n\
    \   |                    ^ expected enum `Option`, found integer\n   |\n   = note:\
    \ expected enum `Option<usize>`\n              found type `{integer}`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n19 |     if dot_index > Some(0) {\n\
    \   |                    +++++ +\n\nerror[E0368]: binary assignment operation\
    \ `-=` cannot be applied to type `Option<usize>`\n  --> /tmp/tmprherk903.rs:20:9\n\
    \   |\n20 |         dot_index -= 1;\n   |         ---------^^^^^\n   |       \
    \  |\n   |         cannot use `-=` on type `Option<usize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprherk903.rs:30:22\n   |\n30 |         if letter == first_letter\
    \ {\n   |                      ^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name_check: String = \"No\";\n    let\
    \ mut dot_check: usize = 0;\n    let mut first_letter: usize = 0;\n    let mut\
    \ dot_found: usize = 0;\n    let mut dot_before_dot: usize = 0;\n    let mut dot_after_dot:\
    \ usize = 0;\n    let mut dot_after_dot_check: usize = 0;\n    let mut dot_after_dot_found:\
    \ usize = 0;\n    let mut dot_after_dot_before_dot: usize = 0;\n    let mut dot_after_dot_after_dot:\
    \ usize = 0;\n    let mut dot_after_dot_after_dot_check: usize = 0;\n    let mut\
    \ dot_after_dot_after_dot_found: usize = 0;\n    let mut dot_after_dot_after_dot_before_dot:\
    \ usize = 0;\n    let mut dot_after_dot_after_dot_after_dot: usize = 0;\n    let\
    \ mut dot_after_dot_after_dot_after_dot_check: usize = 0;\n    let mut dot_after_dot_after_dot_after_dot_found:\
    \ usize = 0;\n    let mut dot_after_dot_after_dot_after_dot_before_dot: usize\
    \ = 0;\n    let mut dot_after_dot_after_dot_after_dot_after_dot: usize = 0;\n\
    \    let mut dot_after_dot_after_dot_after_dot_after_dot_check: usize = 0;\n \
    \   let mut dot_after_dot_after_dot_after_dot_after_dot_found: usize = 0;\n  \
    \  let mut dot_after_dot_after_dot_after_dot_after_dot_before_dot: usize = 0;\n\
    \    let mut dot_after_dot_after_dot_after_dot_after_dot_after_dot: usize = 0;\n\
    \    let mut dot_after_dot_after_dot_after_dot_after_dot_after_dot_check: usize\
    \ = 0;\n    let mut dot_after_dot_after_dot_after_dot_after_dot_after_dot_found:\
    \ usize = 0;\n    let mut dot_after_dot_after_dot_after_dot_after_dot_after_dot_before_dot:\
    \ usize = 0;\n    let mut dot_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot:\
    \ usize = 0;\n    let mut dot_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot_check:\
    \ usize = 0;\n    let mut dot_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot_found:\
    \ usize = 0;\n    let mut dot_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot_before_dot:\
    \ usize = 0;\n    let mut dot_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot:\
    \ usize = 0;\n    let mut dot_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot_check:\
    \ usize = 0;\n    let mut dot_after_\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb7nnvxh_.rs:45:23\n   |\n\
    45 |     let mut dot_after_\n   |                       ^ help: add `;` here\n\
    46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb7nnvxh_.rs:14:39\n\
    \   |\n14 |     let mut file_name_check: String = \"No\";\n   |              \
    \                ------   ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                              |        |\n   |                          \
    \    |        expected struct `String`, found `&str`\n   |                   \
    \           expected due to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb7nnvxh_.rs:13:42\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_char: char;\n    let mut second_char:\
    \ char;\n    let mut third_char: char;\n    let mut fourth_char: char;\n    let\
    \ mut fifth_char: char;\n    let mut sixth_char: char;\n    let mut seventh_char:\
    \ char;\n    let mut eighth_char: char;\n    let mut ninth_char: char;\n    let\
    \ mut tenth_char: char;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let \n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpowuxn2c7.rs:71:1\n  \
    \ |\n71 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_char: char;\n    let mut second_char:\
    \ char;\n    let mut third_char: char;\n    let mut fourth_char: char;\n    let\
    \ mut fifth_char: char;\n    let mut sixth_char: char;\n    let mut seventh_char:\
    \ char;\n    let mut eighth_char: char;\n    let mut ninth_char: char;\n    let\
    \ mut tenth_char: char;\n    let mut first_char_valid: String;\n    let mut second_char_valid:\
    \ String;\n    let mut third_char_valid: String;\n    let mut fourth_char_valid:\
    \ String;\n    let mut fifth_char_valid: String;\n    let mut sixth_char_valid:\
    \ String;\n    let mut seventh_char_valid: String;\n    let mut eighth_char_valid:\
    \ String;\n    let mut ninth_char_valid: String;\n    let mut tenth_char_valid:\
    \ String;\n    let mut first_char_valid: String;\n    let mut second_char_valid:\
    \ String;\n    let mut third_char_valid: String;\n    let mut fourth_char_valid:\
    \ String;\n    let mut fifth_char_valid: String;\n    let mut sixth_char_valid:\
    \ String;\n    let mut seventh_char_valid: String;\n    let mut eighth_char_valid:\
    \ String;\n    let mut ninth_char_valid: String;\n    let mut tenth_char_valid:\
    \ String;\n    let mut first_char_valid: String;\n    let mut second_char_valid:\
    \ String;\n    let mut third_char_valid: String;\n    let mut fourth_char_valid:\
    \ String;\n    let mut fifth_char_valid: String;\n    let mut sixth_char_valid:\
    \ String;\n    let mut seventh_char_valid: String;\n    let mut eighth_char_valid:\
    \ String;\n    let mut ninth_char_valid: String;\n    let mut tenth_char_valid:\
    \ String;\n    let mut first_char_valid: String;\n    let mut second_char_valid:\
    \ String;\n    let mut third_char_valid: String;\n    let mut fourth_char_valid:\
    \ String;\n    let mut fifth_char_valid: String;\n    let mut sixth_char_valid:\
    \ String;\n    let mut seventh_char_valid: String;\n    let mut eighth_char_valid:\
    \ String;\n    let mut ninth_char_valid: String;\n    let mut tenth_char_valid:\
    \ String;\n    let mut first_char_valid: String;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpf2ffldzl.rs:66:1\n\
    \   |\n66 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name_checker = String::new();\n    let\
    \ mut dot_count = 0;\n    let mut first_letter = String::new();\n    let mut last_letter\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n    let mut last_dot_index\
    \ = String::new();\n    let mut last_dot_index = String::new();\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf8osvpuj.rs:13:42\n   |\n\
    13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.len() > 3 {\n        return \"No\";\n\
    \    }\n    if file_name.len() == 0 {\n        return \"No\";\n    }\n    if file_name.len()\
    \ == 1 {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_lowercase())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_uppercase())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_digit())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c != '.') {\n        return \"No\";\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_lowercase() || c != 'a' || c != 'z') {\n        return \"No\";\n\
    \    }\n    if file_name.chars().any(|c| !c.is_ascii_uppercase() || c != 'A' ||\
    \ c != 'Z') {\n        return \"No\";\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_digit() || c != '0' || c != '9') {\n        return \"No\";\n    }\n  \
    \  if file_name.chars().any(|c| !c.is_ascii_letter() || c != '.' || c != 'txt'\
    \ || c != 'exe' || c != 'dll') {\n        return \"No\";\n    }\n    return \"\
    Yes\";\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp39m2_vcw.rs:47:75\n\
    \   |\n47 |     if file_name.chars().any(|c| !c.is_ascii_letter() || c != '.'\
    \ || c != 'txt' || c != 'exe' || c != 'dll') {\n   |                         \
    \                                                  ^^^^^\n   |\nhelp: if you meant\
    \ to write a `str` literal, use double quotes\n   |\n47 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c != '.' || c != \"txt\" || c != 'exe' || c != 'dll')\
    \ {\n   |                                                                    \
    \       ~~~~~\n\nerror: character literal may only contain one codepoint\n  -->\
    \ /tmp/tmp39m2_vcw.rs:47:89\n   |\n47 |     if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c != '.' || c != 'txt' || c != 'exe' || c != 'dll') {\n   |             \
    \                                                                            ^^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    47 |     if file_name.chars().any(|c| !c.is_ascii_letter() || c != '.' || c !=\
    \ 'txt' || c != \"exe\" || c != 'dll') {\n   |                               \
    \                                                          ~~~~~\n\nerror: character\
    \ literal may only contain one codepoint\n  --> /tmp/tmp39m2_vcw.rs:47:103\n \
    \  |\n47 |     if file_name.chars().any(|c| !c.is_ascii_letter() || c != '.' ||\
    \ c != 'txt' || c != 'exe' || c != 'dll') {\n   |                            \
    \                                                                           ^^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    47 |     if file_name.chars().any(|c| !c.is_ascii_letter() || c != '.' || c !=\
    \ 'txt' || c != 'exe' || c != \"dll\") {\n   |                               \
    \                                                                        ~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp39m2_vcw.rs:15:16\n   |\n13 |\
    \ fn file_name_check(file_name: String) -> String {\n   |                    \
    \                      ------ expected `String` because of return type\n14 | \
    \    if file_name.len() > 3 {\n15 | "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_pos_2 = file_name.find('.')\n    if\
    \ dot_pos_2 == String::npos { \n        return \"No\";\n    }\n    let mut dot_pos_3\
    \ = file_name.find('.')\n    if dot_pos_3 == String::npos { \n        return \"\
    No\";\n    }\n    let mut dot_pos_4 = file_name.find('.')\n    if dot_pos_4 ==\
    \ String::npos { \n        return \"No\";\n    }\n    let mut dot_pos_5 = file_name.find('.')\n\
    \    if dot_pos_5 == String::npos { \n        return \"No\";\n    }\n    let mut\
    \ dot_pos_6 = file_name.find('.')\n    if dot_pos_6 == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_pos_7 = file_name.find('.')\n    if\
    \ dot_pos_7 == String::npos { \n        return \"No\";\n    }\n    let mut dot_pos_8\
    \ = file_name.find('.')\n    if dot_pos_8 == String::npos { \n        return \"\
    No\";\n    }\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 ==\
    \ String::npos { \n        return \"No\";\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos { \n        return \"No\";\n    }\n    let\
    \ mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos { \n\
    \        return \"No\";\n    }\n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos { \n        return \"No\";\n    }\n    let\
    \ mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos { \n\
    \        return \"No\";\n    }\n    let mut dot_pos_14 = file_name.find('.')\n\
    \    if dot_pos_14 == String::npos { \n        return \"No\";\n    }\n    let\
    \ mut dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos { \n\
    \        return \"No\";\n    }\n    let mut dot_pos_16 = file_name.find('.')\n\
    \    if dot_pos_16 == String::npos { \n        return \"No\";\n    }\n    let\
    \ mut dot_pos_17 = file_name.find('.')\n    if dot_pos_17 == String::npos { \n\
    \        return \"No\";\n    }\n    let mut dot_pos_18 = file_name.find('.')\n\
    \    if dot_pos_18 == String::npos { \n        return \"No\n}\n\nfn main() {\n\
    \    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmp0cml5u50.rs:91:40\n\
    \   |\n91 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n   --> /tmp/tmp0cml5u50.rs:104:56\n    |\n104\
    \ |     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n    |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmp0cml5u50.rs:115:63\n\
    \    |\n115 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    116 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.clone();\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n        return\
    \ String::from(\"No\");\n    }\n    \n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    \n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_4\
    \ = file_name.find('.')\n    if dot_pos_4 == String::npos {\n        return String::from(\"\
    No\");\n    }\n    \n    let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5\
    \ == String::npos {\n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_pos_6 = file_name.find('.')\n    if dot_pos_6 == String::npos {\n  \
    \      return String::from(\"No\");\n    }\n    \n    let mut dot_pos_7 = file_name.find('.')\n\
    \    if dot_pos_7 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    \n    let mut dot_pos_8 = file_name.find('.')\n    if dot_pos_8 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_9\
    \ = file_name.find('.')\n    if dot_pos_9 == String::npos {\n        return String::from(\"\
    No\");\n    }\n    \n    let mut dot_pos_10 = file_name.find('.')\n    if dot_pos_10\
    \ == String::npos {\n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos {\n\
    \        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    \n    let mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 ==\
    \ String::npos {\n        return String::from(\"No\");\n    }\n    \n    let mut\
    \ dot_pos_14 = file_name.find('.')\n    if dot_pos_14 == String::npos {\n    \
    \    return String::from(\"No\");\n    }\n    \n    let mut dot_pos_15 = file_name.find('.')\n\
    \    if dot_pos_15 == String::npos {\n        return String::from(\"No\n}\n\n\
    fn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmpi6y0po81.rs:93:40\n\
    \   |\n93 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n   --> /tmp/tmpi6y0po81.rs:106:56\n    |\n106\
    \ |     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n    |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmpi6y0po81.rs:117:63\n\
    \    |\n117 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    118 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_char = file_name[0];\n    let mut second_char\
    \ = file_name[1];\n    let mut third_char = file_name[2];\n    if first_char ==\
    \ '0' {\n        first_char = '1';\n    }\n    if second_char == '.' {\n     \
    \   second_char = '0';\n    }\n    if third_char == '.' {\n        third_char\
    \ = '0';\n    }\n    if first_char == '0' {\n        first_char = '1';\n    }\n\
    \    if second_char == '.' {\n        second_char = '0';\n    }\n    if third_char\
    \ == '.' {\n        third_char = '0';\n    }\n    if first_char == 'a' || first_char\
    \ == 'A' {\n        first_char = 'a';\n    }\n    if second_char == '.' {\n  \
    \      second_char = '0';\n    }\n    if third_char == '.' {\n        third_char\
    \ = '0';\n    }\n    if first_char == 'a' || first_char == 'A' {\n        first_char\
    \ = 'a';\n    }\n    if second_char == '.' {\n        second_char = '0';\n   \
    \ }\n    if third_char == '.' {\n        third_char = '0';\n    }\n    if first_char\
    \ == 'a' || first_char == 'A' {\n        first_char = 'a';\n    }\n    if second_char\
    \ == '.' {\n        second_char = '0';\n    }\n    if third_char == '.' {\n  \
    \      third_char = '0';\n    }\n    if first_char == 'a' || first_char == 'A'\
    \ {\n        first_char = 'a';\n    }\n    if second_char == '.' {\n        second_char\
    \ = '0';\n    }\n    if third_char == '.' {\n        third_char = '0';\n    }\n\
    \    if first_char == 'a' || first_char == 'A' {\n        first_char = 'a';\n\
    \    }\n    if second_char == '.' {\n        second_char = '0';\n    }\n    if\
    \ third_char == '.' {\n        third_char = '0';\n    }\n    if first_char ==\
    \ 'a' || first_char == 'A' {\n        first_char = 'a';\n    }\n    if second_char\
    \ == '.' {\n        second_char = '0';\n    }\n    if third_char == '.' {\n  \
    \      third_char = '0';\n    }\n    if first_char == 'a' || first_char == 'A'\
    \ {\n        first_char = 'a';\n    }\n    if second_char == '.' {\n        second_char\
    \ = '0';\n    }\n    if third_char == '.' {\n        third_char = '0';\n    }\n\
    \    if first_char == 'a\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `while`, `for`, `loop` or `{` after a label\n  --> /tmp/tmpxpuhbm3v.rs:99:1\n\
    \   |\n99 | }\n   | ^ expected `while`, `for`, `loop` or `{` after a label\n\n\
    error: expected expression, found `}`\n  --> /tmp/tmpxpuhbm3v.rs:99:1\n   |\n\
    99 | }\n   | ^ expected expression\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `{integer}`\n  --> /tmp/tmpxpuhbm3v.rs:14:26\n   |\n14 |     let\
    \ mut first_char = file_name[0];\n   |                          ^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpxpuhbm3v.rs:15:27\n   |\n15 |     let mut second_char = file_name[1];\n\
    \   |                           ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpxpuhbm3v.rs:16:26\n   |\n16 |     let mut third_char = file_name[2];\n\
    \   |                          ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implemen"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos { \n \
    \       return \"No\";\n    }\n    if file_name[dot_index - 1] == ' ' {\n    \
    \    return \"No\";\n    }\n    if file_name[dot_index - 2] != 'a' && file_name[dot_index\
    \ - 2] != 'A' {\n        return \"No\";\n    }\n    if file_name[dot_index - 3]\
    \ != '.' {\n        return \"No\";\n    }\n    if file_name[dot_index - 4] !=\
    \ 'txt' && file_name[dot_index - 4] != 'exe' && file_name[dot_index - 4] != 'dll'\
    \ {\n        return \"No\";\n    }\n    return \"Yes\";\n}\n\nfn main() {\n  \
    \  let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpizd85zlq.rs:28:36\n\
    \   |\n28 |     if file_name[dot_index - 4] != 'txt' && file_name[dot_index -\
    \ 4] != 'exe' && file_name[dot_index - 4] != 'dll' {\n   |                   \
    \                 ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use\
    \ double quotes\n   |\n28 |     if file_name[dot_index - 4] != \"txt\" && file_name[dot_index\
    \ - 4] != 'exe' && file_name[dot_index - 4] != 'dll' {\n   |                 \
    \                   ~~~~~\n\nerror: character literal may only contain one codepoint\n\
    \  --> /tmp/tmpizd85zlq.rs:28:73\n   |\n28 |     if file_name[dot_index - 4] !=\
    \ 'txt' && file_name[dot_index - 4] != 'exe' && file_name[dot_index - 4] != 'dll'\
    \ {\n   |                                                                    \
    \     ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n28 |     if file_name[dot_index - 4] != 'txt' && file_name[dot_index -\
    \ 4] != \"exe\" && file_name[dot_index - 4] != 'dll' {\n   |                 \
    \                                                        ~~~~~\n\nerror: character\
    \ literal may only contain one codepoint\n  --> /tmp/tmpizd85zlq.rs:28:110\n \
    \  |\n28 |     if file_name[dot_index - 4] != 'txt' && file_name[dot_index - 4]\
    \ != 'exe' && file_name[dot_index - 4] != 'dll' {\n   |                      \
    \                                                                            \
    \            ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n28 |     if file_name[dot_index - 4] != 'txt' && file_name[dot_index\
    \ - 4] != 'exe' && file_name[dot_index - 4] != \"dll\" {\n   |               \
    \                                                                            \
    \                   ~~~~~\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpizd85zlq.rs:15:44\n\
    \   |\n15 |     let mut dot_index = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n16 |     if dot_index == String::npos\
    \ { \n   |     -- unexpected token\n\nerror[E0599]: no function or associated\
    \ item named"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    if\
    \ file_name.len() > 3 {\n        file_name.truncate(3);\n    }\n    if file_name.contains(\"\
    .\") {\n        file_name.truncate(file_name.rfind('.'));\n    }\n    if file_name[0]\
    \ != 'a' || file_name[0] != 'A' || file_name[1] != 'z' || file_name[1] != 'Z'\
    \ {\n        file_name.truncate(0);\n    }\n    if !file_name.contains(\"txt\"\
    ) && !file_name.contains(\"exe\") && !file_name.contains(\"dll\") {\n        file_name.truncate(0);\n\
    \    }\n    file_name\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp08llvso7.rs:19:28\n   |\n\
    19 |         file_name.truncate(file_name.rfind('.'));\n   |                 \
    \           ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n\
    \   = note: expected type `usize`\n              found enum `Option<usize>`\n\n\
    error[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp08llvso7.rs:21:8\n\
    \   |\n21 |     if file_name[0] != 'a' || file_name[0] != 'A' || file_name[1]\
    \ != 'z' || file_name[1] != 'Z' {\n   |        ^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp08llvso7.rs:21:31\n   |\n21 |     if file_name[0] != 'a' || file_name[0]\
    \ != 'A' || file_name[1] != 'z' || file_name[1] != 'Z' {\n   |               \
    \                ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp08llvso7.rs:21:54\n   |\n21 |     if file_name[0] != 'a' || file_name[0]\
    \ != 'A' || file_name[1] != 'z' || file_name[1] != 'Z' {\n   |               \
    \      "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_char: char;\n    let mut second_char:\
    \ char;\n    let mut third_char: char;\n    let mut fourth_char: char;\n    let\
    \ mut fifth_char: char;\n    let mut sixth_char: char;\n    let mut seventh_char:\
    \ char;\n    let mut eighth_char: char;\n    let mut ninth_char: char;\n    let\
    \ mut tenth_char: char;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let \n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpet09ky25.rs:71:1\n  \
    \ |\n71 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name_chars = file_name.chars();\n    let\
    \ mut dot_pos = file_name_chars.find_first_of(\".\");\n    let mut dot_pos_end\
    \ = file_name_chars.find_first_not_of(\".\", dot_pos);\n    let mut dot_pos_start\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `find_first_of` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmp1w60bhxm.rs:15:39\n   |\n15 |     let mut\
    \ dot_pos = file_name_chars.find_first_of(\".\");\n   |                      \
    \                 ^^^^^^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `find_first_not_of` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp1w60bhxm.rs:16:43\n   |\n16 |     let mut dot_pos_end =\
    \ file_name_chars.find_first_not_of(\".\", dot_pos);\n   |                   \
    \                        ^^^^^^^^^^^^^^^^^ method not found in `Chars<'_>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp1w60bhxm.rs:13:42\n   |\n13 | fn\
    \ file_name_check(file_name: String) -> String {\n   |    ---------------    \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_name = file_name.clone();\n\
    \    dot_name.truncate(dot_pos);\n    let mut dot_name_pos = dot_name.find('.')\n\
    \    if dot_name_pos == String::npos {\n        return String::from(\"No\");\n\
    \    }\n    let mut dot_name_char = dot_name[dot_name_pos];\n    if dot_name_char\
    \ == '.' {\n        dot_name_pos = dot_name.find('.')\n        if dot_name_pos\
    \ == String::npos {\n            return String::from(\"No\");\n        }\n   \
    \     dot_name_char = dot_name[dot_name_pos];\n    }\n    if dot_name_char !=\
    \ 'a' && dot_name_char != 'A' && dot_name_char != 'b' && dot_name_char != 'B'\
    \ && dot_name_char != 'c' && dot_name_char != 'C' && dot_name_char != 'd' && dot_name_char\
    \ != 'D' && dot_name_char != 'e' && dot_name_char != 'E' && dot_name_char != 'f'\
    \ && dot_name_char != 'F' && dot_name_char != 'g' && dot_name_char != 'G' && dot_name_char\
    \ != 'h' && dot_name_char != 'H' && dot_name_char != 'i' && dot_name_char != 'I'\
    \ && dot_name_char != 'j' && dot_name_char != 'J' && dot_name_char != 'k' && dot_name_char\
    \ != 'K' && dot_name_char != 'l' && dot_name_char != 'L' && dot_name_char != 'm'\
    \ && dot_name_char != 'M' && dot_name_char != 'n' && dot_name_char != 'N' && dot_name_char\
    \ != 'o' && dot_name_char != 'O' && dot_name_char != 'p' && dot_name_char != 'P'\
    \ && dot_name_char != 'q' && dot_name_char != 'Q' && dot_name_char != 'r' && dot_name_char\
    \ != 'R' && dot_name_char != 's' && dot_name_char != 'S' && dot_name_char != 't'\
    \ && dot_name_char != 'T' && dot_name_char != 'u' && dot_name_char != 'U' && dot_name_char\
    \ != 'v' && dot_name_char != 'V' && dot_name_char != 'w' && dot_name_char != 'W'\
    \ && dot_name_char != 'x' && dot_name_char != 'X' && dot_name_char != 'y' && dot_name_char\
    \ != 'Y' && dot_name_char != 'z' && dot_name_char != 'Z' {\n        return String::from(\"\
    No\");\n    }\n    let mut dot_name_pos = dot_name.find('.')\n    if dot_name_pos\
    \ == String::npos {\n        return String::from(\"No\");\n\n}\n\nfn main() {\n\
    \    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpldi3cg0e.rs:70:3\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n37 |     if\
    \ dot_name_pos == String::npos {\n   |                                     - this\
    \ delimiter might not be properly closed...\n...\n40 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n70 | }\n   |   ^\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpldi3cg0e.rs:15:42\n   |\n15 |     let\
    \ mut dot_pos = file_name.find('.')\n   |                                    \
    \      ^ help: add `;` here\n16 |     if dot_pos == String::npos {\n   |     --\
    \ unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpldi3cg0e.rs:21:46\n\
    \   |\n21 |     let mut dot_name_pos = dot_name.find('.')\n   |              \
    \                                ^ help: add `;` here\n22 |     if dot_name_pos\
    \ == String::npos {\n   |     -- unexpected token\n\nerror: expected `;`, found\
    \ keyword `if`\n  --> /tmp/tmpldi3cg0e.rs:27:42\n   |\n27 |         dot_name_pos\
    \ = dot_name.find('.')\n   |                                          ^ help:\
    \ add `;` here\n28 |         if dot_name_pos == String::npos {\n   |         --\
    \ unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpldi3cg0e.rs:36:46\n\
    \   |\n36 |     let mut dot_name_pos = dot_name.find('.')\n   |              \
    \                                ^ help: add `;` here\n37 |     if dot_name_pos\
    \ == String::npos {\n   |     -- unexpected token\n\nerror[E0599]: no function\
    \ or associated item named `npos` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpldi3cg0e.rs:16:27\n   |\n16 |     if dot_pos == String::npos {\n\
    \   |                           ^^^^ function or associated item not found in\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpldi3cg0e.rs:20:23\n\
    \   |\n20 |     dot_name.truncate(dot_pos);\n   |                       ^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerro"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    if\
    \ file_name.len() > 3 {\n        file_name.truncate(3);\n    }\n    if file_name.contains(\"\
    .\") {\n        file_name.truncate(file_name.rfind('.'));\n    }\n    if file_name.starts_with(\"\
    a\") || file_name.starts_with(\"A\") {\n        file_name.truncate(0);\n    }\n\
    \    if file_name.contains(\".\") {\n        let dot_index = file_name.rfind('.')\n\
    \        if dot_index == 0 {\n            file_name.truncate(0);\n        } else\
    \ {\n            file_name.truncate(dot_index);\n        }\n    }\n    if file_name.contains(\"\
    .\") {\n        let dot_index = file_name.rfind('.')\n        if dot_index ==\
    \ 0 {\n            file_name.truncate(0);\n        } else {\n            file_name.truncate(dot_index);\n\
    \        }\n    }\n    if file_name.contains(\".\") {\n        let dot_index =\
    \ file_name.rfind('.')\n        if dot_index == 0 {\n            file_name.truncate(0);\n\
    \        } else {\n            file_name.truncate(dot_index);\n        }\n   \
    \ }\n    if file_name.contains(\".\") {\n        let dot_index = file_name.rfind('.')\n\
    \        if dot_index == 0 {\n            file_name.truncate(0);\n        } else\
    \ {\n            file_name.truncate(dot_index);\n        }\n    }\n    if file_name.contains(\"\
    .\") {\n        let dot_index = file_name.rfind('.')\n        if dot_index ==\
    \ 0 {\n            file_name.truncate(0);\n        } else {\n            file_name.truncate(dot_index);\n\
    \        }\n    }\n    if file_name.contains(\".\") {\n        let dot_index =\
    \ file_name.rfind('.')\n        if dot_index == 0 {\n            file_name.truncate(0);\n\
    \        } else {\n            file_name.truncate(dot_index);\n        }\n   \
    \ }\n    if file_name.contains(\".\") {\n        let dot_index = file_name.rfind('.')\n\
    \        if dot_index == 0 {\n            file_name.truncate(0);\n        } else\
    \ {\n            file_name.truncate(dot_index);\n        }\n    }\n    if file_name.contains(\"\
    .\") {\n        let dot_index = file_name.rfind('.')\n        if dot_index ==\
    \ 0 {\n            file_name.truncate(0);\n        } else {\n            file_name.truncate(dot_index);\n\
    \        }\n    }\n    if file_name.contains(\".\") {\n        let dot_index =\
    \ file_name.rfind('.')\n        if dot_index == 0 {\n            file_name.truncate(0);\n\
    \        } else {\n            file_name.truncate(dot_index);\n        }\n   \
    \ }\n    if file_name.contains(\".\") {\n        let dot_index = file_name.rfind('.')\n\
    \        if dot_index == 0 {\n            file_name.truncate(0);\n        } else\
    \ {\n            file_name.truncate(dot_index);\n        }\n    }\n    if file_name.contains(\"\
    .\") {\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5hb0q54j.rs:135:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n104 |  \
    \   if file_name.contains(\".\") {\n    |                                - this\
    \ delimiter might not be properly closed...\n105 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n135 | }\n    |   ^\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp5hb0q54j.rs:25:45\n   |\n25 |       \
    \  let dot_index = file_name.rfind('.')\n   |                                \
    \             ^ help: add `;` here\n26 |         if dot_index == 0 {\n   |   \
    \      -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp5hb0q54j.rs:33:45\n\
    \   |\n33 |         let dot_index = file_name.rfind('.')\n   |               \
    \                              ^ help: add `;` here\n34 |         if dot_index\
    \ == 0 {\n   |         -- unexpected token\n\nerror: expected `;`, found keyword\
    \ `if`\n  --> /tmp/tmp5hb0q54j.rs:41:45\n   |\n41 |         let dot_index = file_name.rfind('.')\n\
    \   |                                             ^ help: add `;` here\n42 | \
    \        if dot_index == 0 {\n   |         -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp5hb0q54j.rs:49:45\n   |\n49 |       \
    \  let dot_index = file_name.rfind('.')\n   |                                \
    \             ^ help: add `;` here\n50 |         if dot_index == 0 {\n   |   \
    \      -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp5hb0q54j.rs:57:45\n\
    \   |\n57 |         let dot_index = file_name.rfind('.')\n   |               \
    \                              ^ help: add `;` here\n58 |         if dot_index\
    \ == 0 {\n   |         -- unexpected token\n\nerror: expected `;`, found keyword\
    \ `if`\n  --> /tmp/tmp5hb0q54j.rs:65:45\n   |\n65 |         let dot_index = file_name.rfind('.')\n\
    \   |                                             ^ help: add `;` here\n66 | \
    \        if dot_index == 0 {\n   |         -- unexpected token\n\nerror: expected\
    \ `;`, fo"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    \n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    \n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_4\
    \ = file_name.find('.')\n    if dot_pos_4 == String::npos {\n        return String::from(\"\
    No\");\n    }\n    \n    let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5\
    \ == String::npos {\n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_pos_6 = file_name.find('.')\n    if dot_pos_6 == String::npos {\n  \
    \      return String::from(\"No\");\n    }\n    \n    let mut dot_pos_7 = file_name.find('.')\n\
    \    if dot_pos_7 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    \n    let mut dot_pos_8 = file_name.find('.')\n    if dot_pos_8 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_9\
    \ = file_name.find('.')\n    if dot_pos_9 == String::npos {\n        return String::from(\"\
    No\");\n    }\n    \n    let mut dot_pos_10 = file_name.find('.')\n    if dot_pos_10\
    \ == String::npos {\n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos {\n\
    \        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    \n    let mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 ==\
    \ String::npos {\n        return String::from(\"No\");\n    }\n    \n    let mut\
    \ dot_pos_14 = file_name.find('.')\n    if dot_pos_14 == String::npos {\n    \
    \    return String::from(\"No\");\n    }\n    \n    let mut dot_pos_15 = file_name.find('.')\n\
    \    if dot_pos_15 == String::npos {\n        return String::from(\"\n}\n\nfn\
    \ main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmpkw57wv3v.rs:93:40\n\
    \   |\n93 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n   --> /tmp/tmpkw57wv3v.rs:106:56\n    |\n106\
    \ |     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n    |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmpkw57wv3v.rs:117:63\n\
    \    |\n117 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    118 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_next = dot_pos + 1;\n\
    \    let mut dot_pos_prev = dot_pos_next;\n    let mut dot_pos_len = dot_pos -\
    \ dot_pos_next;\n    let mut dot_pos_len_prev = dot_pos_len;\n    let mut dot_pos_len_next\
    \ = dot_pos_len;\n    let mut dot_pos_len_len = dot_pos_len - dot_pos_len_prev;\n\
    \    let mut dot_pos_len_len_prev = dot_pos_len_len;\n    let mut dot_pos_len_len_next\
    \ = dot_pos_len_len;\n    let mut dot_pos_len_len_len = dot_pos_len_len - dot_pos_len_len_prev;\n\
    \    let mut dot_pos_len_len_len_prev = dot_pos_len_len_len;\n    let mut dot_pos_len_len_len_next\
    \ = dot_pos_len_len_len;\n    let mut dot_pos_len_len_len_len = dot_pos_len_len_len\
    \ - dot_pos_len_len_len_prev;\n    let mut dot_pos_len_len_len_len_prev = dot_pos_len_len_len_len;\n\
    \    let mut dot_pos_len_len_len_len_next = dot_pos_len_len_len_len;\n    let\
    \ mut dot_pos_len_len_len_len_prev = dot_pos_len_len_len_len_next;\n    let mut\
    \ dot_pos_len_len_len_len_next = dot_pos_len_len_len_len_len;\n    let mut dot_pos_len_len_len_len_len_prev\
    \ = dot_pos_len_len_len_len_len_next;\n    let mut dot_pos_len_len_len_len_len_next\
    \ = dot_pos_len_len_len_len_len_len;\n    let mut dot_pos_len_len_len_len_len_prev\
    \ = dot_pos_len_len_len_len_len_len_next;\n    let mut dot_pos_len_len_len_len_len_next\
    \ = dot_pos_len_len_len_len_len_len_len;\n    let mut dot_pos_len_len_len_len_len_len_prev\
    \ = dot_pos_len_len_len_len_len_len_len_next;\n    let mut dot_pos_len_len_len_len_len_len_next\
    \ = dot_pos_len_len_len_len_len_len_len_len;\n    let mut dot_pos_len_len_len_len_len_len_len_prev\
    \ = dot_pos_len_len_len_len_len_len_len_len_len_next;\n    let mut dot_pos_len_len_len_len_len_len_len_next\
    \ = dot_pos_len_len_len_len_len_len_len_len_len_len;\n    let mut dot_pos_len_len_len_len_len_len_len_len_prev\
    \ = dot_pos_len_len_len_len_len_len_len_len_len_len_len_len_next;\n    let mut\
    \ dot_pos_len_len_len_len_len_len_len_len_next = dot_pos_len_len_len_len_len_len_len_len_\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp43m74xho.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp43m74xho.rs:44:100\n\
    \   |\n44 |     let mut dot_pos_len_len_len_len_len_len_len_len_next = dot_pos_len_len_len_len_len_len_len_len_\n\
    \   |                                                                        \
    \                            ^ help: add `;` here\n45 | }\n   | - unexpected token\n\
    \nerror[E0425]: cannot find value `dot_pos_len_len_len_len_len` in this scope\n\
    \  --> /tmp/tmp43m74xho.rs:34:44\n   |\n34 |     let mut dot_pos_len_len_len_len_next\
    \ = dot_pos_len_len_len_len_len;\n   |                                       \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `dot_pos_len_len_len_len_next`\n\nerror[E0425]: cannot find value `dot_pos_len_len_len_len_len_next`\
    \ in this scope\n  --> /tmp/tmp43m74xho.rs:35:48\n   |\n35 |     let mut dot_pos_len_len_len_len_len_prev\
    \ = dot_pos_len_len_len_len_len_next;\n   |                                  \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a\
    \ similar name exists: `dot_pos_len_len_len_len_next`\n\nerror[E0425]: cannot\
    \ find value `dot_pos_len_len_len_len_len_len` in this scope\n  --> /tmp/tmp43m74xho.rs:36:48\n\
    \   |\n36 |     let mut dot_pos_len_len_len_len_len_next = dot_pos_len_len_len_len_len_len;\n\
    \   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `dot_pos_len_len_len_len_len_prev`\n\
    \nerror[E0425]: cannot find value `dot_pos_len_len_len_len_len_len_next` in this\
    \ scope\n  --> /tmp/tmp43m74xho.rs:37:48\n   |\n37 |     let mut dot_pos_len_len_len_len_len_prev\
    \ = dot_pos_len_len_len_len_len_len_next;\n   |                              \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `dot_pos_len"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name : String = file_name;\n    let mut\
    \ dot_pos : usize = 0;\n    let mut dot_pos_2 : usize = 0;\n    let mut dot_pos_3\
    \ : usize = 0;\n    let mut dot_pos_4 : usize = 0;\n    let mut dot_pos_5 : usize\
    \ = 0;\n    let mut dot_pos_6 : usize = 0;\n    let mut dot_pos_7 : usize = 0;\n\
    \    let mut dot_pos_8 : usize = 0;\n    let mut dot_pos_9 : usize = 0;\n    let\
    \ mut dot_pos_10 : usize = 0;\n    let mut dot_pos_11 : usize = 0;\n    let mut\
    \ dot_pos_12 : usize = 0;\n    let mut dot_pos_13 : usize = 0;\n    let mut dot_pos_14\
    \ : usize = 0;\n    let mut dot_pos_15 : usize = 0;\n    let mut dot_pos_16 :\
    \ usize = 0;\n    let mut dot_pos_17 : usize = 0;\n    let mut dot_pos_18 : usize\
    \ = 0;\n    let mut dot_pos_19 : usize = 0;\n    let mut dot_pos_20 : usize =\
    \ 0;\n    let mut dot_pos_21 : usize = 0;\n    let mut dot_pos_22 : usize = 0;\n\
    \    let mut dot_pos_23 : usize = 0;\n    let mut dot_pos_24 : usize = 0;\n  \
    \  let mut dot_pos_25 : usize = 0;\n    let mut dot_pos_26 : usize = 0;\n    let\
    \ mut dot_pos_27 : usize = 0;\n    let mut dot_pos_28 : usize = 0;\n    let mut\
    \ dot_pos_29 : usize = 0;\n    let mut dot_pos_30 : usize = 0;\n    let mut dot_pos_31\
    \ : usize = 0;\n    let mut dot_pos_32 : usize = 0;\n    let mut dot_pos_33 :\
    \ usize = 0;\n    let mut dot_pos_34 : usize = 0;\n    let mut dot_pos_35 : usize\
    \ = 0;\n    let mut dot_pos_36 : usize = 0;\n    let mut dot_pos_37 : usize =\
    \ 0;\n    let mut dot_pos_38 : usize = 0;\n    let mut dot_pos_39 : usize = 0;\n\
    \    let mut dot_pos_40 : usize = 0;\n    let mut dot_pos_41 : usize = 0;\n  \
    \  let mut dot_pos_42 : usize = 0;\n    let mut dot_pos_43 : usize = 0;\n    let\
    \ mut dot_pos_44 : usize = 0;\n    let mut dot_pos_45 : usize = 0;\n    let mut\
    \ dot_pos_46 : usize\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgwtcg9be.rs:60:31\n   |\n\
    60 |     let mut dot_pos_46 : usize\n   |                               ^ help:\
    \ add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgwtcg9be.rs:13:42\n   |\n13 | fn file_name_check(file_name: String)\
    \ -> String {\n   |    ---------------                       ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_char: char;\n    let mut second_char:\
    \ char;\n    let mut third_char: char;\n    let mut fourth_char: char;\n    let\
    \ mut fifth_char: char;\n    let mut sixth_char: char;\n    let mut seventh_char:\
    \ char;\n    let mut eighth_char: char;\n    let mut ninth_char: char;\n    let\
    \ mut tenth_char: char;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let \n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp_wenqzuh.rs:71:1\n  \
    \ |\n71 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    if\
    \ file_name.len() > 3 {\n        file_name.truncate(3);\n    }\n    if file_name.contains(\"\
    .\") {\n        file_name.truncate(file_name.rfind('.'));\n    }\n    if file_name.starts_with(\"\
    a\") || file_name.starts_with(\"A\") {\n        file_name.truncate(0);\n    }\n\
    \    if file_name.ends_with(\"txt\") || file_name.ends_with(\"exe\") || file_name.ends_with(\"\
    dll\") {\n        return file_name;\n    }\n    return \"No\";\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprnsc3bdr.rs:19:28\n   |\n\
    19 |         file_name.truncate(file_name.rfind('.'));\n   |                 \
    \           ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n\
    \   = note: expected type `usize`\n              found enum `Option<usize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprnsc3bdr.rs:27:12\n   |\n13 | fn\
    \ file_name_check(file_name: String) -> String {\n   |                       \
    \                   ------ expected `String` because of return type\n...\n27 |\
    \     return \"No\";\n   |            ^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |            |\n   |            expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_letter = file_name[0];\n    let mut last_letter\
    \ = file_name[file_name.len() - 1];\n    if first_letter != 'a' && first_letter\
    \ != 'A' {\n        first_letter = 'a';\n    }\n    if last_letter != 'z' && last_letter\
    \ != 'Z' {\n        last_letter = 'z';\n    }\n    if file_name.len() < 3 {\n\
    \        return \"No\";\n    }\n    if file_name.contains(\".\") {\n        return\
    \ \"No\";\n    }\n    if file_name.starts_with(first_letter) && file_name.ends_with(last_letter)\
    \ && \n        file_name.len() == 3 {\n        return \"Yes\";\n    }\n    return\
    \ \"No\";\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpv03rnydo.rs:14:28\n   |\n14 |     let mut first_letter = file_name[0];\n\
    \   |                            ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpv03rnydo.rs:15:27\n   |\n15 |     let mut last_letter = file_name[file_name.len()\
    \ - 1];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv03rnydo.rs:23:16\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n23 |         return \"No\";\n   |                ^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                |\n   |             \
    \   expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    if\
    \ file_name.len() > 3 {\n        return String::from(\"No\");\n    }\n    if file_name.contains(\"\
    .\") {\n        let mut dot_pos = file_name.find('.')\n        if dot_pos == String::npos\
    \ {\n            return String::from(\"No\");\n        }\n        if dot_pos ==\
    \ 0 {\n            return String::from(\"No\");\n        }\n        if file_name[dot_pos\
    \ - 1] != char::from_u32(97).unwrap() {\n            return String::from(\"No\"\
    );\n        }\n        let mut dot_pos_2 = file_name.find('.')\n        if dot_pos_2\
    \ == String::npos {\n            return String::from(\"No\");\n        }\n   \
    \     if dot_pos_2 == 0 {\n            return String::from(\"No\");\n        }\n\
    \        if file_name[dot_pos_2 - 1] != char::from_u32(122).unwrap() {\n     \
    \       return String::from(\"No\");\n        }\n    }\n    if file_name[0] <\
    \ 'a' || file_name[0] > 'z' {\n        return String::from(\"No\");\n    }\n \
    \   if file_name[1] < 'a' || file_name[1] > 'z' {\n        return String::from(\"\
    No\");\n    }\n    if file_name[2] < 'a' || file_name[2] > 'z' {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name[0] >= 'a' && file_name[0] <=\
    \ 'z' {\n        return String::from(\"No\");\n    }\n    if file_name[1] >= 'a'\
    \ && file_name[1] <= 'z' {\n        return String::from(\"No\");\n    }\n    if\
    \ file_name[2] >= 'a' && file_name[2] <= 'z' {\n        return String::from(\"\
    No\");\n    }\n    if file_name[0] >= 'A' && file_name[0] <= 'Z' {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name[1] >= 'A' && file_name[1] <=\
    \ 'Z' {\n        return String::from(\"No\");\n    }\n    if file_name[2] >= 'A'\
    \ && file_name[2] <= 'Z' {\n        return String::from(\"No\");\n    }\n    if\
    \ file_name[0] >= '0' && file_name[0] <= '9' {\n        return String::from(\"\
    No\");\n    }\n    if file_name[1] >= '0' && file_name[1] <= '9' {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name[2] >= '0' && file_name[2] <=\
    \ '9' {\n        return String::from(\"No\");\n    }\n    if file_name[0] >= 'a'\
    \ && file_name[0] <= 'z' {\n        return String::from(\"No\");\n    }\n    if\
    \ file_name[1]\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpmzvcg06y.rs:19:46\n\
    \   |\n19 |         let mut dot_pos = file_name.find('.')\n   |              \
    \                                ^ help: add `;` here\n20 |         if dot_pos\
    \ == String::npos {\n   |         -- unexpected token\n\nerror: expected `;`,\
    \ found keyword `if`\n  --> /tmp/tmpmzvcg06y.rs:29:48\n   |\n29 |         let\
    \ mut dot_pos_2 = file_name.find('.')\n   |                                  \
    \              ^ help: add `;` here\n30 |         if dot_pos_2 == String::npos\
    \ {\n   |         -- unexpected token\n\nerror: expected `{`, found `}`\n  -->\
    \ /tmp/tmpmzvcg06y.rs:80:1\n   |\n79 |     if file_name[1]\n   |     -- this `if`\
    \ expression has a condition, but no block\n80 | }\n   | ^ expected `{`\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpmzvcg06y.rs:20:31\n   |\n20 |         if dot_pos\
    \ == String::npos {\n   |                               ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmzvcg06y.rs:23:23\n\
    \   |\n23 |         if dot_pos == 0 {\n   |                       ^ expected enum\
    \ `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n23 |         if dot_pos == Some(0) {\n   |                       +++++\
    \ +\n\nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpmzvcg06y.rs:26:30\n\
    \   |\n26 |         if file_name[dot_pos - 1] != char::from_u32(97).unwrap() {\n\
    \   |                      ------- ^ - {integer}\n   |                      |\n\
    \   |                      Option<usize>\n\nerror[E0599]: no function or associated\
    \ item named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpmzvcg06y.rs:30:33\n\
    \   |\n30 |         if dot_pos_2 == String::npos {\n   |                     \
    \            ^^^^ function or associated item not found in `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmzvcg06y.rs:33:25\n   |\n33 |         if dot_pos_2\
    \ ="
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut i = 0;\n\
    \    while i < file_name.len() {\n        if file_name[i] == '.' {\n         \
    \   if i != 0 && i != file_name.len() - 1 {\n                res.push_str(\"No\"\
    );\n                break;\n            }\n        }\n        if file_name[i]\
    \ >= 'a' && file_name[i] <= 'z' {\n            if i != 0 && i != file_name.len()\
    \ - 1 {\n                res.push_str(\"No\");\n                break;\n     \
    \       }\n        }\n        if file_name[i] >= 'A' && file_name[i] <= 'Z' {\n\
    \            if i != 0 && i != file_name.len() - 1 {\n                res.push_str(\"\
    No\");\n                break;\n            }\n        }\n        if file_name[i]\
    \ >= '0' && file_name[i] <= '9' {\n            if i != 0 && i != file_name.len()\
    \ - 1 {\n                res.push_str(\"No\");\n                break;\n     \
    \       }\n        }\n        i += 1;\n    }\n    res.push_str(\"Yes\");\n   \
    \ return res;\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfmp7mahy.rs:17:12\n\
    \   |\n17 |         if file_name[i] == '.' {\n   |            ^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfmp7mahy.rs:23:12\n   |\n23 |         if file_name[i] >= 'a' &&\
    \ file_name[i] <= 'z' {\n   |            ^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfmp7mahy.rs:23:35\n   |\n23 |         if file_name[i] >= 'a' &&\
    \ file_name[i] <= 'z' {\n   |                                   ^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<st"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    \n    let mut dot_pos_end = dot_pos;\n\
    \    dot_pos_end += 1;\n    let mut dot_pos_start = dot_pos;\n    dot_pos_start\
    \ += 1;\n    \n    while dot_pos_start < dot_pos_end {\n        let mut dot_pos_end\
    \ = dot_pos_end;\n        dot_pos_end += 1;\n        let mut dot_pos_start = dot_pos_start;\n\
    \        dot_pos_start += 1;\n        \n        if dot_pos_start == dot_pos_end\
    \ {\n            if dot_pos_start == 0 {\n                return String::from(\"\
    No\");\n            }\n            \n            if file_name[dot_pos_start -\
    \ 1] < 'a' || file_name[dot_pos_start - 1] > 'z' {\n                return String::from(\"\
    No\");\n            }\n            \n            if dot_pos_start == file_name.len()\
    \ - 1 {\n                return String::from(\"Yes\");\n            }\n      \
    \      \n            if file_name[dot_pos_start] != 'a' && file_name[dot_pos_start]\
    \ != 'z' {\n                return String::from(\"No\");\n            }\n    \
    \        \n            if dot_pos_start == 0 {\n                return String::from(\"\
    No\");\n            }\n            \n            if file_name[dot_pos_start -\
    \ 1] < 'A' || file_name[dot_pos_start - 1] > 'Z' {\n                return String::from(\"\
    No\");\n            }\n            \n            if dot_pos_start == file_name.len()\
    \ - 1 {\n                return String::from(\"Yes\");\n            }\n      \
    \      \n            if file_name[dot_pos_start] != 'A' && file_name[dot_pos_start]\
    \ != 'Z' {\n                return String::from(\"No\");\n            }\n    \
    \    }\n    }\n    \n    return String::from(\"Yes\");\n}\n\nfn main() {\n   \
    \ let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp0etno3pm.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmp0etno3pm.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `Option<usize>`\n  --> /tmp/tmp0etno3pm.rs:21:5\n\
    \   |\n21 |     dot_pos_end += 1;\n   |     -----------^^^^^\n   |     |\n   |\
    \     cannot use `+=` on type `Option<usize>`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `Option<usize>`\n  --> /tmp/tmp0etno3pm.rs:23:5\n\
    \   |\n23 |     dot_pos_start += 1;\n   |     -------------^^^^^\n   |     |\n\
    \   |     cannot use `+=` on type `Option<usize>`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `Option<usize>`\n  --> /tmp/tmp0etno3pm.rs:27:9\n\
    \   |\n27 |         dot_pos_end += 1;\n   |         -----------^^^^^\n   |   \
    \      |\n   |         cannot use `+=` on type `Option<usize>`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Option<usize>`\n\
    \  --> /tmp/tmp0etno3pm.rs:29:9\n   |\n29 |         dot_pos_start += 1;\n   |\
    \         -------------^^^^^\n   |         |\n   |         cannot use `+=` on\
    \ type `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0etno3pm.rs:32:33\n\
    \   |\n32 |             if dot_pos_start == 0 {\n   |                        \
    \         ^ expected enum `Option`, found integer\n   |\n   = note: expected enum\
    \ `Option<usize>`\n              found type `{integer}`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n32 |             if dot_pos_start == Some(0) {\n\
    \   |                                 +++++ +\n\nerror[E0369]: cannot subtract\
    \ `{integer}` from `Option<usize>`\n  --> /tmp/tmp0etno3pm.rs:36:40\n   |\n36\
    \ |           "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n    if dot_pos\
    \ == String::npos { \n        return \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n\
    \    if dot_pos == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n        return\
    \ \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n    if dot_pos ==\
    \ String::npos { \n        return \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n\
    \    if dot_pos == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n        return\
    \ \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n    if dot_pos ==\
    \ String::npos { \n        return \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n\
    \    if dot_pos == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n        return\
    \ \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n    if dot_pos ==\
    \ String::npos { \n        return \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n\
    \    if dot_pos == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n        return\
    \ \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n    if dot_pos ==\
    \ String::npos { \n        return \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n\
    \    if dot_pos == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n        return\
    \ \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n    if dot_pos ==\
    \ String::npos { \n        return \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n\
    \    if dot_pos == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n        return\
    \ \"No\"\n    }\n    let mut dot_pos = file_name.find('\n}\n\nfn main() {\n  \
    \  let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmppzhpvrcp.rs:91:38\n\
    \   |\n91 |     let mut dot_pos = file_name.find('\n   |                     \
    \                 ^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    while dot_pos_end < file_name.len() {\n        if file_name[dot_pos_end]\
    \ >= 'a' && file_name[dot_pos_end] <= 'z' ||\n            file_name[dot_pos_end]\
    \ >= 'A' && file_name[dot_pos_end] <= 'Z' ||\n            file_name[dot_pos_end]\
    \ >= '0' && file_name[dot_pos_end] <= '9' {\n            break;\n        }\n \
    \       dot_pos_end += 1;\n    }\n    if dot_pos_end == file_name.len() {\n  \
    \      return String::from(\"No\");\n    }\n    let mut dot_pos_start = dot_pos\
    \ + 1;\n    while dot_pos_start < dot_pos_end {\n        if file_name[dot_pos_start]\
    \ >= 'a' && file_name[dot_pos_start] <= 'z' ||\n            file_name[dot_pos_start]\
    \ >= 'A' && file_name[dot_pos_start] <= 'Z' ||\n            file_name[dot_pos_start]\
    \ >= '0' && file_name[dot_pos_start] <= '9' {\n            break;\n        }\n\
    \        dot_pos_start += 1;\n    }\n    if dot_pos_start == dot_pos_end {\n \
    \       return String::from(\"No\");\n    }\n    if file_name[dot_pos_start] ==\
    \ '.' {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos_start]\
    \ != file_name[dot_pos_end] {\n        return String::from(\"No\");\n    }\n \
    \   if dot_pos_start == dot_pos_end {\n        return String::from(\"Yes\");\n\
    \    }\n    if file_name[dot_pos_start] == '.' {\n        return String::from(\"\
    Yes\");\n    }\n    if file_name[dot_pos_start] == '.' {\n        return String::from(\"\
    Yes\");\n    }\n    if file_name[dot_pos_start] == '.' {\n        return String::from(\"\
    Yes\");\n    }\n    if file_name[dot_pos_start] == '.' {\n        return String::from(\"\
    Yes\");\n    }\n    if file_name[dot_pos_start] == '.' {\n        return String::from(\"\
    Yes\");\n    }\n    if file_name[dot_pos_start] == '.' {\n        return String::from(\"\
    Yes\");\n    }\n    if file_name[dot_pos_start] == '.' {\n        return String::from(\"\
    Yes\");\n    }\n    if file_name[dot_pos_start] == '.' {\n        return String::from(\"\
    \n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmpakn2a36d.rs:80:40\n\
    \   |\n80 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n  --> /tmp/tmpakn2a36d.rs:93:56\n   |\n93 |\
    \     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n   |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmpakn2a36d.rs:104:63\n\
    \    |\n104 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    105 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.len() > 3 {\n        String::from(\"\"\
    )\n    } else {\n        let mut first_letter = file_name.chars().nth(1).unwrap();\n\
    \        if first_letter < 'a' || first_letter > 'z' {\n            String::from(\"\
    \")\n        } else {\n            let mut dot_pos = file_name.find('.')\n   \
    \         if dot_pos == String::npos {\n                String::from(\"\")\n \
    \           } else {\n                let mut dot_string = file_name.chars().nth(dot_pos).unwrap();\n\
    \                if dot_string != 'txt' && dot_string != 'exe' && dot_string !=\
    \ 'dll' {\n                    String::from(\"\")\n                } else {\n\
    \                    String::from(\"\")\n                }\n            }\n  \
    \      }\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpml1h1cuc.rs:26:34\n\
    \   |\n26 |                 if dot_string != 'txt' && dot_string != 'exe' && dot_string\
    \ != 'dll' {\n   |                                  ^^^^^\n   |\nhelp: if you\
    \ meant to write a `str` literal, use double quotes\n   |\n26 |              \
    \   if dot_string != \"txt\" && dot_string != 'exe' && dot_string != 'dll' {\n\
    \   |                                  ~~~~~\n\nerror: character literal may only\
    \ contain one codepoint\n  --> /tmp/tmpml1h1cuc.rs:26:57\n   |\n26 |         \
    \        if dot_string != 'txt' && dot_string != 'exe' && dot_string != 'dll'\
    \ {\n   |                                                         ^^^^^\n   |\n\
    help: if you meant to write a `str` literal, use double quotes\n   |\n26 |   \
    \              if dot_string != 'txt' && dot_string != \"exe\" && dot_string !=\
    \ 'dll' {\n   |                                                         ~~~~~\n\
    \nerror: character literal may only contain one codepoint\n  --> /tmp/tmpml1h1cuc.rs:26:80\n\
    \   |\n26 |                 if dot_string != 'txt' && dot_string != 'exe' && dot_string\
    \ != 'dll' {\n   |                                                           \
    \                     ^^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n26 |                 if dot_string != 'txt' && dot_string\
    \ != 'exe' && dot_string != \"dll\" {\n   |                                  \
    \                                              ~~~~~\n\nerror: expected `;`, found\
    \ keyword `if`\n  --> /tmp/tmpml1h1cuc.rs:21:50\n   |\n21 |             let mut\
    \ dot_pos = file_name.find('.')\n   |                                        \
    \          ^ help: add `;` here\n22 |             if dot_pos == String::npos {\n\
    \   |             -- unexpected token\n\nerror[E0599]: no function or associated\
    \ item named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpml1h1cuc.rs:22:35\n\
    \   |\n22 |             if dot_pos == String::npos {\n   |                   \
    \                ^^^^ function or associated item not found in `String`\n\nerror[E0308]:\
    \ misma"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter =\
    \ String::from(\"a\");\n    let mut dot_pos_end_letter = String::from(\"z\");\n\
    \    let mut dot_pos_start_letter2 = String::from(\"A\");\n    let mut dot_pos_end_letter2\
    \ = String::from(\"Z\");\n    let mut dot_pos_start_letter3 = String::from(\"\
    0\");\n    let mut dot_pos_end_letter3 = String::from(\"9\");\n    let mut dot_pos_start_letter4\
    \ = String::from(\"a\");\n    let mut dot_pos_end_letter4 = String::from(\"z\"\
    );\n    let mut dot_pos_start_letter5 = String::from(\"A\");\n    let mut dot_pos_end_letter5\
    \ = String::from(\"Z\");\n    let mut dot_pos_start_letter6 = String::from(\"\
    0\");\n    let mut dot_pos_end_letter6 = String::from(\"9\");\n    let mut dot_pos_start_letter7\
    \ = String::from(\"a\");\n    let mut dot_pos_end_letter7 = String::from(\"z\"\
    );\n    let mut dot_pos_start_letter8 = String::from(\"A\");\n    let mut dot_pos_end_letter8\
    \ = String::from(\"Z\");\n    let mut dot_pos_start_letter9 = String::from(\"\
    0\");\n    let mut dot_pos_end_letter9 = String::from(\"9\");\n    let mut dot_pos_start_letter10\
    \ = String::from(\"a\");\n    let mut dot_pos_end_letter10 = String::from(\"z\"\
    );\n    let mut dot_pos_start_letter11 = String::from(\"A\");\n    let mut dot_pos_end_letter11\
    \ = String::from(\"Z\");\n    let mut dot_pos_start_letter12 = String::from(\"\
    0\");\n    let mut dot_pos_end_letter12 = String::from(\"9\");\n    let mut dot_pos_start_letter13\
    \ = String::from(\"a\");\n    let mut dot_pos_end_letter13 = String::from(\"z\"\
    );\n    let mut dot_pos_start_letter14 = String::from(\"A\");\n    let mut dot_pos_end_letter14\
    \ = String::from(\"Z\");\n    let mut dot_pos_start_letter15 = String::from(\"\
    0\");\n    let mut dot_pos_end_letter15 = String::from\n}\n\nfn main() {\n   \
    \ let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpk04q1_k2.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpk04q1_k2.rs:50:48\n\
    \   |\n50 |     let mut dot_pos_end_letter15 = String::from\n   |            \
    \                                    ^ help: add `;` here\n51 | }\n   | - unexpected\
    \ token\n\nerror[E0599]: no function or associated item named `npos` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpk04q1_k2.rs:16:27\n   |\n\
    16 |     if dot_pos == String::npos {\n   |                           ^^^^ function\
    \ or associated item not found in `String`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmpk04q1_k2.rs:19:35\n   |\n19 |     let mut\
    \ dot_pos_end = dot_pos + 1;\n   |                           ------- ^ - {integer}\n\
    \   |                           |\n   |                           Option<usize>\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpk04q1_k2.rs:20:37\n\
    \   |\n20 |     let mut dot_pos_start = dot_pos + 1;\n   |                   \
    \          ------- ^ - {integer}\n   |                             |\n   |   \
    \                          Option<usize>\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpk04q1_k2.rs:13:42\n   |\n13 | fn file_name_check(file_name: String)\
    \ -> String {\n   |    ---------------                       ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_str = String::from(\"\
    \");\n    let mut dot_pos_str_len = String::from(\"\");\n    let mut dot_pos_str_len\
    \ = 0;\n    let mut dot_pos_str_len_max = String::from(\"\");\n    let mut dot_pos_str_len_max\
    \ = 0;\n    let mut dot_pos_str_len_min = String::from(\"\");\n    let mut dot_pos_str_len_min\
    \ = 0;\n    let mut dot_pos_str_len_min_max = String::from(\"\");\n    let mut\
    \ dot_pos_str_len_min_max = 0;\n    let mut dot_pos_str_len_min_max_max = String::from(\"\
    \");\n    let mut dot_pos_str_len_min_max_max = 0;\n    let mut dot_pos_str_len_min_max_max_max\
    \ = String::from(\"\");\n    let mut dot_pos_str_len_min_max_max_max = 0;\n  \
    \  let mut dot_pos_str_len_min_max_max_max_max = String::from(\"\");\n    let\
    \ mut dot_pos_str_len_min_max_max_max_max = String::from(\"\");\n    let mut dot_pos_str_len_min_max_max_max_max\
    \ = String::from(\"\");\n    let mut dot_pos_str_len_min_max_max_max_max_max =\
    \ String::from(\"\");\n    let mut dot_pos_str_len_min_max_max_max_max_max = String::from(\"\
    \");\n    let mut dot_pos_str_len_min_max_max_max_max_max = String::from(\"\"\
    );\n    let mut dot_pos_str_len_min_max_max_max_max_max_max = String::from(\"\"\
    );\n    let mut dot_pos_str_len_min_max_max_max_max_max_max = String::from(\"\"\
    );\n    let mut dot_pos_str_len_min_max_max_max_max_max_max_max = String::from(\"\
    \");\n    let mut dot_pos_str_len_min_max_max_max_max_max_max_max = String::from(\"\
    \");\n    let mut dot_pos_str_len_min_max_max_max_max_max_max_max_max = String::from(\"\
    \");\n    let mut dot_pos_str_len_min_max_max_max_max_max_max_max_max = String::from(\"\
    \");\n    let mut dot_pos_str_len_min_max_max_max_max_max_max_max_max_max = String::from(\"\
    \");\n    let mut dot_pos_str_len_min_max_max_max_max_max_max_max_max_max = String::from(\"\
    \");\n    let mut dot_pos_str_len_min_max_max_max_max_max_max_max_max_max_max\
    \ = String::from(\"\");\n    let mut dot_pos_str_len_min_max_max_max_max_max_max_max_max_max_max\
    \ = String::from(\n}\n\nfn main() {\n    let candidate = file_name_check;\n  \
    \  assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"));\n\
    \    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"));\n\
    \    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp451fkxi7.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected one of `.`, `;`, `?`, `else`,\
    \ or an operator, found `}`\n  --> /tmp/tmp451fkxi7.rs:48:1\n   |\n48 | }\n  \
    \ | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmp451fkxi7.rs:47:87\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                                 -\
    \ closing delimiter possibly meant for this\n...\n47 |     let mut dot_pos_str_len_min_max_max_max_max_max_max_max_max_max_max\
    \ = String::from(\n   |                                                      \
    \                                 ^ unclosed delimiter\n48 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0599]: no function or associated item named `npos`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp451fkxi7.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_char: u8 = 0;\n    let mut second_char:\
    \ u8 = 0;\n    let mut third_char: u8 = 0;\n    let mut fourth_char: u8 = 0;\n\
    \    let mut fifth_char: u8 = 0;\n    let mut sixth_char: u8 = 0;\n    let mut\
    \ seventh_char: u8 = 0;\n    let mut eighth_char: u8 = 0;\n    let mut ninth_char:\
    \ u8 = 0;\n    let mut tenth_char: u8 = 0;\n    let mut first_char_valid = false;\n\
    \    let mut second_char_valid = false;\n    let mut third_char_valid = false;\n\
    \    let mut fourth_char_valid = false;\n    let mut fifth_char_valid = false;\n\
    \    let mut sixth_char_valid = false;\n    let mut seventh_char_valid = false;\n\
    \    let mut eighth_char_valid = false;\n    let mut ninth_char_valid = false;\n\
    \    let mut tenth_char_valid = false;\n    let mut first_char_valid = true;\n\
    \    let mut second_char_valid = true;\n    let mut third_char_valid = true;\n\
    \    let mut fourth_char_valid = true;\n    let mut fifth_char_valid = true;\n\
    \    let mut sixth_char_valid = true;\n    let mut seventh_char_valid = true;\n\
    \    let mut eighth_char_valid = true;\n    let mut ninth_char_valid = true;\n\
    \    let mut tenth_char_valid = true;\n    let mut first_char_valid = file_name.chars().any(|c|\
    \ c >= '0' && c <= '9');\n    let mut second_char_valid = file_name.chars().any(|c|\
    \ c >= 'a' && c <= 'z');\n    let mut third_char_valid = file_name.chars().any(|c|\
    \ c >= 'A' && c <= 'Z');\n    let mut fourth_char_valid = file_name.chars().any(|c|\
    \ c >= 'a' && c <= 'z');\n    let mut fifth_char_valid = file_name.chars().any(|c|\
    \ c >= 'A' && c <= 'Z');\n    let mut sixth_char_valid = file_name.chars().any(|c|\
    \ c >= 'a' && c <= 'z');\n    let mut seventh_char_valid = file_name.chars().any(|c|\
    \ c >= 'A' && c <= 'Z');\n    let mut eighth_char_valid = file_name.chars().any(|c|\
    \ c >= 'a' && c <= 'z');\n    let mut ninth_char_valid = file_name.chars().any(|c|\
    \ \n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpm3u2318g.rs:52:53\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n52 |     let mut ninth_char_valid = file_name.chars().any(|c| \n\
    \   |                                                     ^ unclosed delimiter\n\
    53 | }\n   | ^ mismatched closing delimiter\n\nerror: expected expression, found\
    \ `)`\n  --> /tmp/tmpm3u2318g.rs:53:1\n   |\n53 | }\n   | ^ expected expression\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter =\
    \ dot_pos_start;\n    while dot_pos_start != dot_pos_end {\n        let mut dot_pos_start_letter\
    \ = dot_pos_start;\n        if dot_pos_start == dot_pos_end {\n            break;\n\
    \        }\n        let mut dot_pos_end_letter = dot_pos_end;\n        if dot_pos_end\
    \ == dot_pos_start {\n            dot_pos_end_letter += 1;\n        }\n      \
    \  let mut dot_pos_start_letter = dot_pos_start;\n        let mut dot_pos_end_letter\
    \ = dot_pos_end;\n        if dot_pos_start == dot_pos_end {\n            break;\n\
    \        }\n        let mut dot_pos_start_letter = dot_pos_start;\n        let\
    \ mut dot_pos_end_letter = dot_pos_end;\n        if dot_pos_start == dot_pos_end\
    \ {\n            break;\n        }\n        let mut dot_pos_start_letter = dot_pos_start;\n\
    \        let mut dot_pos_end_letter = dot_pos_end;\n        if dot_pos_start ==\
    \ dot_pos_end {\n            break;\n        }\n        let mut dot_pos_start_letter\
    \ = dot_pos_start;\n        let mut dot_pos_end_letter = dot_pos_end;\n      \
    \  if dot_pos_start == dot_pos_end {\n            break;\n        }\n        let\
    \ mut dot_pos_start_letter = dot_pos_start;\n        let mut dot_pos_end_letter\
    \ = dot_pos_end;\n        if dot_pos_start == dot_pos_end {\n            break;\n\
    \        }\n        let mut dot_pos_start_letter = dot_pos_start;\n        let\
    \ mut dot_pos_end_letter = dot_pos_end;\n        if dot_pos_start == dot_pos_end\
    \ {\n            break;\n        }\n        let mut dot_pos_start_letter = dot_pos_start;\n\
    \        let mut dot_pos_end_letter = dot_pos_end;\n        if dot_pos_start ==\
    \ dot_pos_end {\n            break;\n        }\n        let mut dot_pos_start_letter\
    \ = dot_pos_start;\n        let mut dot_pos_end_letter = dot_pos_end;\n      \
    \  if dot_pos_start == dot_pos_end {\n            break;\n        }\n        let\
    \ mut dot_pos_start_letter = dot_pos_start;\n        let mut dot_pos_end_letter\
    \ = dot_pos_end;\n        if dot_pos_start == dot_pos_end {\n            break;\n\
    \        }\n        let mut dot_pos_start_letter = dot_pos_start;\n        let\
    \ mut dot_pos_end_letter = dot_pos_end;\n        if dot_pos_start == dot_\n}\n\
    \nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp4ncie1l9.rs:109:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n22  |  \
    \   while dot_pos_start != dot_pos_end {\n    |                              \
    \          - this delimiter might not be properly closed...\n...\n79  | }\n  \
    \  | - ...as it matches this but it has different indentation\n...\n109 | }\n\
    \    |   ^\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp4ncie1l9.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp4ncie1l9.rs:79:1\n\
    \   |\n78 |         if dot_pos_start == dot_\n   |         -- this `if` expression\
    \ has a condition, but no block\n79 | }\n   | ^ expected `{`\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp4ncie1l9.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmp4ncie1l9.rs:19:35\n   |\n19 |     let mut dot_pos_end = dot_pos\
    \ + 1;\n   |                           ------- ^ - {integer}\n   |           \
    \                |\n   |                           Option<usize>\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp4ncie1l9.rs:20:37\n\
    \   |\n20 |     let mut dot_pos_start = dot_pos + 1;\n   |                   \
    \          ------- ^ - {integer}\n   |                             |\n   |   \
    \                          Option<usize>\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp4ncie1l9.rs:13:42\n   |\n13 | fn file_name_check(file_name: String)\
    \ -> String {\n   |    ---------------                       ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: abort"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name : String = \"\";\n    let mut dot_count\
    \ : usize = 0;\n    let mut first_letter : char;\n    let mut dot_letter : char;\n\
    \    let mut dot_dot_letter : char;\n    let mut dot_dot_dot_letter : char;\n\
    \    let mut dot_dot_dot_dot_letter : char;\n    let mut dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_letter : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_letter : char;\n    let\
    \ mut dot_dot_dot_dot_dot_dot_dot_dot_dot_letter : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter : char;\n\
    \    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter : char;\n    let\
    \ mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter : char;\n    let\
    \ mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter : char;\n   \
    \ let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter : char;\n\
    \    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_letter\
    \ : char;\n    let mut dot_dot_dot_dot_dot_dot_\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpokhi6v92.rs:41:37\n   |\n\
    41 |     let mut dot_dot_dot_dot_dot_dot_\n   |                              \
    \       ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpokhi6v92.rs:14:34\n   |\n14 |     let mut file_name\
    \ : String = \"\";\n   |                         ------   ^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                         |        |\n\
    \   |                         |        expected struct `String`, found `&str`\n\
    \   |                         expected due to this\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpokhi6v92.rs:13:42\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |    ---------------                       ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_pos_2 = file_name.find('.')\n    if\
    \ dot_pos_2 == String::npos { \n        return \"No\";\n    }\n    let mut dot_pos_3\
    \ = file_name.find('.')\n    if dot_pos_3 == String::npos { \n        return \"\
    No\";\n    }\n    let mut dot_pos_4 = file_name.find('.')\n    if dot_pos_4 ==\
    \ String::npos { \n        return \"No\";\n    }\n    let mut dot_pos_5 = file_name.find('.')\n\
    \    if dot_pos_5 == String::npos { \n        return \"No\";\n    }\n    let mut\
    \ dot_pos_6 = file_name.find('.')\n    if dot_pos_6 == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_pos_7 = file_name.find('.')\n    if\
    \ dot_pos_7 == String::npos { \n        return \"No\";\n    }\n    let mut dot_pos_8\
    \ = file_name.find('.')\n    if dot_pos_8 == String::npos { \n        return \"\
    No\";\n    }\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 ==\
    \ String::npos { \n        return \"No\";\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos { \n        return \"No\";\n    }\n    let\
    \ mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos { \n\
    \        return \"No\";\n    }\n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos { \n        return \"No\";\n    }\n    let\
    \ mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos { \n\
    \        return \"No\";\n    }\n    let mut dot_pos_14 = file_name.find('.')\n\
    \    if dot_pos_14 == String::npos { \n        return \"No\";\n    }\n    let\
    \ mut dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos { \n\
    \        return \"No\";\n    }\n    let mut dot_pos_16 = file_name.find('.')\n\
    \    if dot_pos_16 == String::npos { \n        return \"No\";\n    }\n    let\
    \ mut dot_pos_17 = file_name.find('.')\n    if dot_pos_17 == String::npos { \n\
    \        return \"No\";\n    }\n    let mut dot_pos_18 = file_name.find('.')\n\
    \    if dot_pos_18 == String::npos { \n        return \"No\n}\n\nfn main() {\n\
    \    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmpbjmezzj0.rs:91:40\n\
    \   |\n91 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n   --> /tmp/tmpbjmezzj0.rs:104:56\n    |\n104\
    \ |     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n    |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmpbjmezzj0.rs:115:63\n\
    \    |\n115 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    116 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut counter = 0;\n    let mut dot_count = 0;\n\
    \    let mut first_letter = false;\n    let mut dot_found = false;\n    let mut\
    \ dot_before_first_letter = false;\n    let mut dot_after_first_letter = false;\n\
    \    for c in file_name.chars() {\n        if c == '.' {\n            dot_found\
    \ = true;\n            dot_before_first_letter = true;\n            dot_after_first_letter\
    \ = true;\n            dot_count += 1;\n        } else if !dot_found {\n     \
    \       if c == '0' || c == '9' {\n                counter += 1;\n           \
    \ } else {\n                dot_found = false;\n            }\n        }\n   \
    \     if dot_count == 3 {\n            dot_found = false;\n            dot_before_first_letter\
    \ = false;\n            dot_after_first_letter = false;\n            dot_count\
    \ = 0;\n        }\n        if dot_count == 2 && dot_before_first_letter && dot_after_first_letter\
    \ {\n            dot_before_first_letter = false;\n            dot_after_first_letter\
    \ = false;\n            dot_count = 0;\n        }\n        if dot_count == 2 &&\
    \ dot_before_first_letter && !dot_after_first_letter {\n            dot_before_first_letter\
    \ = false;\n            dot_count = 0;\n        }\n        if dot_count == 2 &&\
    \ dot_after_first_letter && !dot_before_first_letter {\n            dot_after_first_letter\
    \ = false;\n            dot_count = 0;\n        }\n        if dot_count == 1 &&\
    \ !dot_before_first_letter && !dot_after_first_letter {\n            dot_before_first_letter\
    \ = false;\n            dot_after_first_letter = false;\n            dot_count\
    \ = 0;\n        }\n        if dot_count == 1 && !dot_before_first_letter && !dot_after_first_letter\
    \ {\n            dot_before_first_letter = false;\n            dot_count = 0;\n\
    \        }\n        if dot_count == 1 && !dot_before_first_letter && !dot_after_first_letter\
    \ {\n            dot_before_first_letter = false;\n            dot_count = 0;\n\
    \        }\n        if dot_count == 1 && !dot_before_first_letter && !dot_after_first_letter\
    \ {\n            dot_before_first_letter = false;\n            dot_count = 0;\n\
    \        }\n        if dot_count == 1 && !dot_before_first_letter && !dot_after_first_letter\
    \ {\n            dot_before_first_letter = false;\n            dot_count = 0;\n\
    \        }\n        if dot_count == 1 && !dot_before_first_letter && !dot_after_first_letter\
    \ {\n            dot_before_first_letter = false;\n            dot_count = 0;\n\
    \        }\n        if dot_count == 1 && !dot_before_first_letter && !dot_after_first_letter\
    \ {\n            dot_before_first_letter = false;\n            dot_count = 0;\n\
    \        }\n        if dot_count == 1 && !dot_before_first_letter && !dot_after_first_letter\
    \ {\n            dot_before_first_letter = false;\n            dot_count = 0;\n\
    \        }\n        if dot_count == 1 && !dot_before_first_letter && !dot_after_first_letter\
    \ {\n            dot_before_first_letter = false;\n            dot_count = 0;\n\
    \        }\n        if dot_count == 1 && !\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjxdmzfdk.rs:120:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n20  |  \
    \   for c in file_name.chars() {\n    |                                - this\
    \ delimiter might not be properly closed...\n...\n90  | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n120 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n  --> /tmp/tmpjxdmzfdk.rs:90:1\n   |\n90 | }\n   | ^\
    \ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjxdmzfdk.rs:13:42\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return String::from(\"No\");\n    }\n    if file_name.len() > 3 {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name.len() == 1 {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name[0] < 'a' || file_name[0]\
    \ > 'z' {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos\
    \ - 1] < 'a' || file_name[dot_pos - 1] > 'z' {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos] != 'txt' && file_name[dot_pos] != 'exe'\
    \ && file_name[dot_pos] != 'dll' {\n        return String::from(\"No\");\n   \
    \ }\n    return String::from(\"Yes\");\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpvk2zxboi.rs:31:30\n\
    \   |\n31 |     if file_name[dot_pos] != 'txt' && file_name[dot_pos] != 'exe'\
    \ && file_name[dot_pos] != 'dll' {\n   |                              ^^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    31 |     if file_name[dot_pos] != \"txt\" && file_name[dot_pos] != 'exe' && file_name[dot_pos]\
    \ != 'dll' {\n   |                              ~~~~~\n\nerror: character literal\
    \ may only contain one codepoint\n  --> /tmp/tmpvk2zxboi.rs:31:61\n   |\n31 |\
    \     if file_name[dot_pos] != 'txt' && file_name[dot_pos] != 'exe' && file_name[dot_pos]\
    \ != 'dll' {\n   |                                                           \
    \  ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n31 |     if file_name[dot_pos] != 'txt' && file_name[dot_pos] != \"exe\"\
    \ && file_name[dot_pos] != 'dll' {\n   |                                     \
    \                        ~~~~~\n\nerror: character literal may only contain one\
    \ codepoint\n  --> /tmp/tmpvk2zxboi.rs:31:92\n   |\n31 |     if file_name[dot_pos]\
    \ != 'txt' && file_name[dot_pos] != 'exe' && file_name[dot_pos] != 'dll' {\n \
    \  |                                                                         \
    \                   ^^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n31 |     if file_name[dot_pos] != 'txt' && file_name[dot_pos]\
    \ != 'exe' && file_name[dot_pos] != \"dll\" {\n   |                          \
    \                                                                  ~~~~~\n\nerror:\
    \ expected `;`, found keyword `if`\n  --> /tmp/tmpvk2zxboi.rs:15:42\n   |\n15\
    \ |     let mut dot_pos = file_name.find('.')\n   |                          \
    \                ^ help: add `;` here\n16 |     if dot_pos == String::npos { \n\
    \   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpvk2zxboi.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos { \n   |                          \
    \ ^^^^ function or associat"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name[dot_pos - 1] != String::from('0')\
    \ && file_name[dot_pos - 1] != String::from('9') {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos - 2] != String::from('0') && file_name[dot_pos\
    \ - 2] != String::from('9') {\n        return String::from(\"No\");\n    }\n \
    \   if file_name[dot_pos - 3] != String::from('0') && file_name[dot_pos - 3] !=\
    \ String::from('9') {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos\
    \ - 4] != String::from('0') && file_name[dot_pos - 4] != String::from('9') {\n\
    \        return String::from(\"No\");\n    }\n    if file_name[dot_pos - 5] !=\
    \ String::from('0') && file_name[dot_pos - 5] != String::from('9') {\n       \
    \ return String::from(\"No\");\n    }\n    if file_name[dot_pos - 6] != String::from('0')\
    \ && file_name[dot_pos - 6] != String::from('9') {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos - 7] != String::from('0') && file_name[dot_pos\
    \ - 7] != String::from('9') {\n        return String::from(\"No\");\n    }\n \
    \   if file_name[dot_pos - 8] != String::from('0') && file_name[dot_pos - 8] !=\
    \ String::from('9') {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos\
    \ - 9] != String::from('0') && file_name[dot_pos - 9] != String::from('9') {\n\
    \        return String::from(\"No\");\n    }\n    if file_name[dot_pos - 10] !=\
    \ String::from('0') && file_name[dot_pos - 10] != String::from('9') {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name[dot_pos - 11] != String::from('0')\
    \ && file_name[dot_pos - 11] != String::from('9') {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos - 12] != String::from('0') && file_name[dot_pos\
    \ - 12] != String::from('9') {\n        return String::from(\"No\");\n    }\n\
    \    if file_name[dot_\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpn0uxubk1.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpn0uxubk1.rs:56:1\n\
    \   |\n55 |     if file_name[dot_\n   |     -- this `if` expression has a condition,\
    \ but no block\n56 | }\n   | ^ expected `{`\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpn0uxubk1.rs:55:17\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                                 -\
    \ closing delimiter possibly meant for this\n...\n55 |     if file_name[dot_\n\
    \   |                 ^ unclosed delimiter\n56 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0599]: no function or associated item named `npos` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpn0uxubk1.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot subtract\
    \ `{integer}` from `Option<usize>`\n  --> /tmp/tmpn0uxubk1.rs:19:26\n   |\n19\
    \ |     if file_name[dot_pos - 1] != String::from('0') && file_name[dot_pos -\
    \ 1] != String::from('9') {\n   |                  ------- ^ - {integer}\n   |\
    \                  |\n   |                  Option<usize>\n\nerror[E0369]: cannot\
    \ subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpn0uxubk1.rs:19:73\n\
    \   |\n19 |     if file_name[dot_pos - 1] != String::from('0') && file_name[dot_pos\
    \ - 1] != String::from('9') {\n   |                                          \
    \                       ------- ^ - {integer}\n   |                          \
    \                                       |\n   |                              \
    \                                   Option<usize>\n\nerror[E0369]: cannot subtract\
    \ `{integer}` from `Option<usize>`\n  --> /tmp/tmpn0uxubk1.rs:22:26\n   |\n22\
    \ |     if file_name[dot_pos - 2] != String::from('0') && file_name[dot_pos -\
    \ 2] != String::from('9') {\n   |                  --"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_char: char;\n    let mut second_char:\
    \ char;\n    let mut third_char: char;\n    let mut fourth_char: char;\n    let\
    \ mut fifth_char: char;\n    let mut sixth_char: char;\n    let mut seventh_char:\
    \ char;\n    let mut eighth_char: char;\n    let mut ninth_char: char;\n    let\
    \ mut tenth_char: char;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = true;\n    let mut second_char_valid\
    \ = true;\n    let mut third_char_valid = true;\n    let mut fourth_char_valid\
    \ = true;\n    let mut fifth_char_valid = true;\n    let mut sixth_char_valid\
    \ = true;\n    let mut seventh_char_valid = true;\n    let mut eighth_char_valid\
    \ = true;\n    let mut ninth_char_valid = true;\n    let mut tenth_char_valid\
    \ = true;\n    let mut first_char_index = 0;\n    let mut second_char_index =\
    \ 0;\n    let mut third_char_index = 0;\n    let mut fourth_char_index = 0;\n\
    \    let mut fifth_char_index = 0;\n    let mut sixth_char_index = 0;\n    let\
    \ mut seventh_char_index = 0;\n    let mut eighth_char_index = 0;\n    let mut\
    \ ninth_char_index = 0;\n    let mut tenth_char_index = 0;\n    let mut first_char_string\
    \ = String::new();\n    let mut second_char_string = String::new();\n    let mut\
    \ third_char_string = String::new();\n    let mut fourth_char_string = String::new();\n\
    \    let mut fifth_char_string = String::new();\n    let mut sixth_char_string\
    \ = String::new();\n    let mut seventh_char_string = String::new();\n    let\
    \ mut eighth_char_string = String::new();\n    let mut ninth_char_string = String::new();\n\
    \    let mut tenth_char_string = String::new();\n    let mut first_char_string\
    \ = String::new();\n\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp28pwvpik.rs:13:42\n   |\n\
    13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_4 = file_name.find('.')\n\
    \    if dot_pos_4 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_6 = file_name.find('.')\n\
    \    if dot_pos_6 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_7 = file_name.find('.')\n    if dot_pos_7 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_8 = file_name.find('.')\n\
    \    if dot_pos_8 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_14 = file_name.find('.')\n\
    \    if dot_pos_14 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_16 = file_name.find('.')\n\
    \    if dot_pos_16 == String::npos {\n\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpx2uherot.rs:108:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n76  |  \
    \   if dot_pos_16 == String::npos {\n    |                                   -\
    \ this delimiter might not be properly closed...\n77  | \n78  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n108 | }\n    |   ^\n\n\
    error: expected `;`, found keyword `if`\n  --> /tmp/tmpx2uherot.rs:15:42\n   |\n\
    15 |     let mut dot_pos = file_name.find('.')\n   |                         \
    \                 ^ help: add `;` here\n16 |     if dot_pos == String::npos {\n\
    \   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmpx2uherot.rs:19:44\n   |\n19 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n20 |  \
    \   if dot_pos_2 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpx2uherot.rs:23:44\n   |\n23 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n24 |     if dot_pos_3 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpx2uherot.rs:27:44\n\
    \   |\n27 |     let mut dot_pos_4 = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n28 |     if dot_pos_4 == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpx2uherot.rs:31:44\n   |\n31 |     let mut dot_pos_5 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n32 |  \
    \   if dot_pos_5 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpx2uherot.rs:35:44\n   |\n35 |     let\
    \ mut dot_pos_6 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n36 |     if dot_pos_6 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: exp"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter =\
    \ String::new();\n    let mut dot_pos_end_letter = String::new();\n    let mut\
    \ dot_pos_start_letter_pos = 0;\n    let mut dot_pos_end_letter_pos = 0;\n   \
    \ let mut dot_pos_start_letter_pos_end = 0;\n    let mut dot_pos_end_letter_pos_end\
    \ = 0;\n    let mut dot_pos_start_letter_pos_end_end = 0;\n    let mut dot_pos_end_letter_pos_end_end\
    \ = 0;\n    let mut dot_pos_start_letter_pos_end_end_end = 0;\n    let mut dot_pos_end_letter_pos_end_end_end\
    \ = 0;\n    let mut dot_pos_start_letter_pos_end_end_end_end = 0;\n    let mut\
    \ dot_pos_end_letter_pos_end_end_end_end = 0;\n    let mut dot_pos_start_letter_pos_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_end_letter_pos_end_end_end_end_end = 0;\n    let mut\
    \ dot_pos_start_letter_pos_end_end_end_end_end_end = 0;\n    let mut dot_pos_end_letter_pos_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_start_letter_pos_end_end_end_end_end_end_end = 0;\n\
    \    let mut dot_pos_end_letter_pos_end_end_end_end_end_end_end = 0;\n    let\
    \ mut dot_pos_start_letter_pos_end_end_end_end_end_end_end_end = 0;\n    let mut\
    \ dot_pos_end_letter_pos_end_end_end_end_end_end_end_end = 0;\n    let mut dot_pos_start_letter_pos_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_end_letter_pos_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_start_letter_pos_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_end_letter_pos_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_start_letter_pos_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_end_letter_pos_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_start_letter_pos_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_end_letter_pos_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_start_letter_pos_\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpu2k0xb2e.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpu2k0xb2e.rs:49:38\n\
    \   |\n49 |     let mut dot_pos_start_letter_pos_\n   |                      \
    \                ^ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpu2k0xb2e.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpu2k0xb2e.rs:19:35\n   |\n19 |     let mut dot_pos_end = dot_pos\
    \ + 1;\n   |                           ------- ^ - {integer}\n   |           \
    \                |\n   |                           Option<usize>\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpu2k0xb2e.rs:20:37\n\
    \   |\n20 |     let mut dot_pos_start = dot_pos + 1;\n   |                   \
    \          ------- ^ - {integer}\n   |                             |\n   |   \
    \                          Option<usize>\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpu2k0xb2e.rs:13:42\n   |\n13 | fn file_name_check(file_name: String)\
    \ -> String {\n   |    ---------------                       ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { return \"\
    No\"; }\n    \n    let mut dot_pos_1 = dot_pos;\n    let mut dot_pos_2 = dot_pos;\n\
    \    \n    while dot_pos_2 != String::npos {\n        if dot_pos_2 != dot_pos_1\
    \ + 1 {\n            if dot_pos_2 != dot_pos_1 + 2 {\n                if dot_pos_2\
    \ != dot_pos_1 + 3 {\n                    dot_pos_2 = String::npos;\n        \
    \        } else {\n                    dot_pos_2 = dot_pos_2 + 1;\n          \
    \      }\n            } else {\n                dot_pos_2 = dot_pos_2 + 1;\n \
    \           }\n        } else {\n            dot_pos_2 = dot_pos_2 + 1;\n    \
    \    }\n        dot_pos_1 = dot_pos_2;\n    }\n    \n    if dot_pos_1 != dot_pos\
    \ {\n        return \"No\";\n    } else {\n        return \"Yes\";\n    }\n}\n\
    \nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpqc8jzhr1.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ { return \"No\"; }\n   |     -- unexpected token\n\nerror[E0599]: no function\
    \ or associated item named `npos` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpqc8jzhr1.rs:16:27\n   |\n16 |     if dot_pos == String::npos {\
    \ return \"No\"; }\n   |                           ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqc8jzhr1.rs:16:41\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n16 |     if dot_pos == String::npos { return \"No\"; }\n   |            \
    \                             ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                         |\n   |                        \
    \                 expected struct `String`, found `&str`\n\nerror[E0599]: no function\
    \ or associated item named `npos` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpqc8jzhr1.rs:21:32\n   |\n21 |     while dot_pos_2 != String::npos\
    \ {\n   |                                ^^^^ function or associated item not\
    \ found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpqc8jzhr1.rs:22:35\n   |\n22 |         if dot_pos_2 != dot_pos_1\
    \ + 1 {\n   |                         --------- ^ - {integer}\n   |          \
    \               |\n   |                         Option<usize>\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpqc8jzhr1.rs:23:39\n\
    \   |\n23 |             if dot_pos_2 != dot_pos_1 + 2 {\n   |                \
    \             --------- ^ - {integer}\n   |                             |\n  \
    \ |                             Option<usize>\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmpqc8jzhr1.rs:24:43\n   |\n24 |            \
    \     if dot_pos_2 != dot_pos_1 + 3 {\n   |        "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_pos_2 = file_name.find('.')\n    if\
    \ dot_pos_2 == String::npos { \n        return \"No\";\n    }\n    if dot_pos_2\
    \ > dot_pos + 1 {\n        return \"No\";\n    }\n    let mut dot_pos_3 = file_name.find('.')\n\
    \    if dot_pos_3 == String::npos { \n        return \"No\";\n    }\n    if dot_pos_3\
    \ > dot_pos_2 + 1 {\n        return \"No\";\n    }\n    let mut dot_pos_4 = file_name.find('.')\n\
    \    if dot_pos_4 == String::npos { \n        return \"No\";\n    }\n    if dot_pos_4\
    \ > dot_pos_3 + 1 {\n        return \"No\";\n    }\n    let mut dot_pos_5 = file_name.find('.')\n\
    \    if dot_pos_5 == String::npos { \n        return \"No\";\n    }\n    if dot_pos_5\
    \ > dot_pos_4 + 1 {\n        return \"No\";\n    }\n    let mut dot_pos_6 = file_name.find('.')\n\
    \    if dot_pos_6 == String::npos { \n        return \"No\";\n    }\n    if dot_pos_6\
    \ > dot_pos_5 + 1 {\n        return \"No\";\n    }\n    let mut dot_pos_7 = file_name.find('.')\n\
    \    if dot_pos_7 == String::npos { \n        return \"No\";\n    }\n    if dot_pos_7\
    \ > dot_pos_6 + 1 {\n        return \"No\";\n    }\n    let mut dot_pos_8 = file_name.find('.')\n\
    \    if dot_pos_8 == String::npos { \n        return \"No\";\n    }\n    if dot_pos_8\
    \ > dot_pos_7 + 1 {\n        return \"No\";\n    }\n    let mut dot_pos_9 = file_name.find('.')\n\
    \    if dot_pos_9 == String::npos { \n        return \"No\";\n    }\n    if dot_pos_9\
    \ > dot_pos_8 + 1 {\n        return \"No\";\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos { \n        return \"No\";\n    }\n    if dot_pos_10\
    \ > dot_pos_9 + 1 {\n        return \"No\";\n    }\n    let mut dot_pos_11 = file_name.find('.')\n\
    \    if dot_pos_11 == String::npos { \n        return \"No\";\n    }\n    if dot_pos_11\
    \ > dot_pos_10 + 1 {\n        return \"No\";\n    }\n    let mut dot_pos_12 =\
    \ file_name.find('.')\n    if dot_pos_12 == String::npos { \n        return \"\
    No\";\n    }\n    if dot_pos_12 > \n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpd6_w6b2c.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ { \n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpd6_w6b2c.rs:19:44\n   |\n19 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n20 |  \
    \   if dot_pos_2 == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpd6_w6b2c.rs:26:44\n   |\n26 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n27 |     if dot_pos_3 == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmpd6_w6b2c.rs:33:44\n   |\n33 |     let mut dot_pos_4 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n34 |  \
    \   if dot_pos_4 == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpd6_w6b2c.rs:40:44\n   |\n40 |     let\
    \ mut dot_pos_5 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n41 |     if dot_pos_5 == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmpd6_w6b2c.rs:47:44\n   |\n47 |     let mut dot_pos_6 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n48 |  \
    \   if dot_pos_6 == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpd6_w6b2c.rs:54:44\n   |\n54 |     let\
    \ mut dot_pos_7 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n55 |     if dot_pos_7 == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmpd6_w6b2c.rs:61:44\n   |\n61 |     let mut dot_pos_8 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` he"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return String::from(\"No\");\n    }\n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_4 = file_name.find('.')\n\
    \    if dot_pos_4 == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_6 = file_name.find('.')\n\
    \    if dot_pos_6 == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_7 = file_name.find('.')\n    if dot_pos_7 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_8 = file_name.find('.')\n\
    \    if dot_pos_8 == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos { \n        return String::from(\"No\");\n\
    \    }\n    let mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos { \n        return String::from(\"No\");\n\
    \    }\n    let mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_14 = file_name.find('.')\n\
    \    if dot_pos_14 == String::npos { \n        return String::from(\"No\");\n\
    \    }\n    let mut dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_16 = file_name.find('.')\n\
    \    if dot_pos_16 == String::npos { \n\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpr42wytfv.rs:108:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n76  |  \
    \   if dot_pos_16 == String::npos { \n    |                                  \
    \ - this delimiter might not be properly closed...\n77  | \n78  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n108 | }\n    |   ^\n\n\
    error: expected `;`, found keyword `if`\n  --> /tmp/tmpr42wytfv.rs:15:42\n   |\n\
    15 |     let mut dot_pos = file_name.find('.')\n   |                         \
    \                 ^ help: add `;` here\n16 |     if dot_pos == String::npos {\
    \ \n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpr42wytfv.rs:19:44\n   |\n19 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n20 |  \
    \   if dot_pos_2 == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpr42wytfv.rs:23:44\n   |\n23 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n24 |     if dot_pos_3 == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmpr42wytfv.rs:27:44\n   |\n27 |     let mut dot_pos_4 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n28 |  \
    \   if dot_pos_4 == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpr42wytfv.rs:31:44\n   |\n31 |     let\
    \ mut dot_pos_5 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n32 |     if dot_pos_5 == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmpr42wytfv.rs:35:44\n   |\n35 |     let mut dot_pos_6 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n36 |  \
    \   if dot_pos_6 == String::npos { \n   |     -- unexpected token\n\nerr"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_letter = file_name.chars().next().unwrap();\n\
    \    if first_letter >= 'a' && first_letter <= 'z' {\n        first_letter = first_letter\
    \ - 'a' + 1;\n    }\n    if first_letter >= 'A' && first_letter <= 'Z' {\n   \
    \     first_letter = first_letter - 'A' + 1;\n    }\n    if file_name.chars().count()\
    \ > 3 {\n        return \"No\";\n    }\n    if file_name.chars().count() == 1\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().count() == 2 && file_name.chars().next().unwrap()\
    \ == '.' {\n        return \"No\";\n    }\n    if file_name.chars().count() ==\
    \ 2 && file_name.chars().next().unwrap() == '.' {\n        return \"No\";\n  \
    \  }\n    if file_name.chars().count() == 2 && file_name.chars().next().unwrap()\
    \ == '.' {\n        return \"No\";\n    }\n    if file_name.chars().count() ==\
    \ 2 && file_name.chars().next().unwrap() == '.' {\n        return \"No\";\n  \
    \  }\n    if file_name.chars().count() == 2 && file_name.chars().next().unwrap()\
    \ == '.' {\n        return \"No\";\n    }\n    if file_name.chars().count() ==\
    \ 2 && file_name.chars().next().unwrap() == '.' {\n        return \"No\";\n  \
    \  }\n    if file_name.chars().count() == 2 && file_name.chars().next().unwrap()\
    \ == '.' {\n        return \"No\";\n    }\n    if file_name.chars().count() ==\
    \ 2 && file_name.chars().next().unwrap() == '.' {\n        return \"No\";\n  \
    \  }\n    if file_name.chars().count() == 2 && file_name.chars().next().unwrap()\
    \ == '.' {\n        return \"No\";\n    }\n    if file_name.chars().count() ==\
    \ 2 && file_name.chars().next().unwrap() == '.' {\n        return \"No\";\n  \
    \  }\n    if file_name.chars().count() == 2 && file_name.chars().next().unwrap()\
    \ == '.' {\n        return \"No\";\n    }\n    if file_name.chars().count() ==\
    \ 2 && file_name.chars().next().unwrap() == '.' {\n        return \"No\";\n  \
    \  }\n    if file_name.chars().count() == 2 && file_name.chars().next().unwrap()\
    \ == '.' {\n        return \"No\";\n    }\n    if file_name.chars().count() ==\
    \ 2 && file_name.chars().next().unwrap() == '.' {\n        return \"No\";\n  \
    \  }\n    if file_name.chars().count() == 2 && file_name.chars().next().unwrap()\
    \ == '.' {\n        return \"No\";\n    }\n    if file_name.chars().count() ==\
    \ 2 && file_name.chars().next().unwrap() == '.' {\n        return \"No\";\n  \
    \  }\n    if file_name.chars().count() == 2 && file_name.chars().\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpearxyk6w.rs:76:1\n   |\n76\
    \ | }\n   | ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpearxyk6w.rs:76:1\n\
    \   |\n75 |     if file_name.chars().count() == 2 && file_name.chars().\n   |\
    \     -- this `if` expression has a condition, but no block\n76 | }\n   | ^ expected\
    \ `{`\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpearxyk6w.rs:16:37\n\
    \   |\n16 |         first_letter = first_letter - 'a' + 1;\n   |             \
    \           ------------ ^ --- char\n   |                        |\n   |     \
    \                   char\n\nerror[E0369]: cannot subtract `char` from `char`\n\
    \  --> /tmp/tmpearxyk6w.rs:19:37\n   |\n19 |         first_letter = first_letter\
    \ - 'A' + 1;\n   |                        ------------ ^ --- char\n   |      \
    \                  |\n   |                        char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpearxyk6w.rs:22:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n22 |         return \"No\";\n   |    \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \               |\n   |                expected struct `String`, found `&str`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos { \n \
    \       return \"No\";\n    }\n    let mut dot_index = file_name.find('.')\n \
    \   if dot_index == String::npos { \n        return \"No\";\n    }\n    let mut\
    \ dot_index = file_name.find('.')\n    if dot_index == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_index = file_name.find('.')\n    if\
    \ dot_index == String::npos { \n        return \"No\";\n    }\n    let mut dot_index\
    \ = file_name.find('.')\n    if dot_index == String::npos { \n        return \"\
    No\";\n    }\n    let mut dot_index = file_name.find('.')\n    if dot_index ==\
    \ String::npos { \n        return \"No\";\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\";\n    }\n    let mut\
    \ dot_index = file_name.find('.')\n    if dot_index == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_index = file_name.find('.')\n    if\
    \ dot_index == String::npos { \n        return \"No\";\n    }\n    let mut dot_index\
    \ = file_name.find('.')\n    if dot_index == String::npos { \n        return \"\
    No\";\n    }\n    let mut dot_index = file_name.find('.')\n    if dot_index ==\
    \ String::npos { \n        return \"No\";\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\";\n    }\n    let mut\
    \ dot_index = file_name.find('.')\n    if dot_index == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_index = file_name.find('.')\n    if\
    \ dot_index == String::npos { \n        return \"No\";\n    }\n    let mut dot_index\
    \ = file_name.find('.')\n    if dot_index == String::npos { \n        return \"\
    No\";\n    }\n    let mut dot_index = file_name.find('.')\n    if dot_index ==\
    \ String::npos { \n        return \"No\";\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\";\n    }\n    let mut\
    \ dot_index = file_name.find('.')\n    if dot_index == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_index = file_name.find('.')\n    if\
    \ dot_index == String::npos { \n        return \"No\";\n    }\n    let mut dot_index\
    \ = file_name.find('\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp7bipldu8.rs:91:40\n\
    \   |\n91 |     let mut dot_index = file_name.find('\n   |                   \
    \                     ^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_char: char;\n    let mut last_char: char;\n\
    \    let mut dot_index: usize;\n    let mut dot_count: usize;\n    let mut dot_dot_index:\
    \ usize;\n    let mut dot_dot_count: usize;\n    let mut dot_dot_dot_index: usize;\n\
    \    let mut dot_dot_dot_count: usize;\n    let mut dot_dot_dot_dot_index: usize;\n\
    \    let mut dot_dot_dot_dot_count: usize;\n    let mut dot_dot_dot_dot_dot_index:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_count: usize;\n    let mut dot_dot_dot_dot_dot_dot_index:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_count: usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_index:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_count: usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_index:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_count: usize;\n    let mut\
    \ dot_dot_dot_dot_dot_dot_dot_dot_dot_index: usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_count:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_index: usize;\n\
    \    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_count: usize;\n    let mut\
    \ dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_index: usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_count:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_index: usize;\n\
    \    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_count: usize;\n\
    \    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_index: usize;\n\
    \    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_count:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_index:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_count:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_index:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_count:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph7tm17od.rs:46:81\n   |\n\
    46 |     let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_\n\
    \   |                                                                        \
    \         ^ help: add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph7tm17od.rs:13:42\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |    ---------------                       ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_pos = dot_pos + 1;\n    while dot_pos\
    \ < file_name.len() {\n        let mut dot_pos = file_name.find('.', dot_pos);\n\
    \        if dot_pos == String::npos { \n            return \"No\";\n        }\n\
    \        let mut dot_pos = dot_pos + 1;\n        let mut dot_pos = file_name.find('.',\
    \ dot_pos);\n        if dot_pos == String::npos { \n            return \"No\"\
    ;\n        }\n        let mut dot_pos = dot_pos + 1;\n        let mut dot_pos\
    \ = file_name.find('.', dot_pos);\n        if dot_pos == String::npos { \n   \
    \         return \"No\";\n        }\n        let mut dot_pos = dot_pos + 1;\n\
    \        let mut dot_pos = file_name.find('.', dot_pos);\n        if dot_pos ==\
    \ String::npos { \n            return \"No\";\n        }\n        let mut dot_pos\
    \ = dot_pos + 1;\n        let mut dot_pos = file_name.find('.', dot_pos);\n  \
    \      if dot_pos == String::npos { \n            return \"No\";\n        }\n\
    \        let mut dot_pos = dot_pos + 1;\n        let mut dot_pos = file_name.find('.',\
    \ dot_pos);\n        if dot_pos == String::npos { \n            return \"No\"\
    ;\n        }\n        let mut dot_pos = dot_pos + 1;\n        let mut dot_pos\
    \ = file_name.find('.', dot_pos);\n        if dot_pos == String::npos { \n   \
    \         return \"No\";\n        }\n        let mut dot_pos = dot_pos + 1;\n\
    \        let mut dot_pos = file_name.find('.', dot_pos);\n        if dot_pos ==\
    \ String::npos { \n            return \"No\";\n        }\n        let mut dot_pos\
    \ = dot_pos + 1;\n        let mut dot_pos = file_name.find('.', dot_pos);\n  \
    \      if dot_pos == String::npos { \n            return \"No\";\n        }\n\
    \        let mut dot_pos = dot_pos + 1;\n        let mut dot_pos = file_name.find('.',\
    \ dot_pos);\n        if dot_pos == String::npos { \n            return \"No\"\
    ;\n        }\n        let mut dot_pos = dot_pos + 1;\n        let mut dot_pos\
    \ = file_name.find('.', dot_pos);\n        if dot_pos == String::npos { \n   \
    \         return \"No\";\n        }\n        let mut dot_pos = dot_pos + 1;\n\
    \        let mut dot_pos = file_name.find('.', dot_pos);\n        if dot_pos ==\
    \ String::npos { \n            return \"No\";\n        }\n}\n\nfn main() {\n \
    \   let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpmsxkdxro.rs:110:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n20  |  \
    \   while dot_pos < file_name.len() {\n    |                                 \
    \    - this delimiter might not be properly closed...\n...\n80  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n110 | }\n    |   ^\n\n\
    error: expected `;`, found keyword `if`\n  --> /tmp/tmpmsxkdxro.rs:15:42\n   |\n\
    15 |     let mut dot_pos = file_name.find('.')\n   |                         \
    \                 ^ help: add `;` here\n16 |     if dot_pos == String::npos {\
    \ \n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpmsxkdxro.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos { \n   |                          \
    \ ^^^^ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmsxkdxro.rs:17:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n17 |         return \"No\";\n   |    \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \               |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpmsxkdxro.rs:19:31\n\
    \   |\n19 |     let mut dot_pos = dot_pos + 1;\n   |                       -------\
    \ ^ - {integer}\n   |                       |\n   |                       Option<usize>\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpmsxkdxro.rs:21:37\n     |\n21   |         let mut dot_pos = file_name.find('.',\
    \ dot_pos);\n     |                                     ^^^^ ---  ------- supplied\
    \ 2 arguments\n     |                                     |\n     |          \
    \                           expected 1 argument\n     |\nnote: associated function\
    \ def"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\"\n    }\n    let mut dot_pos_end = dot_pos;\n    let mut dot_pos_start\
    \ = dot_pos;\n    while dot_pos_start != dot_pos_end {\n        let mut dot_pos_start\
    \ = dot_pos_end;\n        let mut dot_pos_end = dot_pos_end;\n        let mut\
    \ dot_pos_end = dot_pos_end.next_char();\n        if dot_pos_end == String::npos\
    \ { \n            dot_pos_end = file_name.len();\n        }\n        if dot_pos_end\
    \ < dot_pos_start {\n            dot_pos_end = dot_pos_end;\n        }\n     \
    \   if dot_pos_end < 3 {\n            dot_pos_end = dot_pos_end;\n        }\n\
    \        if dot_pos_end < dot_pos_start {\n            dot_pos_end = dot_pos_end;\n\
    \        }\n        if dot_pos_end < dot_pos_start {\n            dot_pos_end\
    \ = dot_pos_end;\n        }\n        if dot_pos_end < dot_pos_start {\n      \
    \      dot_pos_end = dot_pos_end;\n        }\n        if dot_pos_end < dot_pos_start\
    \ {\n            dot_pos_end = dot_pos_end;\n        }\n        if dot_pos_end\
    \ < dot_pos_start {\n            dot_pos_end = dot_pos_end;\n        }\n     \
    \   if dot_pos_end < dot_pos_start {\n            dot_pos_end = dot_pos_end;\n\
    \        }\n        if dot_pos_end < dot_pos_start {\n            dot_pos_end\
    \ = dot_pos_end;\n        }\n        if dot_pos_end < dot_pos_start {\n      \
    \      dot_pos_end = dot_pos_end;\n        }\n        if dot_pos_end < dot_pos_start\
    \ {\n            dot_pos_end = dot_pos_end;\n        }\n        if dot_pos_end\
    \ < dot_pos_start {\n            dot_pos_end = dot_pos_end;\n        }\n     \
    \   if dot_pos_end < dot_pos_start {\n            dot_pos_end = dot_pos_end;\n\
    \        }\n        if dot_pos_end < dot_pos_start {\n            dot_pos_end\
    \ = dot_pos_end;\n        }\n        if dot_pos_end < dot_pos_start {\n      \
    \      dot_pos_end = dot_pos_end;\n        }\n        if dot_pos_end < dot_pos_start\
    \ {\n            dot_pos_end = dot_pos_end;\n        }\n        if dot_pos_end\
    \ < dot_pos_start {\n            dot_pos_end = dot_pos_end;\n        }\n     \
    \   if dot_pos_end < dot_pos_start {\n            dot_pos_end = dot_pos_end;\n\
    \        }\n        if dot_pos_end < dot_pos_start {\n            dot_pos_end\
    \ = dot_pos_end;\n        }\n        if dot_pos_end < dot_pos_start {\n      \
    \      dot_pos_end = \n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9e6pj38y.rs:117:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n21  |  \
    \   while dot_pos_start != dot_pos_end {\n    |                              \
    \          - unclosed delimiter\n...\n85  |         if dot_pos_end < dot_pos_start\
    \ {\n    |                                        - this delimiter might not be\
    \ properly closed...\n86  |             dot_pos_end = \n87  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n117 | }\n    |   ^\n\n\
    error: expected `;`, found keyword `if`\n  --> /tmp/tmp9e6pj38y.rs:15:42\n   |\n\
    15 |     let mut dot_pos = file_name.find('.')\n   |                         \
    \                 ^ help: add `;` here\n16 |     if dot_pos == String::npos {\
    \ \n   |     -- unexpected token\n\nerror: expected expression, found `}`\n  -->\
    \ /tmp/tmp9e6pj38y.rs:87:1\n   |\n87 | }\n   | ^ expected expression\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp9e6pj38y.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos { \n   |                           ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9e6pj38y.rs:17:16\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n17 |         return \"No\"\n   |                ^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&str`\n\nerror[E0599]: no method named `next_char` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmp9e6pj38y.rs:24:43\n  \
    \ |\n24 |         let mut dot_pos_end = dot_pos_end.next_char();\n   |       \
    \                                    ^^^^^^^^^ method not found in `Option<usize>`\n\
    \nerror[E0599]: no function or associated item named `npos` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp9"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name_chars = file_name.chars();\n    let\
    \ mut dot_pos = file_name_chars.next().unwrap().unwrap();\n    let mut dot_pos_is_empty\
    \ = true;\n    let mut dot_pos_is_first_letter = true;\n    let mut dot_pos_is_last_letter\
    \ = true;\n    let mut dot_pos_is_last_letter_in_range = true;\n    let mut dot_pos_is_last_letter_in_range_in_range\
    \ = true;\n    let mut dot_pos_is_last_letter_in_range_in_range_in_range = true;\n\
    \    let mut dot_pos_is_last_letter_in_range_in_range_in_range_in_range = true;\n\
    \    let mut dot_pos_is_last_letter_in_range_in_range_in_range_in_range_in_range\
    \ = true;\n    let mut dot_pos_is_last_letter_in_range_in_range_in_range_in_range_in_range_in_range\
    \ = true;\n    let mut dot_pos_is_last_letter_in_range_in_range_in_range_in_range_in_range_in_range_in_range\
    \ = true;\n    let mut dot_pos_is_last_letter_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range\
    \ = true;\n    let mut dot_pos_is_last_letter_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range\
    \ = true;\n    let mut dot_pos_is_last_letter_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range\
    \ = true;\n    let mut dot_pos_is_last_letter_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range\
    \ = true;\n    let mut dot_pos_is_last_letter_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range\
    \ = true;\n    let mut dot_pos_is_last_letter_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range\
    \ = true;\n    let mut dot_pos_is_last_letter_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range\
    \ = true;\n    let mut dot_pos_is_last_letter_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range\
    \ = true;\n    let mut dot_pos_is_last_letter_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range\
    \ = true;\n    let mut dot_pos_is_last_letter_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range_in_range\
    \ = true;\n    let mut dot_pos_is_last_letter\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8k2dsmyf.rs:36:35\n   |\n\
    36 |     let mut dot_pos_is_last_letter\n   |                                \
    \   ^ help: add `;` here\n37 | }\n   | - unexpected token\n\nerror[E0599]: no\
    \ method named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmp8k2dsmyf.rs:15:55\n\
    \   |\n15 |     let mut dot_pos = file_name_chars.next().unwrap().unwrap();\n\
    \   |                                                       ^^^^^^ method not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8k2dsmyf.rs:13:42\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    if file_name.len() > 3 {\n        return \"No\"\
    ;\n    }\n    if file_name.len() == 3 {\n        if file_name[0] < 'a' || file_name[0]\
    \ > 'z' {\n            return \"No\";\n        }\n    }\n    if file_name[dot_pos\
    \ - 1] < 'a' || file_name[dot_pos - 1] > 'z' {\n        return \"No\";\n    }\n\
    \    if file_name[dot_pos + 1] < 'a' || file_name[dot_pos + 1] > 'z' {\n     \
    \   return \"No\";\n    }\n    if file_name[dot_pos + 2] != \"txt\" && file_name[dot_pos\
    \ + 2] != \"exe\" && file_name[dot_pos + 2] != \"dll\" {\n        return \"No\"\
    ;\n    }\n    return \"Yes\";\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmph70znjra.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ { \n   |     -- unexpected token\n\nerror[E0599]: no function or associated\
    \ item named `npos` found for struct `String` in the current scope\n  --> /tmp/tmph70znjra.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos { \n   |                          \
    \ ^^^^ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph70znjra.rs:17:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n17 |         return \"No\";\n   |    \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \               |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmph70znjra.rs:23:12\n\
    \   |\n23 |         if file_name[0] < 'a' || file_name[0] > 'z' {\n   |      \
    \      ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmph70znjra.rs:23:34\n\
    \   |\n23 |         if file_name[0] < 'a' || file_name[0] > 'z' {\n   |      \
    \                            ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n    "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { return \"\
    No\" }\n    else if dot_pos == 0 { return \"No\" }\n    else if file_name[dot_pos\
    \ - 1] == '.' { return \"No\" }\n    else if file_name[dot_pos - 1] < 'a' || file_name[dot_pos\
    \ - 1] > 'z' { return \"No\" }\n    else if file_name[dot_pos - 1] == '.' {\n\
    \        let dot_pos_2 = file_name.find('.')\n        if dot_pos_2 == String::npos\
    \ { return \"No\" }\n        else if dot_pos_2 == 0 { return \"No\" }\n      \
    \  else if file_name[dot_pos_2 - 1] < 'a' || file_name[dot_pos_2 - 1] > 'z' {\
    \ return \"No\" }\n        else if file_name[dot_pos_2 - 1] == '.' {\n       \
    \     let dot_pos_3 = file_name.find('.')\n            if dot_pos_3 == String::npos\
    \ { return \"No\" }\n            else if dot_pos_3 == 0 { return \"No\" }\n  \
    \          else if file_name[dot_pos_3 - 1] < 'a' || file_name[dot_pos_3 - 1]\
    \ > 'z' { return \"No\" }\n            else if file_name[dot_pos_3 - 1] == '.'\
    \ {\n                let dot_pos_4 = file_name.find('.')\n                if dot_pos_4\
    \ == String::npos { return \"No\" }\n                else if dot_pos_4 == 0 {\
    \ return \"No\" }\n                else if file_name[dot_pos_4 - 1] < 'a' || file_name[dot_pos_4\
    \ - 1] > 'z' { return \"No\" }\n                else if file_name[dot_pos_4 -\
    \ 1] == '.' {\n                    let dot_pos_5 = file_name.find('.')\n     \
    \               if dot_pos_5 == String::npos { return \"No\" }\n             \
    \       else if dot_pos_5 == 0 { return \"No\" }\n                    else if\
    \ file_name[dot_pos_5 - 1] < 'a' || file_name[dot_pos_5 - 1] > 'z' { return \"\
    No\" }\n                    else if file_name[dot_pos_5 - 1] == '.' {\n      \
    \                  let dot_pos_6 = file_name.find('.')\n                     \
    \   if dot_pos_6 == String::npos { return \"No\" }\n                        else\
    \ if dot_pos_6 == 0 { return \"No\" }\n                        else if file_name[dot_pos_6\
    \ - 1] < 'a' || file_name[dot_pos_6 - 1] > 'z' { return \"No\" }\n           \
    \             else if file_name[dot_pos_6 - 1] == '.' {\n                    \
    \        let dot_pos_7 = file_name.find('.')\n                            if dot_pos_7\
    \ == String::npos { return \"No\" }\n                            else if dot_\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpz90fmst1.rs:79:3\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n20 |     else\
    \ if file_name[dot_pos - 1] == '.' {\n   |                                   \
    \        - unclosed delimiter\n...\n25 |         else if file_name[dot_pos_2 -\
    \ 1] == '.' {\n   |                                                 - unclosed\
    \ delimiter\n...\n30 |             else if file_name[dot_pos_3 - 1] == '.' {\n\
    \   |                                                     - unclosed delimiter\n\
    ...\n35 |                 else if file_name[dot_pos_4 - 1] == '.' {\n   |    \
    \                                                     - unclosed delimiter\n...\n\
    40 |                     else if file_name[dot_pos_5 - 1] == '.' {\n   |     \
    \                                                        - unclosed delimiter\n\
    ...\n45 |                         else if file_name[dot_pos_6 - 1] == '.' {\n\
    \   |                                                                 - this delimiter\
    \ might not be properly closed...\n...\n49 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n79 | }\n   |   ^\n\nerror: expected `;`,\
    \ found keyword `if`\n  --> /tmp/tmpz90fmst1.rs:15:42\n   |\n15 |     let mut\
    \ dot_pos = file_name.find('.')\n   |                                        \
    \  ^ help: add `;` here\n16 |     if dot_pos == String::npos { return \"No\" }\n\
    \   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmpz90fmst1.rs:21:44\n   |\n21 |         let dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n22 |  \
    \       if dot_pos_2 == String::npos { return \"No\" }\n   |         -- unexpected\
    \ token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpz90fmst1.rs:26:48\n\
    \   |\n26 |             let dot_pos_3 = file_name.find('.')\n   |            \
    \                                    ^ help: add `;` here\n27 |             if\
    \ dot_pos_3 == String::npos { return \"No\" }\n   |             -- un"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return \"No\";\n    }\n    \n    if file_name[dot_pos - 1] == '0' {\n     \
    \   return \"No\";\n    }\n    \n    if file_name[dot_pos - 1] == '9' {\n    \
    \    return \"No\";\n    }\n    \n    if file_name[dot_pos - 1] != '.' {\n   \
    \     return \"No\";\n    }\n    \n    if file_name[dot_pos - 1] != file_name[dot_pos\
    \ - 1].chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z').count()\
    \ > 0 {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 1] !=\
    \ file_name[dot_pos - 1].chars().filter(|c| c == '.' || c == '_').count() > 0\
    \ {\n        return \"No\";\n    }\n    \n    if file_name[dot_pos - 1] != file_name[dot_pos\
    \ - 1].chars().filter(|c| c == '_' || c == '.').count() > 0 {\n        return\
    \ \"No\";\n    }\n    \n    if file_name[dot_pos - 1] != file_name[dot_pos - 1].chars().filter(|c|\
    \ c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '_' || c == '.').count()\
    \ > 0 {\n        return \"No\";\n    }\n    \n    return \"Yes\";\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp38e91ceo.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: comparison operators cannot be chained\n\
    \  --> /tmp/tmp38e91ceo.rs:32:31\n   |\n32 |     if file_name[dot_pos - 1] !=\
    \ file_name[dot_pos - 1].chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' &&\
    \ c <= 'Z').count() > 0 {\n   |                               ^^             \
    \                                                                            \
    \        ^\n   |\n   = help: use `::<...>` instead of `<...>` to specify lifetime,\
    \ type, or const arguments\n   = help: or use `(...)` if you meant to specify\
    \ fn arguments\n\nerror[E0599]: no function or associated item named `npos` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp38e91ceo.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp38e91ceo.rs:17:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n17 |         return \"No\";\n   |    \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \               |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmp38e91ceo.rs:20:26\n\
    \   |\n20 |     if file_name[dot_pos - 1] == '0' {\n   |                  -------\
    \ ^ - {integer}\n   |                  |\n   |                  Option<usize>\n\
    \nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmp38e91ceo.rs:24:26\n\
    \   |\n24 |     if file_name[dot_pos - 1] == '9' {\n   |                  -------\
    \ ^ - {integer}\n   |                  |\n   |                  Option<usize>\n\
    \nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmp38e91ceo.rs:28:26\n\
    \   |"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_letter = file_name[0];\n    if first_letter\
    \ >= 'a' && first_letter <= 'z' {\n        first_letter += 'A' - 'a';\n    }\n\
    \    if file_name.len() > 3 {\n        return String::from(\"No\");\n    }\n \
    \   if file_name.len() == 0 {\n        return String::from(\"No\");\n    }\n \
    \   if file_name.len() == 1 {\n        return String::from(\"No\");\n    }\n \
    \   if file_name.len() == 2 && file_name[1] != '.' {\n        return String::from(\"\
    No\");\n    }\n    if file_name.len() == 2 && file_name[1] == '.' {\n        if\
    \ file_name[0] >= 'a' && file_name[0] <= 'z' {\n            first_letter += 'A'\
    \ - 'a';\n        }\n        if file_name[0] >= 'A' && file_name[0] <= 'Z' {\n\
    \            first_letter += 'a' - 'A';\n        }\n        if file_name[0] >=\
    \ '0' && file_name[0] <= '9' {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if file_name.len() == 2 && file_name[1] == '.' && file_name[0]\
    \ >= 'a' && file_name[0] <= 'z' {\n        first_letter += 'A' - 'a';\n    }\n\
    \    if file_name.len() == 2 && file_name[1] == '.' && file_name[0] >= 'A' &&\
    \ file_name[0] <= 'Z' {\n        first_letter += 'a' - 'A';\n    }\n    if file_name.len()\
    \ == 2 && file_name[1] == '.' && file_name[0] >= '0' && file_name[0] <= '9' {\n\
    \        return String::from(\"No\");\n    }\n    if file_name.len() == 2 && file_name[1]\
    \ == '.' && file_name[0] >= 'a' && file_name[0] <= 'z' && file_name[0] >= 'A'\
    \ && file_name[0] <= 'Z' {\n        first_letter += 'A' - 'a';\n    }\n    if\
    \ file_name.len() == 2 && file_name[1] == '.' && file_name[0] >= 'A' && file_name[0]\
    \ <= 'Z' && file_name[0] >= 'a' && file_name[0] <= 'z' {\n        first_letter\
    \ += 'a' - 'A';\n    }\n    if file_name.len() == 2 && file_name[1] == '.' &&\
    \ file_name[0] >= '0' && file_name[0] <= '9' && file_name[0] >= 'a' && file_name[0]\
    \ <= 'z' && file_name[0] >= 'A' && file_name[0] <= 'Z' {\n        first_letter\
    \ += 'A' - 'a';\n    }\n    if file_name.len() == 2 && file_name[1] == '.' &&\
    \ file_name[0] >= 'A' && file_name[0] <= 'Z' && file_name[0] >= 'a' && file_name[0]\
    \ <= 'z' && file_name[0] >= '0' && file_name[0] <= '9\n}\n\nfn main() {\n    let\
    \ candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: lifetimes cannot start with a number\n  --> /tmp/tmps5h_2hkl.rs:59:186\n\
    \   |\n59 | ... && file_name[0] <= 'z' && file_name[0] >= '0' && file_name[0]\
    \ <= '9\n   |                                                                \
    \      ^^\n\nerror: expected `while`, `for`, `loop` or `{` after a label\n  -->\
    \ /tmp/tmps5h_2hkl.rs:60:1\n   |\n60 | }\n   | ^ expected `while`, `for`, `loop`\
    \ or `{` after a label\n\nerror: expected expression, found `}`\n  --> /tmp/tmps5h_2hkl.rs:60:1\n\
    \   |\n60 | }\n   | ^ expected expression\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `{integer}`\n  --> /tmp/tmps5h_2hkl.rs:14:28\n   |\n14 |     let\
    \ mut first_letter = file_name[0];\n   |                            ^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmps5h_2hkl.rs:16:29\n\
    \   |\n16 |         first_letter += 'A' - 'a';\n   |                         ---\
    \ ^ --- char\n   |                         |\n   |                         char\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmps5h_2hkl.rs:27:32\n\
    \   |\n27 |     if file_name.len() == 2 && file_name[1] != '.' {\n   |       \
    \                         ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_4 = file_name.find('.')\n\
    \    if dot_pos_4 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_6 = file_name.find('.')\n\
    \    if dot_pos_6 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_7 = file_name.find('.')\n    if dot_pos_7 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_8 = file_name.find('.')\n\
    \    if dot_pos_8 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_14 = file_name.find('.')\n\
    \    if dot_pos_14 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_16 = file_name.find('.')\n\
    \    if dot_pos_16 == String::npos {\n\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0jikd8k9.rs:108:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n76  |  \
    \   if dot_pos_16 == String::npos {\n    |                                   -\
    \ this delimiter might not be properly closed...\n77  | \n78  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n108 | }\n    |   ^\n\n\
    error: expected `;`, found keyword `if`\n  --> /tmp/tmp0jikd8k9.rs:15:42\n   |\n\
    15 |     let mut dot_pos = file_name.find('.')\n   |                         \
    \                 ^ help: add `;` here\n16 |     if dot_pos == String::npos {\n\
    \   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmp0jikd8k9.rs:19:44\n   |\n19 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n20 |  \
    \   if dot_pos_2 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp0jikd8k9.rs:23:44\n   |\n23 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n24 |     if dot_pos_3 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp0jikd8k9.rs:27:44\n\
    \   |\n27 |     let mut dot_pos_4 = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n28 |     if dot_pos_4 == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmp0jikd8k9.rs:31:44\n   |\n31 |     let mut dot_pos_5 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n32 |  \
    \   if dot_pos_5 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp0jikd8k9.rs:35:44\n   |\n35 |     let\
    \ mut dot_pos_6 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n36 |     if dot_pos_6 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: exp"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos;\n \
    \   dot_pos_end += 1;\n    while dot_pos_end < file_name.len() {\n        let\
    \ mut dot_pos_start = dot_pos;\n        dot_pos_start += 1;\n        if file_name[dot_pos_start]\
    \ >= 'a' && file_name[dot_pos_start] <= 'z' {\n            dot_pos_start += 1;\n\
    \        }\n        if file_name[dot_pos_start] >= 'A' && file_name[dot_pos_start]\
    \ <= 'Z' {\n            dot_pos_start += 1;\n        }\n        if file_name[dot_pos_start]\
    \ == '.' {\n            break;\n        }\n    }\n    if dot_pos_start == dot_pos\
    \ {\n        return String::from(\"No\");\n    }\n    if dot_pos_start == dot_pos_end\
    \ {\n        return String::from(\"Yes\");\n    }\n    if dot_pos_start < dot_pos_end\
    \ {\n        return String::from(\"No\");\n    }\n    if dot_pos_start == dot_pos_end\
    \ + 1 {\n        return String::from(\"Yes\");\n    }\n    if dot_pos_start ==\
    \ dot_pos_end + 2 {\n        return String::from(\"Yes\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end + 3 {\n        return String::from(\"Yes\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end + 4 {\n        return String::from(\"Yes\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end + 5 {\n        return String::from(\"Yes\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end + 6 {\n        return String::from(\"Yes\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end + 7 {\n        return String::from(\"Yes\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end + 8 {\n        return String::from(\"Yes\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end + 9 {\n        return String::from(\"Yes\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end + 10 {\n        return String::from(\"Yes\");\n    }\n    if\
    \ dot_pos_start == dot_pos_end + 11 {\n        return String::from(\"Yes\");\n\
    \    }\n    if dot_pos_start == dot_pos_end + 12 {\n        return String::from(\"\
    Yes\");\n    }\n    if dot_pos_start == dot_pos_end + 13 {\n        return String::from(\"\
    Yes\");\n    }\n    if dot_pos_start == dot_\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmplidv9hpd.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `{`, found `}`\n  --> /tmp/tmplidv9hpd.rs:83:1\n\
    \   |\n82 |     if dot_pos_start == dot_\n   |     -- this `if` expression has\
    \ a condition, but no block\n83 | }\n   | ^ expected `{`\n\nerror[E0425]: cannot\
    \ find value `dot_pos_start` in this scope\n  --> /tmp/tmplidv9hpd.rs:34:8\n \
    \  |\n34 |     if dot_pos_start == dot_pos {\n   |        ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `dot_pos_start` in this scope\n\
    \  --> /tmp/tmplidv9hpd.rs:37:8\n   |\n37 |     if dot_pos_start == dot_pos_end\
    \ {\n   |        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `dot_pos_start` in this scope\n  --> /tmp/tmplidv9hpd.rs:40:8\n \
    \  |\n40 |     if dot_pos_start < dot_pos_end {\n   |        ^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `dot_pos_start` in this\
    \ scope\n  --> /tmp/tmplidv9hpd.rs:43:8\n   |\n43 |     if dot_pos_start == dot_pos_end\
    \ + 1 {\n   |        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `dot_pos_start` in this scope\n  --> /tmp/tmplidv9hpd.rs:46:8\n \
    \  |\n46 |     if dot_pos_start == dot_pos_end + 2 {\n   |        ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `dot_pos_start` in\
    \ this scope\n  --> /tmp/tmplidv9hpd.rs:49:8\n   |\n49 |     if dot_pos_start\
    \ == dot_pos_end + 3 {\n   |        ^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `dot_pos_start` in this scope\n  --> /tmp/tmplidv9hpd.rs:52:8\n\
    \   |\n52 |     if dot_pos_start == dot_pos_end + 4 {\n   |        ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `dot_pos_start` in\
    \ this scope\n  --> /tmp/tmplidv9hpd.rs:55:8\n   |\n55 |     if dot_pos_start\
    \ == dot_pos_end + 5 {\n   |        ^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `dot_pos_start"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    if\
    \ file_name.len() > 3 {\n        file_name.truncate(3);\n    }\n    if file_name.contains('.')\
    \ {\n        file_name.truncate(file_name.find('.'));\n    }\n    if file_name.starts_with(\"\
    a\") || file_name.starts_with(\"A\") {\n        file_name.truncate(0);\n    }\n\
    \    if file_name.ends_with(\"txt\") || file_name.ends_with(\"exe\") || file_name.ends_with(\"\
    dll\") {\n        return String::from(\"Yes\");\n    }\n    return String::from(\"\
    No\");\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj_sbf16v.rs:19:28\n   |\n\
    19 |         file_name.truncate(file_name.find('.'));\n   |                  \
    \          ^^^^^^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n \
    \  = note: expected type `usize`\n              found enum `Option<usize>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter =\
    \ false;\n    while dot_pos_start != dot_pos_end {\n        let mut dot_pos_letter\
    \ = dot_pos_start.chars().next().unwrap();\n        if dot_pos_letter == 'a' ||\
    \ dot_pos_letter == 'A' {\n            dot_pos_start_letter = true;\n        }\n\
    \        if dot_pos_letter == '0' || dot_pos_letter == '9' {\n            break;\n\
    \        }\n        dot_pos_start = dot_pos_start + 1;\n        dot_pos_letter\
    \ = dot_pos_start.chars().next().unwrap();\n    }\n    if dot_pos_start_letter\
    \ == false {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpa8s3ls_e.rs:116:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n84  |  \
    \   if dot_pos_start == dot_pos_end {\n    |                                 \
    \    - this delimiter might not be properly closed...\n85  | \n86  | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n116 | }\n   \
    \ |   ^\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpa8s3ls_e.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpa8s3ls_e.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n  --> /tmp/tmpa8s3ls_e.rs:19:35\n   |\n19 |\
    \     let mut dot_pos_end = dot_pos + 1;\n   |                           -------\
    \ ^ - {integer}\n   |                           |\n   |                      \
    \     Option<usize>\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpa8s3ls_e.rs:20:37\n   |\n20 |     let mut dot_pos_start = dot_pos\
    \ + 1;\n   |                             ------- ^ - {integer}\n   |         \
    \                    |\n   |                             Option<usize>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa8s3ls_e.rs:13:42\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |    ---------------                       ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name : String = file_name;\n    let mut\
    \ dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos\
    \ : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize\
    \ = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n \
    \   let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut\
    \ dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos\
    \ : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize\
    \ = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n \
    \   let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut\
    \ dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos\
    \ : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize\
    \ = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n \
    \   let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut\
    \ dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos\
    \ : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize\
    \ = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n \
    \   let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut\
    \ dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos\
    \ : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize\
    \ = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n \
    \   let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut\
    \ dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos\
    \ : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = file_name_check;\n \
    \   assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcpzgd89.rs:65:11\n   |\n\
    65 |     let mu\n   |           ^ help: add `;` here\n66 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxcpzgd89.rs:13:42\n \
    \  |\n13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    if\
    \ file_name.len() > 3 {\n        file_name.truncate(3);\n    }\n    if file_name.contains(\"\
    .\") {\n        file_name.truncate(file_name.rfind(\".\"));\n    }\n    if file_name.starts_with(\"\
    a\") || file_name.starts_with(\"A\") {\n        file_name.truncate(1);\n    }\n\
    \    if file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\"\
    .\"));\n    }\n    if file_name.ends_with(\"txt\") || file_name.ends_with(\"exe\"\
    ) || file_name.ends_with(\"dll\") {\n        return \"Yes\";\n    }\n    return\
    \ \"No\";\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy16pdp30.rs:19:28\n   |\n\
    19 |         file_name.truncate(file_name.rfind(\".\"));\n   |               \
    \             ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n\
    \   = note: expected type `usize`\n              found enum `Option<usize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpy16pdp30.rs:25:28\n   |\n25 |  \
    \       file_name.truncate(file_name.rfind(\".\"));\n   |                    \
    \        ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n  \
    \ = note: expected type `usize`\n              found enum `Option<usize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpy16pdp30.rs:28:16\n   |\n13 | fn\
    \ file_name_check(file_name: String) -> String {\n   |                       \
    \                   ------ expected `String` because of return type\n...\n28 |\
    \         return \"Yes\";\n   |                ^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return String::from(\"No\");\n    }\n    let mut dot_pos = dot_pos as usize;\n\
    \    let mut dot_pos_2 = file_name.find('.')\n    if dot_pos_2 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_2 = dot_pos_2\
    \ as usize;\n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 ==\
    \ String::npos {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_3\
    \ = dot_pos_3 as usize;\n    let mut dot_pos_4 = file_name.find('.')\n    if dot_pos_4\
    \ == String::npos {\n        return String::from(\"No\");\n    }\n    let mut\
    \ dot_pos_4 = dot_pos_4 as usize;\n    let mut dot_pos_5 = file_name.find('.')\n\
    \    if dot_pos_5 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_5 = dot_pos_5 as usize;\n    let mut dot_pos_6 = file_name.find('.')\n\
    \    if dot_pos_6 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_6 = dot_pos_6 as usize;\n    let mut dot_pos_7 = file_name.find('.')\n\
    \    if dot_pos_7 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_7 = dot_pos_7 as usize;\n    let mut dot_pos_8 = file_name.find('.')\n\
    \    if dot_pos_8 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_8 = dot_pos_8 as usize;\n    let mut dot_pos_9 = file_name.find('.')\n\
    \    if dot_pos_9 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_9 = dot_pos_9 as usize;\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_10 = dot_pos_10 as usize;\n    let mut dot_pos_11 =\
    \ file_name.find('.')\n    if dot_pos_11 == String::npos {\n        return String::from(\"\
    No\");\n    }\n    let mut dot_pos_11 = dot_pos_11 as usize;\n    let mut dot_pos_12\
    \ = file_name.find('.')\n    if dot_pos_\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpcay23p53.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ { \n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpcay23p53.rs:20:44\n   |\n20 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n21 |  \
    \   if dot_pos_2 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpcay23p53.rs:25:44\n   |\n25 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n26 |     if dot_pos_3 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpcay23p53.rs:30:44\n\
    \   |\n30 |     let mut dot_pos_4 = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n31 |     if dot_pos_4 == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpcay23p53.rs:35:44\n   |\n35 |     let mut dot_pos_5 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n36 |  \
    \   if dot_pos_5 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpcay23p53.rs:40:44\n   |\n40 |     let\
    \ mut dot_pos_6 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n41 |     if dot_pos_6 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpcay23p53.rs:45:44\n\
    \   |\n45 |     let mut dot_pos_7 = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n46 |     if dot_pos_7 == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpcay23p53.rs:50:44\n   |\n50 |     let mut dot_pos_8 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n51 "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name_chars = file_name.to_chars();\n \
    \   file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_chars.next();\n\
    \    file_name_chars.next();\n    file_name_chars.next();\n    file_name_\n}\n\
    \nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `file_name_` in this scope\n  --> /tmp/tmpinnrknzh.rs:86:5\n\
    \   |\n86 |     file_name_\n   |     ^^^^^^^^^^ help: a local variable with a\
    \ similar name exists: `file_name`\n\nerror[E0599]: no method named `to_chars`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpinnrknzh.rs:14:41\n\
    \   |\n14 |     let mut file_name_chars = file_name.to_chars();\n   |        \
    \                                 ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `chars`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos = dot_pos + 1;\n \
    \   let mut dot_len = file_name.len();\n    let mut dot_len2 = dot_len;\n    while\
    \ dot_len2 > dot_pos {\n        dot_len2 -= 1;\n        if file_name[dot_len2]\
    \ != '0' && file_name[dot_len2] != '1' &&\n            file_name[dot_len2] !=\
    \ '2' && file_name[dot_len2] != '3' &&\n            file_name[dot_len2] != '4'\
    \ && file_name[dot_len2] != '5' &&\n            file_name[dot_len2] != '6' &&\
    \ file_name[dot_len2] != '7' &&\n            file_name[dot_len2] != '8' && file_name[dot_len2]\
    \ != '9' &&\n            file_name[dot_len2] != 'A' && file_name[dot_len2] !=\
    \ 'B' &&\n            file_name[dot_len2] != 'C' && file_name[dot_len2] != 'D'\
    \ &&\n            file_name[dot_len2] != 'E' && file_name[dot_len2] != 'F' &&\n\
    \            file_name[dot_len2] != 'G' && file_name[dot_len2] != 'H' &&\n   \
    \         file_name[dot_len2] != 'I' && file_name[dot_len2] != 'J' &&\n      \
    \      file_name[dot_len2] != 'K' && file_name[dot_len2] != 'L' &&\n         \
    \   file_name[dot_len2] != 'M' && file_name[dot_len2] != 'N' &&\n            file_name[dot_len2]\
    \ != 'O' && file_name[dot_len2] != 'P' &&\n            file_name[dot_len2] !=\
    \ 'Q' && file_name[dot_len2] != 'R' &&\n            file_name[dot_len2] != 'S'\
    \ && file_name[dot_len2] != 'T' &&\n            file_name[dot_len2] != 'U' &&\
    \ file_name[dot_len2] != 'V' &&\n            file_name[dot_len2] != 'W' && file_name[dot_len2]\
    \ != 'X' &&\n            file_name[dot_len2] != 'Y' && file_name[dot_len2] !=\
    \ 'Z' &&\n            file_name[dot_len2] != 'a' && file_name[dot_len2] != 'b'\
    \ &&\n            file_name[dot_len2] != 'c' && file_name[dot_len2] != 'd' &&\n\
    \            file_name[dot_len2] != 'e' && file_name[dot_len2] != 'f' &&\n   \
    \         file_name[dot_len2] != 'g' && file_name[dot_len2] != 'h' &&\n      \
    \      file_name[dot_len2] != 'i' && file_name[\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpnjrwnvvv.rs:77:3\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n22 |     while\
    \ dot_len2 > dot_pos {\n   |                              - this delimiter might\
    \ not be properly closed...\n...\n47 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n77 | }\n   |   ^\n\nerror: expected `;`, found\
    \ keyword `if`\n  --> /tmp/tmpnjrwnvvv.rs:15:42\n   |\n15 |     let mut dot_pos\
    \ = file_name.find('.')\n   |                                          ^ help:\
    \ add `;` here\n16 |     if dot_pos == String::npos {\n   |     -- unexpected\
    \ token\n\nerror: expected expression, found `]`\n  --> /tmp/tmpnjrwnvvv.rs:47:1\n\
    \   |\n47 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpnjrwnvvv.rs:46:52\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                                 -\
    \ closing delimiter possibly meant for this\n...\n46 |             file_name[dot_len2]\
    \ != 'i' && file_name[\n   |                                                 \
    \   ^ unclosed delimiter\n47 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpnjrwnvvv.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpnjrwnvvv.rs:19:31\n   |\n19 |     let mut dot_pos = dot_pos + 1;\n\
    \   |                       ------- ^ - {integer}\n   |                      \
    \ |\n   |                       Option<usize>\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnjrwnvvv.rs:13:42\n   |\n13 | fn file_name_check(file_name: String)\
    \ -> String {\n   |    ---------------                       ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: abortin"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut counter = 0;\n    for c in file_name.chars()\
    \ {\n        if !c.is_ascii_letter() || c.is_ascii_digit() {\n            counter\
    \ = counter + 1;\n        }\n        if c.is_ascii_dot() {\n            if counter\
    \ > 3 {\n                return \"No\";\n            }\n            counter =\
    \ counter + 1;\n        }\n        if counter > 1 {\n            return \"No\"\
    ;\n        }\n    }\n    return \"Yes\";\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpnmbg7rib.rs:16:15\n   |\n16 |         if !c.is_ascii_letter()\
    \ || c.is_ascii_digit() {\n   |               ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0599]: no method\
    \ named `is_ascii_dot` found for type `char` in the current scope\n  --> /tmp/tmpnmbg7rib.rs:19:14\n\
    \   |\n19 |         if c.is_ascii_dot() {\n   |              ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnmbg7rib.rs:21:24\n   |\n21 |              \
    \   return \"No\";\n   |                        ^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                        |\n   |                \
    \        expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_4 = file_name.find('.')\n\
    \    if dot_pos_4 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_6 = file_name.find('.')\n\
    \    if dot_pos_6 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_7 = file_name.find('.')\n    if dot_pos_7 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_8 = file_name.find('.')\n\
    \    if dot_pos_8 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_14 = file_name.find('.')\n\
    \    if dot_pos_14 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_16 = file_name.find('.')\n\
    \    if dot_pos_16 == String::npos {\n\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpowhqlpp_.rs:108:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n76  |  \
    \   if dot_pos_16 == String::npos {\n    |                                   -\
    \ this delimiter might not be properly closed...\n77  | \n78  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n108 | }\n    |   ^\n\n\
    error: expected `;`, found keyword `if`\n  --> /tmp/tmpowhqlpp_.rs:15:42\n   |\n\
    15 |     let mut dot_pos = file_name.find('.')\n   |                         \
    \                 ^ help: add `;` here\n16 |     if dot_pos == String::npos {\n\
    \   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmpowhqlpp_.rs:19:44\n   |\n19 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n20 |  \
    \   if dot_pos_2 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpowhqlpp_.rs:23:44\n   |\n23 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n24 |     if dot_pos_3 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpowhqlpp_.rs:27:44\n\
    \   |\n27 |     let mut dot_pos_4 = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n28 |     if dot_pos_4 == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpowhqlpp_.rs:31:44\n   |\n31 |     let mut dot_pos_5 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n32 |  \
    \   if dot_pos_5 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpowhqlpp_.rs:35:44\n   |\n35 |     let\
    \ mut dot_pos_6 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n36 |     if dot_pos_6 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: exp"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    let mut dot_pos_len = dot_pos_end\
    \ - dot_pos_start;\n    let mut dot_pos_len2 = dot_pos_end - dot_pos_start;\n\
    \    let mut dot_pos_len3 = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len4\
    \ = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len5 = dot_pos_end - dot_pos_start;\n\
    \    let mut dot_pos_len6 = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len7\
    \ = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len8 = dot_pos_end - dot_pos_start;\n\
    \    let mut dot_pos_len9 = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len10\
    \ = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len11 = dot_pos_end - dot_pos_start;\n\
    \    let mut dot_pos_len12 = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len13\
    \ = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len14 = dot_pos_end - dot_pos_start;\n\
    \    let mut dot_pos_len15 = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len16\
    \ = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len17 = dot_pos_end - dot_pos_start;\n\
    \    let mut dot_pos_len18 = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len19\
    \ = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len20 = dot_pos_end - dot_pos_start;\n\
    \    let mut dot_pos_len21 = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len22\
    \ = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len23 = dot_pos_end - dot_pos_start;\n\
    \    let mut dot_pos_len24 = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len25\
    \ = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len26 = dot_pos_end - dot_pos_start;\n\
    \    let mut dot_pos_len27 = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len28\
    \ = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len29 = dot_pos_end - dot_pos_start;\n\
    \    let mut dot_pos_len30 = dot_pos_end - dot_pos_start;\n    let mut dot_pos_len31\
    \ = dot_pos_end - dot_pos_start;\n\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpqzzdday7.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpqzzdday7.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n  --> /tmp/tmpqzzdday7.rs:19:35\n   |\n19 |\
    \     let mut dot_pos_end = dot_pos + 1;\n   |                           -------\
    \ ^ - {integer}\n   |                           |\n   |                      \
    \     Option<usize>\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpqzzdday7.rs:20:37\n   |\n20 |     let mut dot_pos_start = dot_pos\
    \ + 1;\n   |                             ------- ^ - {integer}\n   |         \
    \                    |\n   |                             Option<usize>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqzzdday7.rs:13:42\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |    ---------------                       ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { return \"\
    No\" }\n    else if dot_pos == 0 { file_name.insert(0, '.') }\n    else if file_name[dot_pos-1]\
    \ != '.' { return \"No\" }\n    let mut first_letter = file_name[0];\n    if first_letter\
    \ != 'a' && first_letter != 'A' { return \"No\" }\n    else if file_name.len()\
    \ != 2 { return \"No\" }\n    else if file_name[1] != '.' { return \"No\" }\n\
    \    else if file_name[0] < 'a' || file_name[0] > 'z' { return \"No\" }\n    else\
    \ if file_name[0] < 'A' || file_name[0] > 'Z' { return \"No\" }\n    else if file_name[1]\
    \ < 'a' || file_name[1] > 'z' { return \"No\" }\n    else if file_name[1] < 'A'\
    \ || file_name[1] > 'Z' { return \"No\" }\n    else if file_name[0] > '9' || file_name[0]\
    \ < '0' { return \"No\" }\n    else if file_name[1] > '9' || file_name[1] < '0'\
    \ { return \"No\" }\n    else if file_name[0] > '9' || file_name[0] < '0' { return\
    \ \"No\" }\n    else if file_name[1] > '9' || file_name[1] < '0' { return \"No\"\
    \ }\n    else if file_name[0] > '9' || file_name[0] < '0' { return \"No\" }\n\
    \    else if file_name[1] > '9' || file_name[1] < '0' { return \"No\" }\n    else\
    \ if file_name[0] > '9' || file_name[0] < '0' { return \"No\" }\n    else if file_name[1]\
    \ > '9' || file_name[1] < '0' { return \"No\" }\n    else if file_name[0] > '9'\
    \ || file_name[0] < '0' { return \"No\" }\n    else if file_name[1] > '9' || file_name[1]\
    \ < '0' { return \"No\" }\n    else if file_name[0] > '9' || file_name[0] < '0'\
    \ { return \"No\" }\n    else if file_name[1] > '9' || file_name[1] < '0' { return\
    \ \"No\" }\n    else if file_name[0] > '9' || file_name[0] < '0' { return \"No\"\
    \ }\n    else if file_name[1] > '9' || file_name[1] < '0' { return \"No\" }\n\
    \    else if file_name[0] > '9' || file_name[0] < '0' { return \"No\" }\n    else\
    \ if file_name[1] > '9' || file_name[1] < '0' { return \"No\" }\n    else if file_name[0]\
    \ > '9' || file_name[0] < \n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpamyoin4m.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ { return \"No\" }\n   |     -- unexpected token\n\nerror: expected expression,\
    \ found `}`\n  --> /tmp/tmpamyoin4m.rs:44:1\n   |\n44 | }\n   | ^ expected expression\n\
    \nerror[E0599]: no function or associated item named `npos` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpamyoin4m.rs:16:27\n   |\n16 |     if dot_pos\
    \ == String::npos { return \"No\" }\n   |                           ^^^^ function\
    \ or associated item not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpamyoin4m.rs:16:41\n   |\n13 | fn file_name_check(file_name: String)\
    \ -> String {\n   |                                          ------ expected `String`\
    \ because of return type\n...\n16 |     if dot_pos == String::npos { return \"\
    No\" }\n   |                                         ^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                         |\n   |\
    \                                         expected struct `String`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpamyoin4m.rs:17:24\n   |\n17 |\
    \     else if dot_pos == 0 { file_name.insert(0, '.') }\n   |                \
    \        ^ expected enum `Option`, found integer\n   |\n   = note: expected enum\
    \ `Option<usize>`\n              found type `{integer}`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n17 |     else if dot_pos == Some(0) { file_name.insert(0,\
    \ '.') }\n   |                        +++++ +\n\nerror[E0369]: cannot subtract\
    \ `{integer}` from `Option<usize>`\n  --> /tmp/tmpamyoin4m.rs:18:30\n   |\n18\
    \ |     else if file_name[dot_pos-1] != '.' { return \"No\" }\n   |          \
    \             -------^- {integer}\n   |                       |\n   |        \
    \               Option<usize>\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpamyoin4m.rs:19:28\n   |\n19 |     let mut first_letter\
    \ = file_name[0];\n   |                 "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\n  \
    \      return String::from(\"No\");\n    }\n    if dot_index == 0 {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name.chars().count() > 3 {\n     \
    \   return String::from(\"No\");\n    }\n    if file_name.chars().count() == 3\
    \ {\n        if file_name[0] < 'a' || file_name[0] > 'z' {\n            return\
    \ String::from(\"No\");\n        }\n        if file_name[1] < 'a' || file_name[1]\
    \ > 'z' {\n            return String::from(\"No\");\n        }\n        if file_name[2]\
    \ < 'a' || file_name[2] > 'z' {\n            return String::from(\"No\");\n  \
    \      }\n    }\n    if file_name.chars().count() == 1 {\n        if file_name[0]\
    \ < 'a' || file_name[0] > 'z' {\n            return String::from(\"No\");\n  \
    \      }\n    }\n    if file_name.chars().count() == 0 {\n        return String::from(\"\
    No\");\n    }\n    if file_name.chars().count() == 2 {\n        if file_name[0]\
    \ < 'a' || file_name[0] > 'z' {\n            return String::from(\"No\");\n  \
    \      }\n        if file_name[1] < 'a' || file_name[1] > 'z' {\n            return\
    \ String::from(\"No\");\n        }\n    }\n    if file_name.chars().count() ==\
    \ 3 {\n        if file_name[0] < 'a' || file_name[0] > 'z' {\n            return\
    \ String::from(\"No\");\n        }\n        if file_name[1] < 'a' || file_name[1]\
    \ > 'z' {\n            return String::from(\"No\");\n        }\n        if file_name[2]\
    \ < 'a' || file_name[2] > 'z' {\n            return String::from(\"No\");\n  \
    \      }\n    }\n    if file_name.chars().count() == 4 {\n        if file_name[0]\
    \ < 'a' || file_name[0] > 'z' {\n            return String::from(\"No\");\n  \
    \      }\n        if file_name[1] < 'a' || file_name[1] > 'z' {\n            return\
    \ String::from(\"No\");\n        }\n        if file_name[2] < 'a' || file_name[2]\
    \ > 'z' {\n            return String::from(\"No\");\n        }\n        if file_name[3]\
    \ < 'a' || file_name[3] > 'z' {\n            return String::from(\"No\");\n  \
    \      }\n    }\n    if file_name.chars().count() == 5 {\n        if file_name[0]\
    \ < 'a' || file_name[0] > 'z' {\n            return String::from(\"No\");\n  \
    \      }\n        if file_name[1]\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjh00hadu.rs:112:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n77  |  \
    \   if file_name.chars().count() == 5 {\n    |                               \
    \        - this delimiter might not be properly closed...\n...\n82  | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n112 | }\n   \
    \ |   ^\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpjh00hadu.rs:15:44\n\
    \   |\n15 |     let mut dot_index = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n16 |     if dot_index == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpjh00hadu.rs:82:1\n\
    \   |\n81 |         if file_name[1]\n   |         -- this `if` expression has\
    \ a condition, but no block\n82 | }\n   | ^ expected `{`\n\nerror[E0599]: no function\
    \ or associated item named `npos` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpjh00hadu.rs:16:29\n   |\n16 |     if dot_index == String::npos\
    \ {\n   |                             ^^^^ function or associated item not found\
    \ in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjh00hadu.rs:19:21\n\
    \   |\n19 |     if dot_index == 0 {\n   |                     ^ expected enum\
    \ `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n19 |     if dot_index == Some(0) {\n   |                     +++++ +\n\n\
    error[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpjh00hadu.rs:26:12\n\
    \   |\n26 |         if file_name[0] < 'a' || file_name[0] > 'z' {\n   |      \
    \      ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<Ra"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return \"No\";\n    }\n    let mut dot_pos_2 = file_name.find('.')\n    if\
    \ dot_pos_2 == String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_3\
    \ = file_name.find('.')\n    if dot_pos_3 == String::npos {\n        return \"\
    No\";\n    }\n    let mut dot_pos_4 = file_name.find('.')\n    if dot_pos_4 ==\
    \ String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_5 = file_name.find('.')\n\
    \    if dot_pos_5 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_6 = file_name.find('.')\n    if dot_pos_6 == String::npos {\n      \
    \  return \"No\";\n    }\n    let mut dot_pos_7 = file_name.find('.')\n    if\
    \ dot_pos_7 == String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_8\
    \ = file_name.find('.')\n    if dot_pos_8 == String::npos {\n        return \"\
    No\";\n    }\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 ==\
    \ String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos {\n    \
    \    return \"No\";\n    }\n    let mut dot_pos_12 = file_name.find('.')\n   \
    \ if dot_pos_12 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos {\n    \
    \    return \"No\";\n    }\n    let mut dot_pos_14 = file_name.find('.')\n   \
    \ if dot_pos_14 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos {\n    \
    \    return \"No\";\n    }\n    let mut dot_pos_16 = file_name.find('.')\n   \
    \ if dot_pos_16 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_17 = file_name.find('.')\n    if dot_pos_17 == String::npos {\n    \
    \    return \"No\";\n    }\n    let mut dot_pos_18 = file_name.find('.')\n   \
    \ if dot_pos_18 == String::npos {\n        return \"No\n}\n\nfn main() {\n   \
    \ let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmp49uxxlo_.rs:91:40\n\
    \   |\n91 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n   --> /tmp/tmp49uxxlo_.rs:104:56\n    |\n104\
    \ |     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n    |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmp49uxxlo_.rs:115:63\n\
    \    |\n115 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    116 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter =\
    \ String::new();\n    let mut dot_pos_end_letter = String::new();\n    let mut\
    \ dot_pos_letter = String::new();\n    let mut dot_pos_letter_end = String::new();\n\
    \    let mut dot_pos_letter_start = String::new();\n    let mut dot_pos_letter_start_letter\
    \ = String::new();\n    let mut dot_pos_letter_end_letter = String::new();\n \
    \   let mut dot_pos_letter_letter = String::new();\n    let mut dot_pos_letter_letter_end\
    \ = String::new();\n    let mut dot_pos_letter_letter_start = String::new();\n\
    \    let mut dot_pos_letter_letter_start_letter = String::new();\n    let mut\
    \ dot_pos_letter_letter_end_letter = String::new();\n    let mut dot_pos_letter_letter_letter\
    \ = String::new();\n    let mut dot_pos_letter_letter_letter_end = String::new();\n\
    \    let mut dot_pos_letter_letter_letter_start = String::new();\n    let mut\
    \ dot_pos_letter_letter_letter_start_letter = String::new();\n    let mut dot_pos_letter_letter_letter_end_letter\
    \ = String::new();\n    let mut dot_pos_letter_letter_letter_letter = String::new();\n\
    \    let mut dot_pos_letter_letter_letter_letter_end = String::new();\n    let\
    \ mut dot_pos_letter_letter_letter_letter_start = String::new();\n    let mut\
    \ dot_pos_letter_letter_letter_letter_start_letter = String::new();\n    let mut\
    \ dot_pos_letter_letter_letter_letter_end_letter = String::new();\n    let mut\
    \ dot_pos_letter_letter_letter_letter_letter = String::new();\n    let mut dot_pos_letter_letter_letter_letter_letter_end\
    \ = String::new();\n    let mut dot_pos_letter_letter_letter_letter_letter_start\
    \ = String::new();\n    let mut dot_pos_letter_letter_letter_letter_letter_start_letter\
    \ = String::new();\n    let mut dot_pos_letter_letter_letter_letter_end_letter\
    \ = String::new();\n    let mut dot_pos_letter_letter_letter_letter_letter_end\
    \ = String::new();\n    let mut dot_pos_letter_letter_letter_letter_letter_start\
    \ = String::new();\n    let mut dot_pos_letter_letter_letter_letter_letter_start_letter\
    \ = String::new();\n    let mut dot_pos_letter_letter_\n}\n\nfn main() {\n   \
    \ let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpnnu32su9.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpnnu32su9.rs:51:35\n\
    \   |\n51 |     let mut dot_pos_letter_letter_\n   |                         \
    \          ^ help: add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpnnu32su9.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpnnu32su9.rs:19:35\n   |\n19 |     let mut dot_pos_end = dot_pos\
    \ + 1;\n   |                           ------- ^ - {integer}\n   |           \
    \                |\n   |                           Option<usize>\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpnnu32su9.rs:20:37\n\
    \   |\n20 |     let mut dot_pos_start = dot_pos + 1;\n   |                   \
    \          ------- ^ - {integer}\n   |                             |\n   |   \
    \                          Option<usize>\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpnnu32su9.rs:13:42\n   |\n13 | fn file_name_check(file_name: String)\
    \ -> String {\n   |    ---------------                       ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    if dot_pos_2 > dot_pos {\n\
    \        return String::from(\"No\");\n    }\n    if dot_pos_3 > dot_pos_2 {\n\
    \        return String::from(\"No\");\n    }\n    if file_name[dot_pos - 1] <\
    \ 'a' || file_name[dot_pos - 1] > 'z' {\n        return String::from(\"No\");\n\
    \    }\n    if file_name[dot_pos_2 - 1] < 'a' || file_name[dot_pos_2 - 1] > 'z'\
    \ {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos_3 -\
    \ 1] < 'a' || file_name[dot_pos_3 - 1] > 'z' {\n        return String::from(\"\
    No\");\n    }\n    if dot_pos == dot_pos_2 {\n        return String::from(\"No\"\
    );\n    }\n    if dot_pos == dot_pos_3 {\n        return String::from(\"No\");\n\
    \    }\n    if dot_pos == dot_pos_2 + 1 {\n        return String::from(\"No\"\
    );\n    }\n    if dot_pos == dot_pos_3 + 1 {\n        return String::from(\"No\"\
    );\n    }\n    if dot_pos == dot_pos_2 + 2 {\n        return String::from(\"No\"\
    );\n    }\n    if dot_pos == dot_pos_3 + 2 {\n        return String::from(\"No\"\
    );\n    }\n    if dot_pos == dot_pos_2 + 3 {\n        return String::from(\"No\"\
    );\n    }\n    if dot_pos == dot_pos_3 + 3 {\n        return String::from(\"No\"\
    );\n    }\n    if dot_pos == dot_pos_2 + 4 {\n        return String::from(\"No\"\
    );\n    }\n    if dot_pos == dot_pos_3 + 4 {\n        return String::from(\"No\"\
    );\n    }\n    if dot_pos == dot_pos_2 + 5 {\n        return String::from(\"No\"\
    );\n    }\n    if dot_pos == dot_pos_3 + 5 {\n        return String::from(\"No\"\
    );\n    }\n    if dot_pos == dot_pos_2 + 6 {\n        return String::from(\"No\"\
    );\n    }\n    if dot_pos == dot_pos_3 + 6 {\n        return String::from(\"No\"\
    );\n    }\n    if dot_pos == dot_\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpo07v_26a.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpo07v_26a.rs:19:44\n   |\n19 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n20 |  \
    \   if dot_pos_2 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpo07v_26a.rs:23:44\n   |\n23 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n24 |     if dot_pos_3 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpo07v_26a.rs:85:1\n\
    \   |\n84 |     if dot_pos == dot_\n   |     -- this `if` expression has a condition,\
    \ but no block\n85 | }\n   | ^ expected `{`\n\nerror[E0599]: no function or associated\
    \ item named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpo07v_26a.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0599]: no function\
    \ or associated item named `npos` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpo07v_26a.rs:20:29\n   |\n20 |     if dot_pos_2 == String::npos\
    \ {\n   |                             ^^^^ function or associated item not found\
    \ in `String`\n\nerror[E0599]: no function or associated item named `npos` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpo07v_26a.rs:24:29\n\
    \   |\n24 |     if dot_pos_3 == String::npos {\n   |                         \
    \    ^^^^ function or associated item not found in `String`\n\nerror[E0369]: cannot\
    \ subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpo07v_26a.rs:33:26\n\
    \   |\n33 |     if file_name[dot_pos - 1] < 'a' || file_name[dot_pos - 1] > 'z'\
    \ {\n   |                  ------- ^ - {integer}\n   |                  |\n  \
    \ |                 "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name.len() > 3 {\n       \
    \ return String::from(\"No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter())\
    \ {\n        return String::from(\"No\");\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c != 'a' && c != 'z' || c != 'A' && c != 'Z') {\n  \
    \      return String::from(\"No\");\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c != '0' && c != '9' || c != 'a' && c != 'z' || c != 'A' && c != 'Z') {\n\
    \        return String::from(\"No\");\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c != '0' && c != '9' || c != 'a' && c != 'z' || c !=\
    \ 'A' && c != 'Z' || c != '.') {\n        return String::from(\"No\");\n    }\n\
    \    if file_name.chars().any(|c| !c.is_ascii_letter() || c != '0' && c != '9'\
    \ || c != 'a' && c != 'z' || c != 'A' && c != 'Z' || c != '.' || c != 'txt' ||\
    \ c != 'exe' || c != 'dll') {\n        return String::from(\"No\");\n    }\n \
    \   String::from(\"Yes\")\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpua94fuvt.rs:34:147\n\
    \   |\n34 | ... != 'a' && c != 'z' || c != 'A' && c != 'Z' || c != '.' || c !=\
    \ 'txt' || c != 'exe' || c != 'dll') {\n   |                                 \
    \                                   ^^^^^\n   |\nhelp: if you meant to write a\
    \ `str` literal, use double quotes\n   |\n34 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c != '0' && c != '9' || c != 'a' && c != 'z' || c !=\
    \ 'A' && c != 'Z' || c != '.' || c != \"txt\" || c != 'exe' || c != 'dll') {\n\
    \   |                                                                        \
    \                                                                           ~~~~~\n\
    \nerror: character literal may only contain one codepoint\n  --> /tmp/tmpua94fuvt.rs:34:161\n\
    \   |\n34 | ...= 'z' || c != 'A' && c != 'Z' || c != '.' || c != 'txt' || c !=\
    \ 'exe' || c != 'dll') {\n   |                                               \
    \                     ^^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n34 |     if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c != '0' && c != '9' || c != 'a' && c != 'z' || c != 'A' && c != 'Z' || c\
    \ != '.' || c != 'txt' || c != \"exe\" || c != 'dll') {\n   |                \
    \                                                                            \
    \                                                                     ~~~~~\n\n\
    error: character literal may only contain one codepoint\n  --> /tmp/tmpua94fuvt.rs:34:175\n\
    \   |\n34 | ...'A' && c != 'Z' || c != '.' || c != 'txt' || c != 'exe' || c !=\
    \ 'dll') {\n   |                                                             \
    \       ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n34 |     if file_name.chars().any(|c| !c.is_ascii_letter() || c != '0'\
    \ && c != '9' || c != 'a' && c != 'z' || c != 'A' && c != 'Z' || c != '.' || c\
    \ != 'txt' || c != 'exe' || c != \"dll\") {\n   |                            \
    \                                                                            \
    \                          "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_pos_2 = file_name.find('.')\n    if\
    \ dot_pos_2 == String::npos { \n        return \"No\";\n    }\n    let mut dot_pos_3\
    \ = file_name.find('.')\n    if dot_pos_3 == String::npos { \n        return \"\
    No\";\n    }\n    let mut dot_pos_4 = file_name.find('.')\n    if dot_pos_4 ==\
    \ String::npos { \n        return \"No\";\n    }\n    let mut dot_pos_5 = file_name.find('.')\n\
    \    if dot_pos_5 == String::npos { \n        return \"No\";\n    }\n    let mut\
    \ dot_pos_6 = file_name.find('.')\n    if dot_pos_6 == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_pos_7 = file_name.find('.')\n    if\
    \ dot_pos_7 == String::npos { \n        return \"No\";\n    }\n    let mut dot_pos_8\
    \ = file_name.find('.')\n    if dot_pos_8 == String::npos { \n        return \"\
    No\";\n    }\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 ==\
    \ String::npos { \n        return \"No\";\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos { \n        return \"No\";\n    }\n    let\
    \ mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos { \n\
    \        return \"No\";\n    }\n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos { \n        return \"No\";\n    }\n    let\
    \ mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos { \n\
    \        return \"No\";\n    }\n    let mut dot_pos_14 = file_name.find('.')\n\
    \    if dot_pos_14 == String::npos { \n        return \"No\";\n    }\n    let\
    \ mut dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos { \n\
    \        return \"No\";\n    }\n    let mut dot_pos_16 = file_name.find('.')\n\
    \    if dot_pos_16 == String::npos { \n        return \"No\";\n    }\n    let\
    \ mut dot_pos_17 = file_name.find('.')\n    if dot_pos_17 == String::npos { \n\
    \        return \"No\";\n    }\n    let mut dot_pos_18 = file_name.find('.')\n\
    \    if dot_pos_18 == String::npos { \n        return \"No\n}\n\nfn main() {\n\
    \    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmpj24it27b.rs:91:40\n\
    \   |\n91 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n   --> /tmp/tmpj24it27b.rs:104:56\n    |\n104\
    \ |     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n    |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmpj24it27b.rs:115:63\n\
    \    |\n115 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    116 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_char: char;\n    let mut second_char:\
    \ char;\n    let mut third_char: char;\n    let mut fourth_char: char;\n    let\
    \ mut fifth_char: char;\n    let mut sixth_char: char;\n    let mut seventh_char:\
    \ char;\n    let mut eighth_char: char;\n    let mut ninth_char: char;\n    let\
    \ mut tenth_char: char;\n    let mut first_char_valid: char;\n    let mut second_char_valid:\
    \ char;\n    let mut third_char_valid: char;\n    let mut fourth_char_valid: char;\n\
    \    let mut fifth_char_valid: char;\n    let mut sixth_char_valid: char;\n  \
    \  let mut seventh_char_valid: char;\n    let mut eighth_char_valid: char;\n \
    \   let mut ninth_char_valid: char;\n    let mut tenth_char_valid: char;\n   \
    \ let mut first_char_valid: char;\n    let mut second_char_valid: char;\n    let\
    \ mut third_char_valid: char;\n    let mut fourth_char_valid: char;\n    let mut\
    \ fifth_char_valid: char;\n    let mut sixth_char_valid: char;\n    let mut seventh_char_valid:\
    \ char;\n    let mut eighth_char_valid: char;\n    let mut ninth_char_valid: char;\n\
    \    let mut tenth_char_valid: char;\n    let mut first_char_valid: char;\n  \
    \  let mut second_char_valid: char;\n    let mut third_char_valid: char;\n   \
    \ let mut fourth_char_valid: char;\n    let mut fifth_char_valid: char;\n    let\
    \ mut sixth_char_valid: char;\n    let mut seventh_char_valid: char;\n    let\
    \ mut eighth_char_valid: char;\n    let mut ninth_char_valid: char;\n    let mut\
    \ tenth_char_valid: char;\n    let mut first_char_valid: char;\n    let mut second_char_valid:\
    \ char;\n    let mut third_char_valid: char;\n    let mut fourth_char_valid: char;\n\
    \    let mut fifth_char_valid: char;\n    let mut sixth_char_valid: char;\n  \
    \  let mut seventh_char_valid: char;\n    let mut eighth_char_\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpulko3o7c.rs:61:25\n   |\n\
    61 |     let mut eighth_char_\n   |                         ^ help: add `;` here\n\
    62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpulko3o7c.rs:13:42\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name : String = file_name;\n    let mut\
    \ dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos\
    \ : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize\
    \ = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n \
    \   let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut\
    \ dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos\
    \ : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize\
    \ = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n \
    \   let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut\
    \ dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos\
    \ : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize\
    \ = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n \
    \   let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut\
    \ dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos\
    \ : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize\
    \ = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n \
    \   let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut\
    \ dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos\
    \ : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize\
    \ = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n \
    \   let mut dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut\
    \ dot_pos : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos\
    \ : usize = 0;\n    let mut dot_pos : usize = 0;\n    let mut dot_pos : usize\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = file_name_check;\n \
    \   assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphc6zs6zb.rs:65:11\n   |\n\
    65 |     let mu\n   |           ^ help: add `;` here\n66 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphc6zs6zb.rs:13:42\n \
    \  |\n13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name.len() > 3 {\n       \
    \ return String::from(\"No\");\n    }\n    if file_name.len() == 3 {\n       \
    \ if file_name[0] < 'a' || file_name[0] > 'z' {\n            return String::from(\"\
    No\");\n        }\n    }\n    if file_name[dot_pos - 1] < 'a' || file_name[dot_pos\
    \ - 1] > 'z' {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos\
    \ + 1] < 'a' || file_name[dot_pos + 1] > 'z' {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos + 2] != 'txt' && file_name[dot_pos + 2]\
    \ != 'exe' && file_name[dot_pos + 2] != 'dll' {\n        return String::from(\"\
    No\");\n    }\n    return String::from(\"Yes\");\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp0yfn9kd7.rs:33:34\n\
    \   |\n33 |     if file_name[dot_pos + 2] != 'txt' && file_name[dot_pos + 2] !=\
    \ 'exe' && file_name[dot_pos + 2] != 'dll' {\n   |                           \
    \       ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n33 |     if file_name[dot_pos + 2] != \"txt\" && file_name[dot_pos + 2]\
    \ != 'exe' && file_name[dot_pos + 2] != 'dll' {\n   |                        \
    \          ~~~~~\n\nerror: character literal may only contain one codepoint\n\
    \  --> /tmp/tmp0yfn9kd7.rs:33:69\n   |\n33 |     if file_name[dot_pos + 2] !=\
    \ 'txt' && file_name[dot_pos + 2] != 'exe' && file_name[dot_pos + 2] != 'dll'\
    \ {\n   |                                                                    \
    \ ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n33 |     if file_name[dot_pos + 2] != 'txt' && file_name[dot_pos + 2] !=\
    \ \"exe\" && file_name[dot_pos + 2] != 'dll' {\n   |                         \
    \                                            ~~~~~\n\nerror: character literal\
    \ may only contain one codepoint\n  --> /tmp/tmp0yfn9kd7.rs:33:104\n   |\n33 |\
    \     if file_name[dot_pos + 2] != 'txt' && file_name[dot_pos + 2] != 'exe' &&\
    \ file_name[dot_pos + 2] != 'dll' {\n   |                                    \
    \                                                                    ^^^^^\n \
    \  |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n33\
    \ |     if file_name[dot_pos + 2] != 'txt' && file_name[dot_pos + 2] != 'exe'\
    \ && file_name[dot_pos + 2] != \"dll\" {\n   |                               \
    \                                                                         ~~~~~\n\
    \nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp0yfn9kd7.rs:15:42\n \
    \  |\n15 |     let mut dot_pos = file_name.find('.')\n   |                   \
    \                       ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/t"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos { \n \
    \       return String::from(\"No\");\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    \n    let mut dot_index = file_name.find('.')\n    if dot_index ==\
    \ String::npos { \n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos { \n \
    \       return String::from(\"No\");\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    \n    let mut dot_index = file_name.find('.')\n    if dot_index ==\
    \ String::npos { \n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos { \n \
    \       return String::from(\"No\");\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    \n    let mut dot_index = file_name.find('.')\n    if dot_index ==\
    \ String::npos { \n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos { \n \
    \       return String::from(\"No\");\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    \n    let mut dot_index = file_name.find('.')\n    if dot_index ==\
    \ String::npos { \n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos { \n \
    \       return String::from(\"No\");\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    \n    let mut dot_index = file_name.find('.')\n    if dot_index ==\
    \ String::npos { \n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos { \n \
    \       return String\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp989c3v7s.rs:123:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n91  |  \
    \   if dot_index == String::npos { \n    |                                  -\
    \ this delimiter might not be properly closed...\n92  |         return String\n\
    93  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    123 | }\n    |   ^\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp989c3v7s.rs:15:44\n\
    \   |\n15 |     let mut dot_index = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n16 |     if dot_index == String::npos\
    \ { \n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmp989c3v7s.rs:20:44\n   |\n20 |     let mut dot_index = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n21 |  \
    \   if dot_index == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp989c3v7s.rs:25:44\n   |\n25 |     let\
    \ mut dot_index = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n26 |     if dot_index == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmp989c3v7s.rs:30:44\n   |\n30 |     let mut dot_index = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n31 |  \
    \   if dot_index == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp989c3v7s.rs:35:44\n   |\n35 |     let\
    \ mut dot_index = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n36 |     if dot_index == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmp989c3v7s.rs:40:44\n   |\n40 |     let mut dot_index = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n41 |  \
    \   if dot_index == String::npos { \n   |    "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_char: u8 = 0;\n    let mut second_char:\
    \ u8 = 0;\n    let mut third_char: u8 = 0;\n    let mut fourth_char: u8 = 0;\n\
    \    let mut fifth_char: u8 = 0;\n    let mut sixth_char: u8 = 0;\n    let mut\
    \ seventh_char: u8 = 0;\n    let mut eighth_char: u8 = 0;\n    let mut ninth_char:\
    \ u8 = 0;\n    let mut tenth_char: u8 = 0;\n    let mut first_char_valid = false;\n\
    \    let mut second_char_valid = false;\n    let mut third_char_valid = false;\n\
    \    let mut fourth_char_valid = false;\n    let mut fifth_char_valid = false;\n\
    \    let mut sixth_char_valid = false;\n    let mut seventh_char_valid = false;\n\
    \    let mut eighth_char_valid = false;\n    let mut ninth_char_valid = false;\n\
    \    let mut tenth_char_valid = false;\n    let mut first_char_valid = false;\n\
    \    let mut second_char_valid = false;\n    let mut third_char_valid = false;\n\
    \    let mut fourth_char_valid = false;\n    let mut fifth_char_valid = false;\n\
    \    let mut sixth_char_valid = false;\n    let mut seventh_char_valid = false;\n\
    \    let mut eighth_char_valid = false;\n    let mut ninth_char_valid = false;\n\
    \    let mut tenth_char_valid = false;\n    let mut first_char_valid = false;\n\
    \    let mut second_char_valid = false;\n    let mut third_char_valid = false;\n\
    \    let mut fourth_char_valid = false;\n    let mut fifth_char_valid = false;\n\
    \    let mut sixth_char_valid = false;\n    let mut seventh_char_valid = false;\n\
    \    let mut eighth_char_valid = false;\n    let mut ninth_char_valid = false;\n\
    \    let mut tenth_char_valid = false;\n    let mut first_char_valid = false;\n\
    \    let mut second_char_valid = false;\n    let mut third_char_valid = false;\n\
    \    let mut fourth_char_valid = false;\n    let mut fifth_char_valid = false;\n\
    \    let mut sixth_char_valid = false;\n    let mut seventh_char_valid = false;\n\
    \    let mut eighth_char_valid = false;\n    let mut ninth_char_valid = false;\n\
    \    let mut tenth_char_valid = false;\n    let mut first_char_valid = false;\n\
    \    let mut second_char_valid = false;\n    let mut third_char_valid = false;\n\
    \    let mut fourth_char_valid = false;\n    let mut fifth_char_valid = false;\n\
    \    let mut sixth_char_valid = false;\n    let \n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpwwsd1l_x.rs:71:1\n  \
    \ |\n71 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    while dot_pos_start < dot_pos_end\
    \ {\n        let mut dot_pos_start = dot_pos_end;\n        let mut dot_pos_end\
    \ = dot_pos_start;\n        let mut dot_pos_end = dot_pos_start..dot_pos_end.find(|&x|\
    \ x == char::from_u32(95).unwrap());\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end = dot_pos_end + 1;\n        }\n        if dot_pos_end\
    \ == dot_pos_start {\n            dot_pos_end = dot_pos_end + 1;\n        }\n\
    \        if dot_pos_end == dot_pos_start {\n            dot_pos_end = dot_pos_end\
    \ + 1;\n        }\n        if dot_pos_end == dot_pos_start {\n            dot_pos_end\
    \ = dot_pos_end + 1;\n        }\n        if dot_pos_end == dot_pos_start {\n \
    \           dot_pos_end = dot_pos_end + 1;\n        }\n        if dot_pos_end\
    \ == dot_pos_start {\n            dot_pos_end = dot_pos_end + 1;\n        }\n\
    \        if dot_pos_end == dot_pos_start {\n            dot_pos_end = dot_pos_end\
    \ + 1;\n        }\n        if dot_pos_end == dot_pos_start {\n            dot_pos_end\
    \ = dot_pos_end + 1;\n        }\n        if dot_pos_end == dot_pos_start {\n \
    \           dot_pos_end = dot_pos_end + 1;\n        }\n        if dot_pos_end\
    \ == dot_pos_start {\n            dot_pos_end = dot_pos_end + 1;\n        }\n\
    \        if dot_pos_end == dot_pos_start {\n            dot_pos_end = dot_pos_end\
    \ + 1;\n        }\n        if dot_pos_end == dot_pos_start {\n            dot_pos_end\
    \ = dot_pos_end + 1;\n        }\n        if dot_pos_end == dot_pos_start {\n \
    \           dot_pos_end = dot_pos_end + 1;\n        }\n        if dot_pos_end\
    \ == dot_pos_start {\n            dot_pos_end = dot_pos_end + 1;\n        }\n\
    \        if dot_pos_end == dot_pos_start {\n            dot_pos_end = dot_pos_end\
    \ + 1;\n        }\n        if dot_pos_end == dot_pos_start {\n            dot_pos_end\
    \ = dot_pos_end + 1;\n        }\n        if dot_pos_end == dot_pos_start {\n \
    \           dot_pos_end = dot_pos_end + 1;\n        }\n        if dot_pos_end\
    \ == dot_pos_start {\n            dot_pos_end = dot_pos_end + 1;\n\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0fvuuuhm.rs:109:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n21  |  \
    \   while dot_pos_start < dot_pos_end {\n    |                               \
    \        - unclosed delimiter\n...\n76  |         if dot_pos_end == dot_pos_start\
    \ {\n    |                                         - this delimiter might not\
    \ be properly closed...\n...\n79  | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n109 | }\n    |   ^\n\nerror: expected `;`, found\
    \ keyword `if`\n  --> /tmp/tmp0fvuuuhm.rs:15:42\n   |\n15 |     let mut dot_pos\
    \ = file_name.find('.')\n   |                                          ^ help:\
    \ add `;` here\n16 |     if dot_pos == String::npos {\n   |     -- unexpected\
    \ token\n\nerror[E0599]: no function or associated item named `npos` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp0fvuuuhm.rs:16:27\n   |\n\
    16 |     if dot_pos == String::npos {\n   |                           ^^^^ function\
    \ or associated item not found in `String`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmp0fvuuuhm.rs:19:35\n   |\n19 |     let mut\
    \ dot_pos_end = dot_pos + 1;\n   |                           ------- ^ - {integer}\n\
    \   |                           |\n   |                           Option<usize>\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp0fvuuuhm.rs:20:37\n\
    \   |\n20 |     let mut dot_pos_start = dot_pos + 1;\n   |                   \
    \          ------- ^ - {integer}\n   |                             |\n   |   \
    \                          Option<usize>\n\nerror[E0308]: mismatched types\n \
    \  --> /tmp/tmp0fvuuuhm.rs:21:5\n    |\n13  |   fn file_name_check(file_name:\
    \ String) -> String {\n    |                                            ------\
    \ expected `String` because of return type\n...\n21  | /     while dot_pos_start\
    \ < dot_pos_end {\n22  | |         let mut dot_pos_start = dot_pos_end;\n23  |\
    \ |         let mut dot_pos_end = dot_pos_start;\n24  | |         "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\"\n    }\n    \n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_pos_4 = file_name.find('.')\n\
    \    if dot_pos_4 == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5 == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_pos_6 = file_name.find('.')\n\
    \    if dot_pos_6 == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_pos_7 = file_name.find('.')\n    if dot_pos_7 == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_pos_8 = file_name.find('.')\n\
    \    if dot_pos_8 == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos { \n        return \"No\"\n    }\n    \n  \
    \  let mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos\
    \ { \n        return \"No\"\n    }\n    \n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos { \n        return \"No\"\n    }\n    \n  \
    \  let mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos\
    \ { \n        return \"No\"\n    }\n    \n    let mut dot_pos_14 = file_name.find('.')\n\
    \    if dot_pos_14 == String::npos { \n        return \"No\"\n    }\n    \n  \
    \  let mut dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos\
    \ { \n        return \"No\"\n    }\n    \n    let mut dot_pos_16 = file_name.find('.')\n\
    \    if dot_pos_16 == String::npos { \n        return \"No\"\n    }\n    \n  \
    \  let mut dot_pos_17 = file_name.find('.')\n    if dot_pos_17 == String::npos\
    \ { \n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpqq24xawm.rs:127:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n96  |  \
    \   if dot_pos_17 == String::npos { \n    |                                  \
    \ - this delimiter might not be properly closed...\n97  | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n127 | }\n    |   ^\n\nerror:\
    \ expected `;`, found keyword `if`\n  --> /tmp/tmpqq24xawm.rs:15:42\n   |\n15\
    \ |     let mut dot_pos = file_name.find('.')\n   |                          \
    \                ^ help: add `;` here\n16 |     if dot_pos == String::npos { \n\
    \   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmpqq24xawm.rs:20:44\n   |\n20 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n21 |  \
    \   if dot_pos_2 == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpqq24xawm.rs:25:44\n   |\n25 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n26 |     if dot_pos_3 == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmpqq24xawm.rs:30:44\n   |\n30 |     let mut dot_pos_4 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n31 |  \
    \   if dot_pos_4 == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpqq24xawm.rs:35:44\n   |\n35 |     let\
    \ mut dot_pos_5 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n36 |     if dot_pos_5 == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmpqq24xawm.rs:40:44\n   |\n40 |     let mut dot_pos_6 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n41 |  \
    \   if dot_pos_6 == String::npos { \n   |     -- unexpected token\n\nerror: exp"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.len() > 3 {\n        String::from(\"\"\
    )\n    } else {\n        let mut dot_index = file_name.rfind('.')\n        if\
    \ dot_index == String::npos {\n            String::from(\"\")\n        } else\
    \ {\n            let mut dot_string = file_name[dot_index..].to_string();\n  \
    \          if dot_string.len() != 1 || dot_string[0] != 'a' || dot_string[0] !=\
    \ 'A' || dot_string[0] != 'z' || dot_string[0] != 'Z' {\n                String::from(\"\
    \")\n            } else {\n                dot_string = dot_string[1..].to_string();\n\
    \                if dot_string.len() != 1 || dot_string[0] != '0' || dot_string[0]\
    \ != '9' {\n                    String::from(\"\")\n                } else {\n\
    \                    String::from(\"Yes\")\n                }\n            }\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n  \
    \  assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"));\n\
    \    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"));\n\
    \    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpl5q1wajs.rs:17:49\n\
    \   |\n17 |         let mut dot_index = file_name.rfind('.')\n   |           \
    \                                      ^ help: add `;` here\n18 |         if dot_index\
    \ == String::npos {\n   |         -- unexpected token\n\nerror[E0599]: no function\
    \ or associated item named `npos` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpl5q1wajs.rs:18:33\n   |\n18 |         if dot_index == String::npos\
    \ {\n   |                                 ^^^^ function or associated item not\
    \ found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \  --> /tmp/tmpl5q1wajs.rs:21:34\n   |\n21 |             let mut dot_string =\
    \ file_name[dot_index..].to_string();\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `RangeFrom<Option<usize>>`\n   |\n   = help: the\
    \ trait `Index<RangeFrom<Option<usize>>>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    if\
    \ file_name.len() > 3 {\n        file_name.truncate(3);\n    }\n    if file_name.contains('.')\
    \ {\n        file_name.truncate(file_name.rfind('.'));\n    }\n    if file_name.starts_with(\"\
    a\") || file_name.starts_with(\"A\") || file_name.starts_with(\"0\") || file_name.starts_with(\"\
    9\") {\n        file_name.truncate(0);\n    }\n    if file_name.contains(\".\"\
    ) {\n        file_name.truncate(file_name.rfind(\".\") + 1);\n    }\n    if file_name.contains(\"\
    .\") {\n        file_name.truncate(file_name.rfind(\".\") + 1);\n    }\n    if\
    \ file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\".\"\
    ) + 1);\n    }\n    if file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\"\
    .\") + 1);\n    }\n    if file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\"\
    .\") + 1);\n    }\n    if file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\"\
    .\") + 1);\n    }\n    if file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\"\
    .\") + 1);\n    }\n    if file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\"\
    .\") + 1);\n    }\n    if file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\"\
    .\") + 1);\n    }\n    if file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\"\
    .\") + 1);\n    }\n    if file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\"\
    .\") + 1);\n    }\n    if file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\"\
    .\") + 1);\n    }\n    if file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\"\
    .\") + 1);\n    }\n    if file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\"\
    .\") + 1);\n    }\n    if file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\"\
    .\") + 1);\n    }\n    if file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\"\
    .\") + 1);\n    }\n    if file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\"\
    .\") + 1);\n    }\n    if file_name.contains(\".\") {\n        file_name.truncate(file_name.rfind(\"\
    .\") + 1);\n    }\n    if file_name.contains(\"\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmp9ycddpfj.rs:84:40\n\
    \   |\n84 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n  --> /tmp/tmp9ycddpfj.rs:97:56\n   |\n97 |\
    \     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n   |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmp9ycddpfj.rs:108:63\n\
    \    |\n108 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    109 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name_len = file_name.len();\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n        return\
    \ String::from(\"No\");\n    }\n    let mut dot_len = dot_pos - file_name.len()\
    \ - 1;\n    while dot_len > 0 {\n        if file_name[dot_len] != '0' && file_name[dot_len]\
    \ != '9' {\n            return String::from(\"No\");\n        }\n        dot_len\
    \ -= 1;\n    }\n    let mut first_letter = file_name[0];\n    if first_letter\
    \ != 'a' && first_letter != 'A' {\n        return String::from(\"No\");\n    }\n\
    \    let mut last_letter = file_name[file_name_len - 1];\n    if last_letter !=\
    \ 'z' && last_letter != 'Z' {\n        return String::from(\"No\");\n    }\n \
    \   String::from(\"\")\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp_oipbmhq.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmp_oipbmhq.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot subtract\
    \ `usize` from `Option<usize>`\n  --> /tmp/tmp_oipbmhq.rs:19:31\n   |\n19 |  \
    \   let mut dot_len = dot_pos - file_name.len() - 1;\n   |                   \
    \    ------- ^ --------------- usize\n   |                       |\n   |     \
    \                  Option<usize>\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `{integer}`\n  --> /tmp/tmp_oipbmhq.rs:26:28\n   |\n26 |     let\
    \ mut first_letter = file_name[0];\n   |                            ^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_oipbmhq.rs:30:27\n   |\n30 |     let mut last_letter = file_name[file_name_len\
    \ - 1];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeI"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return String::from(\"No\");\n    }\n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_4 = file_name.find('.')\n\
    \    if dot_pos_4 == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_6 = file_name.find('.')\n\
    \    if dot_pos_6 == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_7 = file_name.find('.')\n    if dot_pos_7 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_8 = file_name.find('.')\n\
    \    if dot_pos_8 == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos { \n        return String::from(\"No\");\n\
    \    }\n    let mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos { \n        return String::from(\"No\");\n\
    \    }\n    let mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_14 = file_name.find('.')\n\
    \    if dot_pos_14 == String::npos { \n        return String::from(\"No\");\n\
    \    }\n    let mut dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_16 = file_name.find('.')\n\
    \    if dot_pos_16 == String::npos { \n\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp3mh74srk.rs:108:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n76  |  \
    \   if dot_pos_16 == String::npos { \n    |                                  \
    \ - this delimiter might not be properly closed...\n77  | \n78  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n108 | }\n    |   ^\n\n\
    error: expected `;`, found keyword `if`\n  --> /tmp/tmp3mh74srk.rs:15:42\n   |\n\
    15 |     let mut dot_pos = file_name.find('.')\n   |                         \
    \                 ^ help: add `;` here\n16 |     if dot_pos == String::npos {\
    \ \n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmp3mh74srk.rs:19:44\n   |\n19 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n20 |  \
    \   if dot_pos_2 == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp3mh74srk.rs:23:44\n   |\n23 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n24 |     if dot_pos_3 == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmp3mh74srk.rs:27:44\n   |\n27 |     let mut dot_pos_4 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n28 |  \
    \   if dot_pos_4 == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp3mh74srk.rs:31:44\n   |\n31 |     let\
    \ mut dot_pos_5 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n32 |     if dot_pos_5 == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmp3mh74srk.rs:35:44\n   |\n35 |     let mut dot_pos_6 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n36 |  \
    \   if dot_pos_6 == String::npos { \n   |     -- unexpected token\n\nerr"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos { \n \
    \       return \"No\"\n    }\n    \n    let mut first_letter = file_name[..dot_index].chars().next().unwrap();\n\
    \    if first_letter < 'a' || first_letter > 'z' {\n        return \"No\"\n  \
    \  }\n    \n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ { \n        return \"No\"\n    }\n    \n    let mut dot_name = file_name[dot_index..].chars().next().unwrap();\n\
    \    if dot_name.is_empty() {\n        return \"No\"\n    }\n    \n    if dot_name.len()\
    \ != 3 {\n        return \"No\"\n    }\n    \n    if dot_name[0] < 'a' || dot_name[0]\
    \ > 'z' {\n        return \"No\"\n    }\n    \n    if dot_name[1] < 'a' || dot_name[1]\
    \ > 'z' {\n        return \"No\"\n    }\n    \n    if dot_name[2] < 'a' || dot_name[2]\
    \ > 'z' {\n        return \"No\"\n    }\n    \n    return \"Yes\"\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmphyyra1rn.rs:15:44\n\
    \   |\n15 |     let mut dot_index = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n16 |     if dot_index == String::npos\
    \ { \n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmphyyra1rn.rs:25:44\n   |\n25 |     let mut dot_index = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n26 |  \
    \   if dot_index == String::npos { \n   |     -- unexpected token\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmphyyra1rn.rs:16:29\n   |\n16 |     if dot_index\
    \ == String::npos { \n   |                             ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphyyra1rn.rs:17:16\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n17 |         return \"No\"\n   |                ^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&str`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `RangeTo<Option<usize>>`\n  --> /tmp/tmphyyra1rn.rs:20:28\n   |\n20 |   \
    \  let mut first_letter = file_name[..dot_index].chars().next().unwrap();\n  \
    \ |                            ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `RangeTo<Option<usize>>`\n   |\n   = help: the trait `Index<RangeTo<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no function or associated i"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return \"No\";\n    }\n    let mut dot_pos_end = dot_pos;\n    dot_pos_end\
    \ += 1;\n    while dot_pos_end < file_name.len() {\n        let mut dot_pos_start\
    \ = dot_pos;\n        dot_pos_start += 1;\n        if file_name[dot_pos_start]\
    \ >= 'a' && file_name[dot_pos_start] <= 'z' {\n            dot_pos_start += 1;\n\
    \        }\n        if file_name[dot_pos_start] >= 'A' && file_name[dot_pos_start]\
    \ <= 'Z' {\n            dot_pos_start += 1;\n        }\n        if file_name[dot_pos_start]\
    \ != '0' && file_name[dot_pos_start] != '9' {\n            return \"No\";\n  \
    \      }\n        if dot_pos_start == dot_pos_end {\n            break;\n    \
    \    }\n    }\n    return \"Yes\";\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpplsy3s_b.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpplsy3s_b.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpplsy3s_b.rs:17:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n17 |         return \"No\";\n   |    \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \               |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Option<usize>`\n\
    \  --> /tmp/tmpplsy3s_b.rs:20:5\n   |\n20 |     dot_pos_end += 1;\n   |     -----------^^^^^\n\
    \   |     |\n   |     cannot use `+=` on type `Option<usize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpplsy3s_b.rs:21:25\n   |\n21 |     while dot_pos_end\
    \ < file_name.len() {\n   |                         ^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n21 |     while dot_pos_end < Some(file_name.len()) {\n   |            \
    \             +++++               +\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `Option<usize>`\n  --> /tmp/tmpplsy3s_b.rs:23:9\n\
    \   |\n23 |         dot_pos_start += 1;\n   |         -------------^^^^^\n   |\
    \         |\n   |         cannot use `+=` on type `Option<usize>`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `Option<usize>`\n  --> /tmp/tmpplsy3s_b.rs:24:12\n\
    \   |\n24 |         if file_name[dot_pos_start] >= 'a' && file_name[dot_pos_start]\
    \ <= '"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_char: u8 = 0;\n    let mut second_char:\
    \ u8 = 0;\n    let mut third_char: u8 = 0;\n    let mut fourth_char: u8 = 0;\n\
    \    let mut fifth_char: u8 = 0;\n    let mut sixth_char: u8 = 0;\n    let mut\
    \ seventh_char: u8 = 0;\n    let mut eighth_char: u8 = 0;\n    let mut ninth_char:\
    \ u8 = 0;\n    let mut tenth_char: u8 = 0;\n    let mut first_char_str: String\
    \ = String::new();\n    let mut second_char_str: String = String::new();\n   \
    \ let mut third_char_str: String = String::new();\n    let mut fourth_char_str:\
    \ String = String::new();\n    let mut fifth_char_str: String = String::new();\n\
    \    let mut sixth_char_str: String = String::new();\n    let mut seventh_char_str:\
    \ String = String::new();\n    let mut eighth_char_str: String = String::new();\n\
    \    let mut ninth_char_str: String = String::new();\n    let mut tenth_char_str:\
    \ String = String::new();\n    let mut first_char_str_index: usize = 0;\n    let\
    \ mut second_char_str_index: usize = 0;\n    let mut third_char_str_index: usize\
    \ = 0;\n    let mut fourth_char_str_index: usize = 0;\n    let mut fifth_char_str_index:\
    \ usize = 0;\n    let mut sixth_char_str_index: usize = 0;\n    let mut seventh_char_str_index:\
    \ usize = 0;\n    let mut eighth_char_str_index: usize = 0;\n    let mut ninth_char_str_index:\
    \ usize = 0;\n    let mut tenth_char_str_index: usize = 0;\n    let mut first_char_str_index2:\
    \ usize = 0;\n    let mut second_char_str_index2: usize = 0;\n    let mut third_char_str_index2:\
    \ usize = 0;\n    let mut fourth_char_str_index2: usize = 0;\n    let mut fifth_char_str_index2:\
    \ usize = 0;\n    let mut sixth_char_str_index2: usize = 0;\n    let mut seventh_char_str_index2:\
    \ usize = 0;\n    let mut eighth_char_str_index2: usize = 0;\n    let mut ninth_char_str_index2:\
    \ usize = 0;\n    let mut tenth_char_str_index2: usize = 0;\n    let mut first_char_str_index3:\
    \ usize = 0;\n\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt3qzf0z4.rs:13:42\n   |\n\
    13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    \n    let mut dot_pos_end = dot_pos\
    \ + 1;\n    let mut dot_pos_start = dot_pos + 1;\n    \n    while dot_pos_start\
    \ < dot_pos_end {\n        let mut dot_pos_end = dot_pos_end;\n        \n    \
    \    if dot_pos_end == dot_pos_start {\n            dot_pos_end += 1;\n      \
    \  }\n        \n        let mut dot_pos_start = dot_pos_start;\n        \n   \
    \     if dot_pos_start < dot_pos_end {\n            let mut dot_pos_start = dot_pos_start;\n\
    \            \n            if dot_pos_start < dot_pos_end {\n                let\
    \ mut dot_pos_start = dot_pos_start;\n                \n                if dot_pos_start\
    \ < dot_pos_end {\n                    let mut dot_pos_start = dot_pos_start;\n\
    \                    \n                    if dot_pos_start < dot_pos_end {\n\
    \                        let mut dot_pos_start = dot_pos_start;\n            \
    \            \n                        if dot_pos_start < dot_pos_end {\n    \
    \                        let mut dot_pos_start = dot_pos_start;\n            \
    \                \n                            if dot_pos_start < dot_pos_end\
    \ {\n                                let mut dot_pos_start = dot_pos_start;\n\
    \                                \n                                if dot_pos_start\
    \ < dot_pos_end {\n                                    let mut dot_pos_start =\
    \ dot_pos_start;\n                                    \n                     \
    \               if dot_pos_start < dot_pos_end {\n                           \
    \             let mut dot_pos_start = dot_pos_start;\n                       \
    \                 \n                                        if dot_pos_start <\
    \ dot_pos_end {\n                                            let mut dot_pos_start\
    \ = dot_pos_start;\n                                            \n           \
    \                                 if dot_pos_start < dot_pos_end {\n         \
    \                                       let mut dot_pos_start = dot_pos_start;\n\
    \                                                \n                          \
    \                      if dot_pos_start < dot_pos_end {\n                    \
    \                                let mut dot_pos_start = dot_pos_start;\n    \
    \                                                \n                          \
    \                          if dot_pos_start < dot_pos_end {\n                \
    \                                        let mut dot_pos_start = dot_pos_start;\n\
    \                                                        \n                  \
    \                                      if dot_pos_start < dot_pos_end {\n    \
    \                                                        let mut dot_pos_start\
    \ = dot_pos_start;\n                                                         \
    \   \n                                                            if dot_pos_start\
    \ < dot_pos_end {\n                                                          \
    \      let mut dot_pos_start = dot_pos_start;\n                              \
    \                                  \n                                        \
    \                        if dot_pos_start < dot_pos_end {\n                  \
    \                                                  let mut dot_pos_start = dot_pos_start;\n\
    \                                                                    \n      \
    \                                                              if dot_pos_start\
    \ < dot_pos_end {\n                                                          \
    \              let mut dot_pos_start = dot_pos_start;\n                      \
    \                                                  \n                        \
    \                                                if dot_pos_start < dot_pos_end\
    \ {\n\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9efccq66.rs:112:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n23  |  \
    \   while dot_pos_start < dot_pos_end {\n    |                               \
    \        - unclosed delimiter\n...\n32  |         if dot_pos_start < dot_pos_end\
    \ {\n    |                                        - unclosed delimiter\n...\n\
    35  |             if dot_pos_start < dot_pos_end {\n    |                    \
    \                        - unclosed delimiter\n...\n38  |                 if dot_pos_start\
    \ < dot_pos_end {\n    |                                                - unclosed\
    \ delimiter\n...\n41  |                     if dot_pos_start < dot_pos_end {\n\
    \    |                                                    - unclosed delimiter\n\
    ...\n44  |                         if dot_pos_start < dot_pos_end {\n    |   \
    \                                                     - unclosed delimiter\n...\n\
    47  |                             if dot_pos_start < dot_pos_end {\n    |    \
    \                                                        - unclosed delimiter\n\
    ...\n50  |                                 if dot_pos_start < dot_pos_end {\n\
    \    |                                                                - unclosed\
    \ delimiter\n...\n53  |                                     if dot_pos_start <\
    \ dot_pos_end {\n    |                                                       \
    \             - unclosed delimiter\n...\n56  |                               \
    \          if dot_pos_start < dot_pos_end {\n    |                           \
    \                                             - unclosed delimiter\n...\n59  |\
    \                                             if dot_pos_start < dot_pos_end {\n\
    \    |                                                                       \
    \     - unclosed delimiter\n...\n62  |                                       \
    \          if dot_pos_start < dot_pos_end {\n    |                           \
    \                                                     - unclose"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return String::from(\"No\");\n    }\n    \n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    \n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 ==\
    \ String::npos { \n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_pos_4 = file_name.find('.')\n    if dot_pos_4 == String::npos { \n \
    \       return String::from(\"No\");\n    }\n    \n    let mut dot_pos_5 = file_name.find('.')\n\
    \    if dot_pos_5 == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    \n    let mut dot_pos_6 = file_name.find('.')\n    if dot_pos_6 ==\
    \ String::npos { \n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_pos_7 = file_name.find('.')\n    if dot_pos_7 == String::npos { \n \
    \       return String::from(\"No\");\n    }\n    \n    let mut dot_pos_8 = file_name.find('.')\n\
    \    if dot_pos_8 == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    \n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 ==\
    \ String::npos { \n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_pos_10 = file_name.find('.')\n    if dot_pos_10 == String::npos { \n\
    \        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_11 = file_name.find('.')\n\
    \    if dot_pos_11 == String::npos { \n        return String::from(\"No\");\n\
    \    }\n    \n    let mut dot_pos_12 = file_name.find('.')\n    if dot_pos_12\
    \ == String::npos { \n        return String::from(\"No\");\n    }\n    \n    let\
    \ mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos { \n\
    \        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_14 = file_name.find('.')\n\
    \    if dot_pos_14 == String::npos { \n        return String::from(\"No\");\n\
    \    }\n    \n    let mut dot_pos_15 = file_name.find('.')\n    if dot_pos_15\
    \ == String::npos { \n        return String::from(\"\n}\n\nfn main() {\n    let\
    \ candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmps8lr0ov0.rs:93:40\n\
    \   |\n93 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n   --> /tmp/tmps8lr0ov0.rs:106:56\n    |\n106\
    \ |     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n    |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmps8lr0ov0.rs:117:63\n\
    \    |\n117 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    118 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos = dot_pos + 1;\n \
    \   let mut dot_pos_end = file_name.find('.')\n    if dot_pos_end == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos_end\
    \ - 1;\n    let mut dot_pos_start = dot_pos;\n    let mut dot_pos_start_end =\
    \ dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut dot_pos_start_end = dot_pos_end;\n    let mut dot_pos_start_end\
    \ = dot_pos_end;\n    let mut \n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpoiavnjj1.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpoiavnjj1.rs:20:46\n   |\n20 |     let mut dot_pos_end = file_name.find('.')\n\
    \   |                                              ^ help: add `;` here\n21 |\
    \     if dot_pos_end == String::npos {\n   |     -- unexpected token\n\nerror:\
    \ expected identifier, found `}`\n  --> /tmp/tmpoiavnjj1.rs:64:1\n   |\n64 | }\n\
    \   | ^ expected identifier\n\nerror[E0599]: no function or associated item named\
    \ `npos` found for struct `String` in the current scope\n  --> /tmp/tmpoiavnjj1.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n  --> /tmp/tmpoiavnjj1.rs:19:31\n   |\n19 |\
    \     let mut dot_pos = dot_pos + 1;\n   |                       ------- ^ - {integer}\n\
    \   |                       |\n   |                       Option<usize>\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpoiavnjj1.rs:21:31\n   |\n21 |     if dot_pos_end\
    \ == String::npos {\n   |                               ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0369]: cannot subtract `{integer}` from\
    \ `Option<usize>`\n  --> /tmp/tmpoiavnjj1.rs:24:39\n   |\n24 |     let mut dot_pos_end\
    \ = dot_pos_end - 1;\n   |                           ----------- ^ - {integer}\n\
    \   |                           |\n   |                           Option<usize>\n\
    \nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return \"No\"\n    }\n    if file_name.len() > 3 {\n        return \"No\"\n\
    \    }\n    if file_name.starts_with(\"0\") || file_name.starts_with(\"1\") ||\
    \ file_name.starts_with(\"2\") || file_name.starts_with(\"3\") || file_name.starts_with(\"\
    4\") || file_name.starts_with(\"5\") || file_name.starts_with(\"6\") || file_name.starts_with(\"\
    7\") || file_name.starts_with(\"8\") || file_name.starts_with(\"9\") {\n     \
    \   return \"No\"\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter())\
    \ {\n        return \"No\"\n    }\n    if file_name.chars().any(|c| !c.is_ascii_lowercase())\
    \ {\n        return \"No\"\n    }\n    if file_name.chars().any(|c| !c.is_ascii_uppercase())\
    \ {\n        return \"No\"\n    }\n    if file_name.chars().any(|c| !c.is_ascii_punctuation())\
    \ {\n        return \"No\"\n    }\n    if file_name.chars().any(|c| !c.is_ascii_digit())\
    \ {\n        return \"No\"\n    }\n    if file_name.chars().any(|c| !c.is_ascii_symbol())\
    \ {\n        return \"No\"\n    }\n    if file_name.chars().any(|c| !c.is_ascii_whitespace())\
    \ {\n        return \"No\"\n    }\n    if file_name.chars().any(|c| !c.is_ascii_control())\
    \ {\n        return \"No\"\n    }\n    if file_name.chars().any(|c| !c.is_ascii_newline())\
    \ {\n        return \"No\"\n    }\n    if file_name.chars().any(|c| !c.is_ascii_linefeed())\
    \ {\n        return \"No\"\n    }\n    if file_name.chars().any(|c| !c.is_ascii_formfeed())\
    \ {\n        return \"No\"\n    }\n    if file_name.chars().any(|c| !c.is_ascii_return())\
    \ {\n        return \"No\"\n    }\n    if file_name.chars().any(|c| !c.is_ascii_tab())\
    \ {\n        return \"No\"\n    }\n    if file_name.chars().any(|c| !c.is_ascii_vertical_tab())\
    \ {\n        return \"No\"\n    }\n    if file_name.chars().any(|c| !c.is_ascii_horizontal_tab())\
    \ {\n        return \"No\"\n    }\n    if file_name.chars().any(|c| !c.is_ascii_backspace())\
    \ {\n        return \"No\"\n    }\n    if file_name.chars().any(|\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpdo9dx5oi.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `|`, found `)`\n  --> /tmp/tmpdo9dx5oi.rs:74:1\n\
    \   |\n73 |     if file_name.chars().any(|\n   |                             \
    \  - expected `|`\n74 | }\n   | ^ unexpected token\n\nerror: mismatched closing\
    \ delimiter: `}`\n  --> /tmp/tmpdo9dx5oi.rs:73:29\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                                 -\
    \ closing delimiter possibly meant for this\n...\n73 |     if file_name.chars().any(|\n\
    \   |                             ^ unclosed delimiter\n74 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0599]: no function or associated item named `npos`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpdo9dx5oi.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdo9dx5oi.rs:17:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n17 |         return \"No\"\n   |     \
    \           ^^^^- help: try using a conversion method: `.to_string()`\n   |  \
    \              |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0599]: no method named `is_ascii_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpdo9dx5oi.rs:25:37\n   |\n25 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n   |                                     ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_symbol` found for type `char` in the current scope\n\
    \  --> /tmp/tmpdo9dx5oi.rs:40:37\n   |\n40 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_symbol()) {\n   |                                     ^^^^^^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter =\
    \ dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = \n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp138jrh_p.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected expression, found `}`\n \
    \ --> /tmp/tmp138jrh_p.rs:59:1\n   |\n59 | }\n   | ^ expected expression\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp138jrh_p.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmp138jrh_p.rs:19:35\n   |\n19 |     let mut dot_pos_end = dot_pos\
    \ + 1;\n   |                           ------- ^ - {integer}\n   |           \
    \                |\n   |                           Option<usize>\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp138jrh_p.rs:20:37\n\
    \   |\n20 |     let mut dot_pos_start = dot_pos + 1;\n   |                   \
    \          ------- ^ - {integer}\n   |                             |\n   |   \
    \                          Option<usize>\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { return \"\
    No\" }\n    if file_name[dot_pos - 1] != '.' { return \"No\" }\n    if file_name[dot_pos\
    \ - 2] != '0' && file_name[dot_pos - 2] != '9' { return \"No\" }\n    if file_name[dot_pos\
    \ - 1] == file_name[dot_pos - 2] {\n        file_name.truncate(dot_pos - 1);\n\
    \    }\n    if file_name.chars().any(|c| !c.is_ascii_letter()) { return \"No\"\
    \ }\n    if file_name.chars().any(|c| !c.is_ascii_lowercase()) { return \"No\"\
    \ }\n    if file_name.chars().any(|c| !c.is_ascii_uppercase()) { return \"No\"\
    \ }\n    if file_name.chars().any(|c| !c.is_ascii_punctuation()) { return \"No\"\
    \ }\n    if file_name.chars().any(|c| !c.is_ascii_digit()) { return \"No\" }\n\
    \    return \"Yes\"\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpy0_vpgae.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ { return \"No\" }\n   |     -- unexpected token\n\nerror[E0599]: no function\
    \ or associated item named `npos` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpy0_vpgae.rs:16:27\n   |\n16 |     if dot_pos == String::npos {\
    \ return \"No\" }\n   |                           ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy0_vpgae.rs:16:41\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n16 |     if dot_pos == String::npos { return \"No\" }\n   |             \
    \                            ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                         |\n   |                        \
    \                 expected struct `String`, found `&str`\n\nerror[E0369]: cannot\
    \ subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpy0_vpgae.rs:17:26\n\
    \   |\n17 |     if file_name[dot_pos - 1] != '.' { return \"No\" }\n   |     \
    \             ------- ^ - {integer}\n   |                  |\n   |           \
    \       Option<usize>\n\nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n\
    \  --> /tmp/tmpy0_vpgae.rs:18:26\n   |\n18 |     if file_name[dot_pos - 2] !=\
    \ '0' && file_name[dot_pos - 2] != '9' { return \"No\" }\n   |               \
    \   ------- ^ - {integer}\n   |                  |\n   |                  Option<usize>\n\
    \nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpy0_vpgae.rs:18:59\n\
    \   |\n18 |     if file_name[dot_pos - 2] != '0' && file_name[dot_pos - 2] !=\
    \ '9' { return \"No\" }\n   |                                                \
    \   ------- ^ - {integer}\n   |                                              \
    \     |\n   |                                                   Option<usize>\n\
    \nerror[E0369]: cannot subtract `{"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return \"No\";\n    }\n    let mut dot_pos_end = dot_pos + 1;\n    let mut\
    \ dot_pos_start = dot_pos + 1;\n    while dot_pos_start < dot_pos_end {\n    \
    \    let mut dot_pos_end = dot_pos_end;\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpimlxit1p.rs:122:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n21  |  \
    \   while dot_pos_start < dot_pos_end {\n    |                               \
    \        - this delimiter might not be properly closed...\n...\n92  | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n122 | }\n   \
    \ |   ^\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpimlxit1p.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpimlxit1p.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpimlxit1p.rs:17:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n17 |         return \"No\";\n   |    \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \               |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpimlxit1p.rs:19:35\n\
    \   |\n19 |     let mut dot_pos_end = dot_pos + 1;\n   |                     \
    \      ------- ^ - {integer}\n   |                           |\n   |         \
    \                  Option<usize>\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpimlxit1p.rs:20:37\n   |\n20 |     let mut dot_pos_start = dot_pos\
    \ + 1;\n   |                             ------- ^ - {integer}\n   |         \
    \                    |\n   |                             Option<usize>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpimlxit1p.rs:13:42\n   |\n13 | fn file_name_check(file_name:\
    \ String)"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut counter = 0;\n    for c in file_name.chars()\
    \ {\n        if !c.is_ascii_letter() {\n            return format!(\"No\");\n\
    \        }\n        if c.is_ascii_letter() && counter < 3 {\n            counter\
    \ = counter + 1;\n        }\n        if c.is_ascii_letter() && counter == 3 &&\
    \ c != '.' {\n            return format!(\"No\");\n        }\n        if c.is_ascii_letter()\
    \ && counter == 3 && c == '.' {\n            if !file_name.chars().next().unwrap().is_ascii_letter()\
    \ {\n                return format!(\"No\");\n            }\n        }\n    }\n\
    \    return \"Yes\";\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpjz95lcsv.rs:16:15\n   |\n16 |         if !c.is_ascii_letter()\
    \ {\n   |               ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpjz95lcsv.rs:19:14\n\
    \   |\n19 |         if c.is_ascii_letter() && counter < 3 {\n   |            \
    \  ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpjz95lcsv.rs:22:14\n   |\n22 |   \
    \      if c.is_ascii_letter() && counter == 3 && c != '.' {\n   |            \
    \  ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpjz95lcsv.rs:25:14\n   |\n25 |   \
    \      if c.is_ascii_letter() && counter == 3 && c == '.' {\n   |            \
    \  ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpjz95lcsv.rs:26:51\n   |\n26 |   \
    \          if !file_name.chars().next().unwrap().is_ascii_letter() {\n   |   \
    \                                                ^^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjz95lcsv.rs:31:12\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n31 |     return \"Yes\";\n   |       \
    \     ^^^^^- help: try using a conversion method: `.to_string()`\n   |       \
    \     |\n   |            expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_4 = file_name.find('.')\n\
    \    if dot_pos_4 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_6 = file_name.find('.')\n\
    \    if dot_pos_6 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_7 = file_name.find('.')\n    if dot_pos_7 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_8 = file_name.find('.')\n\
    \    if dot_pos_8 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_14 = file_name.find('.')\n\
    \    if dot_pos_14 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_16 = file_name.find('.')\n\
    \    if dot_pos_16 == String::npos {\n\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6269nr50.rs:108:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n76  |  \
    \   if dot_pos_16 == String::npos {\n    |                                   -\
    \ this delimiter might not be properly closed...\n77  | \n78  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n108 | }\n    |   ^\n\n\
    error: expected `;`, found keyword `if`\n  --> /tmp/tmp6269nr50.rs:15:42\n   |\n\
    15 |     let mut dot_pos = file_name.find('.')\n   |                         \
    \                 ^ help: add `;` here\n16 |     if dot_pos == String::npos {\n\
    \   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmp6269nr50.rs:19:44\n   |\n19 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n20 |  \
    \   if dot_pos_2 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp6269nr50.rs:23:44\n   |\n23 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n24 |     if dot_pos_3 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp6269nr50.rs:27:44\n\
    \   |\n27 |     let mut dot_pos_4 = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n28 |     if dot_pos_4 == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmp6269nr50.rs:31:44\n   |\n31 |     let mut dot_pos_5 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n32 |  \
    \   if dot_pos_5 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp6269nr50.rs:35:44\n   |\n35 |     let\
    \ mut dot_pos_6 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n36 |     if dot_pos_6 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: exp"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.len() > 3 {\n        return \"No\";\n\
    \    }\n    if file_name.contains(\".\") {\n        return \"No\";\n    }\n  \
    \  if file_name.chars().any(|c| !c.is_ascii_letter()) {\n        return \"No\"\
    ;\n    }\n    if file_name.chars().any(|c| !c.is_ascii_lowercase()) {\n      \
    \  return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_uppercase())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_digit())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_punctuation())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_symbol())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_whitespace())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_control())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_graph())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_print())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_graphical())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_graphic())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_printable())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_graphical())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_graphic())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_printable())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_graphical())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_graphic())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_printable())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_graphical())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_graphic())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_print\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpgikjofsx.rs:84:1\n   |\n\
    83 |     if file_name.chars().any(|c| !c.is_ascii_print\n   |     -- this `if`\
    \ expression has a condition, but no block\n84 | }\n   | ^ expected `{`\n\nerror:\
    \ mismatched closing delimiter: `}`\n  --> /tmp/tmpgikjofsx.rs:83:29\n   |\n13\
    \ | fn file_name_check(file_name: String) -> String {\n   |                  \
    \                               - closing delimiter possibly meant for this\n\
    ...\n83 |     if file_name.chars().any(|c| !c.is_ascii_print\n   |           \
    \                  ^ unclosed delimiter\n84 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgikjofsx.rs:15:16\n   |\n13 |\
    \ fn file_name_check(file_name: String) -> String {\n   |                    \
    \                      ------ expected `String` because of return type\n14 | \
    \    if file_name.len() > 3 {\n15 |         return \"No\";\n   |             \
    \   ^^^^- help: try using a conversion method: `.to_string()`\n   |          \
    \      |\n   |                expected struct `String`, found `&str`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmpgikjofsx.rs:20:37\n   |\n20 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n   |                                     ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_symbol` found for type `char` in the current scope\n\
    \  --> /tmp/tmpgikjofsx.rs:35:37\n   |\n35 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_symbol()) {\n   |                                     ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_graph` found for type `char` in the current scope\n\
    \  --> /tmp/tmpgikjofsx.rs:44:37\n   |\n44 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_graph()) {\n   |                                     ^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_print` found for t"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter =\
    \ dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = \n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpuyz4qq9h.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected expression, found `}`\n \
    \ --> /tmp/tmpuyz4qq9h.rs:59:1\n   |\n59 | }\n   | ^ expected expression\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpuyz4qq9h.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpuyz4qq9h.rs:19:35\n   |\n19 |     let mut dot_pos_end = dot_pos\
    \ + 1;\n   |                           ------- ^ - {integer}\n   |           \
    \                |\n   |                           Option<usize>\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpuyz4qq9h.rs:20:37\n\
    \   |\n20 |     let mut dot_pos_start = dot_pos + 1;\n   |                   \
    \          ------- ^ - {integer}\n   |                             |\n   |   \
    \                          Option<usize>\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return \"No\";\n    }\n    let mut dot_pos_2 = file_name.find('.')\n    if\
    \ dot_pos_2 == String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_3\
    \ = file_name.find('.')\n    if dot_pos_3 == String::npos {\n        return \"\
    No\";\n    }\n    let mut dot_pos_4 = file_name.find('.')\n    if dot_pos_4 ==\
    \ String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_5 = file_name.find('.')\n\
    \    if dot_pos_5 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_6 = file_name.find('.')\n    if dot_pos_6 == String::npos {\n      \
    \  return \"No\";\n    }\n    let mut dot_pos_7 = file_name.find('.')\n    if\
    \ dot_pos_7 == String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_8\
    \ = file_name.find('.')\n    if dot_pos_8 == String::npos {\n        return \"\
    No\";\n    }\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 ==\
    \ String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos {\n    \
    \    return \"No\";\n    }\n    let mut dot_pos_12 = file_name.find('.')\n   \
    \ if dot_pos_12 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos {\n    \
    \    return \"No\";\n    }\n    let mut dot_pos_14 = file_name.find('.')\n   \
    \ if dot_pos_14 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos {\n    \
    \    return \"No\";\n    }\n    let mut dot_pos_16 = file_name.find('.')\n   \
    \ if dot_pos_16 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_17 = file_name.find('.')\n    if dot_pos_17 == String::npos {\n    \
    \    return \"No\";\n    }\n    let mut dot_pos_18 = file_name.find('.')\n   \
    \ if dot_pos_18 == String::npos {\n        return \"No\n}\n\nfn main() {\n   \
    \ let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmpzbbaa21e.rs:91:40\n\
    \   |\n91 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n   --> /tmp/tmpzbbaa21e.rs:104:56\n    |\n104\
    \ |     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n    |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmpzbbaa21e.rs:115:63\n\
    \    |\n115 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    116 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\n  \
    \      return String::from(\"No\");\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ {\n        return String\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp69sbkzca.rs:112:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n80  |  \
    \   if dot_index == String::npos {\n    |                                  - this\
    \ delimiter might not be properly closed...\n81  |         return String\n82 \
    \ | }\n    | - ...as it matches this but it has different indentation\n...\n112\
    \ | }\n    |   ^\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp69sbkzca.rs:15:44\n\
    \   |\n15 |     let mut dot_index = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n16 |     if dot_index == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmp69sbkzca.rs:19:44\n   |\n19 |     let mut dot_index = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n20 |  \
    \   if dot_index == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp69sbkzca.rs:23:44\n   |\n23 |     let\
    \ mut dot_index = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n24 |     if dot_index == String::npos {\n   |\
    \     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp69sbkzca.rs:27:44\n\
    \   |\n27 |     let mut dot_index = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n28 |     if dot_index == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmp69sbkzca.rs:31:44\n   |\n31 |     let mut dot_index = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n32 |  \
    \   if dot_index == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp69sbkzca.rs:35:44\n   |\n35 |     let\
    \ mut dot_index = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n36 |     if dot_index == String::npos {\n   |\
    \     -- une"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_letter = file_name[0];\n    let mut last_letter\
    \ = file_name[file_name.len() - 1];\n    if first_letter != 'a' && first_letter\
    \ != 'A' {\n        first_letter = 'a';\n    }\n    if last_letter != 'z' && last_letter\
    \ != 'Z' {\n        last_letter = 'z';\n    }\n    if file_name.len() != 3 ||\
    \ file_name.contains('.') != true || file_name.starts_with(first_letter) != true\
    \ || file_name.ends_with(last_letter) != true {\n        return \"No\";\n    }\n\
    \    return \"Yes\";\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpj9f9at4o.rs:14:28\n   |\n14 |     let mut first_letter = file_name[0];\n\
    \   |                            ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpj9f9at4o.rs:15:27\n   |\n15 |     let mut last_letter = file_name[file_name.len()\
    \ - 1];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj9f9at4o.rs:23:16\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n23 |         return \"No\";\n   |                ^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                |\n   |             \
    \   expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name_len = file_name.len();\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name_len > 3 {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos - 1] != String::from('0') && file_name[dot_pos\
    \ - 1] != String::from('1') {\n        return String::from(\"No\");\n    }\n \
    \   if file_name[dot_pos - 2] != String::from('a') && file_name[dot_pos - 2] !=\
    \ String::from('z') && file_name[dot_pos - 2] != String::from('A') && file_name[dot_pos\
    \ - 2] != String::from('Z') {\n        return String::from(\"No\");\n    }\n \
    \   if file_name[dot_pos - 3] != String::from('txt') && file_name[dot_pos - 3]\
    \ != String::from('exe') && file_name[dot_pos - 3] != String::from('dll') {\n\
    \        return String::from(\"No\");\n    }\n    return String::from(\"Yes\"\
    );\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp6kx6ab0v.rs:28:47\n\
    \   |\n28 |     if file_name[dot_pos - 3] != String::from('txt') && file_name[dot_pos\
    \ - 3] != String::from('exe') && file_name[dot_pos - 3] != String...\n   |   \
    \                                            ^^^^^\n   |\nhelp: if you meant to\
    \ write a `str` literal, use double quotes\n   |\n28 |     if file_name[dot_pos\
    \ - 3] != String::from(\"txt\") && file_name[dot_pos - 3] != String::from('exe')\
    \ && file_name[dot_pos - 3] != String::from('dll') {\n   |                   \
    \                            ~~~~~\n\nerror: character literal may only contain\
    \ one codepoint\n  --> /tmp/tmp6kx6ab0v.rs:28:96\n   |\n28 |     if file_name[dot_pos\
    \ - 3] != String::from('txt') && file_name[dot_pos - 3] != String::from('exe')\
    \ && file_name[dot_pos - 3] != String...\n   |                               \
    \                                                                 ^^^^^\n   |\n\
    help: if you meant to write a `str` literal, use double quotes\n   |\n28 |   \
    \  if file_name[dot_pos - 3] != String::from('txt') && file_name[dot_pos - 3]\
    \ != String::from(\"exe\") && file_name[dot_pos - 3] != String::from('dll') {\n\
    \   |                                                                        \
    \                        ~~~~~\n\nerror: character literal may only contain one\
    \ codepoint\n  --> /tmp/tmp6kx6ab0v.rs:28:145\n   |\n28 | ...= String::from('exe')\
    \ && file_name[dot_pos - 3] != String::from('dll') {\n   |                   \
    \                                                 ^^^^^\n   |\nhelp: if you meant\
    \ to write a `str` literal, use double quotes\n   |\n28 |     if file_name[dot_pos\
    \ - 3] != String::from('txt') && file_name[dot_pos - 3] != String::from('exe')\
    \ && file_name[dot_pos - 3] != String::from(\"dll\") {\n   |                 \
    \                                                                            \
    \                                                    ~~~~~\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp6kx6ab0v.rs:15:42\n   |\n15 |     let\
    \ mut dot_pos = file_name.find('.')\n   |            "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name_chars = file_name.chars();\n    let\
    \ mut file_name_chars_iter = file_name_chars.iter();\n    let mut file_name_chars_iter\
    \ = file_name_chars_iter.peekable();\n    let mut file_name_chars_iter = file_name_chars_iter.peekable();\n\
    \    let mut file_name_chars_iter = file_name_chars_iter.peekable();\n    let\
    \ mut file_name_chars_iter = file_name_chars_iter.peekable();\n    let mut file_name_chars_iter\
    \ = file_name_chars_iter.peekable();\n    let mut file_name_chars_iter = file_name_chars_iter.peekable();\n\
    \    let mut file_name_chars_iter = file_name_chars_iter.peekable();\n    let\
    \ mut file_name_chars_iter = file_name_chars_iter.peekable();\n    let mut file_name_chars_iter\
    \ = file_name_chars_iter.peekable();\n    let mut file_name_chars_iter = file_name_chars_iter.peekable();\n\
    \    let mut file_name_chars_iter = file_name_chars_iter.peekable();\n    let\
    \ mut file_name_chars_iter = file_name_chars_iter.peekable();\n    let mut file_name_chars_iter\
    \ = file_name_chars_iter.peekable();\n    let mut file_name_chars_iter = file_name_chars_iter.peekable();\n\
    \    let mut file_name_chars_iter = file_name_chars_iter.peekable();\n    let\
    \ mut file_name_chars_iter = file_name_chars_iter.peekable();\n    let mut file_name_chars_iter\
    \ = file_name_chars_iter.peekable();\n    let mut file_name_chars_iter = file_name_chars_iter.peekable();\n\
    \    let mut file_name_chars_iter = file_name_chars_iter.peekable();\n    let\
    \ mut file_name_chars_iter = file_name_chars_iter.peekable();\n    let mut file_name_chars_iter\
    \ = file_name_chars_iter.peekable();\n    let mut file_name_chars_iter = file_name_chars_iter.peekable();\n\
    \    let mut file_name_chars_iter = file_name_chars_iter.peekable();\n    let\
    \ mut file_name_chars_iter = file_name_chars_iter.peekable();\n    let mut file_name_chars_iter\
    \ = file_name_chars_iter.peekable();\n    let mut file_name_chars_iter = file_name_chars_iter.peekable();\n\
    \    let mut file_name_chars_iter = file_name_chars_iter.peekable();\n    let\
    \ mut file_name_chars_iter = file_name_chars_iter.peekable();\n    let mut file_name_chars_iter\
    \ = file_name_chars_iter.peekable();\n    let mut file_name_chars_iter = file_name_chars_iter.peekable();\n\
    \    let mut file_name_chars_iter = file_name_chars_iter.peekable();\n    let\
    \ mut file_name_chars_iter = file_name_chars_iter.peekable();\n    let mut file_name_chars_\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpto6cysuy.rs:48:29\n   |\n\
    48 |     let mut file_name_chars_\n   |                             ^ help: add\
    \ `;` here\n49 | }\n   | - unexpected token\n\nerror[E0599]: no method named `iter`\
    \ found for struct `Chars` in the current scope\n  --> /tmp/tmpto6cysuy.rs:15:52\n\
    \   |\n15 |     let mut file_name_chars_iter = file_name_chars.iter();\n   | \
    \                                                   ^^^^ private field, not a\
    \ method\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpto6cysuy.rs:13:42\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_next = dot_pos + 1;\n\
    \    while dot_pos_next < file_name.len() {\n        let mut dot_pos_next = dot_pos_next;\n\
    \        let mut dot_pos_prev = dot_pos_prev + 1;\n        if dot_pos_prev ==\
    \ dot_pos {\n            if file_name[dot_pos_prev] == '0' {\n               \
    \ return String::from(\"No\");\n            }\n        }\n        if dot_pos_prev\
    \ == dot_pos_next {\n            if file_name[dot_pos_prev] == '9' {\n       \
    \         return String::from(\"No\");\n            }\n        }\n        if dot_pos_prev\
    \ == dot_pos_next - 1 && dot_pos_prev != dot_pos {\n            if file_name[dot_pos_prev]\
    \ != 'a' && file_name[dot_pos_prev] != 'A' && file_name[dot_pos_prev] != 'z' &&\
    \ file_name[dot_pos_prev] != 'Z' {\n                return String::from(\"No\"\
    );\n            }\n        }\n    }\n    return String::from(\"Yes\");\n}\n\n\
    fn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmprzj79nl0.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0425]: cannot find value `dot_pos_prev`\
    \ in this scope\n  --> /tmp/tmprzj79nl0.rs:22:32\n   |\n22 |         let mut dot_pos_prev\
    \ = dot_pos_prev + 1;\n   |                                ^^^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `dot_pos_next`\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmprzj79nl0.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmprzj79nl0.rs:19:36\n   |\n19 |     let mut dot_pos_next = dot_pos\
    \ + 1;\n   |                            ------- ^ - {integer}\n   |          \
    \                  |\n   |                            Option<usize>\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos { \n \
    \       return \"No\"\n    }\n    if file_name[dot_index - 1] == '0' {\n     \
    \   return \"No\"\n    }\n    if file_name[dot_index - 1] == '9' {\n        return\
    \ \"No\"\n    }\n    if file_name[dot_index - 2] != ' ' {\n        return \"No\"\
    \n    }\n    if file_name[dot_index - 3] != 'a' {\n        return \"No\"\n   \
    \ }\n    if file_name[dot_index - 4] != 'z' {\n        return \"No\"\n    }\n\
    \    if file_name[dot_index - 5] != 'A' {\n        return \"No\"\n    }\n    if\
    \ file_name[dot_index - 6] != 'Z' {\n        return \"No\"\n    }\n    return\
    \ \"Yes\"\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpb5a5r2w6.rs:15:44\n\
    \   |\n15 |     let mut dot_index = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n16 |     if dot_index == String::npos\
    \ { \n   |     -- unexpected token\n\nerror[E0599]: no function or associated\
    \ item named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpb5a5r2w6.rs:16:29\n\
    \   |\n16 |     if dot_index == String::npos { \n   |                        \
    \     ^^^^ function or associated item not found in `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb5a5r2w6.rs:17:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n17 |         return \"No\"\n   |     \
    \           ^^^^- help: try using a conversion method: `.to_string()`\n   |  \
    \              |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpb5a5r2w6.rs:19:28\n\
    \   |\n19 |     if file_name[dot_index - 1] == '0' {\n   |                  ---------\
    \ ^ - {integer}\n   |                  |\n   |                  Option<usize>\n\
    \nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpb5a5r2w6.rs:22:28\n\
    \   |\n22 |     if file_name[dot_index - 1] == '9' {\n   |                  ---------\
    \ ^ - {integer}\n   |                  |\n   |                  Option<usize>\n\
    \nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpb5a5r2w6.rs:25:28\n\
    \   |\n25 |     if file_name[dot_index - 2] != ' ' {\n   |                  ---------\
    \ ^ - {integer}\n   |                  |\n   |                  Option<usize>\n\
    \nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpb5a5r2w6.rs:28:28\n\
    \   |\n28 |     if file_name[dot_index - 3] != 'a' {\n   |                  ---------\
    \ ^ - {integer}\n   |                  |\n   |                  Option<usize>\n\
    \nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpb5a5r2w6.rs:31:"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter =\
    \ true;\n    while dot_pos_start != dot_pos_end {\n        if dot_pos_start <\
    \ dot_pos_end {\n            if dot_pos_start[0] >= 'a' && dot_pos_start[0] <=\
    \ 'z' {\n                dot_pos_start_letter = true;\n            }\n       \
    \     if dot_pos_start[0] >= 'A' && dot_pos_start[0] <= 'Z' {\n              \
    \  dot_pos_start_letter = false;\n            }\n        }\n        if dot_pos_start\
    \ == dot_pos_end {\n            if dot_pos_start_letter {\n                return\
    \ String::from(\"No\");\n            }\n        }\n        if dot_pos_start ==\
    \ dot_pos_end {\n            return String::from(\"No\");\n        }\n       \
    \ dot_pos_start = dot_pos_end + 1;\n    }\n    String::from(\"Yes\");\n}\n\nfn\
    \ main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpherd65bs.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpherd65bs.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n  --> /tmp/tmpherd65bs.rs:19:35\n   |\n19 |\
    \     let mut dot_pos_end = dot_pos + 1;\n   |                           -------\
    \ ^ - {integer}\n   |                           |\n   |                      \
    \     Option<usize>\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpherd65bs.rs:20:37\n   |\n20 |     let mut dot_pos_start = dot_pos\
    \ + 1;\n   |                             ------- ^ - {integer}\n   |         \
    \                    |\n   |                             Option<usize>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpherd65bs.rs:13:42\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |    ---------------                       ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n...\n41 |     String::from(\"Yes\"\
    );\n   |                        - help: remove this semicolon\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0369,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos = dot_pos + 1;\n \
    \   let mut dot_pos_2 = file_name.find('.')\n    if dot_pos_2 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_2 = dot_pos_2\
    \ + 1;\n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_3 = dot_pos_3\
    \ + 1;\n    let mut dot_pos_4 = file_name.find('.')\n    if dot_pos_4 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_4 = dot_pos_4\
    \ + 1;\n    let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_5 = dot_pos_5\
    \ + 1;\n    let mut dot_pos_6 = file_name.find('.')\n    if dot_pos_6 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_6 = dot_pos_6\
    \ + 1;\n    let mut dot_pos_7 = file_name.find('.')\n    if dot_pos_7 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_7 = dot_pos_7\
    \ + 1;\n    let mut dot_pos_8 = file_name.find('.')\n    if dot_pos_8 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_8 = dot_pos_8\
    \ + 1;\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_9 = dot_pos_9\
    \ + 1;\n    let mut dot_pos_10 = file_name.find('.')\n    if dot_pos_10 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_10 = dot_pos_10\
    \ + 1;\n    let mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_11 = dot_pos_11\
    \ + 1;\n    let mut dot_pos_12 = file_name.find('.')\n    if dot_pos_12 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmprw_p2d1d.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmprw_p2d1d.rs:20:44\n   |\n20 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n21 |  \
    \   if dot_pos_2 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmprw_p2d1d.rs:25:44\n   |\n25 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n26 |     if dot_pos_3 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmprw_p2d1d.rs:30:44\n\
    \   |\n30 |     let mut dot_pos_4 = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n31 |     if dot_pos_4 == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmprw_p2d1d.rs:35:44\n   |\n35 |     let mut dot_pos_5 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n36 |  \
    \   if dot_pos_5 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmprw_p2d1d.rs:40:44\n   |\n40 |     let\
    \ mut dot_pos_6 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n41 |     if dot_pos_6 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmprw_p2d1d.rs:45:44\n\
    \   |\n45 |     let mut dot_pos_7 = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n46 |     if dot_pos_7 == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmprw_p2d1d.rs:50:44\n   |\n50 |     let mut dot_pos_8 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n51 |"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.len() > 3 {\n        String::from(\"\"\
    )\n    } else {\n        let mut first_char = file_name[0];\n        let mut last_char\
    \ = file_name[file_name.len() - 1];\n        if first_char.chars().any(|c| !c.is_ascii_letter())\
    \ {\n            String::from(\"\")\n        } else {\n            if first_char\
    \ != first_char.chars().nth(0) {\n                String::from(\"\")\n       \
    \     } else {\n                if last_char != last_char.chars().nth(0) {\n \
    \                   String::from(\"\")\n                } else {\n           \
    \         if file_name.chars().any(|c| !c.is_ascii_letter()) {\n             \
    \           String::from(\"\")\n                    } else {\n               \
    \         if file_name.chars().any(|c| !c.is_ascii_letter() || c != '.') {\n \
    \                           String::from(\"\")\n                        } else\
    \ {\n                            if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c != '.' || c != 'txt' || c != 'exe' || c != 'dll') {\n                 \
    \               String::from(\"\")\n                            } else {\n   \
    \                             String::from(\"Yes\")\n                        \
    \    }\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpkc7zmoay.rs:34:99\n\
    \   |\n34 | ...                   if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c != '.' || c != 'txt' || c != 'exe' || c != 'dll') {\n   |             \
    \                                                                            \
    \    ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n34 |                             if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c != '.' || c != \"txt\" || c != 'exe' || c != 'dll') {\n   |           \
    \                                                                            \
    \            ~~~~~\n\nerror: character literal may only contain one codepoint\n\
    \  --> /tmp/tmpkc7zmoay.rs:34:113\n   |\n34 | ...                   if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c != '.' || c != 'txt' || c != 'exe' || c != 'dll')\
    \ {\n   |                                                                    \
    \                                       ^^^^^\n   |\nhelp: if you meant to write\
    \ a `str` literal, use double quotes\n   |\n34 |                             if\
    \ file_name.chars().any(|c| !c.is_ascii_letter() || c != '.' || c != 'txt' ||\
    \ c != \"exe\" || c != 'dll') {\n   |                                        \
    \                                                                         ~~~~~\n\
    \nerror: character literal may only contain one codepoint\n  --> /tmp/tmpkc7zmoay.rs:34:127\n\
    \   |\n34 | ...                   if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c != '.' || c != 'txt' || c != 'exe' || c != 'dll') {\n   |             \
    \                                                                            \
    \                                ^^^^^\n   |\nhelp: if you meant to write a `str`\
    \ literal, use double quotes\n   |\n34 |                             if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c != '.' || c != 'txt' || c != 'exe' || c != \"dll\"\
    ) {\n   |                                                                    \
    \                                                           ~~~~~\n\nerr"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut counter = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    let mut l = file_name.len();\n    let mut valid\
    \ = false;\n    \n    while i < l {\n        if file_name[i] == \".\" {\n    \
    \        i += 1;\n            if i < l {\n                if file_name[i] == '.'\
    \ {\n                    i += 1;\n                    if i < l {\n           \
    \             if file_name[i] == '.' {\n                            i += 1;\n\
    \                            if i < l {\n                                if file_name[i]\
    \ == '.' {\n                                    i += 1;\n                    \
    \                if i < l {\n                                        if file_name[i]\
    \ == '.' {\n                                            i += 1;\n            \
    \                                if i < l {\n                                \
    \                if file_name[i] == '.' {\n                                  \
    \                  i += 1;\n                                                 \
    \   if i < l {\n                                                        if file_name[i]\
    \ == '.' {\n                                                            i += 1;\n\
    \                                                            if i < l {\n    \
    \                                                            if file_name[i] ==\
    \ '.' {\n                                                                    i\
    \ += 1;\n                                                                    if\
    \ i < l {\n                                                                  \
    \      if file_name[i] == '.' {\n                                            \
    \                                i += 1;\n                                   \
    \                                         if i < l {\n                       \
    \                                                         if file_name[i] == '.'\
    \ {\n                                                                        \
    \            i += 1;\n                                                       \
    \                             if i < l {\n                                   \
    \                                                     if file_name[i] == '.' {\n\
    \                                                                            \
    \                i += 1;\n                                                   \
    \                                         if i < l {\n                       \
    \                                                                         if file_name[i]\
    \ == '.' {\n                                                                 \
    \                                   i += 1;\n                                \
    \                                                                    if i < l\
    \ {\n                                                                        \
    \                                if file_name[i] == '.' {\n                  \
    \                                                                            \
    \              i += 1;\n                                                     \
    \                                                       if i < l {\n         \
    \                                                                            \
    \                           if file_name[i] == '.' {\n                       \
    \                                                                            \
    \                 i += 1;\n                                                  \
    \                                                                  if i < l {\n\
    \                                                                            \
    \                                            if file_name[i] == '.' {\n      \
    \                                                                            \
    \                                          i += 1;\n                         \
    \                                                                            \
    \                       if i < l {\n                                         \
    \                                                                            \
    \           if file_name[i] == '.' {\n                                       \
    \                                                                            \
    \                 i += 1;\n                                                  \
    \                                                                            \
    \      if i < l {\n                                                          \
    \                                                                            \
    \  if file_name[i] == '.' {\n                                                \
    \                                                                            \
    \                i += 1;\n                                                   \
    \                                                                            \
    \             if i < l {\n                                                   \
    \                                                                            \
    \                 if file_name[i] == '.' {\n                                 \
    \                                                                            \
    \                                       i += 1;\n                            \
    \                                                                            \
    \                                            if i < l {\n                    \
    \                                                                            \
    \                                                        if file_name[i] == '.'\
    \ {\n                                                                        \
    \                                                                            \
    \        i += 1;\n                                                           \
    \                                                                            \
    \                     if i < l {\n                                           \
    \                                                                            \
    \                                         if file_name[i] == '.' {\n         \
    \                                                                            \
    \                                                                            \
    \   i += 1;\n                                                                \
    \                                                                            \
    \                        if i < l {\n                                        \
    \                                                                            \
    \                                                    if file_name[i] == '.' {\n\
    \                                                                            \
    \                                                                            \
    \                    i += 1;\n                                               \
    \                                                                            \
    \                                                 if i < l {\n               \
    \                                                                            \
    \                                                                            \
    \         if file_name[i] == '.' {\n                                         \
    \                                                                            \
    \                                                               i += 1;\n    \
    \                                                                            \
    \                                                                            \
    \                        if i < l {\n                                        \
    \                                                                            \
    \                                                                    if file_name\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpkgl1ewp5.rs:119:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n21  |  \
    \   while i < l {\n    |                 - unclosed delimiter\n22  |         if\
    \ file_name[i] == \".\" {\n    |                                - unclosed delimiter\n\
    23  |             i += 1;\n24  |             if i < l {\n    |               \
    \       - unclosed delimiter\n25  |                 if file_name[i] == '.' {\n\
    \    |                                        - unclosed delimiter\n26  |    \
    \                 i += 1;\n27  |                     if i < l {\n    |       \
    \                       - unclosed delimiter\n28  |                         if\
    \ file_name[i] == '.' {\n    |                                               \
    \ - unclosed delimiter\n29  |                             i += 1;\n30  |     \
    \                        if i < l {\n    |                                   \
    \   - unclosed delimiter\n31  |                                 if file_name[i]\
    \ == '.' {\n    |                                                        - unclosed\
    \ delimiter\n32  |                                     i += 1;\n33  |        \
    \                             if i < l {\n    |                              \
    \                - unclosed delimiter\n34  |                                 \
    \        if file_name[i] == '.' {\n    |                                     \
    \                           - unclosed delimiter\n35  |                      \
    \                       i += 1;\n36  |                                       \
    \      if i < l {\n    |                                                     \
    \ - unclosed delimiter\n37  |                                                \
    \ if file_name[i] == '.' {\n    |                                            \
    \                            - unclosed delimiter\n38  |                     \
    \                                i += 1;\n39  |                              \
    \                       if i < l {\n    |                                    \
    \      "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_letter = file_name.chars().nth(1).unwrap();\n\
    \    if first_letter < 'a' || first_letter > 'z' {\n        return \"No\";\n \
    \   }\n    if file_name.chars().count() > 3 {\n        return \"No\";\n    }\n\
    \    if file_name.chars().count() == 1 {\n        return \"No\";\n    }\n    if\
    \ file_name.chars().count() == 2 && file_name.chars().nth(1).unwrap() == '.' {\n\
    \        return \"No\";\n    }\n    if file_name.chars().count() == 2 && file_name.chars().nth(1).unwrap()\
    \ == '.' {\n        return \"No\";\n    }\n    if file_name.chars().count() ==\
    \ 2 && file_name.chars().nth(1).unwrap() == '.' {\n        return \"No\";\n  \
    \  }\n    if file_name.chars().count() == 2 && file_name.chars().nth(1).unwrap()\
    \ == '.' {\n        return \"No\";\n    }\n    if file_name.chars().count() ==\
    \ 2 && file_name.chars().nth(1).unwrap() == '.' {\n        return \"No\";\n  \
    \  }\n    if file_name.chars().count() == 2 && file_name.chars().nth(1).unwrap()\
    \ == '.' {\n        return \"No\";\n    }\n    if file_name.chars().count() ==\
    \ 2 && file_name.chars().nth(1).unwrap() == '.' {\n        return \"No\";\n  \
    \  }\n    if file_name.chars().count() == 2 && file_name.chars().nth(1).unwrap()\
    \ == '.' {\n        return \"No\";\n    }\n    if file_name.chars().count() ==\
    \ 2 && file_name.chars().nth(1).unwrap() == '.' {\n        return \"No\";\n  \
    \  }\n    if file_name.chars().count() == 2 && file_name.chars().nth(1).unwrap()\
    \ == '.' {\n        return \"No\";\n    }\n    if file_name.chars().count() ==\
    \ 2 && file_name.chars().nth(1).unwrap() == '.' {\n        return \"No\";\n  \
    \  }\n    if file_name.chars().count() == 2 && file_name.chars().nth(1).unwrap()\
    \ == '.' {\n        return \"No\";\n    }\n    if file_name.chars().count() ==\
    \ 2 && file_name.chars().nth(1).unwrap() == '.' {\n        return \"No\";\n  \
    \  }\n    if file_name.chars().count() == 2 && file_name.chars().nth(1).unwrap()\
    \ == '.' {\n        return \"No\";\n    }\n    if file_name.chars().count() ==\
    \ 2 && file_name.chars().nth(1).unwrap() == '.' {\n        return \"No\";\n  \
    \  }\n    if file_name.chars().count() == 2 && file_name.chars().nth(1).unwrap()\
    \ == '.' {\n        return \"No\";\n    }\n    if file_name.chars().count() ==\
    \ 2 && file_name.chars().nth\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmph7iknbqw.rs:73:1\n   |\n\
    72 |     if file_name.chars().count() == 2 && file_name.chars().nth\n   |    \
    \ -- this `if` expression has a condition, but no block\n73 | }\n   | ^ expected\
    \ `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph7iknbqw.rs:16:16\n   |\n\
    13 | fn file_name_check(file_name: String) -> String {\n   |                 \
    \                         ------ expected `String` because of return type\n...\n\
    16 |         return \"No\";\n   |                ^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.len() > 3 {\n        String::from(\"\"\
    )\n    } else {\n        let mut first_letter = file_name[0];\n        if first_letter\
    \ != 'a' && first_letter != 'A' {\n            first_letter = 'a';\n        }\n\
    \        let mut dot_index = file_name.find('.')\n        if dot_index == String::npos\
    \ {\n            String::from(\"\")\n        } else {\n            let mut dot_string\
    \ = file_name[dot_index..];\n            if dot_string.len() > 3 {\n         \
    \       String::from(\"\")\n            } else {\n                let mut dot_string\
    \ = dot_string.to_string();\n                if dot_string.len() == 0 {\n    \
    \                dot_string = \".\".to_string();\n                }\n        \
    \        if dot_string.len() > 3 {\n                    String::from(\"\")\n \
    \               } else {\n                    let mut dot_string = dot_string.to_string();\n\
    \                    if dot_string.len() == 0 {\n                        dot_string\
    \ = \".\".to_string();\n                    }\n                    if dot_string.len()\
    \ > 3 {\n                        String::from(\"\")\n                    } else\
    \ {\n                        let mut dot_string = dot_string.to_string();\n  \
    \                      if dot_string.len() == 0 {\n                          \
    \  dot_string = \".\".to_string();\n                        }\n              \
    \          if dot_string.len() > 3 {\n                            String::from(\"\
    \")\n                        } else {\n                            let mut dot_string\
    \ = dot_string.to_string();\n                            if dot_string.len() ==\
    \ 0 {\n                                dot_string = \".\".to_string();\n     \
    \                       }\n                            if dot_string.len() > 3\
    \ {\n                                String::from(\"\")\n                    \
    \        } else {\n                                let mut dot_string = dot_string.to_string();\n\
    \                                if dot_string.len() == 0 {\n                \
    \                    dot_string = \".\".to_string();\n                       \
    \         }\n                                if dot_string.len() > 3 {\n     \
    \                               String::from(\"\")\n                         \
    \       } else {\n                                    let mut dot_string = dot_string.to_string();\n\
    \                                    if dot_string.len() == 0 {\n            \
    \                            dot_string = \".\".to_string();\n               \
    \                     }\n                                    if dot_string.len()\
    \ > 3 {\n                                        String::from(\"\")\n        \
    \                            } else {\n                                      \
    \  let mut dot_string = dot_string.to_string();\n                            \
    \            if dot_string.len() == 0 {\n                                    \
    \        dot_string = \".\".to_string();\n                                   \
    \     }\n                                        if dot_string.len() > 3 {\n \
    \                                           String::from(\"\")\n             \
    \                           } else {\n                                       \
    \     return String::from(\"Yes\");\n                                        }\n\
    \                                    }\n                                }\n  \
    \                          }\n                        }\n                    }\n\
    \                }\n            }\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpfv82nnwt.rs:21:48\n\
    \   |\n21 |         let mut dot_index = file_name.find('.')\n   |            \
    \                                    ^ help: add `;` here\n22 |         if dot_index\
    \ == String::npos {\n   |         -- unexpected token\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpfv82nnwt.rs:17:32\n\
    \   |\n17 |         let mut first_letter = file_name[0];\n   |               \
    \                 ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no function or associated item named `npos` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpfv82nnwt.rs:22:33\n\
    \   |\n22 |         if dot_index == String::npos {\n   |                     \
    \            ^^^^ function or associated item not found in `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n  --> /tmp/tmpfv82nnwt.rs:25:34\n\
    \   |\n25 |             let mut dot_string = file_name[dot_index..];\n   |   \
    \                               ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `RangeFrom<Option<usize>>`\n   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n       "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    if\
    \ file_name.len() > 3 {\n        file_name.truncate(3);\n    }\n    if file_name.contains('.')\
    \ {\n        file_name.truncate(file_name.find('.'));\n    }\n    if file_name.starts_with(\"\
    a\") || file_name.starts_with(\"A\") {\n        file_name.truncate(0);\n    }\n\
    \    if file_name.contains(\".\") {\n        let dot_index = file_name.rfind('.');\n\
    \        if dot_index == 0 {\n            file_name.truncate(0);\n        } else\
    \ {\n            file_name.truncate(dot_index);\n        }\n    }\n    if file_name.contains(\"\
    .\") {\n        let dot_index = file_name.rfind('.');\n        if dot_index ==\
    \ 0 {\n            file_name.truncate(0);\n        } else {\n            file_name.truncate(dot_index);\n\
    \        }\n    }\n    if file_name.contains(\".\") {\n        let dot_index =\
    \ file_name.rfind('.');\n        if dot_index == 0 {\n            file_name.truncate(0);\n\
    \        } else {\n            file_name.truncate(dot_index);\n        }\n   \
    \ }\n    if file_name.contains(\".\") {\n        let dot_index = file_name.rfind('.');\n\
    \        if dot_index == 0 {\n            file_name.truncate(0);\n        } else\
    \ {\n            file_name.truncate(dot_index);\n        }\n    }\n    if file_name.contains(\"\
    .\") {\n        let dot_index = file_name.rfind('.');\n        if dot_index ==\
    \ 0 {\n            file_name.truncate(0);\n        } else {\n            file_name.truncate(dot_index);\n\
    \        }\n    }\n    if file_name.contains(\".\") {\n        let dot_index =\
    \ file_name.rfind('.');\n        if dot_index == 0 {\n            file_name.truncate(0);\n\
    \        } else {\n            file_name.truncate(dot_index);\n        }\n   \
    \ }\n    if file_name.contains(\".\") {\n        let dot_index = file_name.rfind('.');\n\
    \        if dot_index == 0 {\n            file_name.truncate(0);\n        } else\
    \ {\n            file_name.truncate(dot_index);\n        }\n    }\n    if file_name.contains(\"\
    .\") {\n        let dot_index = file_name.rfind('.');\n        if dot_index ==\
    \ 0 {\n            file_name.truncate(0);\n        } else {\n            file_name.truncate(dot_index);\n\
    \        }\n    }\n    if file_name.contains(\".\") {\n        let dot_index =\
    \ file_name.rfind('.');\n        if dot_index == 0 {\n            file_name.truncate(0);\n\
    \        } else {\n            file_name.truncate(dot_index);\n        }\n   \
    \ }\n    if file_name.contains(\".\") {\n        let dot_index = file_name.rfind('.');\n\
    \        if dot_index == 0 {\n            file_name.truncate(0);\n        } else\
    \ {\n            file_name.truncate(dot_index);\n        }\n\n}\n\nfn main() {\n\
    \    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjy3b7znw.rs:134:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n96  |  \
    \   if file_name.contains(\".\") {\n    |                                - this\
    \ delimiter might not be properly closed...\n...\n104 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjy3b7znw.rs:19:28\n   |\n19 |         file_name.truncate(file_name.find('.'));\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^ expected `usize`, found enum\
    \ `Option`\n   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjy3b7znw.rs:26:25\n   |\n26 |\
    \         if dot_index == 0 {\n   |                         ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    26 |         if dot_index == Some(0) {\n   |                         +++++ +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjy3b7znw.rs:29:32\n   |\n29 |\
    \             file_name.truncate(dot_index);\n   |                           \
    \     ^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n   = note: expected\
    \ type `usize`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjy3b7znw.rs:34:25\n   |\n34 |         if dot_index == 0\
    \ {\n   |                         ^ expected enum `Option`, found integer\n  \
    \ |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n34 |         if dot_index ==\
    \ Some(0) {\n   |                         +++++ +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjy3b7znw.rs:37:32\n   |\n37 |             file_name.truncate(dot_index);\n\
    \   |                                ^^^^^^^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<us"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos = dot_pos + 1;\n \
    \   let mut dot_pos_end = file_name.find('.')\n    if dot_pos_end == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos_end\
    \ + 1;\n    let mut dot_pos_end = file_name.find('.')\n    if dot_pos_end == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos_end\
    \ + 1;\n    let mut dot_pos_end = file_name.find('.')\n    if dot_pos_end == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos_end\
    \ + 1;\n    let mut dot_pos_end = file_name.find('.')\n    if dot_pos_end == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos_end\
    \ + 1;\n    let mut dot_pos_end = file_name.find('.')\n    if dot_pos_end == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos_end\
    \ + 1;\n    let mut dot_pos_end = file_name.find('.')\n    if dot_pos_end == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos_end\
    \ + 1;\n    let mut dot_pos_end = file_name.find('.')\n    if dot_pos_end == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos_end\
    \ + 1;\n    let mut dot_pos_end = file_name.find('.')\n    if dot_pos_end == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos_end\
    \ + 1;\n    let mut dot_pos_end = file_name.find('.')\n    if dot_pos_end == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos_end\
    \ + 1;\n    let mut dot_pos_end = file_name.find('.')\n    if dot_pos_end == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos_end\
    \ + 1;\n    let mut dot_pos_end = file_name.find('.')\n    if dot_pos_end == String::npos\
    \ {\n        return \n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpqp_fd5r7.rs:103:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n71  |  \
    \   if dot_pos_end == String::npos {\n    |                                  \
    \  - this delimiter might not be properly closed...\n72  |         return \n73\
    \  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    103 | }\n    |   ^\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpqp_fd5r7.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpqp_fd5r7.rs:20:46\n   |\n20 |     let mut dot_pos_end = file_name.find('.')\n\
    \   |                                              ^ help: add `;` here\n21 |\
    \     if dot_pos_end == String::npos {\n   |     -- unexpected token\n\nerror:\
    \ expected `;`, found keyword `if`\n  --> /tmp/tmpqp_fd5r7.rs:25:46\n   |\n25\
    \ |     let mut dot_pos_end = file_name.find('.')\n   |                      \
    \                        ^ help: add `;` here\n26 |     if dot_pos_end == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpqp_fd5r7.rs:30:46\n   |\n30 |     let mut dot_pos_end = file_name.find('.')\n\
    \   |                                              ^ help: add `;` here\n31 |\
    \     if dot_pos_end == String::npos {\n   |     -- unexpected token\n\nerror:\
    \ expected `;`, found keyword `if`\n  --> /tmp/tmpqp_fd5r7.rs:35:46\n   |\n35\
    \ |     let mut dot_pos_end = file_name.find('.')\n   |                      \
    \                        ^ help: add `;` here\n36 |     if dot_pos_end == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpqp_fd5r7.rs:40:46\n   |\n40 |     let mut dot_pos_end = file_name.find('.')\n\
    \   |                                              ^ help: add `;` here\n41 |\
    \     if dot_pos_end == String::"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut counter = 0;\n    let mut is_valid = false;\n\
    \    for c in file_name.chars() {\n        if c >= '0' && c <= '9' {\n       \
    \     counter += 1;\n        }\n        if c == '.' {\n            if counter\
    \ > 3 {\n                is_valid = false;\n                break;\n         \
    \   }\n            counter += 1;\n        }\n        if !c.is_latin_letter() {\n\
    \            is_valid = false;\n            break;\n        }\n        if c.is_latin_letter()\
    \ && c != 'a' && c != 'z' && c != 'A' && c != 'Z' {\n            is_valid = false;\n\
    \            break;\n        }\n    }\n    if is_valid {\n        return \"Yes\"\
    ;\n    }\n    return \"No\";\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_latin_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp954ck_sj.rs:27:15\n   |\n27 |         if !c.is_latin_letter()\
    \ {\n   |               ^^^^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `is_latin_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmp954ck_sj.rs:31:14\n   |\n31 |         if c.is_latin_letter() &&\
    \ c != 'a' && c != 'z' && c != 'A' && c != 'Z' {\n   |              ^^^^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp954ck_sj.rs:37:16\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n37 |         return \"Yes\";\n   |                ^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                |\n   |           \
    \     expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.len() > 3 {\n        String::from(\"\"\
    )\n    } else {\n        let mut first_char = file_name[0];\n        let mut second_char\
    \ = file_name[1];\n        let mut third_char = file_name[2];\n        if first_char\
    \ == '.' {\n            if second_char == '.' {\n                if third_char\
    \ == '.' {\n                    String::from(\"\")\n                } else {\n\
    \                    String::from(\"No\")\n                }\n            } else\
    \ {\n                String::from(\"No\")\n            }\n        } else {\n \
    \           String::from(\"No\")\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp8eey_42c.rs:17:30\n   |\n17 |         let mut first_char = file_name[0];\n\
    \   |                              ^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp8eey_42c.rs:18:31\n   |\n18 |         let mut second_char = file_name[1];\n\
    \   |                               ^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp8eey_42c.rs:19:30\n   |\n19 |         let mut third_char = file_name[2];\n\
    \   |                              ^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<Range"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return \"No\";\n    }\n    let mut dot_pos_end = dot_pos + 1;\n    let mut\
    \ dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    while dot_pos_start < dot_pos_end {\n        let mut dot_pos_start_letter\
    \ = dot_pos_start;\n        while dot_pos_start_letter < dot_pos_end && file_name[dot_pos_start_letter]\
    \ >= 'a' && file_name[dot_pos_start_letter] <= 'z' {\n            dot_pos_start_letter\
    \ += 1;\n        }\n        if dot_pos_start_letter < dot_pos_end && file_name[dot_pos_start_letter]\
    \ >= 'A' && file_name[dot_pos_start_letter] <= 'Z' {\n            dot_pos_start_letter\
    \ += 1;\n        }\n        if dot_pos_start_letter < dot_pos_end && file_name[dot_pos_start_letter]\
    \ != '0' && file_name[dot_pos_start_letter] != '9' {\n            return \"No\"\
    ;\n        }\n        dot_pos_start += 1;\n    }\n    return \"Yes\";\n}\n\nfn\
    \ main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmprbyzwa0w.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmprbyzwa0w.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprbyzwa0w.rs:17:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n17 |         return \"No\";\n   |    \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \               |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmprbyzwa0w.rs:19:35\n\
    \   |\n19 |     let mut dot_pos_end = dot_pos + 1;\n   |                     \
    \      ------- ^ - {integer}\n   |                           |\n   |         \
    \                  Option<usize>\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmprbyzwa0w.rs:20:37\n   |\n20 |     let mut dot_pos_start = dot_pos\
    \ + 1;\n   |                             ------- ^ - {integer}\n   |         \
    \                    |\n   |                             Option<usize>\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos { \n \
    \       return \"No\";\n    }\n    let mut dot_index = file_name.find('.')\n \
    \   if dot_index == String::npos { \n        return \"No\";\n    }\n    let mut\
    \ dot_index = file_name.find('.')\n    if dot_index == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_index = file_name.find('.')\n    if\
    \ dot_index == String::npos { \n        return \"No\";\n    }\n    let mut dot_index\
    \ = file_name.find('.')\n    if dot_index == String::npos { \n        return \"\
    No\";\n    }\n    let mut dot_index = file_name.find('.')\n    if dot_index ==\
    \ String::npos { \n        return \"No\";\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\";\n    }\n    let mut\
    \ dot_index = file_name.find('.')\n    if dot_index == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_index = file_name.find('.')\n    if\
    \ dot_index == String::npos { \n        return \"No\";\n    }\n    let mut dot_index\
    \ = file_name.find('.')\n    if dot_index == String::npos { \n        return \"\
    No\";\n    }\n    let mut dot_index = file_name.find('.')\n    if dot_index ==\
    \ String::npos { \n        return \"No\";\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\";\n    }\n    let mut\
    \ dot_index = file_name.find('.')\n    if dot_index == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_index = file_name.find('.')\n    if\
    \ dot_index == String::npos { \n        return \"No\";\n    }\n    let mut dot_index\
    \ = file_name.find('.')\n    if dot_index == String::npos { \n        return \"\
    No\";\n    }\n    let mut dot_index = file_name.find('.')\n    if dot_index ==\
    \ String::npos { \n        return \"No\";\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\";\n    }\n    let mut\
    \ dot_index = file_name.find('.')\n    if dot_index == String::npos { \n     \
    \   return \"No\";\n    }\n    let mut dot_index = file_name.find('.')\n    if\
    \ dot_index == String::npos { \n        return \"No\";\n    }\n    let mut dot_index\
    \ = file_name.find('\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp2iuo0gsv.rs:91:40\n\
    \   |\n91 |     let mut dot_index = file_name.find('\n   |                   \
    \                     ^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    if dot_pos == dot_pos_2 {\n        return String::from(\"No\");\n  \
    \  }\n    if dot_pos == 0 {\n        return String::from(\"No\");\n    }\n   \
    \ if dot_pos == file_name.len() - 1 {\n        return String::from(\"No\");\n\
    \    }\n    if file_name[dot_pos - 1] < 'a' || file_name[dot_pos - 1] > 'z' {\n\
    \        return String::from(\"No\");\n    }\n    if file_name[dot_pos + 1] <\
    \ 'a' || file_name[dot_pos + 1] > 'z' {\n        return String::from(\"No\");\n\
    \    }\n    if file_name[dot_pos - 1] != '.' {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos_2 - 1] != '.' {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos_2] != \"txt\" && file_name[dot_pos_2]\
    \ != \"exe\" && file_name[dot_pos_2] != \"dll\" {\n        return String::from(\"\
    No\");\n    }\n    return String::from(\"Yes\");\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmppl6naz08.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmppl6naz08.rs:19:44\n   |\n19 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n20 |  \
    \   if dot_pos_2 == String::npos {\n   |     -- unexpected token\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmppl6naz08.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0599]: no function or associated item named\
    \ `npos` found for struct `String` in the current scope\n  --> /tmp/tmppl6naz08.rs:20:29\n\
    \   |\n20 |     if dot_pos_2 == String::npos {\n   |                         \
    \    ^^^^ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppl6naz08.rs:26:19\n   |\n26 |     if dot_pos == 0 {\n \
    \  |                   ^ expected enum `Option`, found integer\n   |\n   = note:\
    \ expected enum `Option<usize>`\n              found type `{integer}`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n26 |     if dot_pos == Some(0) {\n\
    \   |                   +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppl6naz08.rs:29:19\n\
    \   |\n29 |     if dot_pos == file_name.len() - 1 {\n   |                   ^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n29 |     if dot_pos == Some(file_name.len() - 1) {\n   |              \
    \     +++++                   +\n\nerror[E0369]: cannot subtract `{integer}` from\
    \ `Option<usize>`\n  --> /tmp/tmppl6naz08.rs:32:26\n   |\n32 |     if file_name[dot_pos\
    \ - 1] < 'a' || file_name[dot_pos - 1] > 'z' {\n   |                  -------\
    \ ^ -"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter =\
    \ String::from(\"a\");\n    while dot_pos_start < dot_pos_end {\n        if file_name[dot_pos_start]\
    \ >= 'a' && file_name[dot_pos_start] <= 'z' {\n            dot_pos_start_letter\
    \ = String::from(file_name[dot_pos_start]);\n        }\n        dot_pos_start\
    \ += 1;\n    }\n    if dot_pos_start_letter != String::from(\"a\") {\n       \
    \ return String::from(\"No\");\n    }\n    let mut dot_pos_end_letter = String::from(\"\
    z\");\n    while dot_pos_end_letter < dot_pos_end {\n        if file_name[dot_pos_end_letter]\
    \ >= 'A' && file_name[dot_pos_end_letter] <= 'Z' {\n            dot_pos_end_letter\
    \ = String::from(file_name[dot_pos_end_letter]);\n        }\n        dot_pos_end_letter\
    \ += 1;\n    }\n    if dot_pos_end_letter != String::from(\"z\") {\n        return\
    \ String::from(\"No\");\n    }\n    let mut dot_pos_end_letter = String::from(\"\
    z\");\n    while dot_pos_end_letter < dot_pos_end {\n        if file_name[dot_pos_end_letter]\
    \ >= '0' && file_name[dot_pos_end_letter] <= '9' {\n            dot_pos_end_letter\
    \ = String::from(file_name[dot_pos_end_letter]);\n        }\n        dot_pos_end_letter\
    \ += 1;\n    }\n    if dot_pos_end_letter != String::from(\"z\") {\n        return\
    \ String::from(\"No\");\n    }\n    if dot_pos_end != file_name.len() {\n    \
    \    return String::from(\"No\");\n    }\n    return String::from(\"Yes\");\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpdpmd02cl.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpdpmd02cl.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n  --> /tmp/tmpdpmd02cl.rs:19:35\n   |\n19 |\
    \     let mut dot_pos_end = dot_pos + 1;\n   |                           -------\
    \ ^ - {integer}\n   |                           |\n   |                      \
    \     Option<usize>\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpdpmd02cl.rs:20:37\n   |\n20 |     let mut dot_pos_start = dot_pos\
    \ + 1;\n   |                             ------- ^ - {integer}\n   |         \
    \                    |\n   |                             Option<usize>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `String`\n  --> /tmp/tmpdpmd02cl.rs:33:12\n\
    \   |\n33 |         if file_name[dot_pos_end_letter] >= 'A' && file_name[dot_pos_end_letter]\
    \ <= 'Z' {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `String`\n   |\n   = help: the trait `Index<String>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `String`\n\
    \  --> /tmp/tmpdpmd02cl.rs:33:52\n   |\n33 |         if file_name[dot_pos_end_letter]\
    \ >= 'A' && file_name[dot_pos_end_letter] <= 'Z' {\n   |                     \
    \  "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    \n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos { \n        return \"No\";\n    }\n    \n  \
    \  let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos {\
    \ \n        return \"No\";\n    }\n    \n    if dot_pos == dot_pos_2 {\n     \
    \   return \"No\";\n    }\n    \n    if dot_pos == dot_pos_3 {\n        return\
    \ \"No\";\n    }\n    \n    if dot_pos_2 == dot_pos_3 {\n        return \"No\"\
    ;\n    }\n    \n    if dot_pos_2 > dot_pos {\n        return \"No\";\n    }\n\
    \    \n    if dot_pos_3 > dot_pos {\n        return \"No\";\n    }\n    \n   \
    \ if dot_pos_3 > dot_pos_2 {\n        return \"No\";\n    }\n    \n    if dot_pos_2\
    \ < dot_pos {\n        return \"No\";\n    }\n    \n    if dot_pos_2 < dot_pos_3\
    \ {\n        return \"No\";\n    }\n    \n    if dot_pos_2 < dot_pos_2 {\n   \
    \     return \"No\";\n    }\n    \n    if dot_pos_3 < dot_pos {\n        return\
    \ \"No\";\n    }\n    \n    if dot_pos_3 < dot_pos_2 {\n        return \"No\"\
    ;\n    }\n    \n    if dot_pos_3 < dot_pos_3 {\n        return \"No\";\n    }\n\
    \    \n    if dot_pos_3 > dot_pos_2 {\n        return \"No\";\n    }\n    \n \
    \   if dot_pos_2 > dot_pos_3 {\n        return \"No\";\n    }\n    \n    if dot_pos\
    \ > dot_pos_2 {\n        return \"No\";\n    }\n    \n    if dot_pos > dot_pos_3\
    \ {\n        return \"No\";\n    }\n    \n    if dot_pos > dot_pos_2 {\n     \
    \   return \"No\";\n    }\n    \n    if dot_pos < dot_pos_3 {\n        return\
    \ \"No\";\n    }\n    \n    if dot_pos < dot_pos_2 {\n        return \"No\";\n\
    \    }\n    \n    if dot_pos < dot_pos {\n        return \"No\";\n    }\n    \n\
    \    return \"Yes\";\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp85ft7v2p.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ { \n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmp85ft7v2p.rs:20:44\n   |\n20 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n21 |  \
    \   if dot_pos_2 == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp85ft7v2p.rs:25:44\n   |\n25 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n26 |     if dot_pos_3 == String::npos { \n  \
    \ |     -- unexpected token\n\nerror[E0599]: no function or associated item named\
    \ `npos` found for struct `String` in the current scope\n  --> /tmp/tmp85ft7v2p.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos { \n   |                          \
    \ ^^^^ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp85ft7v2p.rs:17:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n17 |         return \"No\";\n   |    \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \               |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0599]: no function or associated item named `npos` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp85ft7v2p.rs:21:29\n   |\n21 |     if dot_pos_2\
    \ == String::npos { \n   |                             ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0599]: no function or associated item named\
    \ `npos` found for struct `String` in the current scope\n  --> /tmp/tmp85ft7v2p.rs:26:29\n\
    \   |\n26 |     if dot_pos_3 == String::npos { \n   |                        \
    \     ^^^^ function or associated item not found in `String`\n\nerror: aborting\
    \ due to 7 previous err"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_4 = file_name.find('.')\n\
    \    if dot_pos_4 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_6 = file_name.find('.')\n\
    \    if dot_pos_6 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_7 = file_name.find('.')\n    if dot_pos_7 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_8 = file_name.find('.')\n\
    \    if dot_pos_8 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_12 = file_name.find('.')\n\
    \    if dot_pos_12 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_14 = file_name.find('.')\n\
    \    if dot_pos_14 == String::npos {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    let mut dot_pos_16 = file_name.find('.')\n\
    \    if dot_pos_16 == String::npos {\n\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpj6ex5mwz.rs:108:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n76  |  \
    \   if dot_pos_16 == String::npos {\n    |                                   -\
    \ this delimiter might not be properly closed...\n77  | \n78  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n108 | }\n    |   ^\n\n\
    error: expected `;`, found keyword `if`\n  --> /tmp/tmpj6ex5mwz.rs:15:42\n   |\n\
    15 |     let mut dot_pos = file_name.find('.')\n   |                         \
    \                 ^ help: add `;` here\n16 |     if dot_pos == String::npos {\n\
    \   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmpj6ex5mwz.rs:19:44\n   |\n19 |     let mut dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n20 |  \
    \   if dot_pos_2 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpj6ex5mwz.rs:23:44\n   |\n23 |     let\
    \ mut dot_pos_3 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n24 |     if dot_pos_3 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpj6ex5mwz.rs:27:44\n\
    \   |\n27 |     let mut dot_pos_4 = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n28 |     if dot_pos_4 == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpj6ex5mwz.rs:31:44\n   |\n31 |     let mut dot_pos_5 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n32 |  \
    \   if dot_pos_5 == String::npos {\n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpj6ex5mwz.rs:35:44\n   |\n35 |     let\
    \ mut dot_pos_6 = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n36 |     if dot_pos_6 == String::npos {\n   |\
    \     -- unexpected token\n\nerror: exp"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter =\
    \ dot_pos_start;\n    while dot_pos_start != dot_pos_end {\n        let mut dot_pos_start_letter\
    \ = dot_pos_start;\n        if file_name[dot_pos_start_letter] >= 'a' && file_name[dot_pos_start_letter]\
    \ <= 'z' {\n            dot_pos_start_letter += 1;\n        }\n        if file_name[dot_pos_start_letter]\
    \ >= 'A' && file_name[dot_pos_start_letter] <= 'Z' {\n            dot_pos_start_letter\
    \ += 1;\n        }\n        if file_name[dot_pos_start_letter] == '.' {\n    \
    \        break;\n        }\n        dot_pos_start += 1;\n    }\n    if dot_pos_start\
    \ == dot_pos_end {\n        return String::from(\"No\");\n    }\n    if dot_pos_start\
    \ == dot_pos_start_letter {\n        return String::from(\"Yes\");\n    }\n  \
    \  if dot_pos_start == dot_pos_start_letter + 1 {\n        return String::from(\"\
    No\");\n    }\n    return String::from(\"Yes\");\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpmq9r5jvw.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpmq9r5jvw.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n  --> /tmp/tmpmq9r5jvw.rs:19:35\n   |\n19 |\
    \     let mut dot_pos_end = dot_pos + 1;\n   |                           -------\
    \ ^ - {integer}\n   |                           |\n   |                      \
    \     Option<usize>\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpmq9r5jvw.rs:20:37\n   |\n20 |     let mut dot_pos_start = dot_pos\
    \ + 1;\n   |                             ------- ^ - {integer}\n   |         \
    \                    |\n   |                             Option<usize>\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut dot_pos = file_name.find('.')\n    if dot_pos\
    \ == String::npos {\n        return \"No\"\n    }\n    let mut dot_pos_end = dot_pos\
    \ + 1\n    if dot_pos_end > file_name.len() {\n        return \"No\"\n    }\n\
    \    let mut dot_pos_start = dot_pos\n    while dot_pos_start < dot_pos_end {\n\
    \        let mut char_pos = file_name.chars().position(|c| c == dot_pos).unwrap();\n\
    \        if char_pos == dot_pos_end {\n            return \"No\"\n        }\n\
    \        let mut char_pos_end = file_name.chars().position(|c| c == dot_pos_end).unwrap();\n\
    \        if char_pos_end == dot_pos_end {\n            return \"No\"\n       \
    \ }\n        let mut char_pos_start = file_name.chars().position(|c| c == dot_pos_start).unwrap();\n\
    \        if char_pos_start < char_pos_end {\n            return \"No\"\n     \
    \   }\n        dot_pos_start += 1;\n        dot_pos_end += 1;\n    }\n    return\
    \ \"Yes\"\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp8fw3vjf6.rs:14:42\n\
    \   |\n14 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n15 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmp8fw3vjf6.rs:18:38\n   |\n18 |     let mut dot_pos_end = dot_pos\
    \ + 1\n   |                                      ^ help: add `;` here\n19 |  \
    \   if dot_pos_end > file_name.len() {\n   |     -- unexpected token\n\nerror:\
    \ expected `;`, found keyword `while`\n  --> /tmp/tmp8fw3vjf6.rs:22:36\n   |\n\
    22 |     let mut dot_pos_start = dot_pos\n   |                               \
    \     ^ help: add `;` here\n23 |     while dot_pos_start < dot_pos_end {\n   |\
    \     ----- unexpected token\n\nerror[E0599]: no function or associated item named\
    \ `npos` found for struct `String` in the current scope\n  --> /tmp/tmp8fw3vjf6.rs:15:27\n\
    \   |\n15 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8fw3vjf6.rs:16:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n16 |         return \"No\"\n   |     \
    \           ^^^^- help: try using a conversion method: `.to_string()`\n   |  \
    \              |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp8fw3vjf6.rs:18:35\n\
    \   |\n18 |     let mut dot_pos_end = dot_pos + 1\n   |                      \
    \     ------- ^ - {integer}\n   |                           |\n   |          \
    \                 Option<usize>\n\nerror[E0277]: can't compare `Option<usize>`\
    \ with `usize`\n  --> /tmp/tmp8fw3vjf6.rs:19:20\n   |\n19 |     if dot_pos_end\
    \ > file_name.len() {\n   |                    ^ no implementation for `Option<usize>\
    \ < usize` and `Option<usize> > usize`\n   |\n   = help: the trait `PartialOrd<usize>`\
    \ is not implemented for `Option<usize>`\n   = hel"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    \n    let mut dot_pos_end = dot_pos\
    \ + 1;\n    let mut dot_pos_start = dot_pos + 1;\n    \n    while dot_pos_start\
    \ < dot_pos_end {\n        let mut dot_pos_end = dot_pos_end;\n        let mut\
    \ dot_pos_start = dot_pos_start;\n        \n        if dot_pos_end == dot_pos_start\
    \ {\n            dot_pos_end += 1;\n        }\n        \n        if dot_pos_start\
    \ < dot_pos_end {\n            let mut dot_pos_end = dot_pos_end;\n          \
    \  let mut dot_pos_start = dot_pos_start;\n            \n            if dot_pos_end\
    \ == dot_pos_start {\n                dot_pos_end += 1;\n            }\n     \
    \       \n            if dot_pos_start < dot_pos_end {\n                let mut\
    \ dot_pos_end = dot_pos_end;\n                let mut dot_pos_start = dot_pos_start;\n\
    \                \n                if dot_pos_end == dot_pos_start {\n       \
    \             dot_pos_end += 1;\n                }\n                \n       \
    \         if dot_pos_start < dot_pos_end {\n                    let mut dot_pos_end\
    \ = dot_pos_end;\n                    let mut dot_pos_start = dot_pos_start;\n\
    \                    \n                    if dot_pos_end == dot_pos_start {\n\
    \                        dot_pos_end += 1;\n                    }\n          \
    \          \n                    if dot_pos_start < dot_pos_end {\n          \
    \              let mut dot_pos_end = dot_pos_end;\n                        let\
    \ mut dot_pos_start = dot_pos_start;\n                        \n             \
    \           if dot_pos_end == dot_pos_start {\n                            dot_pos_end\
    \ += 1;\n                        }\n                        \n               \
    \         if dot_pos_start < dot_pos_end {\n                            let mut\
    \ dot_pos_end = dot_pos_end;\n                            let mut dot_pos_start\
    \ = dot_pos_start;\n                            \n                           \
    \ if dot_pos_end == dot_pos_start {\n                                dot_pos_end\
    \ += 1;\n                            }\n                            \n       \
    \                     if dot_pos_start < dot_pos_end {\n                     \
    \           let mut dot_pos_end = dot_pos_end;\n                             \
    \   let mut dot_pos_start = dot_pos_start;\n                                \n\
    \                                if dot_pos_end == dot_pos_start {\n         \
    \                           dot_pos_end += 1;\n                              \
    \  }\n                                \n                                if dot_pos_start\
    \ < dot_pos_end {\n                                    let mut dot_pos_end = dot_pos_end;\n\
    \                                    let mut dot_pos_start = dot_pos_start;\n\
    \                                    \n                                    if\
    \ dot_pos_end == dot_pos_start {\n                                        dot_pos_end\
    \ += 1;\n                                    }\n                             \
    \       \n                                    if dot_pos_start < dot_pos_end \n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpb5kp2not.rs:118:3\n\
    \    |\n13  | fn file_name_check(file_name: String) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n23  |  \
    \   while dot_pos_start < dot_pos_end {\n    |                               \
    \        - unclosed delimiter\n...\n31  |         if dot_pos_start < dot_pos_end\
    \ {\n    |                                        - unclosed delimiter\n...\n\
    39  |             if dot_pos_start < dot_pos_end {\n    |                    \
    \                        - unclosed delimiter\n...\n47  |                 if dot_pos_start\
    \ < dot_pos_end {\n    |                                                - unclosed\
    \ delimiter\n...\n55  |                     if dot_pos_start < dot_pos_end {\n\
    \    |                                                    - unclosed delimiter\n\
    ...\n63  |                         if dot_pos_start < dot_pos_end {\n    |   \
    \                                                     - unclosed delimiter\n...\n\
    71  |                             if dot_pos_start < dot_pos_end {\n    |    \
    \                                                        - unclosed delimiter\n\
    ...\n79  |                                 if dot_pos_start < dot_pos_end {\n\
    \    |                                                                - this delimiter\
    \ might not be properly closed...\n...\n88  | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n118 | }\n    |   ^\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpb5kp2not.rs:15:42\n   |\n15 |     let\
    \ mut dot_pos = file_name.find('.')\n   |                                    \
    \      ^ help: add `;` here\n16 |     if dot_pos == String::npos {\n   |     --\
    \ unexpected token\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpb5kp2not.rs:88:1\n\
    \   |\n87 |                                     if dot_pos_start < dot_pos_end\
    \ \n   |                                     -- this `if` expression has a condition,\
    \ but no block\n88 | }\n   | ^ expected `{`\n\nerror[E0599]: no function or associated\
    \ item named `npos` found for struct `Stri"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter =\
    \ String::new();\n    let mut dot_pos_end_letter = String::new();\n    let mut\
    \ dot_pos_start_letter_pos = 0;\n    let mut dot_pos_end_letter_pos = 0;\n   \
    \ let mut dot_pos_start_letter_pos_end = 0;\n    let mut dot_pos_end_letter_pos_end\
    \ = 0;\n    let mut dot_pos_start_letter_pos_end_end = 0;\n    let mut dot_pos_end_letter_pos_end_end\
    \ = 0;\n    let mut dot_pos_start_letter_pos_end_end_end = 0;\n    let mut dot_pos_end_letter_pos_end_end_end\
    \ = 0;\n    let mut dot_pos_start_letter_pos_end_end_end_end = 0;\n    let mut\
    \ dot_pos_end_letter_pos_end_end_end_end = 0;\n    let mut dot_pos_start_letter_pos_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_end_letter_pos_end_end_end_end_end = 0;\n    let mut\
    \ dot_pos_start_letter_pos_end_end_end_end_end_end = 0;\n    let mut dot_pos_end_letter_pos_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_start_letter_pos_end_end_end_end_end_end_end = 0;\n\
    \    let mut dot_pos_end_letter_pos_end_end_end_end_end_end_end = 0;\n    let\
    \ mut dot_pos_start_letter_pos_end_end_end_end_end_end_end_end = 0;\n    let mut\
    \ dot_pos_end_letter_pos_end_end_end_end_end_end_end_end = 0;\n    let mut dot_pos_start_letter_pos_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_end_letter_pos_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_start_letter_pos_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_end_letter_pos_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_start_letter_pos_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_end_letter_pos_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_start_letter_pos_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_end_letter_pos_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut dot_pos_start_letter_pos_\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp44wbdp1h.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp44wbdp1h.rs:49:38\n\
    \   |\n49 |     let mut dot_pos_start_letter_pos_\n   |                      \
    \                ^ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp44wbdp1h.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmp44wbdp1h.rs:19:35\n   |\n19 |     let mut dot_pos_end = dot_pos\
    \ + 1;\n   |                           ------- ^ - {integer}\n   |           \
    \                |\n   |                           Option<usize>\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp44wbdp1h.rs:20:37\n\
    \   |\n20 |     let mut dot_pos_start = dot_pos + 1;\n   |                   \
    \          ------- ^ - {integer}\n   |                             |\n   |   \
    \                          Option<usize>\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp44wbdp1h.rs:13:42\n   |\n13 | fn file_name_check(file_name: String)\
    \ -> String {\n   |    ---------------                       ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return \"No\";\n    }\n    if file_name.len() > 3 {\n        return \"No\"\
    ;\n    }\n    if file_name[0..dot_pos].is_empty() {\n        return \"No\";\n\
    \    }\n    if file_name[dot_pos] != 'a' && file_name[dot_pos] != 'b' && file_name[dot_pos]\
    \ != 'c' && file_name[dot_pos] != 'd' && file_name[dot_pos] != 'e' && file_name[dot_pos]\
    \ != 'f' && file_name[dot_pos] != 'g' && file_name[dot_pos] != 'h' && file_name[dot_pos]\
    \ != 'i' && file_name[dot_pos] != 'j' && file_name[dot_pos] != 'k' && file_name[dot_pos]\
    \ != 'l' && file_name[dot_pos] != 'm' && file_name[dot_pos] != 'n' && file_name[dot_pos]\
    \ != 'o' && file_name[dot_pos] != 'p' && file_name[dot_pos] != 'q' && file_name[dot_pos]\
    \ != 'r' && file_name[dot_pos] != 's' && file_name[dot_pos] != 't' && file_name[dot_pos]\
    \ != 'u' && file_name[dot_pos] != 'v' && file_name[dot_pos] != 'w' && file_name[dot_pos]\
    \ != 'x' && file_name[dot_pos] != 'y' && file_name[dot_pos] != 'z' {\n       \
    \ return \"No\";\n    }\n    if file_name[dot_pos] == '.' {\n        let dot_pos_2\
    \ = file_name.find('.')\n        if dot_pos_2 == String::npos {\n            return\
    \ \"No\";\n        }\n        if dot_pos_2 > dot_pos + 1 {\n            return\
    \ \"No\";\n        }\n    }\n    return \"Yes\";\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpgi7fqaq0.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpgi7fqaq0.rs:29:44\n   |\n29 |         let dot_pos_2 = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n30 |  \
    \       if dot_pos_2 == String::npos {\n   |         -- unexpected token\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpgi7fqaq0.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgi7fqaq0.rs:17:16\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n17 |         return \"No\";\n   |                ^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                |\n   |             \
    \   expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgi7fqaq0.rs:22:21\n   |\n22 |     if file_name[0..dot_pos].is_empty()\
    \ {\n   |                     ^^^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `Option<usize>`\n  -->\
    \ /tmp/tmpgi7fqaq0.rs:25:8\n   |\n25 |     if file_name[dot_pos] != 'a' && file_name[dot_pos]\
    \ != 'b' && file_name[dot_pos] != 'c' && file_name[dot_pos] != 'd' && file_name[dot_...\n\
    \   |        ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `Option<usize>`\n\
    \   |\n   = help: the trait `Index<Option<usize>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \     "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    if\
    \ file_name.len() > 3 {\n        file_name.truncate(3);\n    }\n    if file_name.contains(\"\
    .\") {\n        file_name.truncate(file_name.rfind('.'));\n    }\n    if file_name.starts_with(\"\
    a\") || file_name.starts_with(\"A\") || file_name.starts_with(\"0\") || file_name.starts_with(\"\
    9\") {\n        file_name.truncate(0);\n    }\n    if file_name.contains(\".\"\
    ) {\n        let dot_index = file_name.rfind('.');\n        if dot_index == 0\
    \ {\n            file_name.truncate(dot_index);\n        }\n    }\n    if file_name.contains(\"\
    txt\") || file_name.contains(\"exe\") || file_name.contains(\"dll\") {\n     \
    \   file_name.truncate(0);\n    }\n    file_name\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp95smocxi.rs:19:28\n   |\n\
    19 |         file_name.truncate(file_name.rfind('.'));\n   |                 \
    \           ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n\
    \   = note: expected type `usize`\n              found enum `Option<usize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp95smocxi.rs:26:25\n   |\n26 |  \
    \       if dot_index == 0 {\n   |                         ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    26 |         if dot_index == Some(0) {\n   |                         +++++ +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp95smocxi.rs:27:32\n   |\n27 |\
    \             file_name.truncate(dot_index);\n   |                           \
    \     ^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n   = note: expected\
    \ type `usize`\n              found enum `Option<usize>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.clone();\n    let mut\
    \ dot_index = file_name.find('.')\n    if dot_index == String::npos { \n     \
    \   return \"No\"\n    }\n    \n    let mut first_letter = file_name.chars().next().unwrap();\n\
    \    if first_letter < 'a' || first_letter > 'z' {\n        return \"No\"\n  \
    \  }\n    \n    let mut dot_index = file_name.find('.')\n    if dot_index == String::npos\
    \ { \n        return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos \n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpspzh03_s.rs:15:44\n\
    \   |\n15 |     let mut dot_index = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n16 |     if dot_index == String::npos\
    \ { \n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpspzh03_s.rs:25:44\n   |\n25 |     let mut dot_index = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n26 |  \
    \   if dot_index == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpspzh03_s.rs:30:44\n   |\n30 |     let\
    \ mut dot_index = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n31 |     if dot_index == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmpspzh03_s.rs:35:44\n   |\n35 |     let mut dot_index = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n36 |  \
    \   if dot_index == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpspzh03_s.rs:40:44\n   |\n40 |     let\
    \ mut dot_index = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n41 |     if dot_index == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmpspzh03_s.rs:45:44\n   |\n45 |     let mut dot_index = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n46 |  \
    \   if dot_index == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmpspzh03_s.rs:50:44\n   |\n50 |     let\
    \ mut dot_index = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n51 |     if dot_index == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmpspzh03_s.rs:55:44\n   |\n55 |     let mut dot_index = file_name.find('.')\n\
    \   |                                            ^ help: add "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\"\n    }\n    if file_name[dot_pos - 1] == '0' {\n        return\
    \ \"No\"\n    }\n    if file_name[dot_pos - 1] == '9' {\n        return \"No\"\
    \n    }\n    if file_name[dot_pos - 1] != '.' {\n        return \"No\"\n    }\n\
    \    if file_name[0..dot_pos - 1].is_empty() {\n        return \"No\"\n    }\n\
    \    if file_name[0..dot_pos - 1] != \"a\" && file_name[0..dot_pos - 1] != \"\
    A\" {\n        return \"No\"\n    }\n    if file_name[dot_pos + 1..].is_empty()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos + 1..] != \"txt\"\
    \ && file_name[dot_pos + 1..] != \"exe\" && file_name[dot_pos + 1..] != \"dll\"\
    \ {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\nfn main() {\n    let\
    \ candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpkhwt9e4t.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ { \n   |     -- unexpected token\n\nerror[E0599]: no function or associated\
    \ item named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpkhwt9e4t.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos { \n   |                          \
    \ ^^^^ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkhwt9e4t.rs:17:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n17 |         return \"No\"\n   |     \
    \           ^^^^- help: try using a conversion method: `.to_string()`\n   |  \
    \              |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpkhwt9e4t.rs:19:26\n\
    \   |\n19 |     if file_name[dot_pos - 1] == '0' {\n   |                  -------\
    \ ^ - {integer}\n   |                  |\n   |                  Option<usize>\n\
    \nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpkhwt9e4t.rs:22:26\n\
    \   |\n22 |     if file_name[dot_pos - 1] == '9' {\n   |                  -------\
    \ ^ - {integer}\n   |                  |\n   |                  Option<usize>\n\
    \nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpkhwt9e4t.rs:25:26\n\
    \   |\n25 |     if file_name[dot_pos - 1] != '.' {\n   |                  -------\
    \ ^ - {integer}\n   |                  |\n   |                  Option<usize>\n\
    \nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpkhwt9e4t.rs:28:29\n\
    \   |\n28 |     if file_name[0..dot_pos - 1].is_empty() {\n   |              \
    \       ------- ^ - {integer}\n   |                     |\n   |              \
    \       Option<usize>\n\nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n\
    \  --> /tmp/tmpkhwt9e4t.rs:31:29\n   |\n31"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    if file_name[dot_pos - 1] != String::from('0')\
    \ && file_name[dot_pos - 1] != String::from('9') {\n        return String::from(\"\
    No\");\n    }\n    if dot_pos == 0 {\n        return String::from(\"No\");\n \
    \   }\n    let mut dot_pos_2 = file_name.find('.')\n    if dot_pos_2 == String::npos\
    \ {\n        return String::from(\"No\");\n    }\n    if dot_pos_2 == 0 {\n  \
    \      return String::from(\"No\");\n    }\n    if file_name[dot_pos_2 - 1] !=\
    \ String::from('a') && file_name[dot_pos_2 - 1] != String::from('z') {\n     \
    \   return String::from(\"No\");\n    }\n    if file_name[dot_pos_2] != String::from('txt')\
    \ && file_name[dot_pos_2] != String::from('exe') && file_name[dot_pos_2] != String::from('dll')\
    \ {\n        return String::from(\"No\");\n    }\n    return String::from(\"Yes\"\
    );\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpq98t0zih.rs:35:45\n\
    \   |\n35 |     if file_name[dot_pos_2] != String::from('txt') && file_name[dot_pos_2]\
    \ != String::from('exe') && file_name[dot_pos_2] != String::from...\n   |    \
    \                                         ^^^^^\n   |\nhelp: if you meant to write\
    \ a `str` literal, use double quotes\n   |\n35 |     if file_name[dot_pos_2] !=\
    \ String::from(\"txt\") && file_name[dot_pos_2] != String::from('exe') && file_name[dot_pos_2]\
    \ != String::from('dll') {\n   |                                             ~~~~~\n\
    \nerror: character literal may only contain one codepoint\n  --> /tmp/tmpq98t0zih.rs:35:92\n\
    \   |\n35 |     if file_name[dot_pos_2] != String::from('txt') && file_name[dot_pos_2]\
    \ != String::from('exe') && file_name[dot_pos_2] != String::from...\n   |    \
    \                                                                            \
    \            ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n35 |     if file_name[dot_pos_2] != String::from('txt') && file_name[dot_pos_2]\
    \ != String::from(\"exe\") && file_name[dot_pos_2] != String::from('dll') {\n\
    \   |                                                                        \
    \                    ~~~~~\n\nerror: character literal may only contain one codepoint\n\
    \  --> /tmp/tmpq98t0zih.rs:35:139\n   |\n35 | ... != String::from('exe') && file_name[dot_pos_2]\
    \ != String::from('dll') {\n   |                                             \
    \                       ^^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n35 |     if file_name[dot_pos_2] != String::from('txt')\
    \ && file_name[dot_pos_2] != String::from('exe') && file_name[dot_pos_2] != String::from(\"\
    dll\") {\n   |                                                               \
    \                                                                            ~~~~~\n\
    \nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpq98t0zih.rs:15:42\n \
    \  |\n15 |     let mut dot_pos = file_name.find('.')\n   |                   \
    \                       ^ help"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\"\n    }\n    let mut dot_pos_2 = file_name.find('.')\n    if\
    \ dot_pos_2 == String::npos { \n        return \"No\"\n    }\n    let mut dot_pos_3\
    \ = file_name.find('.')\n    if dot_pos_3 == String::npos { \n        return \"\
    No\"\n    }\n    let mut dot_pos_4 = file_name.find('.')\n    if dot_pos_4 ==\
    \ String::npos { \n        return \"No\"\n    }\n    let mut dot_pos_5 = file_name.find('.')\n\
    \    if dot_pos_5 == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos_6 = file_name.find('.')\n    if dot_pos_6 == String::npos { \n     \
    \   return \"No\"\n    }\n    let mut dot_pos_7 = file_name.find('.')\n    if\
    \ dot_pos_7 == String::npos { \n        return \"No\"\n    }\n    let mut dot_pos_8\
    \ = file_name.find('.')\n    if dot_pos_8 == String::npos { \n        return \"\
    No\"\n    }\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 ==\
    \ String::npos { \n        return \"No\"\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos { \n   \
    \     return \"No\"\n    }\n    let mut dot_pos_12 = file_name.find('.')\n   \
    \ if dot_pos_12 == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos { \n   \
    \     return \"No\"\n    }\n    let mut dot_pos_14 = file_name.find('.')\n   \
    \ if dot_pos_14 == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos { \n   \
    \     return \"No\"\n    }\n    let mut dot_pos_16 = file_name.find('.')\n   \
    \ if dot_pos_16 == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos_17 = file_name.find('.')\n    if dot_pos_17 == String::npos { \n   \
    \     return \"No\"\n    }\n    let mut dot_pos_18 = file_name.find('.')\n   \
    \ if dot_pos_18 == String::npos { \n        return \"No\n}\n\nfn main() {\n  \
    \  let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmp81dectsk.rs:91:40\n\
    \   |\n91 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n   --> /tmp/tmp81dectsk.rs:104:56\n    |\n104\
    \ |     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n    |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmp81dectsk.rs:115:63\n\
    \    |\n115 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    116 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n    if dot_pos\
    \ == String::npos { \n        return \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n\
    \    if dot_pos == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n        return\
    \ \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n    if dot_pos ==\
    \ String::npos { \n        return \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n\
    \    if dot_pos == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n        return\
    \ \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n    if dot_pos ==\
    \ String::npos { \n        return \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n\
    \    if dot_pos == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n        return\
    \ \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n    if dot_pos ==\
    \ String::npos { \n        return \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n\
    \    if dot_pos == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n        return\
    \ \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n    if dot_pos ==\
    \ String::npos { \n        return \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n\
    \    if dot_pos == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n        return\
    \ \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n    if dot_pos ==\
    \ String::npos { \n        return \"No\"\n    }\n    let mut dot_pos = file_name.find('.')\n\
    \    if dot_pos == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n        return\
    \ \"No\"\n    }\n    let mut dot_pos = file_name.find('\n}\n\nfn main() {\n  \
    \  let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp24tv34g7.rs:91:38\n\
    \   |\n91 |     let mut dot_pos = file_name.find('\n   |                     \
    \                 ^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\"\n    }\n    let mut dot_pos_end = dot_pos;\n    dot_pos_end\
    \ += 1;\n    let mut dot_pos_start = dot_pos;\n    dot_pos_start -= 1;\n    let\
    \ mut dot_pos_start_letter = dot_pos_start;\n    dot_pos_start_letter -= 1;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    dot_pos_end_letter += 1;\n\
    \    let mut dot_pos_end_letter2 = dot_pos_end;\n    dot_pos_end_letter2 += 1;\n\
    \    let mut dot_pos_end_letter3 = dot_pos_end;\n    dot_pos_end_letter3 += 1;\n\
    \    let mut dot_pos_end_letter4 = dot_pos_end;\n    dot_pos_end_letter4 += 1;\n\
    \    let mut dot_pos_end_letter5 = dot_pos_end;\n    dot_pos_end_letter5 += 1;\n\
    \    let mut dot_pos_end_letter6 = dot_pos_end;\n    dot_pos_end_letter6 += 1;\n\
    \    let mut dot_pos_end_letter7 = dot_pos_end;\n    dot_pos_end_letter7 += 1;\n\
    \    let mut dot_pos_end_letter8 = dot_pos_end;\n    dot_pos_end_letter8 += 1;\n\
    \    let mut dot_pos_end_letter9 = dot_pos_end;\n    dot_pos_end_letter9 += 1;\n\
    \    let mut dot_pos_end_letter10 = dot_pos_end;\n    dot_pos_end_letter10 +=\
    \ 1;\n    let mut dot_pos_end_letter11 = dot_pos_end;\n    dot_pos_end_letter11\
    \ += 1;\n    let mut dot_pos_end_letter12 = dot_pos_end;\n    dot_pos_end_letter12\
    \ += 1;\n    let mut dot_pos_end_letter13 = dot_pos_end;\n    dot_pos_end_letter13\
    \ += 1;\n    let mut dot_pos_end_letter14 = dot_pos_end;\n    dot_pos_end_letter14\
    \ += 1;\n    let mut dot_pos_end_letter15 = dot_pos_end;\n    dot_pos_end_letter15\
    \ += 1;\n    let mut dot_pos_end_letter16 = dot_pos_end;\n    dot_pos_end_letter16\
    \ += 1;\n    let mut dot_pos_end_letter17 = dot_pos_end;\n    dot_pos_end_letter17\
    \ += 1;\n    let mut dot_pos_end_letter18 = dot_pos_end;\n    dot_pos_end_letter18\
    \ += 1;\n    let mut dot_pos_end_letter19 = dot_pos_end;\n    dot_pos_end_letter19\
    \ += 1;\n    let mut dot_pos_end_letter20 = dot_pos_end;\n    dot_pos_end_\n}\n\
    \nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp4fe613y8.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ { \n   |     -- unexpected token\n\nerror[E0425]: cannot find value `dot_pos_end_`\
    \ in this scope\n  --> /tmp/tmp4fe613y8.rs:64:5\n   |\n64 |     dot_pos_end_\n\
    \   |     ^^^^^^^^^^^^ help: a local variable with a similar name exists: `dot_pos_end`\n\
    \nerror[E0599]: no function or associated item named `npos` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp4fe613y8.rs:16:27\n   |\n16 |     if dot_pos\
    \ == String::npos { \n   |                           ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4fe613y8.rs:17:16\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n17 |         return \"No\"\n   |                ^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `Option<usize>`\n  --> /tmp/tmp4fe613y8.rs:20:5\n\
    \   |\n20 |     dot_pos_end += 1;\n   |     -----------^^^^^\n   |     |\n   |\
    \     cannot use `+=` on type `Option<usize>`\n\nerror[E0368]: binary assignment\
    \ operation `-=` cannot be applied to type `Option<usize>`\n  --> /tmp/tmp4fe613y8.rs:22:5\n\
    \   |\n22 |     dot_pos_start -= 1;\n   |     -------------^^^^^\n   |     |\n\
    \   |     cannot use `-=` on type `Option<usize>`\n\nerror[E0368]: binary assignment\
    \ operation `-=` cannot be applied to type `Option<usize>`\n  --> /tmp/tmp4fe613y8.rs:24:5\n\
    \   |\n24 |     dot_pos_start_letter -= 1;\n   |     --------------------^^^^^\n\
    \   |     |\n   |     cannot use `-=` on type `Option<usize>`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Option<usize>`\n\
    \  --> /tmp/tmp4fe613y8.rs:26:5\n   |\n26 |     dot_pos_end_letter += 1;\n   |\
    \     "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_char: char;\n    let mut second_char:\
    \ char;\n    let mut third_char: char;\n    let mut fourth_char: char;\n    let\
    \ mut fifth_char: char;\n    let mut sixth_char: char;\n    let mut seventh_char:\
    \ char;\n    let mut eighth_char: char;\n    let mut ninth_char: char;\n    let\
    \ mut tenth_char: char;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let mut seventh_char_valid = false;\n    let mut eighth_char_valid\
    \ = false;\n    let mut ninth_char_valid = false;\n    let mut tenth_char_valid\
    \ = false;\n    let mut first_char_valid = false;\n    let mut second_char_valid\
    \ = false;\n    let mut third_char_valid = false;\n    let mut fourth_char_valid\
    \ = false;\n    let mut fifth_char_valid = false;\n    let mut sixth_char_valid\
    \ = false;\n    let \n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpppwp6cfj.rs:71:1\n  \
    \ |\n71 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return String::from(\"No\");\n    }\n    \n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos { \n        return String::from(\"No\");\n \
    \   }\n    \n    if dot_pos_2 > dot_pos {\n        return String::from(\"No\"\
    );\n    }\n    \n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3\
    \ == String::npos { \n        return String::from(\"No\");\n    }\n    \n    if\
    \ dot_pos_3 > dot_pos_2 {\n        return String::from(\"No\");\n    }\n    \n\
    \    let mut dot_pos_4 = file_name.find('.')\n    if dot_pos_4 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    \n    if dot_pos_4 > dot_pos_3\
    \ {\n        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_5\
    \ = file_name.find('.')\n    if dot_pos_5 == String::npos { \n        return String::from(\"\
    No\");\n    }\n    \n    if dot_pos_5 > dot_pos_4 {\n        return String::from(\"\
    No\");\n    }\n    \n    let mut dot_pos_6 = file_name.find('.')\n    if dot_pos_6\
    \ == String::npos { \n        return String::from(\"No\");\n    }\n    \n    if\
    \ dot_pos_6 > dot_pos_5 {\n        return String::from(\"No\");\n    }\n    \n\
    \    let mut dot_pos_7 = file_name.find('.')\n    if dot_pos_7 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    \n    if dot_pos_7 > dot_pos_6\
    \ {\n        return String::from(\"No\");\n    }\n    \n    let mut dot_pos_8\
    \ = file_name.find('.')\n    if dot_pos_8 == String::npos { \n        return String::from(\"\
    No\");\n    }\n    \n    if dot_pos_8 > dot_pos_7 {\n        return String::from(\"\
    No\");\n    }\n    \n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9\
    \ == String::npos { \n        return String::from(\"No\");\n    }\n    \n    if\
    \ dot_pos_9 > dot_pos_8 {\n        return String::from(\"No\");\n    }\n    \n\
    \    let mut dot_pos_10 = file_name.find('.')\n    if dot_pos_10 == String::npos\
    \ { \n        return String::from(\"No\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n   --> /tmp/tmpcbx8mbkn.rs:100:40\n\
    \    |\n100 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n   --> /tmp/tmpcbx8mbkn.rs:113:56\n    |\n113\
    \ |     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n    |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmpcbx8mbkn.rs:124:63\n\
    \    |\n124 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    125 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter =\
    \ dot_pos_start;\n    while dot_pos_start < dot_pos_end {\n        let mut dot_pos_letter\
    \ = dot_pos_start;\n        while dot_pos_letter < dot_pos_end {\n           \
    \ let mut dot_pos_letter = dot_pos_letter + 1;\n            if dot_pos_letter\
    \ > dot_pos_end {\n                dot_pos_letter = dot_pos_end;\n           \
    \ }\n            if file_name[dot_pos_letter] >= 'a' && file_name[dot_pos_letter]\
    \ <= 'z' {\n                dot_pos_start_letter = dot_pos_letter;\n         \
    \   }\n            dot_pos_letter = dot_pos_letter + 1;\n        }\n        if\
    \ dot_pos_start_letter > dot_pos_end {\n            dot_pos_start_letter = dot_pos_end;\n\
    \        }\n        if file_name[dot_pos_start_letter] >= 'a' && file_name[dot_pos_start_letter]\
    \ <= 'z' {\n            break;\n        }\n        dot_pos_start_letter = dot_pos_start_letter\
    \ + 1;\n    }\n    if dot_pos_start_letter > dot_pos {\n        return String::from(\"\
    No\");\n    }\n    if dot_pos == dot_pos_end {\n        return String::from(\"\
    Yes\");\n    }\n    if file_name[dot_pos - 1] != '.' {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos + 1] != '.' {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos - 1] != file_name[dot_pos + 1] {\n   \
    \     return String::from(\"No\");\n    }\n    if file_name[dot_pos - 1] != file_name[dot_pos\
    \ - 1] {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos\
    \ - 1] != file_name[dot_pos - 1] {\n        return String::from(\"No\");\n   \
    \ }\n    if file_name[dot_pos - 1] != file_name[dot_pos - 1] {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name[dot_pos - 1] != file_name[dot_pos\
    \ - 1] {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos\
    \ - 1] != file_name[dot_pos - 1] {\n        return String::from(\"No\");\n   \
    \ }\n    if file_name[dot_pos - 1] != file_name[dot_pos - 1] {\n        return\
    \ String::from(\"No\");\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp_nftofdf.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmp_nftofdf.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n  --> /tmp/tmp_nftofdf.rs:19:35\n   |\n19 |\
    \     let mut dot_pos_end = dot_pos + 1;\n   |                           -------\
    \ ^ - {integer}\n   |                           |\n   |                      \
    \     Option<usize>\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmp_nftofdf.rs:20:37\n   |\n20 |     let mut dot_pos_start = dot_pos\
    \ + 1;\n   |                             ------- ^ - {integer}\n   |         \
    \                    |\n   |                             Option<usize>\n\nerror[E0277]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp_nftofdf.rs:32:45\n\
    \   |\n32 |             dot_pos_letter = dot_pos_letter + 1;\n   |           \
    \                                  ^ no implementation for `Option<usize> + {integer}`\n\
    \   |\n   = help: the trait `Add<{integer}>` is not implemented for `Option<usize>`\n\
    \nerror[E0277]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp_nftofdf.rs:40:53\n\
    \   |\n40 |         dot_pos_start_letter = dot_pos_start_letter + 1;\n   |   \
    \                                                  ^ no implementation for `Option<usize>\
    \ + {integer}`\n   |\n   = help: the trait `Add<{integer}>` is not implemented\
    \ for `Option<usize>`\n\nerror[E0277]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmp_nftofdf.rs:25:53\n   |\n25 |             let mut dot_pos_letter\
    \ = dot_pos_letter + 1;\n   |                                                \
    \     ^ no implementation for `Option<usize> + {integer}`\n   |\n   = help: the\
    \ trait `Add<{in"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut counter = 0;\n    let mut i = 0;\n    let mut\
    \ dot_count = 0;\n    let mut dot_pos = 0;\n    let mut dot_pos_prev = 0;\n  \
    \  let mut dot_pos_next = 0;\n    let mut dot_pos_next2 = 0;\n    let mut dot_pos_next3\
    \ = 0;\n    let mut dot_pos_next4 = 0;\n    let mut dot_pos_next5 = 0;\n    let\
    \ mut dot_pos_next6 = 0;\n    let mut dot_pos_next7 = 0;\n    let mut dot_pos_next8\
    \ = 0;\n    let mut dot_pos_next9 = 0;\n    let mut dot_pos_next10 = 0;\n    let\
    \ mut dot_pos_next11 = 0;\n    let mut dot_pos_next12 = 0;\n    let mut dot_pos_next13\
    \ = 0;\n    let mut dot_pos_next14 = 0;\n    let mut dot_pos_next15 = 0;\n   \
    \ let mut dot_pos_next16 = 0;\n    let mut dot_pos_next17 = 0;\n    let mut dot_pos_next18\
    \ = 0;\n    let mut dot_pos_next19 = 0;\n    let mut dot_pos_next20 = 0;\n   \
    \ let mut dot_pos_next21 = 0;\n    let mut dot_pos_next22 = 0;\n    let mut dot_pos_next23\
    \ = 0;\n    let mut dot_pos_next24 = 0;\n    let mut dot_pos_next25 = 0;\n   \
    \ let mut dot_pos_next26 = 0;\n    let mut dot_pos_next27 = 0;\n    let mut dot_pos_next28\
    \ = 0;\n    let mut dot_pos_next29 = 0;\n    let mut dot_pos_next30 = 0;\n   \
    \ let mut dot_pos_next31 = 0;\n    let mut dot_pos_next32 = 0;\n    let mut dot_pos_next33\
    \ = 0;\n    let mut dot_pos_next34 = 0;\n    let mut dot_pos_next35 = 0;\n   \
    \ let mut dot_pos_next36 = 0;\n    let mut dot_pos_next37 = 0;\n    let mut dot_pos_next38\
    \ = 0;\n    let mut dot_pos_next39 = 0;\n    let mut dot_pos_next40 = 0;\n   \
    \ let mut dot_pos_next41 = 0;\n    let mut dot_pos_next42 = 0;\n    let mut dot_pos_next43\
    \ = 0;\n    let mut dot_pos_next44 = 0;\n    let mut dot_pos_next45 = 0;\n   \
    \ let mut dot_pos_next46 = 0;\n    let mut dot_pos_next47 = 0;\n    let mut dot_pos_next48\
    \ = 0;\n    let mut dot_pos_next49 = 0;\n    let mut dot_pos_next50 = 0;\n   \
    \ let mut dot_pos_next51 = 0;\n    let mut dot_pos_next52 = 0;\n    let mut dot_pos_next53\
    \ = 0;\n    let mut dot_pos_next54 = 0;\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprid2p0al.rs:13:42\n   |\n\
    13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return \"No\";\n    }\n    if file_name.len() < 3 {\n        return \"No\"\
    ;\n    }\n    if file_name[0..1] != \"a\" && file_name[0..1] != \"A\" {\n    \
    \    return \"No\";\n    }\n    if file_name[dot_pos+1..dot_pos+4] != \"txt\"\
    \ && file_name[dot_pos+1..dot_pos+4] != \"exe\" && file_name[dot_pos+1..dot_pos+4]\
    \ != \"dll\" {\n        return \"No\";\n    }\n    return \"Yes\";\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp8pg9wggk.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmp8pg9wggk.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8pg9wggk.rs:17:16\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n17 |         return \"No\";\n   |    \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \               |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmp8pg9wggk.rs:22:24\n\
    \   |\n22 |     if file_name[0..1] != \"a\" && file_name[0..1] != \"A\" {\n  \
    \ |                        ^^ no implementation for `str == &str`\n   |\n   =\
    \ help: the trait `PartialEq<&str>` is not implemented for `str`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `str` with `&str`\n  --> /tmp/tmp8pg9wggk.rs:22:50\n   |\n22 |     if file_name[0..1]\
    \ != \"a\" && file_name[0..1] != \"A\" {\n   |                               \
    \                   ^^ no implementation for `str == &str`\n   |\n   = help: the\
    \ trait `PartialEq<&str>` is not implemented for `str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return String::from(\"No\");\n    }\n    let mut dot_pos = dot_pos - 1;\n\
    \    let mut dot_pos_2 = file_name.find('.')\n    if dot_pos_2 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_2 = dot_pos_2\
    \ - 1;\n    let mut dot_pos_3 = file_name.find('.')\n    if dot_pos_3 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_3 = dot_pos_3\
    \ - 1;\n    let mut dot_pos_4 = file_name.find('.')\n    if dot_pos_4 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_4 = dot_pos_4\
    \ - 1;\n    let mut dot_pos_5 = file_name.find('.')\n    if dot_pos_5 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_5 = dot_pos_5\
    \ - 1;\n    let mut dot_pos_6 = file_name.find('.')\n    if dot_pos_6 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_6 = dot_pos_6\
    \ - 1;\n    let mut dot_pos_7 = file_name.find('.')\n    if dot_pos_7 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_7 = dot_pos_7\
    \ - 1;\n    let mut dot_pos_8 = file_name.find('.')\n    if dot_pos_8 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_8 = dot_pos_8\
    \ - 1;\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_9 = dot_pos_9\
    \ - 1;\n    let mut dot_pos_10 = file_name.find('.')\n    if dot_pos_10 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_10 = dot_pos_10\
    \ - 1;\n    let mut dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos\
    \ { \n        return String::from(\"No\");\n    }\n    let mut dot_pos_11 = dot_pos_11\
    \ - 1;\n    let mut dot_pos_12 = file_name.find('.')\n    if dot_pos_12 == String::npos\
    \ { \n        return String::from(\"\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmpaain8e5j.rs:78:40\n\
    \   |\n78 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n  --> /tmp/tmpaain8e5j.rs:91:56\n   |\n91 |\
    \     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n   |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmpaain8e5j.rs:102:63\n\
    \    |\n102 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    103 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos { \n \
    \       return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    \n   \
    \ let mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\
    \ \n        return \"No\"\n    }\n    \n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n\n}\n\nfn\
    \ main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp9oz6ay6m.rs:15:44\n\
    \   |\n15 |     let mut dot_index = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n16 |     if dot_index == String::npos\
    \ { \n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmp9oz6ay6m.rs:20:44\n   |\n20 |     let mut dot_index = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n21 |  \
    \   if dot_index == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp9oz6ay6m.rs:25:44\n   |\n25 |     let\
    \ mut dot_index = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n26 |     if dot_index == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmp9oz6ay6m.rs:30:44\n   |\n30 |     let mut dot_index = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n31 |  \
    \   if dot_index == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp9oz6ay6m.rs:35:44\n   |\n35 |     let\
    \ mut dot_index = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n36 |     if dot_index == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmp9oz6ay6m.rs:40:44\n   |\n40 |     let mut dot_index = file_name.find('.')\n\
    \   |                                            ^ help: add `;` here\n41 |  \
    \   if dot_index == String::npos { \n   |     -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp9oz6ay6m.rs:45:44\n   |\n45 |     let\
    \ mut dot_index = file_name.find('.')\n   |                                  \
    \          ^ help: add `;` here\n46 |     if dot_index == String::npos { \n  \
    \ |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  -->\
    \ /tmp/tmp9oz6ay6m.rs:50:44\n   |\n50 |     let mut dot_index = file_name.find('.')\n\
    \   |                                            ^ help: add "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut first_char: char;\n    let mut last_char: char;\n\
    \    let mut dot_index: usize;\n    let mut dot_count: usize;\n    let mut dot_dot_index:\
    \ usize;\n    let mut dot_dot_count: usize;\n    let mut dot_dot_dot_index: usize;\n\
    \    let mut dot_dot_dot_count: usize;\n    let mut dot_dot_dot_dot_index: usize;\n\
    \    let mut dot_dot_dot_dot_count: usize;\n    let mut dot_dot_dot_dot_dot_index:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_count: usize;\n    let mut dot_dot_dot_dot_dot_dot_index:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_count: usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_index:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_count: usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_index:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_count: usize;\n    let mut\
    \ dot_dot_dot_dot_dot_dot_dot_dot_dot_index: usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_count:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_index: usize;\n\
    \    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_count: usize;\n    let mut\
    \ dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_index: usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_count:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_index: usize;\n\
    \    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_count: usize;\n \
    \   let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_index: usize;\n\
    \    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_count: usize;\n\
    \    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_index:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_count:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_index:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_count:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_index:\
    \ usize;\n    let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt5phzwvw.rs:47:53\n   |\n\
    47 |     let mut dot_dot_dot_dot_dot_dot_dot_dot_dot_dot_\n   |              \
    \                                       ^ help: add `;` here\n48 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt5phzwvw.rs:13:42\n \
    \  |\n13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos { \n \
    \       return \"No\"\n    }\n    let mut dot_index = file_name.find('.')\n  \
    \  if dot_index == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_index = file_name.find('.')\n    if dot_index == String::npos { \n     \
    \   return \"No\"\n    }\n    let mut dot_index = file_name.find('.')\n    if\
    \ dot_index == String::npos { \n        return \"No\"\n    }\n    let mut dot_index\
    \ = file_name.find('.')\n    if dot_index == String::npos { \n        return \"\
    No\"\n    }\n    let mut dot_index = file_name.find('.')\n    if dot_index ==\
    \ String::npos { \n        return \"No\"\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_index = file_name.find('.')\n    if dot_index == String::npos { \n     \
    \   return \"No\"\n    }\n    let mut dot_index = file_name.find('.')\n    if\
    \ dot_index == String::npos { \n        return \"No\"\n    }\n    let mut dot_index\
    \ = file_name.find('.')\n    if dot_index == String::npos { \n        return \"\
    No\"\n    }\n    let mut dot_index = file_name.find('.')\n    if dot_index ==\
    \ String::npos { \n        return \"No\"\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_index = file_name.find('.')\n    if dot_index == String::npos { \n     \
    \   return \"No\"\n    }\n    let mut dot_index = file_name.find('.')\n    if\
    \ dot_index == String::npos { \n        return \"No\"\n    }\n    let mut dot_index\
    \ = file_name.find('.')\n    if dot_index == String::npos { \n        return \"\
    No\"\n    }\n    let mut dot_index = file_name.find('.')\n    if dot_index ==\
    \ String::npos { \n        return \"No\"\n    }\n    let mut dot_index = file_name.find('.')\n\
    \    if dot_index == String::npos { \n        return \"No\"\n    }\n    let mut\
    \ dot_index = file_name.find('.')\n    if dot_index == String::npos { \n     \
    \   return \"No\"\n    }\n    let mut dot_index = file_name.find('.')\n    if\
    \ dot_index == String::npos { \n        return \"No\"\n    }\n    let mut dot_index\
    \ = file_name.find('\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpqt_xnn9x.rs:91:40\n\
    \   |\n91 |     let mut dot_index = file_name.find('\n   |                   \
    \                     ^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name_chars = file_name.chars();\n    let\
    \ mut dot_pos = file_name_chars.next().unwrap().unwrap();\n    let mut dot_pos_index\
    \ = dot_pos.unwrap();\n    let mut dot_pos_index2 = dot_pos_index.clone();\n \
    \   let mut dot_pos_index3 = dot_pos_index2.clone();\n    let mut dot_pos_index4\
    \ = dot_pos_index3.clone();\n    let mut dot_pos_index5 = dot_pos_index4.clone();\n\
    \    let mut dot_pos_index6 = dot_pos_index5.clone();\n    let mut dot_pos_index7\
    \ = dot_pos_index6.clone();\n    let mut dot_pos_index8 = dot_pos_index7.clone();\n\
    \    let mut dot_pos_index9 = dot_pos_index8.clone();\n    let mut dot_pos_index10\
    \ = dot_pos_index9.clone();\n    let mut dot_pos_index11 = dot_pos_index10.clone();\n\
    \    let mut dot_pos_index12 = dot_pos_index11.clone();\n    let mut dot_pos_index13\
    \ = dot_pos_index12.clone();\n    let mut dot_pos_index14 = dot_pos_index13.clone();\n\
    \    let mut dot_pos_index15 = dot_pos_index14.clone();\n    let mut dot_pos_index16\
    \ = dot_pos_index15.clone();\n    let mut dot_pos_index17 = dot_pos_index16.clone();\n\
    \    let mut dot_pos_index18 = dot_pos_index17.clone();\n    let mut dot_pos_index19\
    \ = dot_pos_index18.clone();\n    let mut dot_pos_index20 = dot_pos_index19.clone();\n\
    \    let mut dot_pos_index21 = dot_pos_index20.clone();\n    let mut dot_pos_index22\
    \ = dot_pos_index21.clone();\n    let mut dot_pos_index23 = dot_pos_index22.clone();\n\
    \    let mut dot_pos_index24 = dot_pos_index23.clone();\n    let mut dot_pos_index25\
    \ = dot_pos_index24.clone();\n    let mut dot_pos_index26 = dot_pos_index25.clone();\n\
    \    let mut dot_pos_index27 = dot_pos_index26.clone();\n    let mut dot_pos_index28\
    \ = dot_pos_index27.clone();\n    let mut dot_pos_index29 = dot_pos_index28.clone();\n\
    \    let mut dot_pos_index30 = dot_pos_index29.clone();\n    let mut dot_pos_index31\
    \ = dot_pos_index30.clone();\n    let mut dot_pos_index32 = dot_pos_index31.clone();\n\
    \    let mut dot_pos_index33 = dot_pos_index32.clone();\n    let mut dot_pos_index34\
    \ = dot_pos_index33.clone();\n    let mut dot_pos_index35 = dot_pos_index34.clone();\n\
    \    let mut dot_pos_index36 = dot_pos_\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppblq0hng.rs:51:39\n   |\n\
    51 |     let mut dot_pos_index36 = dot_pos_\n   |                            \
    \           ^ help: add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `dot_pos_` in this scope\n  --> /tmp/tmppblq0hng.rs:51:31\n\
    \   |\n51 |     let mut dot_pos_index36 = dot_pos_\n   |                     \
    \          ^^^^^^^^ help: a local variable with a similar name exists: `dot_pos`\n\
    \nerror[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmppblq0hng.rs:15:55\n   |\n15 |     let mut dot_pos = file_name_chars.next().unwrap().unwrap();\n\
    \   |                                                       ^^^^^^ method not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppblq0hng.rs:13:42\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos;\n    while dot_pos_start != dot_pos_end\
    \ {\n        let mut dot_pos_end = dot_pos_end;\n        let mut dot_pos_start\
    \ = dot_pos_start;\n        if dot_pos_start == dot_pos_end {\n            dot_pos_end\
    \ = file_name.len();\n        }\n        if file_name[dot_pos_start] != '0' {\n\
    \            return String::from(\"No\");\n        }\n        if dot_pos_start\
    \ == dot_pos_end {\n            dot_pos_end = file_name.len();\n        }\n  \
    \      if file_name[dot_pos_start] != '9' {\n            return String::from(\"\
    No\");\n        }\n        if dot_pos_start == dot_pos_end {\n            dot_pos_end\
    \ = file_name.len();\n        }\n        if file_name[dot_pos_start] != 'a' {\n\
    \            return String::from(\"No\");\n        }\n        if dot_pos_start\
    \ == dot_pos_end {\n            dot_pos_end = file_name.len();\n        }\n  \
    \      if file_name[dot_pos_start] != 'z' {\n            return String::from(\"\
    No\");\n        }\n        if dot_pos_start == dot_pos_end {\n            dot_pos_end\
    \ = file_name.len();\n        }\n        if file_name[dot_pos_start] != 'A' {\n\
    \            return String::from(\"No\");\n        }\n        if dot_pos_start\
    \ == dot_pos_end {\n            dot_pos_end = file_name.len();\n        }\n  \
    \      if file_name[dot_pos_start] != 'Z' {\n            return String::from(\"\
    No\");\n        }\n        if dot_pos_start == dot_pos_end {\n            dot_pos_end\
    \ = file_name.len();\n        }\n        if dot_pos_start != dot_pos_end {\n \
    \           return String::from(\"No\");\n        }\n        dot_pos_start++;\n\
    \    }\n    String::from(\"Yes\")\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpbp3ha26t.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmpbp3ha26t.rs:66:22\n   |\n66 |         dot_pos_start++;\n   |  \
    \                    ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n66 |         { let tmp = dot_pos_start; dot_pos_start += 1; tmp };\n  \
    \ |         +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n66 -       \
    \  dot_pos_start++;\n66 +         dot_pos_start += 1;\n   | \n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpbp3ha26t.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpbp3ha26t.rs:19:35\n   |\n19 |     let mut dot_pos_end = dot_pos\
    \ + 1;\n   |                           ------- ^ - {integer}\n   |           \
    \                |\n   |                           Option<usize>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbp3ha26t.rs:25:27\n   |\n22 |         let mut\
    \ dot_pos_end = dot_pos_end;\n   |                               ----------- expected\
    \ due to this value\n...\n25 |             dot_pos_end = file_name.len();\n  \
    \ |                           ^^^^^^^^^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n25 |             dot_pos_end\
    \ = Some(file_name.len());\n   |                           +++++             \
    \  +\n\nerror[E0277]: the type `String` cannot be indexed by `Option<usize>`\n\
    \  --> /tmp/tmpbp3ha26t.rs:27:12\n   |\n27 |         if file_name[dot_pos_start]\
    \ != '0' {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `Option<usize>`\n   |\n   = help: the trait `Index<Optio"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    if\
    \ file_name.len() > 3 {\n        file_name.truncate(3);\n    }\n    if file_name.contains('.')\
    \ {\n        file_name.truncate(file_name.rfind('.'));\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n        file_name.truncate(file_name.rfind('.'));\n\
    \    }\n    if file_name.chars().any(|c| !c.is_ascii_letter() || c != '.') {\n\
    \        file_name.truncate(file_name.rfind('.'));\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c != '.' || c != 'a' || c != 'z' || c != 'A' || c !=\
    \ 'Z') {\n        file_name.truncate(file_name.rfind('.'));\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c != '.' || c != 'a' || c != 'z' || c != 'A' || c !=\
    \ 'Z' || c != '0' || c != '9') {\n        file_name.truncate(file_name.rfind('.'));\n\
    \    }\n    if file_name.chars().any(|c| !c.is_ascii_letter() || c != '.' || c\
    \ != 'a' || c != 'z' || c != 'A' || c != 'Z' || c != '0' || c != '9' || c != 'x'\
    \ || c != 't' || c != 'e' || c != 'r' || c != 'l' || c != 'd' || c != 'l' || c\
    \ != 'l' || c != 'e' || c != 's' || c != 'e' || c != 's' || c != 't' || c != 't'\
    \ || c != 'x' || c != 't' || c != 'e' || c != 'r' || c != 'l' || c != 'd' || c\
    \ != 'l' || c != 'l' || c != 'e' || c != 's' || c != 'e' || c != 's' || c != 't'\
    \ || c != 't' || c != 'x' || c != 't' || c != 'e' || c != 'r' || c != 'l' || c\
    \ != 'd' || c != 'l' || c != 'l' || c != 'e' || c != 's' || c != 'e' || c != 's'\
    \ || c != 't' || c != 't' || c != 'x' || c != 't' || c != 'e' || c != 'r' || c\
    \ != 'l' || c != 'd' || c != 'l' || c != 'l' || c != 'e' || c != 's' || c != 'e'\
    \ || c != 's' || c != 't' || c != 't' || c != 'x' || c != 't' || c != 'e' || c\
    \ != 'r' || c != 'l' || c \n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpa3f5l_u8.rs:34:1\n   |\n\
    33 |     if file_name.chars().any(|c| !c.is_ascii_letter() || c != '.' || c !=\
    \ 'a' || c != 'z' || c != 'A' || c != 'Z' || c != '0' || c != '9'...\n   |   \
    \  -- this `if` expression has a condition, but no block\n34 | }\n   | ^ expected\
    \ `{`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpa3f5l_u8.rs:33:29\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n33 |     if file_name.chars().any(|c| !c.is_ascii_letter() || c !=\
    \ '.' || c != 'a' || c != 'z' || c != 'A' || c != 'Z' || c != '0' || c != '9'...\n\
    \   |                             ^ unclosed delimiter\n34 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa3f5l_u8.rs:19:28\n\
    \   |\n19 |         file_name.truncate(file_name.rfind('.'));\n   |          \
    \                  ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0599]: no method named `is_ascii_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpa3f5l_u8.rs:21:37\n   |\n21 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n   |                                     ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa3f5l_u8.rs:22:28\n   |\n22 |         file_name.truncate(file_name.rfind('.'));\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<usize>`\n\nerror[E0599]: no method named `is_ascii_letter` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpa3f5l_u8.rs:24:37\n   |\n24\
    \ |     if file_name.chars().any(|c| !c.is_ascii_letter() || c != '.') {\n   |\
    \                                     ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched types"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return \"No\";\n    }\n    let mut dot_pos_2 = file_name.find('.')\n    if\
    \ dot_pos_2 == String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_3\
    \ = file_name.find('.')\n    if dot_pos_3 == String::npos {\n        return \"\
    No\";\n    }\n    let mut dot_pos_4 = file_name.find('.')\n    if dot_pos_4 ==\
    \ String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_5 = file_name.find('.')\n\
    \    if dot_pos_5 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_6 = file_name.find('.')\n    if dot_pos_6 == String::npos {\n      \
    \  return \"No\";\n    }\n    let mut dot_pos_7 = file_name.find('.')\n    if\
    \ dot_pos_7 == String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_8\
    \ = file_name.find('.')\n    if dot_pos_8 == String::npos {\n        return \"\
    No\";\n    }\n    let mut dot_pos_9 = file_name.find('.')\n    if dot_pos_9 ==\
    \ String::npos {\n        return \"No\";\n    }\n    let mut dot_pos_10 = file_name.find('.')\n\
    \    if dot_pos_10 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_11 = file_name.find('.')\n    if dot_pos_11 == String::npos {\n    \
    \    return \"No\";\n    }\n    let mut dot_pos_12 = file_name.find('.')\n   \
    \ if dot_pos_12 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_13 = file_name.find('.')\n    if dot_pos_13 == String::npos {\n    \
    \    return \"No\";\n    }\n    let mut dot_pos_14 = file_name.find('.')\n   \
    \ if dot_pos_14 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_15 = file_name.find('.')\n    if dot_pos_15 == String::npos {\n    \
    \    return \"No\";\n    }\n    let mut dot_pos_16 = file_name.find('.')\n   \
    \ if dot_pos_16 == String::npos {\n        return \"No\";\n    }\n    let mut\
    \ dot_pos_17 = file_name.find('.')\n    if dot_pos_17 == String::npos {\n    \
    \    return \"No\";\n    }\n    let mut dot_pos_18 = file_name.find('.')\n   \
    \ if dot_pos_18 == String::npos {\n        return \"No\n}\n\nfn main() {\n   \
    \ let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmpglutkvbc.rs:91:40\n\
    \   |\n91 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n   --> /tmp/tmpglutkvbc.rs:104:56\n    |\n104\
    \ |     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n    |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmpglutkvbc.rs:115:63\n\
    \    |\n115 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    116 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos + 1;\n\
    \    let mut dot_pos_start = dot_pos + 1;\n    let mut dot_pos_start_letter =\
    \ dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n    let mut\
    \ dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter = dot_pos_start;\n\
    \    let mut dot_pos_end_letter = dot_pos_end;\n    let mut dot_pos_start_letter\
    \ = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n    let mut\
    \ dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter = dot_pos_end;\n\
    \    let mut dot_pos_start_letter = dot_pos_start;\n    let mut dot_pos_end_letter\
    \ = \n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpax6f72ew.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected expression, found `}`\n \
    \ --> /tmp/tmpax6f72ew.rs:59:1\n   |\n59 | }\n   | ^ expected expression\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpax6f72ew.rs:16:27\n   |\n16 |     if dot_pos ==\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpax6f72ew.rs:19:35\n   |\n19 |     let mut dot_pos_end = dot_pos\
    \ + 1;\n   |                           ------- ^ - {integer}\n   |           \
    \                |\n   |                           Option<usize>\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpax6f72ew.rs:20:37\n\
    \   |\n20 |     let mut dot_pos_start = dot_pos + 1;\n   |                   \
    \          ------- ^ - {integer}\n   |                             |\n   |   \
    \                          Option<usize>\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { return \"\
    No\"; }\n    if dot_pos == 0 { return \"No\"; }\n    if file_name[dot_pos - 1]\
    \ == '.' { return \"No\"; }\n    if file_name[dot_pos - 1] < 'a' || file_name[dot_pos\
    \ - 1] > 'z' { return \"No\"; }\n    if file_name[dot_pos - 1] == '.' && file_name[dot_pos\
    \ - 2] != 'd' && file_name[dot_pos - 2] != 'l' { return \"No\"; }\n    if file_name[dot_pos\
    \ - 1] == '.' && file_name[dot_pos - 2] == 'd' && file_name[dot_pos - 3] != 'l'\
    \ { return \"No\"; }\n    if file_name[dot_pos - 1] == '.' && file_name[dot_pos\
    \ - 2] == 'l' && file_name[dot_pos - 3] != 'd' { return \"No\"; }\n    if file_name[dot_pos\
    \ - 1] == '.' && file_name[dot_pos - 2] == 'd' && file_name[dot_pos - 3] == 'l'\
    \ { return \"Yes\"; }\n    return \"Yes\"\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpry6n7ugk.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ { return \"No\"; }\n   |     -- unexpected token\n\nerror[E0599]: no function\
    \ or associated item named `npos` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpry6n7ugk.rs:16:27\n   |\n16 |     if dot_pos == String::npos {\
    \ return \"No\"; }\n   |                           ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpry6n7ugk.rs:16:41\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n16 |     if dot_pos == String::npos { return \"No\"; }\n   |            \
    \                             ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                         |\n   |                        \
    \                 expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpry6n7ugk.rs:17:19\n   |\n17 |     if dot_pos == 0 { return\
    \ \"No\"; }\n   |                   ^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n17 |     if dot_pos == Some(0)\
    \ { return \"No\"; }\n   |                   +++++ +\n\nerror[E0369]: cannot subtract\
    \ `{integer}` from `Option<usize>`\n  --> /tmp/tmpry6n7ugk.rs:18:26\n   |\n18\
    \ |     if file_name[dot_pos - 1] == '.' { return \"No\"; }\n   |            \
    \      ------- ^ - {integer}\n   |                  |\n   |                  Option<usize>\n\
    \nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpry6n7ugk.rs:19:26\n\
    \   |\n19 |     if file_name[dot_pos - 1] < 'a' || file_name[dot_pos - 1] > 'z'\
    \ { return \"No\"; }\n   |                  ------- ^ - {integer}\n   |      \
    \            |\n   |                  Option<usize>\n\nerror[E0369]: cannot subtract\
    \ `{integer"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { return \"\
    No\" }\n    if file_name.len() > 3 { return \"No\" }\n    if file_name.len() <\
    \ 3 { return \"No\" }\n    if file_name[0] < 'a' || file_name[0] > 'z' { return\
    \ \"No\" }\n    if file_name[dot_pos - 1] < 'a' || file_name[dot_pos - 1] > 'z'\
    \ { return \"No\" }\n    if file_name[dot_pos] != 'txt' && file_name[dot_pos]\
    \ != 'exe' && file_name[dot_pos] != 'dll' { return \"No\" }\n    return \"Yes\"\
    \n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpy7a69nyp.rs:21:30\n\
    \   |\n21 |     if file_name[dot_pos] != 'txt' && file_name[dot_pos] != 'exe'\
    \ && file_name[dot_pos] != 'dll' { return \"No\" }\n   |                     \
    \         ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n21 |     if file_name[dot_pos] != \"txt\" && file_name[dot_pos]\
    \ != 'exe' && file_name[dot_pos] != 'dll' { return \"No\" }\n   |            \
    \                  ~~~~~\n\nerror: character literal may only contain one codepoint\n\
    \  --> /tmp/tmpy7a69nyp.rs:21:61\n   |\n21 |     if file_name[dot_pos] != 'txt'\
    \ && file_name[dot_pos] != 'exe' && file_name[dot_pos] != 'dll' { return \"No\"\
    \ }\n   |                                                             ^^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    21 |     if file_name[dot_pos] != 'txt' && file_name[dot_pos] != \"exe\" && file_name[dot_pos]\
    \ != 'dll' { return \"No\" }\n   |                                           \
    \                  ~~~~~\n\nerror: character literal may only contain one codepoint\n\
    \  --> /tmp/tmpy7a69nyp.rs:21:92\n   |\n21 |     if file_name[dot_pos] != 'txt'\
    \ && file_name[dot_pos] != 'exe' && file_name[dot_pos] != 'dll' { return \"No\"\
    \ }\n   |                                                                    \
    \                        ^^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n21 |     if file_name[dot_pos] != 'txt' && file_name[dot_pos]\
    \ != 'exe' && file_name[dot_pos] != \"dll\" { return \"No\" }\n   |          \
    \                                                                            \
    \      ~~~~~\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpy7a69nyp.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ { return \"No\" }\n   |     -- unexpected token\n\nerror[E0599]: no function\
    \ or associated item named `npos` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpy7a69nyp.rs:16:27\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\"\n    }\n    if file_name[dot_pos - 1] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 2] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 3] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 4] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 5] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 6] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 7] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 8] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 9] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 10] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 11] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 12] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 13] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 14] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 15] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 16] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 17] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 18] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 19] != String::from_char('0').unwrap()\
    \ {\n        return \"No\"\n    }\n    if file_name[dot_pos - 20] != String::from_char('0').unwrap()\
    \ {\n        return \"No\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmpz1t_as81.rs:83:40\n\
    \   |\n83 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n  --> /tmp/tmpz1t_as81.rs:96:56\n   |\n96 |\
    \     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n   |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n   --> /tmp/tmpz1t_as81.rs:107:63\n\
    \    |\n107 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n    |  _______________________________________________________________^\n\
    108 | | }\n    | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    let mut dot_pos_end = dot_pos;\n \
    \   let mut dot_pos_start = dot_pos;\n    let mut dot_pos_start2 = dot_pos;\n\
    \    let mut dot_pos_start3 = dot_pos;\n    let mut dot_pos_start4 = dot_pos;\n\
    \    let mut dot_pos_start5 = dot_pos;\n    let mut dot_pos_start6 = dot_pos;\n\
    \    let mut dot_pos_start7 = dot_pos;\n    let mut dot_pos_start8 = dot_pos;\n\
    \    let mut dot_pos_start9 = dot_pos;\n    let mut dot_pos_start10 = dot_pos;\n\
    \    let mut dot_pos_start11 = dot_pos;\n    let mut dot_pos_start12 = dot_pos;\n\
    \    let mut dot_pos_start13 = dot_pos;\n    let mut dot_pos_start14 = dot_pos;\n\
    \    let mut dot_pos_start15 = dot_pos;\n    let mut dot_pos_start16 = dot_pos;\n\
    \    let mut dot_pos_start17 = dot_pos;\n    let mut dot_pos_start18 = dot_pos;\n\
    \    let mut dot_pos_start19 = dot_pos;\n    let mut dot_pos_start20 = dot_pos;\n\
    \    let mut dot_pos_start21 = dot_pos;\n    let mut dot_pos_start22 = dot_pos;\n\
    \    let mut dot_pos_start23 = dot_pos;\n    let mut dot_pos_start24 = dot_pos;\n\
    \    let mut dot_pos_start25 = dot_pos;\n    let mut dot_pos_start26 = dot_pos;\n\
    \    let mut dot_pos_start27 = dot_pos;\n    let mut dot_pos_start28 = dot_pos;\n\
    \    let mut dot_pos_start29 = dot_pos;\n    let mut dot_pos_start30 = dot_pos;\n\
    \    let mut dot_pos_start31 = dot_pos;\n    let mut dot_pos_start32 = dot_pos;\n\
    \    let mut dot_pos_start33 = dot_pos;\n    let mut dot_pos_start34 = dot_pos;\n\
    \    let mut dot_pos_start35 = dot_pos;\n    let mut dot_pos_start36 = dot_pos;\n\
    \    let mut dot_pos_start37 = dot_pos;\n    let mut dot_pos_start38 = dot_pos;\n\
    \    let mut dot_pos_start39 = dot_pos;\n    let mut dot_pos_start40\n}\n\nfn\
    \ main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpibc8otg7.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpibc8otg7.rs:59:28\n\
    \   |\n59 |     let mut dot_pos_start40\n   |                            ^ help:\
    \ add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0599]: no function or\
    \ associated item named `npos` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpibc8otg7.rs:16:27\n   |\n16 |     if dot_pos == String::npos {\n\
    \   |                           ^^^^ function or associated item not found in\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpibc8otg7.rs:13:42\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name_len = file_name.len();\n    let mut\
    \ dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n        return\
    \ String::from(\"No\");\n    }\n    let mut dot_pos_2 = file_name.find('.')\n\
    \    if dot_pos_2 == String::npos {\n        return String::from(\"No\");\n  \
    \  }\n    if dot_pos == dot_pos_2 {\n        return String::from(\"No\");\n  \
    \  }\n    if dot_pos == 0 {\n        return String::from(\"No\");\n    }\n   \
    \ if dot_pos == file_name_len - 1 {\n        return String::from(\"No\");\n  \
    \  }\n    if file_name[dot_pos - 1] < 'a' || file_name[dot_pos - 1] > 'z' {\n\
    \        return String::from(\"No\");\n    }\n    if file_name[dot_pos + 1] <\
    \ 'a' || file_name[dot_pos + 1] > 'z' {\n        return String::from(\"No\");\n\
    \    }\n    if file_name[dot_pos + 2] < '0' || file_name[dot_pos + 2] > '9' {\n\
    \        return String::from(\"No\");\n    }\n    if file_name[dot_pos - 2] <\
    \ 'a' || file_name[dot_pos - 2] > 'z' {\n        return String::from(\"No\");\n\
    \    }\n    if file_name[dot_pos_2 - 2] < '0' || file_name[dot_pos_2 - 2] > '9'\
    \ {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos_2 -\
    \ 1] < 'a' || file_name[dot_pos_2 - 1] > 'z' {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos_2 - 2] < '0' || file_name[dot_pos_2 -\
    \ 2] > '9' {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos_2\
    \ - 3] < 'a' || file_name[dot_pos_2 - 3] > 'z' {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos_2 - 4] < '0' || file_name[dot_pos_2 -\
    \ 4] > '9' {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos_2\
    \ - 5] < 'a' || file_name[dot_pos_2 - 5] > 'z' {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos_2 - 6] < '0' || file_name[dot_pos_2 -\
    \ 6] > '9' {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos_2\
    \ - 7] < 'a' || file_name[dot_pos_2 - 7] > 'z' {\n        return String::from(\"\
    \n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected at least one digit in exponent\n  --> /tmp/tmpymqjiu_3.rs:72:40\n\
    \   |\n72 |     assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n   |                                        ^^^^^^^^\n\nerror: expected\
    \ at least one digit in exponent\n  --> /tmp/tmpymqjiu_3.rs:85:56\n   |\n85 |\
    \     assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"\
    No\"));\n   |                                                        ^^^^^\n\n\
    error[E0765]: unterminated double quote string\n  --> /tmp/tmpymqjiu_3.rs:96:63\n\
    \   |\n96 |       assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n   |  _______________________________________________________________^\n\
    97 | | }\n   | |__^\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return \"No\";\n    }\n    let mut dot_pos_end = dot_pos;\n    dot_pos_end\
    \ += 1;\n    while dot_pos_end < file_name.len() {\n        let mut dot_pos_start\
    \ = dot_pos;\n        dot_pos_start += 1;\n        if file_name[dot_pos_start]\
    \ != 'a' && file_name[dot_pos_start] != 'A' && file_name[dot_pos_start] != 'b'\
    \ && file_name[dot_pos_start] != 'B' && file_name[dot_pos_start] != 'c' && file_name[dot_pos_start]\
    \ != 'C' && file_name[dot_pos_start] != 'd' && file_name[dot_pos_start] != 'D'\
    \ && file_name[dot_pos_start] != 'e' && file_name[dot_pos_start] != 'E' && file_name[dot_pos_start]\
    \ != 'f' && file_name[dot_pos_start] != 'F' && file_name[dot_pos_start] != 'g'\
    \ && file_name[dot_pos_start] != 'G' && file_name[dot_pos_start] != 'h' && file_name[dot_pos_start]\
    \ != 'H' && file_name[dot_pos_start] != 'i' && file_name[dot_pos_start] != 'I'\
    \ && file_name[dot_pos_start] != 'j' && file_name[dot_pos_start] != 'J' && file_name[dot_pos_start]\
    \ != 'k' && file_name[dot_pos_start] != 'K' && file_name[dot_pos_start] != 'l'\
    \ && file_name[dot_pos_start] != 'L' && file_name[dot_pos_start] != 'm' && file_name[dot_pos_start]\
    \ != 'M' && file_name[dot_pos_start] != 'n' && file_name[dot_pos_start] != 'N'\
    \ && file_name[dot_pos_start] != 'o' && file_name[dot_pos_start] != 'O' && file_name[dot_pos_start]\
    \ != 'p' && file_name[dot_pos_start] != 'P' && file_name[dot_pos_start] != 'q'\
    \ && file_name[dot_pos_start] != 'Q' && file_name[dot_pos_start] != 'r' && file_name[dot_pos_start]\
    \ != 'R' && file_name[dot_pos_start] != 's' && file_name[dot_pos_start] != 'S'\
    \ && file_name[dot_pos_start] != 't' && file_name[dot_pos_start] != 'T' && file_name[dot_pos_start]\
    \ != 'u' && file_name[dot_pos_start] != 'U' && file_name[dot_pos_start] != 'v'\
    \ && file_name[dot_pos_start] != 'V' && file_name[dot_pos_start] != 'w' && file_name[dot_pos_start]\
    \ != 'W' && file_name[dot_pos_start] != 'x' && file_name[dot_pos_start] != 'X\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1pch9ksx.rs:55:3\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n21 |     while\
    \ dot_pos_end < file_name.len() {\n   |                                      \
    \   - this delimiter might not be properly closed...\n...\n25 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n55 | }\n   |   ^\n\n\
    error: expected `;`, found keyword `if`\n  --> /tmp/tmp1pch9ksx.rs:15:42\n   |\n\
    15 |     let mut dot_pos = file_name.find('.')\n   |                         \
    \                 ^ help: add `;` here\n16 |     if dot_pos == String::npos {\n\
    \   |     -- unexpected token\n\nerror: expected `while`, `for`, `loop` or `{`\
    \ after a label\n  --> /tmp/tmp1pch9ksx.rs:25:1\n   |\n25 | }\n   | ^ expected\
    \ `while`, `for`, `loop` or `{` after a label\n\nerror: expected expression, found\
    \ `}`\n  --> /tmp/tmp1pch9ksx.rs:25:1\n   |\n25 | }\n   | ^ expected expression\n\
    \nerror[E0599]: no function or associated item named `npos` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp1pch9ksx.rs:16:27\n   |\n16 |     if dot_pos\
    \ == String::npos {\n   |                           ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1pch9ksx.rs:17:16\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n17 |         return \"No\";\n   |                ^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                |\n   |             \
    \   expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `Option<usize>`\n  --> /tmp/tmp1pch9ksx.rs:20:5\n\
    \   |\n20 |     dot_pos_end += 1;\n   |     -----------^^^^^\n   |     |\n   |\
    \     cannot use `+=` on type `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1pch9ksx.rs:21:25\n   |\n21 |     while dot_pos_end < file_name.len()\
    \ {\n   |                         ^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    if\
    \ file_name.len() > 3 {\n        return \"No\";\n    }\n    if file_name.contains(\"\
    .\") {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_lowercase())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_uppercase())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_digit())\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c.is_ascii_lowercase() || c.is_ascii_uppercase() || c.is_digit()) {\n   \
    \     return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c.is_ascii_lowercase() || c.is_ascii_uppercase() || c.is_digit() || c ==\
    \ '.') {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c.is_ascii_lowercase() || c.is_ascii_uppercase() || c.is_digit() || c ==\
    \ '.' || c == '_') {\n        return \"No\";\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_lowercase() || c.is_ascii_uppercase() ||\
    \ c.is_digit() || c == '.' || c == '_' || c == '-') {\n        return \"No\";\n\
    \    }\n    if file_name.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_lowercase()\
    \ || c.is_ascii_uppercase() || c.is_digit() || c == '.' || c == '_' || c == '-'\
    \ || c == '/') {\n        return \"No\";\n    }\n    if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_lowercase() || c.is_ascii_uppercase() ||\
    \ c.is_digit() || c == '.' || c == '_' || c == '-' || c == '/' || c == '\\\\')\
    \ {\n        return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c.is_ascii_lowercase() || c.is_ascii_uppercase() || c.is_digit() || c ==\
    \ '.' || c == '_' || c == '-' || c == '/' || c == '\\\\' || c == ':') {\n    \
    \    return \"No\";\n    }\n    if file_name.chars().any(|c| !c.is_ascii_letter()\
    \ || c.is_ascii_lowercase() || c.is_ascii_\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpkrzw_h42.rs:55:1\n   |\n\
    54 |     if file_name.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_lowercase()\
    \ || c.is_ascii_\n   |     -- this `if` expression has a condition, but no block\n\
    55 | }\n   | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpkrzw_h42.rs:54:29\n   |\n13 | fn file_name_check(file_name: String)\
    \ -> String {\n   |                                                 - closing\
    \ delimiter possibly meant for this\n...\n54 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_lowercase() || c.is_ascii_\n   |        \
    \                     ^ unclosed delimiter\n55 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkrzw_h42.rs:16:16\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n16 |         return \"No\";\n   |                ^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                |\n   |             \
    \   expected struct `String`, found `&str`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpkrzw_h42.rs:21:37\n\
    \   |\n21 |     if file_name.chars().any(|c| !c.is_ascii_letter()) {\n   |   \
    \                                  ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n   --> /tmp/tmpkrzw_h42.rs:30:37\n\
    \    |\n30  |     if file_name.chars().any(|c| !c.is_digit()) {\n    |       \
    \                              ^^^^^^^^- supplied 0 arguments\n    |         \
    \                            |\n    |                                     expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no\
    \ method named `is_ascii_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmpkrzw_h42.rs:33:37\n   |\n33 |     if file_name.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_lowercase() || c.is_ascii_uppercase()"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\n  \
    \      return String::from(\"No\");\n    }\n    if dot_index == 0 {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name.chars().count() > 3 {\n     \
    \   return String::from(\"No\");\n    }\n    if file_name[0..dot_index].chars().count()\
    \ > 1 {\n        return String::from(\"No\");\n    }\n    if file_name[dot_index..].chars().any(|c|\
    \ !c.is_ascii_letter()) {\n        return String::from(\"No\");\n    }\n    if\
    \ file_name[dot_index..].chars().any(|c| !c.is_ascii_letter() || c != 'a' && c\
    \ != 'z') {\n        return String::from(\"No\");\n    }\n    if file_name[dot_index..].chars().any(|c|\
    \ !c.is_ascii_letter() || c != 'A' && c != 'Z') {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_index..].chars().any(|c| !c.is_ascii_letter()\
    \ || c != '0' && c != '9') {\n        return String::from(\"No\");\n    }\n  \
    \  if file_name[dot_index..].chars().any(|c| !c.is_ascii_letter() || c != 'a'\
    \ && c != 'z' || c != 'A' && c != 'Z' || c != '0' && c != '9') {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name[dot_index..].chars().any(|c|\
    \ !c.is_ascii_letter() || c != 'a' && c != 'z' || c != 'A' && c != 'Z' || c !=\
    \ '0' && c != '9' || c != 'a' && c != 'z' || c != 'A' && c != 'Z' || c != '0'\
    \ && c != '9') {\n        return String::from(\"No\");\n    }\n    if file_name[dot_index..].chars().any(|c|\
    \ !c.is_ascii_letter() || c != 'a' && c != 'z' || c != 'A' && c != 'Z' || c !=\
    \ '0' && c != '9' || c != 'a' && c != 'z' || c != 'A' && c != 'Z' || c != '0'\
    \ && c != '9' || c != 'a' && c != 'z' || c != 'A' && c != 'Z' || c != '0' && c\
    \ != '9') {\n        return String::from(\"No\");\n    }\n    if file_name[dot_index..].chars().any(|c|\
    \ !c.is_ascii_letter() || c != 'a' && c != 'z' || c != '\n}\n\nfn main() {\n \
    \   let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpwxrjx52a.rs:49:100\n\
    \   |\n49 |     if file_name[dot_index..].chars().any(|c| !c.is_ascii_letter()\
    \ || c != 'a' && c != 'z' || c != '\n   |                                    \
    \                                                                ^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_index = file_name.find('.')\n    if dot_index == String::npos {\n  \
    \      return String::from(\"No\");\n    }\n    if dot_index > 0 {\n        dot_index\
    \ -= 1;\n    }\n    let mut first_letter = file_name[0];\n    if first_letter\
    \ < 'a' || first_letter > 'z' {\n        return String::from(\"No\");\n    }\n\
    \    if file_name.len() > 3 {\n        return String::from(\"No\");\n    }\n \
    \   if file_name[..dot_index].count() != 1 || file_name[dot_index..].count() !=\
    \ 3 {\n        return String::from(\"No\");\n    }\n    String::from(\"Yes\")\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpaus9m1go.rs:15:44\n\
    \   |\n15 |     let mut dot_index = file_name.find('.')\n   |                \
    \                            ^ help: add `;` here\n16 |     if dot_index == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpaus9m1go.rs:16:29\n\
    \   |\n16 |     if dot_index == String::npos {\n   |                         \
    \    ^^^^ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpaus9m1go.rs:19:20\n   |\n19 |     if dot_index > 0 {\n\
    \   |                    ^ expected enum `Option`, found integer\n   |\n   = note:\
    \ expected enum `Option<usize>`\n              found type `{integer}`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n19 |     if dot_index > Some(0) {\n\
    \   |                    +++++ +\n\nerror[E0368]: binary assignment operation\
    \ `-=` cannot be applied to type `Option<usize>`\n  --> /tmp/tmpaus9m1go.rs:20:9\n\
    \   |\n20 |         dot_index -= 1;\n   |         ---------^^^^^\n   |       \
    \  |\n   |         cannot use `-=` on type `Option<usize>`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpaus9m1go.rs:22:28\n\
    \   |\n22 |     let mut first_letter = file_name[0];\n   |                   \
    \         ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeTo<Option<usize>>`\n  --> /tmp/tmpaus9m1go.rs:29:8\n\
    \   |\n29 |     if file_name[..dot_index].count() != 1 || file_name[dot_index..]."
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos {\n      \
    \  return String::from(\"No\");\n    }\n    if dot_pos == 0 {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name[0..dot_pos - 1].is_empty() {\n\
    \        return String::from(\"No\");\n    }\n    if file_name[dot_pos - 1] ==\
    \ '.' {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos\
    \ - 1] >= 'a' && file_name[dot_pos - 1] <= 'z' {\n        return String::from(\"\
    No\");\n    }\n    if file_name[dot_pos - 1] >= 'A' && file_name[dot_pos - 1]\
    \ <= 'Z' {\n        return String::from(\"No\");\n    }\n    if file_name[dot_pos\
    \ - 1] >= '0' && file_name[dot_pos - 1] <= '9' {\n        return String::from(\"\
    Yes\");\n    }\n    return String::from(\"No\");\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpgifbb6vn.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ {\n   |     -- unexpected token\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpgifbb6vn.rs:16:27\n\
    \   |\n16 |     if dot_pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgifbb6vn.rs:19:19\n   |\n19 |     if dot_pos == 0 {\n \
    \  |                   ^ expected enum `Option`, found integer\n   |\n   = note:\
    \ expected enum `Option<usize>`\n              found type `{integer}`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n19 |     if dot_pos == Some(0) {\n\
    \   |                   +++++ +\n\nerror[E0369]: cannot subtract `{integer}` from\
    \ `Option<usize>`\n  --> /tmp/tmpgifbb6vn.rs:22:29\n   |\n22 |     if file_name[0..dot_pos\
    \ - 1].is_empty() {\n   |                     ------- ^ - {integer}\n   |    \
    \                 |\n   |                     Option<usize>\n\nerror[E0369]: cannot\
    \ subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpgifbb6vn.rs:25:26\n\
    \   |\n25 |     if file_name[dot_pos - 1] == '.' {\n   |                  -------\
    \ ^ - {integer}\n   |                  |\n   |                  Option<usize>\n\
    \nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpgifbb6vn.rs:28:26\n\
    \   |\n28 |     if file_name[dot_pos - 1] >= 'a' && file_name[dot_pos - 1] <=\
    \ 'z' {\n   |                  ------- ^ - {integer}\n   |                  |\n\
    \   |                  Option<usize>\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `Option<usize>`\n  --> /tmp/tmpgifbb6vn.rs:28:59\n   |\n28 |     if file_name[dot_pos\
    \ - 1] >= 'a' && file_name[dot_pos - 1] <= 'z' {\n   |                       \
    \                            ------- ^ - {integer}\n   |                     \
    \                              |\n   |                                       \
    \            Optio"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.to_string();\n    let\
    \ mut dot_pos = file_name.find('.')\n    if dot_pos == String::npos { \n     \
    \   return \"No\";\n    }\n    if file_name.len() > 3 {\n        return \"No\"\
    ;\n    }\n    if file_name.len() == 3 {\n        if file_name[0] < 'a' || file_name[0]\
    \ > 'z' {\n            return \"No\";\n        }\n    }\n    if file_name[dot_pos\
    \ - 1] != '.' {\n        return \"No\";\n    }\n    if file_name[dot_pos - 1]\
    \ != '.' && file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] != '.' {\n\
    \        return \"No\";\n    }\n    if file_name[dot_pos - 1] != '.' && file_name[dot_pos\
    \ - 1] != '.' && file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] != '.'\
    \ && file_name[dot_pos - 1] != '.' {\n        return \"No\";\n    }\n    if file_name[dot_pos\
    \ - 1] != '.' && file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] != '.'\
    \ && file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] != '.' && file_name[dot_pos\
    \ - 1] != '.' && file_name[dot_pos - 1] != '.' {\n        return \"No\";\n   \
    \ }\n    if file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] != '.' &&\
    \ file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] != '.' && file_name[dot_pos\
    \ - 1] != '.' && file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] != '.'\
    \ && file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] != '.' {\n      \
    \  return \"No\";\n    }\n    if file_name[dot_pos - 1] != '.' && file_name[dot_pos\
    \ - 1] != '.' && file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] != '.'\
    \ && file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] != '.' && file_name[dot_pos\
    \ - 1] != '.' && file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] != '.'\
    \ && file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] != '.' && file_name[dot_pos\
    \ - 1] != '.' && file_name[dot_pos - 1] != '.' {\n        return \"No\";\n   \
    \ }\n    if file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] != '.' &&\
    \ file_name[dot_pos - 1] != '.' && file_name[dot_pos - 1] != '.' && \n}\n\nfn\
    \ main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp4yexy0wp.rs:15:42\n\
    \   |\n15 |     let mut dot_pos = file_name.find('.')\n   |                  \
    \                        ^ help: add `;` here\n16 |     if dot_pos == String::npos\
    \ { \n   |     -- unexpected token\n\nerror: expected expression, found `}`\n\
    \  --> /tmp/tmp4yexy0wp.rs:46:1\n   |\n46 | }\n   | ^ expected expression\n\n\
    error[E0599]: no function or associated item named `npos` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp4yexy0wp.rs:16:27\n   |\n16 |     if dot_pos\
    \ == String::npos { \n   |                           ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4yexy0wp.rs:17:16\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n17 |         return \"No\";\n   |                ^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                |\n   |             \
    \   expected struct `String`, found `&str`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmp4yexy0wp.rs:23:12\n   |\n23\
    \ |         if file_name[0] < 'a' || file_name[0] > 'z' {\n   |            ^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp4yexy0wp.rs:23:34\n   |\n23 |         if file_name[0] < 'a' ||\
    \ file_name[0] > 'z' {\n   |                                  ^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integ"
  exit_code: 1
  status: SyntaxError
