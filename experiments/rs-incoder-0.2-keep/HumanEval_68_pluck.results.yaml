name: HumanEval_68_pluck
language: rust
results:
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for &i in even_values {\n        if i < smallest_even_value {\n  \
    \          smallest_even_value = i;\n            smallest_even_index = i;\n  \
    \      }\n    }\n    even_values.remove(&smallest_even_value);\n    even_values.remove(&smallest_even_index);\n\
    \    even_values.sort();\n    let mut result = vec![];\n    for &i in even_values\
    \ {\n        result.push(i);\n    }\n    result.push(smallest_value);\n    result.push(smallest_index);\n\
    \    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu9pkb10_.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu9pkb10_.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu9pkb10_.rs:50:24\n   |\n50 |     even_values.remove(&smallest_even_value);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpu9pkb10_.rs:51:24\n   |\n51 |\
    \     even_values.remove(&smallest_even_index);\n   |                        ^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu9pkb10_.rs:54:9\n\
    \   |\n54 |     for &i in even_values {\n   |         ^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx2\
    \ = 0;\n    let mut min_idx3 = 0;\n    let mut min_idx4 = 0;\n    let mut min_idx5\
    \ = 0;\n    let mut min_idx6 = 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8\
    \ = 0;\n    let mut min_idx9 = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11\
    \ = 0;\n    let mut min_idx12 = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14\
    \ = 0;\n    let mut min_idx15 = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17\
    \ = 0;\n    let mut min_idx18 = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20\
    \ = 0;\n    let mut min_idx21 = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23\
    \ = 0;\n    let mut min_idx24 = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26\
    \ = 0;\n    let mut min_idx27 = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29\
    \ = 0;\n    let mut min_idx30 = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32\
    \ = 0;\n    let mut min_idx33 = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35\
    \ = 0;\n    let mut min_idx36 = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38\
    \ = 0;\n    let mut min_idx39 = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41\
    \ = 0;\n    let mut min_idx42 = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44\
    \ = 0;\n    let mut min_idx45 = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47\
    \ = 0;\n    let mut min_idx48 = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50\
    \ = 0;\n    let mut min_idx51 = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53\
    \ = 0;\n    let mut min_idx54 = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56\
    \ = 0;\n    let mut min_idx57 = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59\
    \ = 0;\n    let mut min_idx60 = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62\
    \ = 0;\n    let mut min_idx63 = 0;\n    let mut min_idx\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv4d59zt3.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv4d59zt3.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for &i in even_values {\n        if i < smallest_even_value {\n  \
    \          smallest_even_value = i;\n            smallest_even_index = i;\n  \
    \      }\n    }\n    even_values.remove(&mut smallest_even_index);\n    even_values.sort();\n\
    \    even_values.insert(0, smallest_even_value);\n    even_values\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplve17ugy.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplve17ugy.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplve17ugy.rs:50:24\n   |\n50 |     even_values.remove(&mut smallest_even_index);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `&mut isize`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::i32::MAX;\n    let mut min_even_index = 0;\n    let\
    \ mut min_even_value = std::i32::MAX;\n    for &i in arr {\n        if i % 2 ==\
    \ 0 {\n            if min_even_value < i {\n                min_even_value = i;\n\
    \                min_even_index = i;\n            }\n        }\n    }\n    let\
    \ mut result = vec![];\n    if min_even_value == std::i32::MAX {\n        return\
    \ result;\n    }\n    for i in arr {\n        if i % 2 == 0 {\n            if\
    \ min_even_value == i {\n                result.push(min_even_index);\n      \
    \      }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp01_4rgl8.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp01_4rgl8.rs:44:34\n   |\n44 |             if min_even_value ==\
    \ i {\n   |                                  ^ expected `i32`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n44 |             if min_even_value == i.try_into().unwrap()\
    \ {\n   |                                   ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp01_4rgl8.rs:45:29\n   |\n45 |              \
    \   result.push(min_even_index);\n   |                             ^^^^^^^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n45 |                 result.push(min_even_index.try_into().unwrap());\n\
    \   |                                           ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2 ==\
    \ 0 {\n            even_values.push(i);\n            if i < smallest_value {\n\
    \                smallest_value = i;\n                smallest_index = i;\n  \
    \          }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = 0;\n    for i in even_values.iter() {\n        if i %\
    \ 2 == 0 {\n            if i < smallest_even_value {\n                smallest_even_value\
    \ = i;\n                smallest_even_index = i;\n            }\n        }\n \
    \   }\n    let mut result = vec![];\n    for i in arr.iter() {\n        if i ==\
    \ smallest_value {\n            result.push(smallest_even_index);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdogyh0pb.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpdogyh0pb.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdogyh0pb.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpdogyh0pb.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdogyh0pb.rs:46:20\n   |\n\
    46 |             if i < smallest_even_value {\n   |                    ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdogyh0pb.rs:48:39\n   |\n43 |     let mut smallest_even_index = 0;\n\
    \   |                                   - expected due to this value\n...\n48\
    \ |                 smallest_even_index = i;\n   |                           \
    \            ^ expected integer, found `&&isize`\n   |\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![0; arr.len()];\n    let mut min_value = arr[0];\n\
    \    let mut min_value_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values[i] = arr[i];\n            if arr[i] < min_value\
    \ {\n                min_value = arr[i];\n                min_value_index = i;\n\
    \            }\n        }\n    }\n    if min_value_index == -1 {\n        return\
    \ vec![];\n    }\n    let mut result = vec![];\n    for i in 0..arr.len() {\n\
    \        if even_values[i] == min_value {\n            result.push(i);\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpeuemax8y.rs:29:31\n\
    \   |\n29 |     let mut min_value_index = -1;\n   |                          \
    \     ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpeuemax8y.rs:39:27\n\
    \   |\n39 |     if min_value_index == -1 {\n   |                           ^^\n\
    \   |                           |\n   |                           cannot apply\
    \ unary operator `-`\n   |                           help: you may have meant\
    \ the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values\
    \ cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeuemax8y.rs:48:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n48\
    \ |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0600.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_value = arr[0];\n    let mut\
    \ min_index = -1;\n    for &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < min_value {\n                min_value = i;\n            \
    \    min_index = i;\n            }\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut smallest_value = even_values[0];\n\
    \    let mut smallest_index = -1;\n    for &i in even_values {\n        if i <\
    \ smallest_value {\n            smallest_value = i;\n            smallest_index\
    \ = i;\n        }\n    }\n    let mut result = vec![];\n    if min_index == -1\
    \ {\n        return vec![];\n    }\n    for i in 0..arr.len() {\n        if i\
    \ != min_index {\n            result.push(i);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp5nmkicm.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp5nmkicm.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp5nmkicm.rs:55:17\n   |\n55 |         if i != min_index {\n   |\
    \                 ^^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n55 |         if i != min_index.try_into().unwrap() {\n   |            \
    \              ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp5nmkicm.rs:59:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n59\
    \ |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2 ==\
    \ 0 {\n            even_values.push(i);\n            if i < smallest_value {\n\
    \                smallest_value = i;\n                smallest_index = i;\n  \
    \          }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = 0;\n    for i in even_values.iter() {\n        if i %\
    \ 2 == 0 {\n            if i < smallest_even_value {\n                smallest_even_value\
    \ = i;\n                smallest_even_index = i;\n            }\n        }\n \
    \   }\n    vec![smallest_value, smallest_even_index]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2v1x_rmd.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2v1x_rmd.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2v1x_rmd.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmp2v1x_rmd.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2v1x_rmd.rs:46:20\n   |\n\
    46 |             if i < smallest_even_value {\n   |                    ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2v1x_rmd.rs:48:39\n   |\n43 |     let mut smallest_even_index = 0;\n\
    \   |                                   - expected due to this value\n...\n48\
    \ |                 smallest_even_index = i;\n   |                           \
    \            ^ expected integer, found `&&isize`\n   |\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = -1;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if min_value == i {\n              \
    \  min_idx = i;\n            }\n        } else {\n            if min_value < i\
    \ {\n                min_value = i;\n                min_idx = i;\n          \
    \  }\n        }\n    }\n    if min_idx == -1 {\n        return vec![];\n    }\n\
    \    let mut result = vec![];\n    for i in 0..arr.len() {\n        if i == min_idx\
    \ {\n            result.push(min_value);\n        } else {\n            result.push(i);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqajuck3a.rs:31:29\n   |\n\
    31 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpqajuck3a.rs:32:27\n   |\n28 |  \
    \   let mut min_idx = -1;\n   |                       -- expected due to this\
    \ value\n...\n32 |                 min_idx = i;\n   |                        \
    \   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n32 |                 min_idx = *i;\n   |                     \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqajuck3a.rs:35:28\n\
    \   |\n35 |             if min_value < i {\n   |                            ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n35 |             if min_value < *i {\n   |                            +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqajuck3a.rs:36:29\n   |\n27 |\
    \     let mut min_value = arr[0];\n   |                         ------ expected\
    \ due to this value\n...\n36 |                 min_value = i;\n   |          \
    \                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n36 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqajuck3a.rs:37:27\n\
    \   |\n28 |     let mut min_idx = -1;\n   |                       -- expected\
    \ due to this value\n...\n37 |                 min_idx = i;\n   |            \
    \               ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n37 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpqajuck3a.rs:28:23\n   |\n28 |     let mut min_idx = -1;\n   | \
    \                      ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![0; arr.len()];\n    let mut min_value = arr[0];\n\
    \    let mut min_value_index = 0;\n    let mut min_value_even_value = 0;\n   \
    \ let mut min_value_even_value_index = 0;\n    for i in 0..arr.len() {\n     \
    \   if arr[i] % 2 == 0 {\n            even_values[i] = arr[i];\n            if\
    \ even_values[i] < min_value {\n                min_value = even_values[i];\n\
    \                min_value_index = i;\n                min_value_even_value =\
    \ even_values[i];\n                min_value_even_value_index = i;\n         \
    \   }\n        } else {\n            if even_values[min_value_even_value_index]\
    \ < min_value {\n                min_value = even_values[min_value_even_value_index];\n\
    \                min_value_index = min_value_even_value_index;\n             \
    \   min_value_even_value = even_values[min_value_even_value_index];\n        \
    \        min_value_even_value_index = min_value_even_value_index;\n          \
    \  }\n        }\n    }\n    if min_value_even_value_index == min_value_index {\n\
    \        return vec![];\n    }\n    let mut result = vec![min_value];\n    for\
    \ i in 0..min_value_index {\n        result.push(i);\n    }\n    for i in min_value_index..arr.len()\
    \ {\n        if arr[i] % 2 == 0 {\n            result.push(i);\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj5zkhfpn.rs:55:21\n   |\n\
    55 |         result.push(i);\n   |                     ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n55 |         result.push(i.try_into().unwrap());\n\
    \   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpj5zkhfpn.rs:59:25\n   |\n59 |             result.push(i);\n   |\
    \                         ^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n59 |             result.push(i.try_into().unwrap());\n   |            \
    \              ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = -1;\n    for i in 0..arr.len()\
    \ {\n        if arr[i] < min_value {\n            min_value = arr[i];\n      \
    \      min_idx = i;\n        }\n    }\n    let mut result = vec![min_value, min_idx];\n\
    \    for i in 1..arr.len() {\n        if arr[i] < min_value {\n            result.swap(0,\
    \ i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpsgt9gqh1.rs:28:23\n\
    \   |\n28 |     let mut min_idx = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsgt9gqh1.rs:35:38\n   |\n35 |     let mut result = vec![min_value,\
    \ min_idx];\n   |                                      ^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_value = arr[0];\n    let mut smallest_index = 0;\n    let\
    \ mut even_values = false;\n    for &i in arr {\n        if i % 2 == 0 {\n   \
    \         even_values = true;\n        }\n        if i == smallest_value {\n \
    \           smallest_index = i;\n        }\n        if even_values {\n       \
    \     if i < smallest_value {\n                smallest_value = i;\n         \
    \       smallest_index = i;\n            }\n        }\n    }\n    vec![smallest_value,\
    \ smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuxkjug8b.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    for &i in arr\
    \ {\n        if i % 2 == 0 {\n            if min_value < i {\n               \
    \ min_value = i;\n                min_idx = i;\n            }\n        }\n   \
    \ }\n    let mut result = vec![min_value, min_idx];\n    for &i in arr {\n   \
    \     if i % 2 == 0 {\n            if min_value == i {\n                result.push(min_idx);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0xznnei2.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0xznnei2.rs:38:9\n   |\n38 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut smallest_even_value = 0;\n    for\
    \ &value in arr {\n        if value % 2 == 0 {\n            even_values.push(value);\n\
    \        }\n        if value < smallest_value {\n            smallest_value =\
    \ value;\n            smallest_index = arr.iter().position(|&x| x == smallest_value);\n\
    \        }\n        if value == smallest_value {\n            smallest_even_value\
    \ = value;\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    if even_values.len() == 1 {\n        return vec![smallest_even_value];\n\
    \    }\n    if even_values.len() == 2 {\n        if even_values[0] < even_values[1]\
    \ {\n            return vec![smallest_even_value];\n        }\n        return\
    \ vec![smallest_even_value];\n    }\n    if even_values.len() == 3 {\n       \
    \ if even_values[0] < even_values[1] {\n            if even_values[0] < even_values[2]\
    \ {\n                return vec![smallest_even_value];\n            }\n      \
    \      return vec![smallest_even_value];\n        }\n        if even_values[1]\
    \ < even_values[2] {\n            return vec![smallest_even_value];\n        }\n\
    \        return vec![smallest_even_value];\n    }\n    if even_values.len() ==\
    \ 4 {\n        if even_values[0] < even_values[1] {\n            if even_values[0]\
    \ < even_values[2] {\n                if even_values[0] < even_values[3] {\n \
    \                   return vec![smallest_even_value];\n                }\n   \
    \             return vec![smallest_even_value];\n            }\n            if\
    \ even_values[1] < even_values[3] {\n                return vec![smallest_even_value];\n\
    \            }\n            return vec![smallest_even_value];\n        }\n   \
    \     if even_values[1] < even_values[2] {\n            if even_values[1] < even_values[3]\
    \ {\n                return vec![smallest_even_value];\n            }\n      \
    \      return vec![smallest_even_value];\n        }\n        if even_values[2]\
    \ < even_values[3] {\n            return vec![smallest_even_value];\n        }\n\
    \        return vec![smallest_even_value];\n    }\n    if even_values.len() ==\
    \ 5 {\n        if even_values[0] < even_values[1] {\n            if even_values[0]\
    \ < even_values[2] {\n                if even_values[0] < even_values[3] {\n \
    \                   if even_values[0] < even_values[4] {\n                   \
    \     return vec![smallest_even_value];\n                    }\n             \
    \       return vec![smallest_even_value];\n                }\n               \
    \ if even_values[1] < \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpa5t0ktbc.rs:113:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n91  |     if even_values.len()\
    \ == 5 {\n    |                               - unclosed delimiter\n92  |    \
    \     if even_values[0] < even_values[1] {\n    |                            \
    \                - unclosed delimiter\n93  |             if even_values[0] < even_values[2]\
    \ {\n    |                                                - this delimiter might\
    \ not be properly closed...\n...\n101 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n113 | }\n    |   ^\n\nerror: expected expression,\
    \ found `}`\n   --> /tmp/tmpa5t0ktbc.rs:101:1\n    |\n101 | }\n    | ^ expected\
    \ expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa5t0ktbc.rs:31:9\n\
    \   |\n31 |     for &value in arr {\n   |         ^^^^^^    --- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `value`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpa5t0ktbc.rs:37:30\n   |\n29 |  \
    \   let mut smallest_index = 0;\n   |                              - expected\
    \ due to this value\n...\n37 |             smallest_index = arr.iter().position(|&x|\
    \ x == smallest_value);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \   --> /tmp/tmpa5t0ktbc.rs:92:44\n    |\n92  |           if even_values[0] <\
    \ even_values[1] {\n    |  ____________________________________________^\n93 \
    \ | |             if even_values[0] < even_values[2] {\n94  | |              \
    \   if even_values[0] < even_values[3] {\n95  | |                     if even_values[0]\
    \ < even_values[4] {\n...   |\n112 | |     assert_eq!(candidate(vec![7, 9, 7,\
    \ 1]), Vec::<isize>"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![0; arr.len()];\n    let mut smallest_value = vec![0;\
    \ arr.len()];\n    let mut smallest_index = vec![0; arr.len()];\n    for i in\
    \ 0..arr.len() {\n        if arr[i] % 2 == 0 {\n            even_values[i] = arr[i];\n\
    \            smallest_value[i] = arr[i];\n            smallest_index[i] = i;\n\
    \        } else {\n            if even_values[i] < arr[i] {\n                even_values[i]\
    \ = arr[i];\n                smallest_value[i] = arr[i];\n                smallest_index[i]\
    \ = i;\n            }\n        }\n    }\n    if even_values.iter().any(|&x| x\
    \ == 0) {\n        return vec![];\n    }\n    let mut smallest_value_iter = smallest_value.iter();\n\
    \    let mut smallest_index_iter = smallest_index.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp97cjrtc9.rs:26:30\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----                \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values.push(i);\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    even_values.sort();\n    let mut\
    \ result = vec![];\n    for i in even_values {\n        let mut index = i;\n \
    \       while index > 0 {\n            if arr[index] % 2 == 0 {\n            \
    \    result.push(i);\n                break;\n            }\n            index\
    \ -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9bumj0ba.rs:51:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n51 |     result\n\
    \   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.is_empty() {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for &i in even_values {\n        if i < smallest_even_value {\n  \
    \          smallest_even_value = i;\n            smallest_even_index = i;\n  \
    \      }\n    }\n    let mut result = vec![];\n    if smallest_even_index == 0\
    \ {\n        result.push(smallest_value);\n        result.push(smallest_index);\n\
    \    } else {\n        result.push(smallest_even_value);\n        result.push(smallest_even_index);\n\
    \    }\n    return result;\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpimml2mfg.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpimml2mfg.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut smallest_index2 = 0;\n    let mut\
    \ smallest_index3 = 0;\n    let mut smallest_index4 = 0;\n    let mut smallest_index5\
    \ = 0;\n    let mut smallest_index6 = 0;\n    let mut smallest_index7 = 0;\n \
    \   let mut smallest_index8 = 0;\n    let mut smallest_index9 = 0;\n    let mut\
    \ smallest_index10 = 0;\n    let mut smallest_index11 = 0;\n    let mut smallest_index12\
    \ = 0;\n    let mut smallest_index13 = 0;\n    let mut smallest_index14 = 0;\n\
    \    let mut smallest_index15 = 0;\n    let mut smallest_index16 = 0;\n    let\
    \ mut smallest_index17 = 0;\n    let mut smallest_index18 = 0;\n    let mut smallest_index19\
    \ = 0;\n    let mut smallest_index20 = 0;\n    let mut smallest_index21 = 0;\n\
    \    let mut smallest_index22 = 0;\n    let mut smallest_index23 = 0;\n    let\
    \ mut smallest_index24 = 0;\n    let mut smallest_index25 = 0;\n    let mut smallest_index26\
    \ = 0;\n    let mut smallest_index27 = 0;\n    let mut smallest_index28 = 0;\n\
    \    let mut smallest_index29 = 0;\n    let mut smallest_index30 = 0;\n    let\
    \ mut smallest_index31 = 0;\n    let mut smallest_index32 = 0;\n    let mut smallest_index33\
    \ = 0;\n    let mut smallest_index34 = 0;\n    let mut smallest_index35 = 0;\n\
    \    let mut smallest_index36 = 0;\n    let mut smallest_index37 = 0;\n    let\
    \ mut smallest_index38 = 0;\n    let mut smallest_index39 = 0;\n    let mut smallest_index40\
    \ = 0;\n    let mut smallest_index41 = 0;\n    let mut smallest_index42 = 0;\n\
    \    let mut smallest_index43 = 0;\n    let mut smallest_index44 = 0;\n    let\
    \ mut smallest_index45 = 0;\n    let mut smallest_index46 = 0;\n    let mut smallest_index47\
    \ = 0;\n    let mut smallest_index48 = 0;\n    let mut smallest_index49 = 0;\n\
    \    let mut smallest_index50 = 0;\n    let mut smallest_index51 = 0;\n    let\
    \ mut smallest_index52 = 0;\n    let mut smallest_index53 = 0;\n    let mut smallest_index54\
    \ = 0;\n    let mut smallest_index55 = 0;\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa9d1o886.rs:84:11\n   |\n\
    84 |     let mu\n   |           ^ help: add `;` here\n85 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa9d1o886.rs:26:30\n \
    \  |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----          \
    \           ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_val = arr[0];\n    let mut min_idx = 1;\n    let mut min_idx2\
    \ = 1;\n    let mut min_idx3 = 1;\n    let mut min_idx4 = 1;\n    let mut min_idx5\
    \ = 1;\n    let mut min_idx6 = 1;\n    let mut min_idx7 = 1;\n    let mut min_idx8\
    \ = 1;\n    let mut min_idx9 = 1;\n    let mut min_idx10 = 1;\n    let mut min_idx11\
    \ = 1;\n    let mut min_idx12 = 1;\n    let mut min_idx13 = 1;\n    let mut min_idx14\
    \ = 1;\n    let mut min_idx15 = 1;\n    let mut min_idx16 = 1;\n    let mut min_idx17\
    \ = 1;\n    let mut min_idx18 = 1;\n    let mut min_idx19 = 1;\n    let mut min_idx20\
    \ = 1;\n    let mut min_idx21 = 1;\n    let mut min_idx22 = 1;\n    let mut min_idx23\
    \ = 1;\n    let mut min_idx24 = 1;\n    let mut min_idx25 = 1;\n    let mut min_idx26\
    \ = 1;\n    let mut min_idx27 = 1;\n    let mut min_idx28 = 1;\n    let mut min_idx29\
    \ = 1;\n    let mut min_idx30 = 1;\n    let mut min_idx31 = 1;\n    let mut min_idx32\
    \ = 1;\n    let mut min_idx33 = 1;\n    let mut min_idx34 = 1;\n    let mut min_idx35\
    \ = 1;\n    let mut min_idx36 = 1;\n    let mut min_idx37 = 1;\n    let mut min_idx38\
    \ = 1;\n    let mut min_idx39 = 1;\n    let mut min_idx40 = 1;\n    let mut min_idx41\
    \ = 1;\n    let mut min_idx42 = 1;\n    let mut min_idx43 = 1;\n    let mut min_idx44\
    \ = 1;\n    let mut min_idx45 = 1;\n    let mut min_idx46 = 1;\n    let mut min_idx47\
    \ = 1;\n    let mut min_idx48 = 1;\n    let mut min_idx49 = 1;\n    let mut min_idx50\
    \ = 1;\n    let mut min_idx51 = 1;\n    let mut min_idx52 = 1;\n    let mut min_idx53\
    \ = 1;\n    let mut min_idx54 = 1;\n    let mut min_idx55 = 1;\n    let mut min_idx56\
    \ = 1;\n    let mut min_idx57 = 1;\n    let mut min_idx58 = 1;\n    let mut min_idx59\
    \ = 1;\n    let mut min_idx60 = 1;\n    let mut min_idx61 = 1;\n    let mut min_idx62\
    \ = 1;\n    let mut min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuaaebvpf.rs:90:20\n   |\n\
    90 |     let mut min_idx\n   |                    ^ help: add `;` here\n91 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuaaebvpf.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx2\
    \ = -1;\n    let mut min_idx3 = -1;\n    let mut min_idx4 = -1;\n    let mut min_idx5\
    \ = -1;\n    let mut min_idx6 = -1;\n    let mut min_idx7 = -1;\n    let mut min_idx8\
    \ = -1;\n    let mut min_idx9 = -1;\n    let mut min_idx10 = -1;\n    let mut\
    \ min_idx11 = -1;\n    let mut min_idx12 = -1;\n    let mut min_idx13 = -1;\n\
    \    let mut min_idx14 = -1;\n    let mut min_idx15 = -1;\n    let mut min_idx16\
    \ = -1;\n    let mut min_idx17 = -1;\n    let mut min_idx18 = -1;\n    let mut\
    \ min_idx19 = -1;\n    let mut min_idx20 = -1;\n    let mut min_idx21 = -1;\n\
    \    let mut min_idx22 = -1;\n    let mut min_idx23 = -1;\n    let mut min_idx24\
    \ = -1;\n    let mut min_idx25 = -1;\n    let mut min_idx26 = -1;\n    let mut\
    \ min_idx27 = -1;\n    let mut min_idx28 = -1;\n    let mut min_idx29 = -1;\n\
    \    let mut min_idx30 = -1;\n    let mut min_idx31 = -1;\n    let mut min_idx32\
    \ = -1;\n    let mut min_idx33 = -1;\n    let mut min_idx34 = -1;\n    let mut\
    \ min_idx35 = -1;\n    let mut min_idx36 = -1;\n    let mut min_idx37 = -1;\n\
    \    let mut min_idx38 = -1;\n    let mut min_idx39 = -1;\n    let mut min_idx40\
    \ = -1;\n    let mut min_idx41 = -1;\n    let mut min_idx42 = -1;\n    let mut\
    \ min_idx43 = -1;\n    let mut min_idx44 = -1;\n    let mut min_idx45 = -1;\n\
    \    let mut min_idx46 = -1;\n    let mut min_idx47 = -1;\n    let mut min_idx48\
    \ = -1;\n    let mut min_idx49 = -1;\n    let mut min_idx50 = -1;\n    let mut\
    \ min_idx51 = -1;\n    let mut min_idx52 = -1;\n    let mut min_idx53 = -1;\n\
    \    let mut min_idx54 = -1;\n    let mut min_idx55 = -1;\n    let mut min_idx56\
    \ = -1;\n    let mut min_idx57 = -1;\n    let mut min_\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8icgb_8r.rs:85:17\n   |\n\
    85 |     let mut min_\n   |                 ^ help: add `;` here\n86 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8icgb_8r.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx\
    \ = arr.iter().min_by_key(|x| {\n        if x % 2 == 0 {\n            min_value\
    \ = x;\n            min_idx = x;\n            true\n        } else {\n       \
    \     false\n        }\n    });\n    min_idx\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpgtfno2t1.rs:30:14\n\
    \   |\n30 |         if x % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `x`\n   |\n30 |         if *x % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgtfno2t1.rs:31:25\n   |\n\
    27 |     let mut min_value = arr[0];\n   |                         ------ expected\
    \ due to this value\n...\n31 |             min_value = x;\n   |              \
    \           ^ expected `isize`, found `&&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n31 |             min_value = **x;\n   |                  \
    \       ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgtfno2t1.rs:32:23\n\
    \   |\n28 |     let mut min_idx = 0;\n   |                       - expected due\
    \ to this value\n...\n32 |             min_idx = x;\n   |                    \
    \   ^ expected integer, found `&&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n32 |             min_idx = **x;\n   |                       ++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgtfno2t1.rs:38:5\n   |\n26 | fn\
    \ pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n38 |     min_idx\n   |  \
    \   ^^^^^^^ expected struct `Vec`, found enum `Option`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n                found enum `Option<&isize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even_value = arr[0];\n    let mut smallest_even_index =\
    \ -1;\n    let mut smallest_even_indexes = Vec::new();\n    for &i in arr {\n\
    \        if i % 2 == 0 {\n            if smallest_even_value == i {\n        \
    \        smallest_even_indexes.push(smallest_even_index);\n                smallest_even_index\
    \ = i;\n            } else {\n                smallest_even_index = i;\n     \
    \       }\n        }\n    }\n    smallest_even_indexes.push(smallest_even_index);\n\
    \    smallest_even_indexes\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz8yo5n67.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values.push(arr[i]);\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = 0;\n    for i in 0..even_values.len() {\n \
    \       if even_values[i] < smallest_even_value {\n            smallest_even_value\
    \ = even_values[i];\n            smallest_even_index = i;\n        }\n    }\n\
    \    let mut result = vec![];\n    for i in 0..even_values.len() {\n        if\
    \ i == smallest_even_index {\n            result.push(smallest_value);\n     \
    \   } else {\n            result.push(even_values[i]);\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2]`,\n right: `[2, 1]`', /tmp/tmp8iaeymue.rs:63:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 1;\n    let mut min_idx2\
    \ = 1;\n    let mut min_idx3 = 1;\n    let mut min_idx4 = 1;\n    let mut min_idx5\
    \ = 1;\n    let mut min_idx6 = 1;\n    let mut min_idx7 = 1;\n    let mut min_idx8\
    \ = 1;\n    let mut min_idx9 = 1;\n    let mut min_idx10 = 1;\n    let mut min_idx11\
    \ = 1;\n    let mut min_idx12 = 1;\n    let mut min_idx13 = 1;\n    let mut min_idx14\
    \ = 1;\n    let mut min_idx15 = 1;\n    let mut min_idx16 = 1;\n    let mut min_idx17\
    \ = 1;\n    let mut min_idx18 = 1;\n    let mut min_idx19 = 1;\n    let mut min_idx20\
    \ = 1;\n    let mut min_idx21 = 1;\n    let mut min_idx22 = 1;\n    let mut min_idx23\
    \ = 1;\n    let mut min_idx24 = 1;\n    let mut min_idx25 = 1;\n    let mut min_idx26\
    \ = 1;\n    let mut min_idx27 = 1;\n    let mut min_idx28 = 1;\n    let mut min_idx29\
    \ = 1;\n    let mut min_idx30 = 1;\n    let mut min_idx31 = 1;\n    let mut min_idx32\
    \ = 1;\n    let mut min_idx33 = 1;\n    let mut min_idx34 = 1;\n    let mut min_idx35\
    \ = 1;\n    let mut min_idx36 = 1;\n    let mut min_idx37 = 1;\n    let mut min_idx38\
    \ = 1;\n    let mut min_idx39 = 1;\n    let mut min_idx40 = 1;\n    let mut min_idx41\
    \ = 1;\n    let mut min_idx42 = 1;\n    let mut min_idx43 = 1;\n    let mut min_idx44\
    \ = 1;\n    let mut min_idx45 = 1;\n    let mut min_idx46 = 1;\n    let mut min_idx47\
    \ = 1;\n    let mut min_idx48 = 1;\n    let mut min_idx49 = 1;\n    let mut min_idx50\
    \ = 1;\n    let mut min_idx51 = 1;\n    let mut min_idx52 = 1;\n    let mut min_idx53\
    \ = 1;\n    let mut min_idx54 = 1;\n    let mut min_idx55 = 1;\n    let mut min_idx56\
    \ = 1;\n    let mut min_idx57 = 1;\n    let mut min_idx58 = 1;\n    let mut min_idx59\
    \ = 1;\n    let mut min_idx60 = 1;\n    let mut min_idx61 = 1;\n    let mut min_idx62\
    \ = 1;\n    let mut min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9l2nyyig.rs:90:20\n   |\n\
    90 |     let mut min_idx\n   |                    ^ help: add `;` here\n91 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9l2nyyig.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_value = arr[0];\n    let mut\
    \ min_index = -1;\n    for &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < min_value {\n                min_value = i;\n            \
    \    min_index = i;\n            }\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut smallest_value = even_values[0];\n\
    \    let mut smallest_index = -1;\n    for i in even_values {\n        if i <\
    \ smallest_value {\n            smallest_value = i;\n            smallest_index\
    \ = i;\n        }\n    }\n    vec![smallest_value, smallest_index]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmpql0ljt.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx2\
    \ = -1;\n    let mut min_idx3 = -1;\n    let mut min_idx4 = -1;\n    let mut min_idx5\
    \ = -1;\n    let mut min_idx6 = -1;\n    let mut min_idx7 = -1;\n    let mut min_idx8\
    \ = -1;\n    let mut min_idx9 = -1;\n    let mut min_idx10 = -1;\n    let mut\
    \ min_idx11 = -1;\n    let mut min_idx12 = -1;\n    let mut min_idx13 = -1;\n\
    \    let mut min_idx14 = -1;\n    let mut min_idx15 = -1;\n    let mut min_idx16\
    \ = -1;\n    let mut min_idx17 = -1;\n    let mut min_idx18 = -1;\n    let mut\
    \ min_idx19 = -1;\n    let mut min_idx20 = -1;\n    let mut min_idx21 = -1;\n\
    \    let mut min_idx22 = -1;\n    let mut min_idx23 = -1;\n    let mut min_idx24\
    \ = -1;\n    let mut min_idx25 = -1;\n    let mut min_idx26 = -1;\n    let mut\
    \ min_idx27 = -1;\n    let mut min_idx28 = -1;\n    let mut min_idx29 = -1;\n\
    \    let mut min_idx30 = -1;\n    let mut min_idx31 = -1;\n    let mut min_idx32\
    \ = -1;\n    let mut min_idx33 = -1;\n    let mut min_idx34 = -1;\n    let mut\
    \ min_idx35 = -1;\n    let mut min_idx36 = -1;\n    let mut min_idx37 = -1;\n\
    \    let mut min_idx38 = -1;\n    let mut min_idx39 = -1;\n    let mut min_idx40\
    \ = -1;\n    let mut min_idx41 = -1;\n    let mut min_idx42 = -1;\n    let mut\
    \ min_idx43 = -1;\n    let mut min_idx44 = -1;\n    let mut min_idx45 = -1;\n\
    \    let mut min_idx46 = -1;\n    let mut min_idx47 = -1;\n    let mut min_idx48\
    \ = -1;\n    let mut min_idx49 = -1;\n    let mut min_idx50 = -1;\n    let mut\
    \ min_idx51 = -1;\n    let mut min_idx52 = -1;\n    let mut min_idx53 = -1;\n\
    \    let mut min_idx54 = -1;\n    let mut min_idx55 = -1;\n    let mut min_idx56\
    \ = -1;\n    let mut min_idx57 = -1;\n    let mut min_\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsw9gikqq.rs:85:17\n   |\n\
    85 |     let mut min_\n   |                 ^ help: add `;` here\n86 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsw9gikqq.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even_value = arr[0];\n    let mut smallest_even_index =\
    \ -1;\n    let mut smallest_index = -1;\n    for &i in arr {\n        if i % 2\
    \ == 0 {\n            if smallest_even_value < i {\n                smallest_even_value\
    \ = i;\n                smallest_even_index = i;\n            }\n        } else\
    \ {\n            if smallest_index == -1 || smallest_even_value < i {\n      \
    \          smallest_index = i;\n            }\n        }\n    }\n    smallest_even_value\
    \ += smallest_index;\n    smallest_even_value += smallest_even_index;\n    smallest_even_value\
    \ += smallest_even_index;\n    smallest_even_value += smallest_even_index;\n \
    \   smallest_even_value += smallest_even_index;\n    smallest_even_value += smallest_even_index;\n\
    \    smallest_even_value += smallest_even_index;\n    smallest_even_value += smallest_even_index;\n\
    \    smallest_even_value += smallest_even_index;\n    smallest_even_value += smallest_even_index;\n\
    \    smallest_even_value += smallest_even_index;\n    smallest_even_value += smallest_even_index;\n\
    \    smallest_even_value += smallest_even_index;\n    smallest_even_value += smallest_even_index;\n\
    \    smallest_even_value += smallest_even_index;\n    smallest_even_value += smallest_even_index;\n\
    \    smallest_even_value += smallest_even_index;\n    smallest_even_value += smallest_even_index;\n\
    \    smallest_even_value += smallest_even_index;\n    smallest_even_value += smallest_even_index;\n\
    \    smallest_even_value += smallest_even_index;\n    smallest_even_value += smallest_even_index;\n\
    \    smallest_even_value += smallest_even_index;\n    smallest_even_value += smallest_even_index;\n\
    \    smallest_even_value += smallest_even_index;\n    smallest_even_value += smallest_even_index;\n\
    \    smallest_even_value += smallest_even_index;\n    smallest_even_value += smallest_even_index;\n\
    \    smallest_even_value += smallest_even_index;\n    smallest_even_value += smallest_even_index;\n\
    \    smallest_even_value += smallest_even_index;\n    smallest_even_value += smallest_even_index;\n\
    \    smallest_even_value \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5qgleubf.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5qgleubf.rs:74:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n74 |     smallest_even_value \n   |     ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![0; arr.len()];\n    let mut min_value = arr[0];\n\
    \    let mut min_value_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values[i] = 1;\n            if arr[i] < min_value\
    \ {\n                min_value = arr[i];\n                min_value_index = i;\n\
    \            }\n        } else {\n            even_values[i] = 0;\n        }\n\
    \    }\n    let mut result = vec![0; arr.len()];\n    for i in 0..arr.len() {\n\
    \        if even_values[i] == 1 {\n            result[min_value_index] = i;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfs_3svue.rs:47:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n47 |     result\n\
    \   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &x in arr {\n        if x % 2 == 0 {\n\
    \            even_values.push(x);\n            if x < smallest_value {\n     \
    \           smallest_value = x;\n                smallest_index = even_values.len()\
    \ - 1;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_even_value = even_values[smallest_index];\n\
    \    let mut smallest_even_index = smallest_index;\n    for &x in even_values\
    \ {\n        if x < smallest_even_value {\n            smallest_even_value = x;\n\
    \            smallest_even_index = even_values.len() - 1;\n        }\n    }\n\
    \    even_values.remove(&smallest_even_value);\n    even_values.sort();\n    let\
    \ mut result = vec![];\n    for &x in even_values {\n        result.push(x);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwxub3xxc.rs:30:9\n   |\n\
    30 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwxub3xxc.rs:44:9\n   |\n44 |     for &x in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwxub3xxc.rs:50:24\n   |\n50 |     even_values.remove(&smallest_even_value);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwxub3xxc.rs:53:9\n   |\n53 | \
    \    for &x in even_values {\n   |         ^^    ----------- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_idx = -1;\n    for &i in arr {\n        if i % 2 == 0 {\n          \
    \  even_values.push(i);\n            if i < min_value {\n                min_value\
    \ = i;\n                min_idx = i;\n            }\n        }\n    }\n    if\
    \ even_values.len() == 0 {\n        return vec![];\n    }\n    let mut min_even_value\
    \ = even_values[even_values.len() - 1];\n    let mut min_idx = -1;\n    for i\
    \ in 0..even_values.len() {\n        if even_values[i] < min_even_value {\n  \
    \          min_even_value = even_values[i];\n            min_idx = i;\n      \
    \  }\n    }\n    let mut result = vec![];\n    for i in 0..even_values.len() {\n\
    \        if even_values[i] == min_even_value {\n            result.push(i);\n\
    \        }\n    }\n    if min_idx != -1 {\n        result.push(min_idx);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwofba5a_.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpwofba5a_.rs:43:23\n   |\n43 | \
    \    let mut min_idx = -1;\n   |                       ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmpwofba5a_.rs:56:19\n   |\n56 |  \
    \   if min_idx != -1 {\n   |                   ^^\n   |                   |\n\
    \   |                   cannot apply unary operator `-`\n   |                \
    \   help: you may have meant the maximum value of `usize`: `usize::MAX`\n   |\n\
    \   = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwofba5a_.rs:59:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n59 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<usize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0600.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    let mut smallest_index_value = arr[0];\n  \
    \  for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if smallest_index_value < i {\n                smallest_index_value\
    \ = i;\n                smallest_index = i;\n            }\n        }\n      \
    \  if smallest_value < i {\n            smallest_value = i;\n            smallest_index\
    \ = i;\n        }\n    }\n    even_values.sort();\n    let mut even_values_index\
    \ = even_values.iter().enumerate().filter(|&(_, v)| v % 2 == 0).collect::<Vec<(isize,\
    \ isize)>>();\n    even_values_index.sort();\n    let mut even_values_index_value\
    \ = even_values_index.iter().enumerate().filter(|&(_, v)| v == smallest_index).collect::<Vec<(isize,\
    \ isize)>>();\n    even_values_index_value.sort();\n    let mut even_values_index_value\
    \ = even_values_index_value.iter().enumerate().filter(|&(_, v)| v == smallest_index_value).collect::<Vec<(isize,\
    \ isize)>>();\n    even_values_index_value.sort();\n    let mut even_values_index_value\
    \ = even_values_index_value.iter().enumerate().filter(|&(_, v)| v == smallest_index_value).collect::<Vec<(isize,\
    \ isize)>>();\n    even_values_index_value.sort();\n    let mut even_values_index_value\
    \ = even_values_index_value.iter().enumerate().filter(|&(_, v)| v == smallest_index_value).collect::<Vec<(isize,\
    \ isize)>>();\n    even_values_index_value.sort();\n    let mut even_values_index_value\
    \ = even_values_index_value.iter().enumerate().filter(|&(_, v)| v == smallest_index_value).collect::<Vec<(isize,\
    \ isize)>>();\n    even_values_index_value.sort();\n    let mut even_values_index_value\
    \ = even_values_index_value.iter().enumerate().filter(|&(_, v)| v == smallest_index_value).collect::<Vec<(isize,\
    \ isize)>>();\n    even_values_index_value.sort();\n    let mut even_values_index_value\
    \ = even_values_index_value.iter().enumerate().filter(|&(_, v)| v == smallest_index_value).collect::<Vec<(isize,\
    \ isize)>>();\n    even_values_index_value.\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpquf31bea.rs:61:1\n   |\n61\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpquf31bea.rs:34:39\n\
    \   |\n34 |             if smallest_index_value < i {\n   |                  \
    \                     ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n34 |             if smallest_index_value < *i\
    \ {\n   |                                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpquf31bea.rs:35:40\n   |\n30 |     let mut smallest_index_value\
    \ = arr[0];\n   |                                    ------ expected due to this\
    \ value\n...\n35 |                 smallest_index_value = i;\n   |           \
    \                             ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n35 |                 smallest_index_value\
    \ = *i;\n   |                                        +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpquf31bea.rs:36:34\n   |\n29 |     let mut smallest_index\
    \ = 0;\n   |                              - expected due to this value\n...\n\
    36 |                 smallest_index = i;\n   |                               \
    \   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n36 |                 smallest_index = *i;\n   |              \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpquf31bea.rs:39:29\n\
    \   |\n39 |         if smallest_value < i {\n   |                            \
    \ ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n39 |         if smallest_value < *i {\n   |                           \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpquf31bea.rs:40:30\n   |\n\
    28 |     let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n40 |             smallest_value = i;\n   |\
    \                              ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n40 |             smallest_value = *i;\n\
    \   |                              +\n\nerror[E0308]: mismatched types\n  --> "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = arr[0];\n    let mut min_even_index = -1;\n    let\
    \ mut min_even_index_in_arr = 0;\n    let mut min_even_index_in_arr2 = 0;\n  \
    \  let mut even_values = Vec::new();\n    let mut even_values2 = Vec::new();\n\
    \    let mut even_values3 = Vec::new();\n    let mut even_values4 = Vec::new();\n\
    \    let mut even_values5 = Vec::new();\n    let mut even_values6 = Vec::new();\n\
    \    let mut even_values7 = Vec::new();\n    let mut even_values8 = Vec::new();\n\
    \    let mut even_values9 = Vec::new();\n    let mut even_values10 = Vec::new();\n\
    \    let mut even_values11 = Vec::new();\n    let mut even_values12 = Vec::new();\n\
    \    let mut even_values13 = Vec::new();\n    let mut even_values14 = Vec::new();\n\
    \    let mut even_values15 = Vec::new();\n    let mut even_values16 = Vec::new();\n\
    \    let mut even_values17 = Vec::new();\n    let mut even_values18 = Vec::new();\n\
    \    let mut even_values19 = Vec::new();\n    let mut even_values20 = Vec::new();\n\
    \    let mut even_values21 = Vec::new();\n    let mut even_values22 = Vec::new();\n\
    \    let mut even_values23 = Vec::new();\n    let mut even_values24 = Vec::new();\n\
    \    let mut even_values25 = Vec::new();\n    let mut even_values26 = Vec::new();\n\
    \    let mut even_values27 = Vec::new();\n    let mut even_values28 = Vec::new();\n\
    \    let mut even_values29 = Vec::new();\n    let mut even_values30 = Vec::new();\n\
    \    let mut even_values31 = Vec::new();\n    let mut even_values32 = Vec::new();\n\
    \    let mut even_values33 = Vec::new();\n    let mut even_values34 = Vec::new();\n\
    \    let mut even_values35 = Vec::new();\n    let mut even_values36 = Vec::new();\n\
    \    let mut even_values37 = Vec::new();\n    let mut even_values38 = Vec::\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmprm835qm0.rs:69:1\n\
    \   |\n69 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 1;\n    let mut min_idx2\
    \ = 1;\n    let mut min_idx3 = 1;\n    let mut min_idx4 = 1;\n    let mut min_idx5\
    \ = 1;\n    let mut min_idx6 = 1;\n    let mut min_idx7 = 1;\n    let mut min_idx8\
    \ = 1;\n    let mut min_idx9 = 1;\n    let mut min_idx10 = 1;\n    let mut min_idx11\
    \ = 1;\n    let mut min_idx12 = 1;\n    let mut min_idx13 = 1;\n    let mut min_idx14\
    \ = 1;\n    let mut min_idx15 = 1;\n    let mut min_idx16 = 1;\n    let mut min_idx17\
    \ = 1;\n    let mut min_idx18 = 1;\n    let mut min_idx19 = 1;\n    let mut min_idx20\
    \ = 1;\n    let mut min_idx21 = 1;\n    let mut min_idx22 = 1;\n    let mut min_idx23\
    \ = 1;\n    let mut min_idx24 = 1;\n    let mut min_idx25 = 1;\n    let mut min_idx26\
    \ = 1;\n    let mut min_idx27 = 1;\n    let mut min_idx28 = 1;\n    let mut min_idx29\
    \ = 1;\n    let mut min_idx30 = 1;\n    let mut min_idx31 = 1;\n    let mut min_idx32\
    \ = 1;\n    let mut min_idx33 = 1;\n    let mut min_idx34 = 1;\n    let mut min_idx35\
    \ = 1;\n    let mut min_idx36 = 1;\n    let mut min_idx37 = 1;\n    let mut min_idx38\
    \ = 1;\n    let mut min_idx39 = 1;\n    let mut min_idx40 = 1;\n    let mut min_idx41\
    \ = 1;\n    let mut min_idx42 = 1;\n    let mut min_idx43 = 1;\n    let mut min_idx44\
    \ = 1;\n    let mut min_idx45 = 1;\n    let mut min_idx46 = 1;\n    let mut min_idx47\
    \ = 1;\n    let mut min_idx48 = 1;\n    let mut min_idx49 = 1;\n    let mut min_idx50\
    \ = 1;\n    let mut min_idx51 = 1;\n    let mut min_idx52 = 1;\n    let mut min_idx53\
    \ = 1;\n    let mut min_idx54 = 1;\n    let mut min_idx55 = 1;\n    let mut min_idx56\
    \ = 1;\n    let mut min_idx57 = 1;\n    let mut min_idx58 = 1;\n    let mut min_idx59\
    \ = 1;\n    let mut min_idx60 = 1;\n    let mut min_idx61 = 1;\n    let mut min_idx62\
    \ = 1;\n    let mut min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_dt6zkpq.rs:90:20\n   |\n\
    90 |     let mut min_idx\n   |                    ^ help: add `;` here\n91 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_dt6zkpq.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    for &i in arr\
    \ {\n        if i % 2 == 0 {\n            if min_value > i {\n               \
    \ min_value = i;\n                min_idx = i;\n            }\n        }\n   \
    \ }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8xh5pl06.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for &i in even_values {\n        if i < smallest_even_value {\n  \
    \          smallest_even_value = i;\n            smallest_even_index = i;\n  \
    \      }\n    }\n    let mut result = vec![];\n    if smallest_even_index < smallest_index\
    \ {\n        result.push(smallest_even_value);\n        result.push(smallest_even_index);\n\
    \    } else {\n        result.push(smallest_value);\n        result.push(smallest_index);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp36d39ltp.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp36d39ltp.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for &i in even_values {\n        if i < smallest_even_value {\n  \
    \          smallest_even_value = i;\n            smallest_even_index = i;\n  \
    \      }\n    }\n    let mut result = vec![];\n    for &i in even_values {\n \
    \       if i == smallest_even_value {\n            result.push(i);\n        }\n\
    \    }\n    result.push(smallest_even_index);\n    result\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps9morza9.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps9morza9.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps9morza9.rs:51:9\n   |\n51 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for &i in even_values {\n        if i < smallest_even_value {\n  \
    \          smallest_even_value = i;\n            smallest_even_index = i;\n  \
    \      }\n    }\n    let mut result = vec![];\n    if smallest_even_index == smallest_index\
    \ {\n        result.push(smallest_even_value);\n        result.push(smallest_index);\n\
    \    } else {\n        result.push(smallest_even_value);\n        result.push(smallest_index);\n\
    \        result.push(smallest_even_index);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2opsqgc.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw2opsqgc.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    even_values.sort_unstable();\n    let mut even_values_index\
    \ = even_values.iter().cloned().enumerate().filter(|&(_, v)| v % 2 == 0).collect::<Vec<_>>();\n\
    \    if even_values_index.len() == 0 {\n        return vec![];\n    }\n    let\
    \ mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmxcm8yoz.rs:54:55\n   |\n\
    54 |     let mut even_values_index = even_values_index.iter\n   |            \
    \                                           ^ help: add `;` here\n55 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmxcm8yoz.rs:30:9\n\
    \   |\n30 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0369]:\
    \ cannot mod `(usize, isize)` by `{integer}`\n  --> /tmp/tmpmxcm8yoz.rs:44:98\n\
    \   |\n44 |     let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n   |                                 \
    \                                                               - ^ - {integer}\n\
    \   |                                                                        \
    \                        |\n   |                                             \
    \                                                   (usize, isize)\n\nerror[E0369]:\
    \ cannot mod `(usize, (usize, isize))` by `{integer}`\n  --> /tmp/tmpmxcm8yoz.rs:45:98\n\
    \   |\n45 |     let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n   |                                 \
    \                                                               - ^ - {integer}\n\
    \   |                                                                        \
    \                        |\n   |                                             \
    \                                                   (usize, (usize, isize))\n\n\
    error[E0369]: cannot mod `(usize, (usize, (usize, isize)))` by `{integer}`\n \
    \ --> /tmp/tmpmxcm8yoz.rs:46:98\n   |\n46 |     let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n   |                                 \
    \                           "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2 ==\
    \ 0 {\n            even_values.push(i);\n            if i < smallest_value {\n\
    \                smallest_value = i;\n                smallest_index = i;\n  \
    \          }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = 0;\n    for i in even_values.iter() {\n        if i <\
    \ smallest_even_value {\n            smallest_even_value = i;\n            smallest_even_index\
    \ = i;\n        }\n    }\n    let mut result = vec![];\n    for i in arr.iter()\
    \ {\n        if i == smallest_value {\n            result.push(i);\n        }\n\
    \    }\n    if smallest_even_index == smallest_index {\n        result.push(smallest_even_value);\n\
    \    }\n    return result;\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwi79kfs5.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpwi79kfs5.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwi79kfs5.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwi79kfs5.rs:45:16\n  \
    \ |\n45 |         if i < smallest_even_value {\n   |                ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwi79kfs5.rs:47:35\n   |\n43 |     let mut smallest_even_index = 0;\n\
    \   |                                   - expected due to this value\n...\n47\
    \ |             smallest_even_index = i;\n   |                               \
    \    ^ expected integer, found `&&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n47 |             smallest_even_index = **i;\n   |            \
    \                       ++\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmpwi79kfs5.rs:52:14\n   |\n52 |         if i == smallest_value {\n\
    \   |              ^^ no implementation for `&isize == isize`\n   |\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx2\
    \ = 0;\n    let mut min_idx3 = 0;\n    let mut min_idx4 = 0;\n    let mut min_idx5\
    \ = 0;\n    let mut min_idx6 = 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8\
    \ = 0;\n    let mut min_idx9 = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11\
    \ = 0;\n    let mut min_idx12 = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14\
    \ = 0;\n    let mut min_idx15 = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17\
    \ = 0;\n    let mut min_idx18 = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20\
    \ = 0;\n    let mut min_idx21 = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23\
    \ = 0;\n    let mut min_idx24 = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26\
    \ = 0;\n    let mut min_idx27 = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29\
    \ = 0;\n    let mut min_idx30 = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32\
    \ = 0;\n    let mut min_idx33 = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35\
    \ = 0;\n    let mut min_idx36 = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38\
    \ = 0;\n    let mut min_idx39 = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41\
    \ = 0;\n    let mut min_idx42 = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44\
    \ = 0;\n    let mut min_idx45 = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47\
    \ = 0;\n    let mut min_idx48 = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50\
    \ = 0;\n    let mut min_idx51 = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53\
    \ = 0;\n    let mut min_idx54 = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56\
    \ = 0;\n    let mut min_idx57 = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59\
    \ = 0;\n    let mut min_idx60 = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62\
    \ = 0;\n    let mut min_idx63 = 0;\n    let mut min_idx\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5_jlytfq.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5_jlytfq.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values.push(i);\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = even_values[0];\n    for i in 1..even_values.len()\
    \ {\n        if even_values[i] < smallest_even_value {\n            smallest_even_value\
    \ = even_values[i];\n            smallest_even_index = even_values[i];\n     \
    \   }\n    }\n    let mut result = vec![];\n    for i in 0..even_values.len()\
    \ {\n        if even_values[i] == smallest_even_value {\n            result.push(i);\n\
    \        }\n    }\n    if result.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut smallest_index = result.iter().min().unwrap();\n    for i in 0..result.len()\
    \ {\n        if result[i] == smallest_index {\n            result.swap(i, smallest_index);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5dv5182k.rs:61:25\n   |\n\
    61 |         if result[i] == smallest_index {\n   |                         ^^^^^^^^^^^^^^\
    \ expected `usize`, found `&usize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n61 |         if result[i] == *smallest_index {\n   |                  \
    \       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5dv5182k.rs:62:28\n\
    \   |\n62 |             result.swap(i, smallest_index);\n   |                \
    \            ^^^^^^^^^^^^^^ expected `usize`, found `&usize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n62 |             result.swap(i, *smallest_index);\n\
    \   |                            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5dv5182k.rs:65:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n65\
    \ |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = i32::MAX;\n    let mut min_index = -1;\n    let mut min_node\
    \ = None;\n    for &i in arr {\n        if i % 2 == 0 {\n            if min_value\
    \ == i32::MAX {\n                min_value = i;\n                min_index = i;\n\
    \                min_node = Some(i);\n            } else {\n                if\
    \ i < min_value {\n                    min_value = i;\n                    min_index\
    \ = i;\n                    min_node = Some(i);\n                }\n         \
    \   }\n        }\n    }\n    if min_value == i32::MAX {\n        return vec![];\n\
    \    }\n    if min_node == None {\n        return vec![min_value];\n    }\n  \
    \  let mut result = vec![min_value];\n    result.push(min_index);\n    result.push(min_node.unwrap());\n\
    \    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc5chcc_t.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc5chcc_t.rs:49:21\n   |\n49 |         return vec![min_value];\n\
    \   |                     ^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp:\
    \ you can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n49 |         return vec![min_value.try_into().unwrap()];\n   |  \
    \                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc5chcc_t.rs:54:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n54 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `i32`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<i32>`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values.push(arr[i]);\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_value_and_index = vec![];\n\
    \    for i in 0..even_values.len() {\n        if even_values[i] < smallest_value\
    \ {\n            smallest_value_and_index.push((even_values[i], i));\n       \
    \ }\n    }\n    if smallest_value_and_index.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_value_and_index_sorted = vec![];\n    for i in 0..smallest_value_and_index.len()\
    \ {\n        smallest_value_and_index_sorted.push((smallest_value_and_index[i][0],\
    \ smallest_value_and_index[i][1]));\n    }\n    smallest_value_and_index_sorted.sort();\n\
    \    smallest_value_and_index_sorted.reverse();\n    return smallest_value_and_index_sorted;\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `(isize, usize)`\n  -->\
    \ /tmp/tmp92nypp1r.rs:53:47\n   |\n53 |         smallest_value_and_index_sorted.push((smallest_value_and_index[i][0],\
    \ smallest_value_and_index[i][1]));\n   |                                    \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: to access tuple elements, use:\
    \ `smallest_value_and_index[i].0`\n\nerror[E0608]: cannot index into a value of\
    \ type `(isize, usize)`\n  --> /tmp/tmp92nypp1r.rs:53:79\n   |\n53 |         smallest_value_and_index_sorted.push((smallest_value_and_index[i][0],\
    \ smallest_value_and_index[i][1]));\n   |                                    \
    \                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help:\
    \ to access tuple elements, use: `smallest_value_and_index[i].1`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for &i in even_values {\n        if i < smallest_even_value {\n  \
    \          smallest_even_value = i;\n            smallest_even_index = i;\n  \
    \      }\n    }\n    let mut result = vec![];\n    if smallest_even_value == smallest_value\
    \ {\n        result.push(smallest_even_index);\n    } else {\n        result.push(smallest_value);\n\
    \        result.push(smallest_even_index);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbz_iwbk3.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbz_iwbk3.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = arr[0];\n    let mut min_even_index = 0;\n    let\
    \ mut min_even_index_in_arr = 0;\n    let mut even_values_found = false;\n   \
    \ let mut even_values_found_in_arr = 0;\n    let mut even_values_found_in_arr_index\
    \ = 0;\n    let mut even_values_found_in_arr_index_in_arr = 0;\n    let mut even_values_found_in_arr_index_in_arr\
    \ = 0;\n    let mut even_values_found_in_arr_index_in_arr = 0;\n    let mut even_values_found_in_arr_index_in_arr\
    \ = 0;\n    let mut even_values_found_in_arr_index_in_arr = 0;\n    let mut even_values_found_in_arr_index_in_arr\
    \ = 0;\n    let mut even_values_found_in_arr_index_in_arr = 0;\n    let mut even_values_found_in_arr_index_in_arr\
    \ = 0;\n    let mut even_values_found_in_arr_index_in_arr = 0;\n    let mut even_values_found_in_arr_index_in_arr\
    \ = 0;\n    let mut even_values_found_in_arr_index_in_arr = 0;\n    let mut even_values_found_in_arr_index_in_arr\
    \ = 0;\n    let mut even_values_found_in_arr_index_in_arr = 0;\n    let mut even_values_found_in_arr_index_in_arr\
    \ = 0;\n    let mut even_values_found_in_arr_index_in_arr = 0;\n    let mut even_values_found_in_arr_index_in_arr\
    \ = 0;\n    let mut even_values_found_in_arr_index_in_arr = 0;\n    let mut even_values_found_in_arr_index_in_arr\
    \ = 0;\n    let mut even_values_found_in_arr_index_in_arr = 0;\n    let mut even_values_found_in_arr_index_in_arr\
    \ = 0;\n    let mut even_values_found_in_arr_index_in_arr = 0;\n    let mut even_values_found_in_arr_index_in_arr\
    \ = 0;\n    let mut even_values_found_in_arr_index_in_arr = 0;\n    let mut even_values_found_in_arr_index_in_arr\
    \ = 0;\n    let mut even_values_found_in_arr_index_in_arr = 0;\n    let mut even_values_found_in_arr_index_in_arr\
    \ = 0;\n    let mut even_values_found_in_arr_index_in_arr = 0;\n    let mut even_values_found_in_arr_index_in_arr\
    \ = 0;\n    let mut even_values_found_in_arr_index_in_arr = 0;\n    let mut even_values_found_in_arr_index_in_arr\
    \ = 0;\n    let mut even_values_found_in_arr_index_in_arr = 0;\n    let mut even_values_found_in_arr_index_in_arr\
    \ = 0;\n    let mut even_value\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt5r_ovhd.rs:65:23\n   |\n\
    65 |     let mut even_value\n   |                       ^ help: add `;` here\n\
    66 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt5r_ovhd.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_val = arr[0];\n    let mut min_idx = 1;\n    let mut min_idx2\
    \ = 1;\n    let mut min_idx3 = 1;\n    let mut min_idx4 = 1;\n    let mut min_idx5\
    \ = 1;\n    let mut min_idx6 = 1;\n    let mut min_idx7 = 1;\n    let mut min_idx8\
    \ = 1;\n    let mut min_idx9 = 1;\n    let mut min_idx10 = 1;\n    let mut min_idx11\
    \ = 1;\n    let mut min_idx12 = 1;\n    let mut min_idx13 = 1;\n    let mut min_idx14\
    \ = 1;\n    let mut min_idx15 = 1;\n    let mut min_idx16 = 1;\n    let mut min_idx17\
    \ = 1;\n    let mut min_idx18 = 1;\n    let mut min_idx19 = 1;\n    let mut min_idx20\
    \ = 1;\n    let mut min_idx21 = 1;\n    let mut min_idx22 = 1;\n    let mut min_idx23\
    \ = 1;\n    let mut min_idx24 = 1;\n    let mut min_idx25 = 1;\n    let mut min_idx26\
    \ = 1;\n    let mut min_idx27 = 1;\n    let mut min_idx28 = 1;\n    let mut min_idx29\
    \ = 1;\n    let mut min_idx30 = 1;\n    let mut min_idx31 = 1;\n    let mut min_idx32\
    \ = 1;\n    let mut min_idx33 = 1;\n    let mut min_idx34 = 1;\n    let mut min_idx35\
    \ = 1;\n    let mut min_idx36 = 1;\n    let mut min_idx37 = 1;\n    let mut min_idx38\
    \ = 1;\n    let mut min_idx39 = 1;\n    let mut min_idx40 = 1;\n    let mut min_idx41\
    \ = 1;\n    let mut min_idx42 = 1;\n    let mut min_idx43 = 1;\n    let mut min_idx44\
    \ = 1;\n    let mut min_idx45 = 1;\n    let mut min_idx46 = 1;\n    let mut min_idx47\
    \ = 1;\n    let mut min_idx48 = 1;\n    let mut min_idx49 = 1;\n    let mut min_idx50\
    \ = 1;\n    let mut min_idx51 = 1;\n    let mut min_idx52 = 1;\n    let mut min_idx53\
    \ = 1;\n    let mut min_idx54 = 1;\n    let mut min_idx55 = 1;\n    let mut min_idx56\
    \ = 1;\n    let mut min_idx57 = 1;\n    let mut min_idx58 = 1;\n    let mut min_idx59\
    \ = 1;\n    let mut min_idx60 = 1;\n    let mut min_idx61 = 1;\n    let mut min_idx62\
    \ = 1;\n    let mut min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa4f_wf7p.rs:90:20\n   |\n\
    90 |     let mut min_idx\n   |                    ^ help: add `;` here\n91 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa4f_wf7p.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_value = arr[0];\n    let mut smallest_index = 0;\n    for\
    \ i in 1..arr.len() {\n        if arr[i] < smallest_value {\n            smallest_value\
    \ = arr[i];\n            smallest_index = i;\n        }\n    }\n    let mut result\
    \ = vec![smallest_value, smallest_index];\n    for i in 1..arr.len() {\n     \
    \   if arr[i] != smallest_value {\n            result.push(i);\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4yqikhuw.rs:35:43\n   |\n\
    35 |     let mut result = vec![smallest_value, smallest_index];\n   |        \
    \                                   ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4yqikhuw.rs:38:25\n   |\n38 |\
    \             result.push(i);\n   |                         ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n38 |             result.push(i.try_into().unwrap());\n\
    \   |                          ++++++++++++++++++++\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_value {\n            min_value = arr[i];\n      \
    \      min_idx = i;\n        }\n    }\n    let mut even_values = Vec::new();\n\
    \    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n            even_values.push(arr[i]);\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return Vec::new();\n\
    \    }\n    if even_values.len() == 1 {\n        return vec![min_value];\n   \
    \ }\n    let mut min_even_value = even_values[0];\n    let mut min_even_idx =\
    \ 0;\n    for i in 1..even_values.len() {\n        if even_values[i] < min_even_value\
    \ {\n            min_even_value = even_values[i];\n            min_even_idx =\
    \ i;\n        }\n    }\n    let mut even_values_copy = even_values.clone();\n\
    \    even_values_copy.remove(min_even_idx);\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.remove(min_even_idx);\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.remove(min_even_idx);\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.remove(min_even_idx);\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.remove(min_even_idx);\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.remove(min_even_idx);\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.remove(min_even_idx);\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.remove(min_even_idx);\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.remove(min_even_idx);\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.remove(min_even_idx);\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.remove(min_even_idx);\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.remove(min_even_idx);\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.remove(min_even_idx);\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.remove(min_even_idx);\n    let mut even_values_copy = even_values_copy.\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp3ex7xm97.rs:84:1\n   |\n84\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp3ex7xm97.rs:83:49\n\
    \   |\n83 |     let mut even_values_copy = even_values_copy.\n   |           \
    \                                      ^ help: add `;` here\n84 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3ex7xm97.rs:26:30\n \
    \  |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----          \
    \           ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx2\
    \ = 0;\n    let mut min_idx3 = 0;\n    let mut min_idx4 = 0;\n    let mut min_idx5\
    \ = 0;\n    let mut min_idx6 = 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8\
    \ = 0;\n    let mut min_idx9 = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11\
    \ = 0;\n    let mut min_idx12 = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14\
    \ = 0;\n    let mut min_idx15 = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17\
    \ = 0;\n    let mut min_idx18 = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20\
    \ = 0;\n    let mut min_idx21 = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23\
    \ = 0;\n    let mut min_idx24 = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26\
    \ = 0;\n    let mut min_idx27 = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29\
    \ = 0;\n    let mut min_idx30 = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32\
    \ = 0;\n    let mut min_idx33 = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35\
    \ = 0;\n    let mut min_idx36 = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38\
    \ = 0;\n    let mut min_idx39 = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41\
    \ = 0;\n    let mut min_idx42 = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44\
    \ = 0;\n    let mut min_idx45 = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47\
    \ = 0;\n    let mut min_idx48 = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50\
    \ = 0;\n    let mut min_idx51 = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53\
    \ = 0;\n    let mut min_idx54 = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56\
    \ = 0;\n    let mut min_idx57 = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59\
    \ = 0;\n    let mut min_idx60 = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62\
    \ = 0;\n    let mut min_idx63 = 0;\n    let mut min_idx\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0gg84nuw.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0gg84nuw.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_value = arr[0];\n    let mut\
    \ min_index = -1;\n    for &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < min_value {\n                min_value = i;\n            \
    \    min_index = i;\n            }\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut even_values_set = HashSet::new();\n\
    \    for &i in even_values {\n        even_values_set.insert(i);\n    }\n    let\
    \ mut smallest_value = min_value;\n    let mut smallest_index = min_index;\n \
    \   for &i in even_values {\n        if !even_values_set.contains(&i) {\n    \
    \        if i < smallest_value {\n                smallest_value = i;\n      \
    \          smallest_index = i;\n            }\n        }\n    }\n    vec![smallest_value,\
    \ smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmplwr7nxyr.rs:42:31\n   |\n42 |     let mut even_values_set = HashSet::new();\n\
    \   |                               ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplwr7nxyr.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplwr7nxyr.rs:43:9\n   |\n43 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplwr7nxyr.rs:48:9\n   |\n48 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n        }\n        if i == smallest_value {\n\
    \            smallest_index = arr.iter().position(|&i| i == smallest_value).unwrap();\n\
    \        }\n        if i == smallest_value {\n            smallest_value = i;\n\
    \        }\n    }\n    if even_values.is_empty() {\n        return vec![];\n \
    \   }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = even_values.iter().position(|&i| i == smallest_even_value).unwrap();\n   \
    \ for &i in even_values {\n        if i == smallest_value {\n            smallest_even_value\
    \ = i;\n            smallest_even_index = even_values.iter().position(|&i| i ==\
    \ smallest_even_value).unwrap();\n        }\n    }\n    even_values.iter().position(|&i|\
    \ i == smallest_even_value).unwrap()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkss8ehjz.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkss8ehjz.rs:46:9\n   |\n46 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkss8ehjz.rs:52:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n52 |     even_values.iter().position(|&i| i == smallest_even_value).unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `usize`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![0; arr.len()];\n    let mut min_value = arr[0];\n\
    \    let mut min_value_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values[i] = arr[i];\n            if arr[i] < min_value\
    \ {\n                min_value = arr[i];\n                min_value_index = i;\n\
    \            }\n        }\n    }\n    let mut even_values_sorted = even_values.iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_sorted.sort();\n    let mut min_value_index = -1;\n    for i\
    \ in 0..even_values_sorted.len() {\n        if even_values_sorted[i] == min_value\
    \ {\n            min_value_index = i;\n        }\n    }\n    if min_value_index\
    \ == -1 {\n        return vec![];\n    }\n    let mut result = vec![min_value_index];\n\
    \    for i in 0..min_value_index {\n        result.push(arr[i]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpuqhf3mxs.rs:29:31\n\
    \   |\n29 |     let mut min_value_index = -1;\n   |                          \
    \     ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpuqhf3mxs.rs:41:31\n\
    \   |\n41 |     let mut min_value_index = -1;\n   |                          \
    \     ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpuqhf3mxs.rs:47:27\n\
    \   |\n47 |     if min_value_index == -1 {\n   |                           ^^\n\
    \   |                           |\n   |                           cannot apply\
    \ unary operator `-`\n   |                           help: you may have meant\
    \ the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values\
    \ cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuqhf3mxs.rs:52:21\n\
    \   |\n52 |         result.push(arr[i]);\n   |                     ^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n52 |         result.push(arr[i].try_into().unwrap());\n\
    \   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuqhf3mxs.rs:54:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n54 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    for &i in arr\
    \ {\n        if i % 2 == 0 {\n            if min_value == i {\n              \
    \  min_idx = i;\n            }\n        } else {\n            min_value = i;\n\
    \            min_idx = i;\n        }\n    }\n    vec![min_value, min_idx]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8gwj52rp.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx2\
    \ = 0;\n    let mut min_idx3 = 0;\n    let mut min_idx4 = 0;\n    let mut min_idx5\
    \ = 0;\n    let mut min_idx6 = 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8\
    \ = 0;\n    let mut min_idx9 = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11\
    \ = 0;\n    let mut min_idx12 = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14\
    \ = 0;\n    let mut min_idx15 = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17\
    \ = 0;\n    let mut min_idx18 = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20\
    \ = 0;\n    let mut min_idx21 = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23\
    \ = 0;\n    let mut min_idx24 = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26\
    \ = 0;\n    let mut min_idx27 = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29\
    \ = 0;\n    let mut min_idx30 = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32\
    \ = 0;\n    let mut min_idx33 = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35\
    \ = 0;\n    let mut min_idx36 = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38\
    \ = 0;\n    let mut min_idx39 = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41\
    \ = 0;\n    let mut min_idx42 = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44\
    \ = 0;\n    let mut min_idx45 = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47\
    \ = 0;\n    let mut min_idx48 = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50\
    \ = 0;\n    let mut min_idx51 = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53\
    \ = 0;\n    let mut min_idx54 = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56\
    \ = 0;\n    let mut min_idx57 = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59\
    \ = 0;\n    let mut min_idx60 = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62\
    \ = 0;\n    let mut min_idx63 = 0;\n    let mut min_idx\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp895ud5r5.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp895ud5r5.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values.push(arr[i]);\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = 0;\n    for i in 0..even_values.len() {\n \
    \       if even_values[i] < smallest_even_value {\n            smallest_even_value\
    \ = even_values[i];\n            smallest_even_index = i;\n        }\n    }\n\
    \    vec![smallest_value, smallest_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjy8i1ub2.rs:50:26\n   |\n\
    50 |     vec![smallest_value, smallest_even_index]\n   |                     \
    \     ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n50 |     vec![smallest_value, smallest_even_index.try_into().unwrap()]\n\
    \   |                                             ++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2\
    \ == 0 {\n            even_values.push(i);\n            if smallest_value < i\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = 0;\n    for i in even_values.iter() {\n        if i %\
    \ 2 == 0 {\n            if smallest_even_value < i {\n                smallest_even_value\
    \ = i;\n                smallest_even_index = i;\n            }\n        }\n \
    \   }\n    let mut result = vec![];\n    for i in even_values.iter() {\n     \
    \   if i == smallest_even_value {\n            result.push(i);\n        }\n  \
    \  }\n    if result.len() == 0 {\n        return vec![];\n    }\n    let mut smallest_value\
    \ = result[0];\n    let mut smallest_index = 0;\n    for i in result.iter() {\n\
    \        if i % 2 == 0 {\n            if smallest_value < i {\n              \
    \  smallest_value = i;\n                smallest_index = i;\n            }\n \
    \       }\n    }\n    if smallest_index == 0 {\n        return vec![];\n    }\n\
    \    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk1t9ns9o.rs:33:33\n   |\n\
    33 |             if smallest_value < i {\n   |                               \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n33 |             if smallest_value < *i {\n   |              \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk1t9ns9o.rs:34:34\n\
    \   |\n28 |     let mut smallest_value = arr[0];\n   |                       \
    \       ------ expected due to this value\n...\n34 |                 smallest_value\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk1t9ns9o.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpk1t9ns9o.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk1t9ns9o.rs:48:39\n   |\n\
    43 |     let mut smallest_even_index = 0;\n   |                              \
    \     - expected due to this value\n...\n48 |                 smallest_even_index\
    \ = i;\n   |                                       ^ expected integer, found `&&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n48 |                 smallest_even_index\
    \ = **i;\n   |                                       ++\n\nerror[E0277]: can't\
    \ compare `&isize` with `isize`\n  --> /tmp/tmpk1t9ns9o.rs:54:14\n   |\n54 | \
    \        if i == smallest_even_value "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n        }\n        if i == smallest_value {\n\
    \            smallest_index = arr.iter().position(|&i| i == smallest_value).unwrap();\n\
    \        }\n        if i == smallest_value {\n            smallest_value = i;\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = even_values.iter().position(|&i| i == smallest_even_value).unwrap();\n   \
    \ for &i in even_values {\n        if i == smallest_value {\n            smallest_even_value\
    \ = i;\n            smallest_even_index = even_values.iter().position(|&i| i ==\
    \ smallest_even_value).unwrap();\n        }\n    }\n    return vec![smallest_value,\
    \ smallest_index];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2js3yfcg.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2js3yfcg.rs:46:9\n   |\n46 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2js3yfcg.rs:52:33\n   |\n52 |     return vec![smallest_value, smallest_index];\n\
    \   |                                 ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n52 |     return vec![smallest_value, smallest_index.try_into().unwrap()];\n\
    \   |                                               ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even_value = arr[0];\n    let mut smallest_even_index =\
    \ -1;\n    let mut smallest_even_index_count = 0;\n    for &i in arr {\n     \
    \   if i % 2 == 0 {\n            if smallest_even_index == -1 || smallest_even_index\
    \ > i {\n                smallest_even_index = i;\n                smallest_even_index_count\
    \ = 1;\n            } else {\n                smallest_even_index_count += 1;\n\
    \            }\n        }\n    }\n    if smallest_even_index_count == 0 {\n  \
    \      return vec![];\n    }\n    let mut smallest_even_index_value = smallest_even_index;\n\
    \    let mut smallest_even_index_value_count = 0;\n    for &i in arr {\n     \
    \   if i % 2 == 0 {\n            if smallest_even_index_value == i {\n       \
    \         smallest_even_index_value_count += 1;\n            } else {\n      \
    \          if smallest_even_index_value_count > smallest_even_index_count {\n\
    \                    smallest_even_index_value = i;\n                    smallest_even_index_value_count\
    \ = smallest_even_index_count;\n                }\n            }\n        }\n\
    \    }\n    vec![smallest_even_index_value, smallest_even_index_count]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8bq95nke.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8bq95nke.rs:45:9\n   |\n45 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_val = arr[0];\n    let mut min_idx = 1;\n    let mut min_even_val\
    \ = false;\n    for &v in arr {\n        if v % 2 == 0 {\n            if min_even_val\
    \ {\n                if v < min_val {\n                    min_val = v;\n    \
    \                min_idx = min_idx;\n                }\n            } else {\n\
    \                min_even_val = true;\n                min_val = v;\n        \
    \        min_idx = v;\n            }\n        } else {\n            min_even_val\
    \ = false;\n        }\n    }\n    vec![min_val, min_idx]\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfaqb3nbj.rs:30:9\n   |\n\
    30 |     for &v in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `v`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    let mut smallest_even_value = 0;\n    for i\
    \ in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if smallest_value == i {\n                smallest_even_value = i;\n\
    \            }\n            if smallest_value < i {\n                smallest_value\
    \ = i;\n                smallest_index = i;\n            }\n        }\n    }\n\
    \    if even_values.len() == 0 {\n        return vec![];\n    }\n    let mut smallest_even_value_index\
    \ = 0;\n    for i in even_values.iter() {\n        if smallest_even_value == i\
    \ {\n            smallest_even_value_index = i;\n        }\n    }\n    even_values.remove(smallest_even_value_index);\n\
    \    even_values.sort();\n    even_values.dedup();\n    even_values.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeavopn1w.rs:34:34\n   |\n\
    34 |             if smallest_value == i {\n   |                              \
    \    ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n34 |             if smallest_value == *i {\n   |             \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeavopn1w.rs:35:39\n\
    \   |\n30 |     let mut smallest_even_value = 0;\n   |                       \
    \            - expected due to this value\n...\n35 |                 smallest_even_value\
    \ = i;\n   |                                       ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n35 |                 smallest_even_value\
    \ = *i;\n   |                                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeavopn1w.rs:37:33\n   |\n37 |             if smallest_value\
    \ < i {\n   |                                 ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n37 |             if smallest_value\
    \ < *i {\n   |                                 +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpeavopn1w.rs:38:34\n   |\n28 |     let mut smallest_value = arr[0];\n\
    \   |                              ------ expected due to this value\n...\n38\
    \ |                 smallest_value = i;\n   |                                \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n38 |                 smallest_value = *i;\n   |              \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeavopn1w.rs:39:34\n\
    \   |\n29 |     let mut smallest_index = 0;\n   |                            \
    \  - expected due to this value\n...\n39 |                 smallest_index = i;\n\
    \   |                                  ^ expected integer, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n39 |                 smallest_index\
    \ = *i;\n   |                                  +\n\nerror[E0277]: can't compare\
    \ `{integer}` with `&&isize`\n  --> /tmp/tmpeavopn1w.rs:48:32\n   |\n48 |    \
    \     if smallest_even"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 1;\n    let mut min_idx2\
    \ = 1;\n    let mut min_idx3 = 1;\n    let mut min_idx4 = 1;\n    let mut min_idx5\
    \ = 1;\n    let mut min_idx6 = 1;\n    let mut min_idx7 = 1;\n    let mut min_idx8\
    \ = 1;\n    let mut min_idx9 = 1;\n    let mut min_idx10 = 1;\n    let mut min_idx11\
    \ = 1;\n    let mut min_idx12 = 1;\n    let mut min_idx13 = 1;\n    let mut min_idx14\
    \ = 1;\n    let mut min_idx15 = 1;\n    let mut min_idx16 = 1;\n    let mut min_idx17\
    \ = 1;\n    let mut min_idx18 = 1;\n    let mut min_idx19 = 1;\n    let mut min_idx20\
    \ = 1;\n    let mut min_idx21 = 1;\n    let mut min_idx22 = 1;\n    let mut min_idx23\
    \ = 1;\n    let mut min_idx24 = 1;\n    let mut min_idx25 = 1;\n    let mut min_idx26\
    \ = 1;\n    let mut min_idx27 = 1;\n    let mut min_idx28 = 1;\n    let mut min_idx29\
    \ = 1;\n    let mut min_idx30 = 1;\n    let mut min_idx31 = 1;\n    let mut min_idx32\
    \ = 1;\n    let mut min_idx33 = 1;\n    let mut min_idx34 = 1;\n    let mut min_idx35\
    \ = 1;\n    let mut min_idx36 = 1;\n    let mut min_idx37 = 1;\n    let mut min_idx38\
    \ = 1;\n    let mut min_idx39 = 1;\n    let mut min_idx40 = 1;\n    let mut min_idx41\
    \ = 1;\n    let mut min_idx42 = 1;\n    let mut min_idx43 = 1;\n    let mut min_idx44\
    \ = 1;\n    let mut min_idx45 = 1;\n    let mut min_idx46 = 1;\n    let mut min_idx47\
    \ = 1;\n    let mut min_idx48 = 1;\n    let mut min_idx49 = 1;\n    let mut min_idx50\
    \ = 1;\n    let mut min_idx51 = 1;\n    let mut min_idx52 = 1;\n    let mut min_idx53\
    \ = 1;\n    let mut min_idx54 = 1;\n    let mut min_idx55 = 1;\n    let mut min_idx56\
    \ = 1;\n    let mut min_idx57 = 1;\n    let mut min_idx58 = 1;\n    let mut min_idx59\
    \ = 1;\n    let mut min_idx60 = 1;\n    let mut min_idx61 = 1;\n    let mut min_idx62\
    \ = 1;\n    let mut min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5v51ddhq.rs:90:20\n   |\n\
    90 |     let mut min_idx\n   |                    ^ help: add `;` here\n91 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5v51ddhq.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &value in arr {\n        if value %\
    \ 2 == 0 {\n            even_values.push(value);\n        }\n        if value\
    \ < smallest_value {\n            smallest_value = value;\n            smallest_index\
    \ = even_values.len();\n        }\n    }\n    even_values.sort();\n    even_values.dedup();\n\
    \    even_values.retain(|&x| x < smallest_value);\n    even_values.retain(|&x|\
    \ x < smallest_index);\n    even_values\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph19x1hss.rs:30:9\n   |\n\
    30 |     for &value in arr {\n   |         ^^^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `value`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph19x1hss.rs:42:33\n   |\n42 |     even_values.retain(|&x|\
    \ x < smallest_index);\n   |                                 ^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n42 |     even_values.retain(|&x|\
    \ x < smallest_index.try_into().unwrap());\n   |                             \
    \                  ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2\
    \ == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = even_values.iter().position(|x| x < smallest_value);\n\
    \    for i in even_values.iter().rev() {\n        if i % 2 == 0 {\n          \
    \  if i < smallest_value {\n                smallest_value = i;\n            \
    \    smallest_index = i;\n            }\n        } else {\n            if i <\
    \ smallest_even_value {\n                smallest_even_value = i;\n          \
    \      smallest_even_index = i;\n            }\n        }\n    }\n    vec![smallest_value,\
    \ smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuupf4jub.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpuupf4jub.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpuupf4jub.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuupf4jub.rs:43:71\n  \
    \ |\n43 |     let mut smallest_even_index = even_values.iter().position(|x| x\
    \ < smallest_value);\n   |                                                   \
    \                    ^^^^^^^^^^^^^^ expected `&&isize`, found `isize`\n\nerror[E0369]:\
    \ cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpuupf4jub.rs:45:14\n   |\n\
    45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |          \
    \  |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`, you can\
    \ dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |            +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpuupf4jub.rs:46:20\n   |\n46 |  \
    \           if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^ expected\
    \ `&&isize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuupf4jub.rs:47:34\n\
    \   |\n28 |     let mut smallest_value = arr[0];\n   |      "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &x in arr {\n        if x % 2 == 0 {\n\
    \            even_values.push(x);\n            if x < smallest_value {\n     \
    \           smallest_value = x;\n                smallest_index = even_values.len()\
    \ - 1;\n            }\n        }\n    }\n    even_values.sort();\n    even_values.dedup();\n\
    \    let mut result = Vec::new();\n    for &x in even_values {\n        result.push(x);\n\
    \    }\n    if even_values.len() == 0 {\n        return result;\n    }\n    let\
    \ mut smallest_value = even_values[0];\n    let mut smallest_index = 0;\n    for\
    \ &x in even_values {\n        if x < smallest_value {\n            smallest_value\
    \ = x;\n            smallest_index = even_values.len() - 1;\n        }\n    }\n\
    \    result.push(smallest_value);\n    result.push(smallest_index);\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp18q1g80j.rs:30:9\n   |\n\
    30 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp18q1g80j.rs:42:9\n   |\n42 |     for &x in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp18q1g80j.rs:50:9\n   |\n50 |     for &x in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp18q1g80j.rs:57:17\n   |\n57 |     result.push(smallest_index);\n\
    \   |                 ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n57 |     result.push(smallest_index.try_into().unwrap());\n   | \
    \                              ++++++++++++++++++++\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx2\
    \ = -1;\n    let mut min_idx3 = -1;\n    let mut min_idx4 = -1;\n    let mut min_idx5\
    \ = -1;\n    let mut min_idx6 = -1;\n    let mut min_idx7 = -1;\n    let mut min_idx8\
    \ = -1;\n    let mut min_idx9 = -1;\n    let mut min_idx10 = -1;\n    let mut\
    \ min_idx11 = -1;\n    let mut min_idx12 = -1;\n    let mut min_idx13 = -1;\n\
    \    let mut min_idx14 = -1;\n    let mut min_idx15 = -1;\n    let mut min_idx16\
    \ = -1;\n    let mut min_idx17 = -1;\n    let mut min_idx18 = -1;\n    let mut\
    \ min_idx19 = -1;\n    let mut min_idx20 = -1;\n    let mut min_idx21 = -1;\n\
    \    let mut min_idx22 = -1;\n    let mut min_idx23 = -1;\n    let mut min_idx24\
    \ = -1;\n    let mut min_idx25 = -1;\n    let mut min_idx26 = -1;\n    let mut\
    \ min_idx27 = -1;\n    let mut min_idx28 = -1;\n    let mut min_idx29 = -1;\n\
    \    let mut min_idx30 = -1;\n    let mut min_idx31 = -1;\n    let mut min_idx32\
    \ = -1;\n    let mut min_idx33 = -1;\n    let mut min_idx34 = -1;\n    let mut\
    \ min_idx35 = -1;\n    let mut min_idx36 = -1;\n    let mut min_idx37 = -1;\n\
    \    let mut min_idx38 = -1;\n    let mut min_idx39 = -1;\n    let mut min_idx40\
    \ = -1;\n    let mut min_idx41 = -1;\n    let mut min_idx42 = -1;\n    let mut\
    \ min_idx43 = -1;\n    let mut min_idx44 = -1;\n    let mut min_idx45 = -1;\n\
    \    let mut min_idx46 = -1;\n    let mut min_idx47 = -1;\n    let mut min_idx48\
    \ = -1;\n    let mut min_idx49 = -1;\n    let mut min_idx50 = -1;\n    let mut\
    \ min_idx51 = -1;\n    let mut min_idx52 = -1;\n    let mut min_idx53 = -1;\n\
    \    let mut min_idx54 = -1;\n    let mut min_idx55 = -1;\n    let mut min_idx56\
    \ = -1;\n    let mut min_idx57 = -1;\n    let mut min_\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb1net3b9.rs:85:17\n   |\n\
    85 |     let mut min_\n   |                 ^ help: add `;` here\n86 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb1net3b9.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![0; arr.len()];\n    let mut min_value = arr[0];\n\
    \    let mut min_idx = 0;\n    for i in 0..arr.len() {\n        if arr[i] % 2\
    \ == 0 {\n            even_values[i] = 1;\n            if arr[i] < min_value {\n\
    \                min_value = arr[i];\n                min_idx = i;\n         \
    \   }\n        } else {\n            even_values[i] = 0;\n        }\n    }\n \
    \   let mut result = vec![min_value; arr.len()];\n    for i in 0..arr.len() {\n\
    \        if even_values[i] == 1 {\n            result[i] = min_idx;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps79a7kw_.rs:44:25\n   |\n\
    44 |             result[i] = min_idx;\n   |             ---------   ^^^^^^^ expected\
    \ `isize`, found `usize`\n   |             |\n   |             expected due to\
    \ the type of this binding\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values.push(i);\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.is_empty() {\n   \
    \     return vec![];\n    }\n    let mut smallest_value_even = even_values[0];\n\
    \    let mut smallest_index_even = 0;\n    for i in 0..even_values.len() {\n \
    \       if even_values[i] < smallest_value_even {\n            smallest_value_even\
    \ = even_values[i];\n            smallest_index_even = i;\n        }\n    }\n\
    \    smallest_value_even\n        .clone()\n        .unwrap()\n        .clone()\n\
    \        .unwrap()\n        .clone()\n        .unwrap()\n        .clone()\n  \
    \      .unwrap()\n        .clone()\n        .unwrap()\n        .clone()\n    \
    \    .unwrap()\n        .clone()\n        .unwrap()\n        .clone()\n      \
    \  .unwrap()\n        .clone()\n        .unwrap()\n        .clone()\n        .unwrap()\n\
    \        .clone()\n        .unwrap()\n        .clone()\n        .unwrap()\n  \
    \      .clone()\n        .unwrap()\n        .clone()\n        .unwrap()\n    \
    \    .clone()\n        .unwrap()\n        .clone()\n        .unwrap()\n      \
    \  .clone()\n        .unwrap()\n        .clone()\n        .unwrap()\n        .clone()\n\
    \        .unwrap()\n        .clone()\n        .unwrap()\n        .clone()\n  \
    \      .unwrap()\n        .clone()\n        .unwrap()\n        .clone()\n    \
    \    .unwrap()\n        .clone()\n        .unwrap()\n        .clone()\n      \
    \  .unwrap()\n        .clone()\n        .unwrap()\n        .clone()\n        .unwrap()\n\
    \        .clone()\n        .unwrap()\n        .clone()\n        .unwrap()\n  \
    \      .clone()\n        .unwrap()\n        .clone()\n        .unwrap()\n    \
    \    .clone()\n        .unwrap()\n        .clone()\n        .unwrap()\n      \
    \  .clone()\n        .unwrap()\n        .clone()\n        .unwrap()\n        .clone()\n\
    \        .unwrap()\n        .clone()\n        .unwrap()\n        .clone()\n  \
    \      .unwrap()\n        .clone()\n        .unwrap()\n        .clone()\n    \
    \    .unwrap()\n        .clone()\n        .unwrap()\n        .clone()\n      \
    \  .unwrap()\n        .clone()\n        .unwrap()\n        .clone()\n        .unwrap()\n\
    \        .clone()\n        .unwrap()\n        .clone()\n        .unwrap()\n  \
    \      .clone()\n        .unwrap()\n        .clone()\n        .unwrap()\n    \
    \    .clone()\n        .unwrap()\n        .clone()\n        .unwrap()\n      \
    \  .clone()\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpd6ov782n.rs:52:10\n   |\n52 |         .unwrap()\n   | \
    \         ^^^^^^ method not found in `usize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    even_values.sort_unstable();\n    let mut even_values_iter\
    \ = even_values.iter();\n    if even_values_iter.next().unwrap() == smallest_value\
    \ {\n        even_values_iter.next();\n    }\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut even_values_iter = even_values.iter();\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_value\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgbc10s0a.rs:74:42\n   |\n\
    74 |     let mut even_values_iter = even_value\n   |                         \
    \                 ^ help: add `;` here\n75 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `even_value` in this scope\n  --> /tmp/tmpgbc10s0a.rs:74:32\n\
    \   |\n74 |     let mut even_values_iter = even_value\n   |                  \
    \              ^^^^^^^^^^ help: a local variable with a similar name exists: `even_values`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgbc10s0a.rs:30:9\n   |\n30 | \
    \    for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `isize`\n  --> /tmp/tmpgbc10s0a.rs:41:41\n   |\n41 |     if even_values_iter.next().unwrap()\
    \ == smallest_value {\n   |                                         ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpgbc10s0a.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |    -----                     ^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \    found unit type `()`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut min_value = isize::MAX;\n\
    \    let mut min_index = isize::MAX;\n    for &i in arr {\n        if i % 2 ==\
    \ 0 {\n            even_values.push(i);\n            if i < min_value {\n    \
    \            min_value = i;\n                min_index = i;\n            }\n \
    \       }\n    }\n    if even_values.is_empty() {\n        return vec![];\n  \
    \  }\n    let mut even_values_iter = even_values.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut even_values_iter = even_values_iter.in\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `in`\n  --> /tmp/tmpfkxwewa5.rs:58:49\n\
    \   |\n58 |     let mut even_values_iter = even_values_iter.in\n   |         \
    \                                        ^^ expected identifier, found keyword\n\
    \   |\nhelp: escape `in` to use it as an identifier\n   |\n58 |     let mut even_values_iter\
    \ = even_values_iter.r#in\n   |                                              \
    \   ++\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpfkxwewa5.rs:58:51\n  \
    \ |\n58 |     let mut even_values_iter = even_values_iter.in\n   |           \
    \                                        ^ help: add `;` here\n59 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfkxwewa5.rs:30:9\n\
    \   |\n30 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0271]:\
    \ type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item == &_`\n\
    \    --> /tmp/tmpfkxwewa5.rs:43:61\n     |\n43   |     let mut even_values_iter\
    \ = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n     |       \
    \                                                      ^^^^^^ expected reference,\
    \ found `isize`\n     |\n     = note: expected reference `&_`\n              \
    \       found type `isize`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpfkxwewa5.rs:43:70\n \
    \  |\n43 |       let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                                                        ^^^^^^^\
    \ method cannot be called on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<std::vec::IntoIter<isize> as Iterator>::Item = &_`\n           which\
    \ is requi"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values.push(arr[i]);\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = 0;\n    for i in 0..even_values.len() {\n \
    \       if even_values[i] < smallest_even_value {\n            smallest_even_value\
    \ = even_values[i];\n            smallest_even_index = i;\n        }\n    }\n\
    \    let mut result = vec![];\n    for i in 0..even_values.len() {\n        if\
    \ even_values[i] == smallest_even_value {\n            result.push(i);\n     \
    \   }\n    }\n    if result.len() == 0 {\n        return vec![];\n    }\n    let\
    \ mut smallest_index = result.len();\n    for i in 0..result.len() {\n       \
    \ if result[i] < smallest_index {\n            smallest_index = result[i];\n \
    \       }\n    }\n    let mut result = vec![];\n    for i in 0..result.len() {\n\
    \        if result[i] == smallest_index {\n            result.push(i);\n     \
    \   }\n    }\n    if result.len() == 0 {\n        return vec![];\n    }\n    let\
    \ mut smallest_value = even_values[smallest_even_index];\n    for i in 0..result.len()\
    \ {\n        if result[i] == smallest_index {\n            result.push(i);\n \
    \       }\n    }\n    if result.len() == 0 {\n        return vec![];\n    }\n\
    \    for i in 0..result.len() {\n        if result[i] == smallest_index {\n  \
    \          result.push(i);\n        }\n    }\n    if result.len() == 0 {\n   \
    \     return vec![];\n    }\n    for i in 0..result.len() {\n        if result[i]\
    \ == smallest_index {\n            result.push(i);\n        }\n    }\n    if result.len()\
    \ == 0 {\n        return vec![];\n    }\n    for i in 0..result.len() {\n    \
    \    if result[i] == smallest_index {\n            result.push(i);\n        }\n\
    \    }\n    if result.len() == 0 {\n        return vec![];\n    }\n    for i in\
    \ 0..result.len() {\n        if result[i] == smallest_index {\n            result.push(i);\n\
    \        }\n    }\n    if result.len() == 0 {\n        return vec![];\n    }\n\
    \    for i in 0..result.len() {\n        if result[i] == smallest_index {\n  \
    \          result.push(i);\n        }\n    }\n    if result.len() == 0 {\n   \
    \     return vec![];\n\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpsimiw70o.rs:135:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n120 |     if result.len()\
    \ == 0 {\n    |                          - this delimiter might not be properly\
    \ closed...\n...\n123 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n135 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsimiw70o.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |    -----                     ^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_value = arr[0];\n    let mut\
    \ min_index = -1;\n    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n\
    \            even_values.push(arr[i]);\n            if arr[i] < min_value {\n\
    \                min_value = arr[i];\n                min_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_value = even_values[0];\n    let mut smallest_index\
    \ = -1;\n    for i in 0..even_values.len() {\n        if even_values[i] < smallest_value\
    \ {\n            smallest_value = even_values[i];\n            smallest_index\
    \ = i;\n        }\n    }\n    let mut result = vec![];\n    for i in 0..even_values.len()\
    \ {\n        if even_values[i] == smallest_value {\n            result.push(i);\n\
    \        }\n    }\n    if result.len() == 0 {\n        return vec![];\n    }\n\
    \    result.push(smallest_index);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp1we_a8_c.rs:29:25\n\
    \   |\n29 |     let mut min_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmp1we_a8_c.rs:43:30\n   |\n43 | \
    \    let mut smallest_index = -1;\n   |                              ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1we_a8_c.rs:60:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n60 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<usize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![0; arr.len()];\n    let mut smallest_value = vec![0;\
    \ arr.len()];\n    let mut smallest_index = vec![0; arr.len()];\n    for i in\
    \ 0..arr.len() {\n        even_values[i] = arr[i] % 2 == 0;\n        if even_values[i]\
    \ {\n            smallest_value[i] = arr[i];\n            smallest_index[i] =\
    \ i;\n        }\n    }\n    if even_values.iter().any(|&x| x == false) {\n   \
    \     return vec![];\n    }\n    if smallest_value.iter().any(|&x| x == 0) {\n\
    \        return vec![];\n    }\n    if smallest_value.iter().any(|&x| x == 1)\
    \ {\n        return vec![];\n    }\n    for i in 0..arr.len() {\n        if smallest_value[i]\
    \ == 0 {\n            smallest_value[i] = smallest_value[smallest_index[i]];\n\
    \            smallest_index[i] = smallest_index[smallest_index[i]];\n        }\n\
    \    }\n    for i in 0..arr.len() {\n        if smallest_value[i] == 1 {\n   \
    \         smallest_value[i] = smallest_value[smallest_index[i]];\n           \
    \ smallest_index[i] = smallest_index[smallest_index[i]];\n        }\n    }\n \
    \   for i in 0..arr.len() {\n        if smallest_value[i] == 2 {\n           \
    \ smallest_value[i] = smallest_value[smallest_index[i]];\n            smallest_index[i]\
    \ = smallest_index[smallest_index[i]];\n        }\n    }\n    for i in 0..arr.len()\
    \ {\n        if smallest_value[i] == 3 {\n            smallest_value[i] = smallest_value[smallest_index[i]];\n\
    \            smallest_index[i] = smallest_index[smallest_index[i]];\n        }\n\
    \    }\n    for i in 0..arr.len() {\n        if smallest_value[i] == 4 {\n   \
    \         smallest_value[i] = smallest_value[smallest_index[i]];\n           \
    \ smallest_index[i] = smallest_index[smallest_index[i]];\n        }\n    }\n \
    \   for i in 0..arr.len() {\n        if smallest_value[i] == 5 {\n           \
    \ smallest_value[i] = smallest_value[smallest_index[i]];\n            smallest_index[i]\
    \ = smallest_index[smallest_index[i]];\n        }\n    }\n    for i in 0..arr.len()\
    \ {\n        if smallest_value[i] == 6 {\n            smallest_value[i] = smallest_value[smallest_index[i]];\n\
    \            smallest_index[i] = smallest_index[smallest_index[i]];\n        }\n\
    \    }\n    for i in 0..arr.len() {\n        if smallest_value[i] == 7 {\n   \
    \         smallest_value[i] = smallest_value[smallest_index[i]];\n\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0aeghdat.rs:104:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n88  |     for i in 0..arr.len()\
    \ {\n    |                           - unclosed delimiter\n89  |         if smallest_value[i]\
    \ == 7 {\n    |                                   - this delimiter might not be\
    \ properly closed...\n...\n92  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n104 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0aeghdat.rs:31:26\n   |\n31 |         even_values[i] = arr[i] % 2 ==\
    \ 0;\n   |         --------------   ^^^^^^^^^^^^^^^ expected integer, found `bool`\n\
    \   |         |\n   |         expected due to the type of this binding\n\nerror[E0271]:\
    \ type mismatch resolving `<usize as SliceIndex<[{integer}]>>::Output == bool`\n\
    \  --> /tmp/tmp0aeghdat.rs:32:12\n   |\n32 |         if even_values[i] {\n   |\
    \            ^^^^^^^^^^^^^^ expected integer, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0aeghdat.rs:37:41\n   |\n37 |     if even_values.iter().any(|&x|\
    \ x == false) {\n   |                                         ^^^^^ expected integer,\
    \ found `bool`\n\nerror[E0277]: can't compare `{integer}` with `bool`\n  --> /tmp/tmp0aeghdat.rs:37:38\n\
    \   |\n37 |     if even_values.iter().any(|&x| x == false) {\n   |           \
    \                           ^^ no implementation for `{integer} == bool`\n   |\n\
    \   = help: the trait `PartialEq<bool>` is not implemented for `{integer}`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        f32\n             f64\n             i128\n             i16\n        \
    \     i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror[E0308]: mismatched types\n   --> /tmp/tmp0aeghdat.rs:88:5\n\
    \    |\n26  |   fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |             \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    ...\n88  | /     for i in 0..arr.len() {\n89  | |         if smallest_value[i]\
    \ == "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_value = arr[0];\n    let mut\
    \ min_value_index = -1;\n    for i in 0..arr.len() {\n        if arr[i] % 2 ==\
    \ 0 {\n            even_values.push(arr[i]);\n            if arr[i] < min_value\
    \ {\n                min_value = arr[i];\n                min_value_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_value = min_value;\n    let mut smallest_value_index\
    \ = min_value_index;\n    for i in 0..even_values.len() {\n        if even_values[i]\
    \ < smallest_value {\n            smallest_value = even_values[i];\n         \
    \   smallest_value_index = i;\n        }\n    }\n    let mut result = vec![];\n\
    \    for i in 0..even_values.len() {\n        if i == smallest_value_index {\n\
    \            result.push(smallest_value);\n        } else {\n            result.push(even_values[i]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpax23y_0y.rs:29:31\n\
    \   |\n29 |     let mut min_value_index = -1;\n   |                          \
    \     ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut smallest_index_value = arr[0];\n\
    \    for i in arr.iter_mut() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if smallest_index_value % 2 == 0 {\n                smallest_index_value\
    \ = i;\n            }\n        } else {\n            if smallest_value < i {\n\
    \                smallest_value = i;\n                smallest_index = i;\n  \
    \          }\n        }\n    }\n    even_values.sort_unstable();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `even` in this scope\n  --> /tmp/tmp9eujp8_4.rs:95:5\n\
    \   |\n95 |     even\n   |     ^^^^ not found in this scope\n\nerror[E0369]: cannot\
    \ mod `&mut isize` by `{integer}`\n  --> /tmp/tmp9eujp8_4.rs:32:14\n   |\n32 |\
    \         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |            |\n\
    \   |            &mut isize\n   |\nhelp: `%` can be used on `isize`, you can dereference\
    \ `i`\n   |\n32 |         if *i % 2 == 0 {\n   |            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9eujp8_4.rs:35:40\n   |\n30 |     let mut smallest_index_value\
    \ = arr[0];\n   |                                    ------ expected due to this\
    \ value\n...\n35 |                 smallest_index_value = i;\n   |           \
    \                             ^ expected `isize`, found `&mut isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n35 |                 smallest_index_value\
    \ = *i;\n   |                                        +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9eujp8_4.rs:38:33\n   |\n38 |             if smallest_value\
    \ < i {\n   |                                 ^ expected `isize`, found `&mut\
    \ isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n38 |          \
    \   if smallest_value < *i {\n   |                                 +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9eujp8_4.rs:39:34\n   |\n28 |     let mut smallest_value\
    \ = arr[0];\n   |                              ------ expected due to this value\n\
    ...\n39 |                 smallest_value = i;\n   |                          \
    \        ^ expected `isize`, found `&mut isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n39 |                 smallest_value = *i;\n   |          \
    \                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9eujp8_4.rs:40:34\n\
    \   |\n29 |     let mut smallest_index = 0;\n   |                            \
    \  - expected due to this value\n...\n40 |                 smallest_index = i;\n\
    \   |                                  ^ expected integer, found `&mut isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n40 |                 smallest_inde"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    for &i in arr\
    \ {\n        if i % 2 == 0 {\n            if min_value < i {\n               \
    \ min_value = i;\n                min_idx = i;\n            }\n        }\n   \
    \ }\n    let mut result: Vec<isize> = vec![];\n    if min_idx != 0 {\n       \
    \ result.push(min_value);\n        result.push(min_idx);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaf1czd1y.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut min_value = arr[0];\n    let\
    \ mut min_value_index = -1;\n    let mut min_value_index2 = -1;\n    for i in\
    \ 0..arr.len() {\n        if arr[i] % 2 == 0 {\n            even_values.push(i);\n\
    \            if arr[i] < min_value {\n                min_value = arr[i];\n  \
    \              min_value_index = i;\n            }\n            if arr[i] == min_value\
    \ {\n                min_value_index2 = i;\n            }\n        }\n    }\n\
    \    if even_values.len() == 0 {\n        return vec![];\n    }\n    if min_value_index2\
    \ == min_value_index {\n        return vec![min_value_index];\n    }\n    if min_value_index2\
    \ < min_value_index {\n        return vec![min_value_index2];\n    }\n    return\
    \ vec![min_value_index, min_value_index2];\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpo2wi7xw5.rs:29:31\n\
    \   |\n29 |     let mut min_value_index = -1;\n   |                          \
    \     ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpo2wi7xw5.rs:30:32\n\
    \   |\n30 |     let mut min_value_index2 = -1;\n   |                         \
    \       ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpo2wi7xw5.rs:47:21\n   |\n47 |  \
    \       return vec![min_value_index];\n   |                     ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n47 |         return\
    \ vec![min_value_index.try_into().unwrap()];\n   |                           \
    \         ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo2wi7xw5.rs:50:21\n\
    \   |\n50 |         return vec![min_value_index2];\n   |                     ^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n50 |         return\
    \ vec![min_value_index2.try_into().unwrap()];\n   |                          \
    \           ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo2wi7xw5.rs:52:17\n\
    \   |\n52 |     return vec![min_value_index, min_value_index2];\n   |        \
    \         ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n52 |     retu"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_index = 0;\n    let mut min_even_value\
    \ = false;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n            if\
    \ min_even_value{\n                min_value = i;\n                min_even_value\
    \ = false;\n            }\n            else{\n                min_even_value =\
    \ true;\n            }\n        }\n        else{\n            if min_value ==\
    \ i {\n                min_index += 1;\n            }\n        }\n    }\n    if\
    \ min_even_value{\n        min_value = min_value + 1;\n    }\n    let mut result\
    \ = vec![min_value, min_index];\n    return result;\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1_1asf0t.rs:33:29\n   |\n\
    27 |     let mut min_value = arr[0];\n   |                         ------ expected\
    \ due to this value\n...\n33 |                 min_value = i;\n   |          \
    \                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1_1asf0t.rs:41:29\n\
    \   |\n41 |             if min_value == i {\n   |                            \
    \ ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n41 |             if min_value == *i {\n   |                           \
    \  +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter().rev() {\n        if i %\
    \ 2 == 0 {\n            even_values.push(i);\n            if smallest_value <\
    \ i {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = even_values.iter().next().unwrap();\n    for i in even_values.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if smallest_even_value < i {\n     \
    \           smallest_even_value = i;\n                smallest_even_index = i;\n\
    \            }\n        }\n    }\n    let mut result = vec![];\n    for i in even_values.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            result.push(i);\n        }\n    }\n\
    \    result.push(smallest_even_index);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkt0uewb9.rs:33:33\n   |\n\
    33 |             if smallest_value < i {\n   |                               \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n33 |             if smallest_value < *i {\n   |              \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkt0uewb9.rs:34:34\n\
    \   |\n28 |     let mut smallest_value = arr[0];\n   |                       \
    \       ------ expected due to this value\n...\n34 |                 smallest_value\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkt0uewb9.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpkt0uewb9.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpkt0uewb9.rs:54:14\n\
    \   |\n54 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n54 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkt0uewb9.rs:59:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n59 |     result\n\
    \   |     ^^^^^^ expected `isize`, found `&&isize`"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = -1;\n    for &i in arr\
    \ {\n        if i % 2 == 0 {\n            if min_value == i {\n              \
    \  min_idx = i;\n            } else {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw5cr2ssg.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value: isize = 0;\n    let mut min_even_index: usize = 0;\n\
    \    let mut min_value: isize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp520bf3ba.rs:83:17\n   |\n\
    83 |     let mut min_\n   |                 ^ help: add `;` here\n84 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp520bf3ba.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_index = -1;\n    for i in arr {\n        if i % 2 == 0 {\n         \
    \   even_values.push(i);\n            if i < min_value {\n                min_value\
    \ = i;\n                min_index = i;\n            }\n        }\n    }\n    if\
    \ even_values.is_empty() {\n        return vec![];\n    }\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n    let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `)`\n  --> /tmp/tmpw7n6w0gt.rs:60:1\n\
    \   |\n60 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpw7n6w0gt.rs:59:67\n   |\n26 | fn pluck(arr: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                         - closing delimiter\
    \ possibly meant for this\n...\n59 |     let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| \n   |                                                                 \
    \  ^ unclosed delimiter\n60 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw7n6w0gt.rs:33:20\n   |\n33 |             if\
    \ i < min_value {\n   |                    ^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n33 |             if i < min_value.try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw7n6w0gt.rs:34:29\n   |\n28 |     let mut min_value = i32::MAX;\n\
    \   |                         -------- expected due to this value\n...\n34 | \
    \                min_value = i;\n   |                             ^ expected `i32`,\
    \ found `isize`\n\nerror[E0369]: cannot mod `(usize, &isize)` by `{integer}`\n\
    \  --> /tmp/tmpw7n6w0gt.rs:44:80\n   |\n44 |     let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n   |                                                     \
    \                         - ^ - {integer}\n   |                              \
    \                                                |\n   |                     \
    \                                                         (usize, &isize)\n\n\
    error[E0369]: cannot mod `(usize, (usize, &isize))` by `{integer}`\n  --> /tmp/tmpw7n6w0gt.rs:45:80\n\
    \   |\n45 |     let mut even_values_iter = even_values_iter.enumerate().filter(|&(_,\
    \ v)| v % 2 == 0);\n   |                                                     \
    \                         - ^ - {integer}\n   |                              \
    \                                           "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_value {\n            min_value = arr[i];\n      \
    \      min_idx = i;\n        }\n    }\n    let mut result = vec![];\n    for i\
    \ in 0..arr.len() {\n        if arr[i] == min_value {\n            result.push(min_idx);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpawmlv_lh.rs:41:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n41 |     result\n\
    \   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2 ==\
    \ 0 {\n            even_values.push(i);\n            if i < smallest_value {\n\
    \                smallest_value = i;\n                smallest_index = i;\n  \
    \          }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = even_values[0];\n    for i in even_values.iter() {\n \
    \       if i < smallest_even_value {\n            smallest_even_value = i;\n \
    \           smallest_even_index = i;\n        }\n    }\n    let mut result = vec![];\n\
    \    for i in arr.iter() {\n        if i == smallest_value {\n            result.push(smallest_even_index);\n\
    \        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppnjdtwz4.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmppnjdtwz4.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppnjdtwz4.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppnjdtwz4.rs:45:16\n  \
    \ |\n45 |         if i < smallest_even_value {\n   |                ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmppnjdtwz4.rs:52:14\n   |\n52 |         if i == smallest_value\
    \ {\n   |              ^^ no implementation for `&isize == isize`\n   |\n   =\
    \ help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppnjdtwz4.rs:56:12\n   |\n26 |\
    \ fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |           "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx2\
    \ = 0;\n    let mut min_idx3 = 0;\n    let mut min_idx4 = 0;\n    let mut min_idx5\
    \ = 0;\n    let mut min_idx6 = 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8\
    \ = 0;\n    let mut min_idx9 = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11\
    \ = 0;\n    let mut min_idx12 = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14\
    \ = 0;\n    let mut min_idx15 = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17\
    \ = 0;\n    let mut min_idx18 = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20\
    \ = 0;\n    let mut min_idx21 = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23\
    \ = 0;\n    let mut min_idx24 = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26\
    \ = 0;\n    let mut min_idx27 = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29\
    \ = 0;\n    let mut min_idx30 = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32\
    \ = 0;\n    let mut min_idx33 = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35\
    \ = 0;\n    let mut min_idx36 = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38\
    \ = 0;\n    let mut min_idx39 = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41\
    \ = 0;\n    let mut min_idx42 = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44\
    \ = 0;\n    let mut min_idx45 = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47\
    \ = 0;\n    let mut min_idx48 = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50\
    \ = 0;\n    let mut min_idx51 = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53\
    \ = 0;\n    let mut min_idx54 = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56\
    \ = 0;\n    let mut min_idx57 = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59\
    \ = 0;\n    let mut min_idx60 = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62\
    \ = 0;\n    let mut min_idx63 = 0;\n    let mut min_idx\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt5yzunhs.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt5yzunhs.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut min_value = i32::MAX;\n  \
    \  let mut min_index = -1;\n    for &i in arr {\n        if i % 2 == 0 {\n   \
    \         even_values.push(i);\n            if i < min_value {\n             \
    \   min_value = i;\n                min_index = i;\n            }\n        }\n\
    \    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    let\
    \ mut smallest_value = even_values[0];\n    let mut smallest_index = -1;\n   \
    \ for i in even_values {\n        if i == smallest_value {\n            smallest_index\
    \ = i;\n        }\n    }\n    let mut result = vec![];\n    for i in even_values\
    \ {\n        if i == smallest_value {\n            result.push(smallest_index);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwxi5gaun.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwxi5gaun.rs:55:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n55 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct\
    \ `Vec<i32>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2\
    \ == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    even_values.sort();\n    let mut result\
    \ = Vec::new();\n    for i in even_values {\n        if i == smallest_value {\n\
    \            result.push(smallest_index);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsy3h8w16.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpsy3h8w16.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsy3h8w16.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpsy3h8w16.rs:42:14\n\
    \   |\n42 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &x in arr {\n        if x % 2 == 0 {\n\
    \            even_values.push(x);\n        }\n        if x < smallest_value {\n\
    \            smallest_value = x;\n            smallest_index = even_values.len();\n\
    \        }\n    }\n    even_values.sort();\n    even_values.dedup();\n    even_values.reverse();\n\
    \    even_values.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu1iwjpl3.rs:30:9\n   |\n\
    30 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even_value = arr[0];\n    let mut smallest_even_index =\
    \ -1;\n    let mut smallest_index = -1;\n    for i in arr.iter().rev() {\n   \
    \     if i % 2 == 0 {\n            if smallest_even_value < i {\n            \
    \    smallest_even_value = i;\n                smallest_even_index = i;\n    \
    \        }\n        } else {\n            if smallest_index == -1 || smallest_even_value\
    \ < i {\n                smallest_index = i;\n            }\n        }\n    }\n\
    \    smallest_even_index.into()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ypu4ba9.rs:32:38\n   |\n\
    32 |             if smallest_even_value < i {\n   |                          \
    \            ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n32 |             if smallest_even_value < *i {\n   |     \
    \                                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ypu4ba9.rs:33:39\n\
    \   |\n27 |     let mut smallest_even_value = arr[0];\n   |                  \
    \                 ------ expected due to this value\n...\n33 |               \
    \  smallest_even_value = i;\n   |                                       ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 smallest_even_value = *i;\n   |                         \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ypu4ba9.rs:34:39\n\
    \   |\n28 |     let mut smallest_even_index = -1;\n   |                      \
    \             -- expected due to this value\n...\n34 |                 smallest_even_index\
    \ = i;\n   |                                       ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_even_index\
    \ = *i;\n   |                                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2ypu4ba9.rs:37:62\n   |\n37 |             if smallest_index\
    \ == -1 || smallest_even_value < i {\n   |                                   \
    \                           ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n37 |             if smallest_index == -1 ||\
    \ smallest_even_value < *i {\n   |                                           \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ypu4ba9.rs:38:34\n\
    \   |\n29 |     let mut smallest_index = -1;\n   |                           \
    \   -- expected due to this value\n...\n38 |                 smallest_index =\
    \ i;\n   |                                  ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n38 |                 smallest_index\
    \ = "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_value = arr[0];\n    let mut\
    \ min_value_index = -1;\n    for i in 0..arr.len() {\n        if arr[i] % 2 ==\
    \ 0 {\n            even_values.push(arr[i]);\n            if arr[i] < min_value\
    \ {\n                min_value = arr[i];\n                min_value_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut min_even_value = even_values[0];\n    let mut min_even_value_index\
    \ = -1;\n    for i in 0..even_values.len() {\n        if even_values[i] < min_even_value\
    \ {\n            min_even_value = even_values[i];\n            min_even_value_index\
    \ = i;\n        }\n    }\n    let mut result = vec![];\n    for i in 0..arr.len()\
    \ {\n        if arr[i] == min_even_value_index {\n            result.push(min_even_value);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp5rdirc93.rs:29:31\n\
    \   |\n29 |     let mut min_value_index = -1;\n   |                          \
    \     ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp5rdirc93.rs:43:36\n\
    \   |\n43 |     let mut min_even_value_index = -1;\n   |                     \
    \               ^^ the trait `Neg` is not implemented for `usize`\n   |\n   =\
    \ help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5rdirc93.rs:52:22\n   |\n52 |\
    \         if arr[i] == min_even_value_index {\n   |                      ^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n52 |         if\
    \ arr[i] == min_even_value_index.try_into().unwrap() {\n   |                 \
    \                         ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = arr[0];\n    let mut min_even_index = -1;\n    let\
    \ mut min_even_index_in_list = -1;\n    let mut even_values_found = false;\n \
    \   for &mut x in arr {\n        if x % 2 == 0 {\n            min_even_value =\
    \ x;\n            even_values_found = true;\n        }\n        if even_values_found\
    \ {\n            if x < min_even_value{\n                min_even_value = x;\n\
    \                min_even_index = x;\n                min_even_index_in_list =\
    \ x;\n            }\n        }\n    }\n    if min_even_index == -1 {\n       \
    \ return vec![];\n    }\n    let mut even_values_found = false;\n    let mut even_values_index\
    \ = -1;\n    let mut even_values_index_in_list = -1;\n    for &mut x in arr {\n\
    \        if x % 2 == 0 {\n            even_values_found = true;\n            if\
    \ x < min_even_value{\n                min_even_value = x;\n                even_values_index\
    \ = x;\n                even_values_index_in_list = x;\n            }\n      \
    \  }\n        if even_values_found {\n            if x < min_even_value{\n   \
    \             min_even_value = x;\n                even_values_index = x;\n  \
    \              even_values_index_in_list = x;\n            }\n        }\n    }\n\
    \    if even_values_found {\n        return vec![min_even_value,even_values_index,even_values_index_in_list];\n\
    \    }\n    return vec![];\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphc5uynsw.rs:31:9\n   |\n\
    31 |     for &mut x in arr {\n   |         ^^^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found `&mut\
    \ _`\n   |         help: you can probably remove the explicit borrow: `x`\n  \
    \ |\n   = note:           expected type `isize`\n           found mutable reference\
    \ `&mut _`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphc5uynsw.rs:50:9\n\
    \   |\n50 |     for &mut x in arr {\n   |         ^^^^^^    --- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ `&mut _`\n   |         help: you can probably remove the explicit borrow: `x`\n\
    \   |\n   = note:           expected type `isize`\n           found mutable reference\
    \ `&mut _`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even_value = arr[0];\n    let mut smallest_even_index =\
    \ -1;\n    let mut smallest_index = -1;\n    let mut even_values = Vec::new();\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if i == smallest_even_value {\n            smallest_even_index\
    \ = arr.iter().position(|&i| i == smallest_even_value).unwrap();\n           \
    \ smallest_even_value = i;\n        }\n        if i == smallest_index {\n    \
    \        smallest_index = arr.iter().position(|&i| i == smallest_index).unwrap();\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = -1;\n    let mut smallest_index = -1;\n    for &i in even_values {\n     \
    \   if i == smallest_even_value {\n            smallest_even_index = even_values.iter().position(|&i|\
    \ i == smallest_even_value).unwrap();\n            smallest_even_value = i;\n\
    \        }\n        if i == smallest_index {\n            smallest_index = even_values.iter().position(|&i|\
    \ i == smallest_index).unwrap();\n        }\n    }\n    let mut result = vec![];\n\
    \    if smallest_even_index == -1 {\n        return result;\n    }\n    for i\
    \ in 0..arr.len() {\n        if i == smallest_even_index {\n            result.push(smallest_even_value);\n\
    \            break;\n        }\n    }\n    if result.len() == 0 {\n        return\
    \ result;\n    }\n    for i in 0..result.len() {\n        if i == smallest_index\
    \ {\n            result.push(smallest_index);\n            break;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvs_3gsvm.rs:31:9\n   |\n\
    31 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpvs_3gsvm.rs:28:35\n   |\n28 | \
    \    let mut smallest_even_index = -1;\n   |                                 \
    \  ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvs_3gsvm.rs:40:30\n   |\n29 |     let mut smallest_index\
    \ = -1;\n   |                              -- expected due to this value\n...\n\
    40 |             smallest_index = arr.iter().position(|&i| i == smallest_index).unwrap();\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvs_3gsvm.rs:49:9\n\
    \   |\n49 |     for &i in even_values {\n   |         ^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpvs_3gsvm.rs:47:35\n\
    \   |\n47 |     let mut smallest_even_index = -1;\n   |                      \
    \             ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help:\
    \ the following other types implement trait `Neg`:\n             &f32\n      \
    \       &f64\n             &i128\n             &i16\n             &i32\n     \
    \        &i64\n             &i8\n             &isize\n           and 8 others"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_index = 0;\n    let mut min_even_value\
    \ = false;\n    for i in 0..arr.len() {\n        if arr[i] < min_value {\n   \
    \         min_value = arr[i];\n            min_index = i;\n            min_even_value\
    \ = true;\n        }\n        if arr[i] == min_value {\n            if min_even_value\
    \ {\n                min_even_value = false;\n            }\n        }\n    }\n\
    \    if min_even_value {\n        vec![min_value, min_index]\n    } else {\n \
    \       vec![]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp5b_zae6.rs:43:25\n   |\n\
    43 |         vec![min_value, min_index]\n   |                         ^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n43 |         vec![min_value,\
    \ min_index.try_into().unwrap()]\n   |                                  ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values.push(arr[i]);\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = 0;\n    for i in 0..even_values.len() {\n \
    \       if even_values[i] < smallest_even_value {\n            smallest_even_value\
    \ = even_values[i];\n            smallest_even_index = i;\n        }\n    }\n\
    \    let mut result = vec![];\n    for i in 0..even_values.len() {\n        if\
    \ i == smallest_even_index {\n            result.push(i);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7i2ttdqr.rs:56:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n56 |     result\n\
    \   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value: isize = 0;\n    let mut min_index: usize = 0;\n \
    \   let mut even_value: isize = 0;\n    let mut index: usize = 0;\n    let mut\
    \ even_values: Vec<isize> = vec![];\n    let mut even_values_index: Vec<usize>\
    \ = vec![];\n    let mut even_values_index: Vec<usize> = vec![];\n    for value\
    \ in arr {\n        if value % 2 == 0 {\n            even_values.push(value);\n\
    \            even_values_index.push(value);\n        }\n        if value == min_even_value\
    \ {\n            min_even_value = value;\n            min_index = index;\n   \
    \     }\n        if value == min_even_value {\n            min_even_value = value;\n\
    \            min_index = index;\n        }\n        if value == min_even_value\
    \ {\n            min_even_value = value;\n            min_index = index;\n   \
    \     }\n        if value == min_even_value {\n            min_even_value = value;\n\
    \            min_index = index;\n        }\n        if value == min_even_value\
    \ {\n            min_even_value = value;\n            min_index = index;\n   \
    \     }\n        if value == min_even_value {\n            min_even_value = value;\n\
    \            min_index = index;\n        }\n        if value == min_even_value\
    \ {\n            min_even_value = value;\n            min_index = index;\n   \
    \     }\n        if value == min_even_value {\n            min_even_value = value;\n\
    \            min_index = index;\n        }\n        if value == min_even_value\
    \ {\n            min_even_value = value;\n            min_index = index;\n   \
    \     }\n        if value == min_even_value {\n            min_even_value = value;\n\
    \            min_index = index;\n        }\n        if value == min_even_value\
    \ {\n            min_even_value = value;\n            min_index = index;\n   \
    \     }\n        if value == min_even_value {\n            min_even_value = value;\n\
    \            min_index = index;\n        }\n        if value == min_even_value\
    \ {\n            min_even_value = value;\n            min_index = index;\n   \
    \     }\n        if value == min_even_value {\n            min_even_value = value;\n\
    \            min_index = index;\n        }\n        if value == min_even_value\
    \ {\n            min_even_value = value;\n            min_index = index;\n   \
    \     }\n        if value == min_even_value {\n            min_even_value = value;\n\
    \            min_index = index;\n        }\n        if value == min_even_value\
    \ {\n            min_even_value = value;\n            min_index = index;\n   \
    \     }\n        if value == min_even_value {\n            min_even_value = value;\n\
    \            min_index = index;\n        }\n        if value == min_even_value\
    \ {\n            min_even_value = value;\n            min_index = index;\n   \
    \     }\n        if value == min_even_value {\n            min_even_value = value;\n\
    \            min_index = index;\n        }\n        if value == min_even_value\
    \ {\n            min_even_value = value;\n            min_index = index;\n\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpxkqsmp3c.rs:135:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n34  |     for value in arr\
    \ {\n    |                      - unclosed delimiter\n...\n119 |         if value\
    \ == min_even_value {\n    |                                    - this delimiter\
    \ might not be properly closed...\n...\n123 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n135 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxkqsmp3c.rs:37:36\n   |\n37 |             even_values_index.push(value);\n\
    \   |                                    ^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n37 |             even_values_index.push(value.try_into().unwrap());\n\
    \   |                                         ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmpxkqsmp3c.rs:34:5\n    |\n26  |   fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    |                                ----------\
    \ expected `Vec<isize>` because of return type\n...\n34  | /     for value in\
    \ arr {\n35  | |         if value % 2 == 0 {\n36  | |             even_values.push(value);\n\
    37  | |             even_values_index.push(value);\n...   |\n134 | |     assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n135 | | }\n    | |__^ expected struct `Vec`,\
    \ found `()`\n    |\n    = note: expected struct `Vec<isize>`\n            found\
    \ unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n        }\n        if i == smallest_value {\n\
    \            smallest_index = arr.iter().position(|&i| i == smallest_value).unwrap();\n\
    \        }\n        if i == smallest_value {\n            smallest_value = i;\n\
    \        }\n    }\n    even_values.sort_unstable();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `even` in this scope\n  --> /tmp/tmpa17vvhat.rs:93:5\n\
    \   |\n93 |     even\n   |     ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa17vvhat.rs:30:9\n   |\n30 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `Option<isize>`\n   |         |\n\
    \   |         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter().rev() {\n        if i %\
    \ 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = even_values.iter().next().unwrap();\n    for i in even_values.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if i < smallest_even_value {\n     \
    \           smallest_even_value = i;\n                smallest_even_index = i;\n\
    \            }\n        }\n    }\n    let mut result = vec![];\n    for i in even_values.iter().rev()\
    \ {\n        if i == smallest_even_index {\n            result.push(smallest_even_value);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk6jy8nr3.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpk6jy8nr3.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk6jy8nr3.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpk6jy8nr3.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6jy8nr3.rs:46:20\n   |\n\
    46 |             if i < smallest_even_value {\n   |                    ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpk6jy8nr3.rs:58:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n58 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<is"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = arr[0];\n    let mut min_even_index = -1;\n    let\
    \ mut min_even_index_in_arr = -1;\n    let mut even_values = Vec::new();\n   \
    \ let mut even_values_index = Vec::new();\n    let mut even_values_index_in_arr\
    \ = Vec::new();\n    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n \
    \           even_values.push(arr[i]);\n            even_values_index.push(i);\n\
    \            even_values_index_in_arr.push(i);\n            if arr[i] < min_even_value\
    \ {\n                min_even_value = arr[i];\n                min_even_index\
    \ = i;\n                min_even_index_in_arr = i;\n            }\n        }\n\
    \    }\n    if even_values.len() == 0 {\n        return even_values_index;\n \
    \   }\n    if min_even_value == 0 {\n        return even_values_index;\n    }\n\
    \    if min_even_index == -1 || min_even_index == even_values_index_in_arr.len()\
    \ - 1 {\n        return even_values_index;\n    }\n    for i in 0..even_values_index_in_arr.len()\
    \ {\n        if even_values_index_in_arr[i] == min_even_index {\n            even_values_index_in_arr[i]\
    \ = even_values_index_in_arr[i] + 1;\n        }\n    }\n    for i in 0..even_values_index_in_arr.len()\
    \ {\n        if even_values_index_in_arr[i] == min_even_index_in_arr {\n     \
    \       even_values_index_in_arr[i] = even_values_index_in_arr[i] + 1;\n     \
    \   }\n    }\n    for i in 0..even_values_index_in_arr.len() {\n        if even_values_index_in_arr[i]\
    \ == min_even_index_in_arr {\n            even_values_index_in_arr[i] = even_values_index_in_arr[i]\
    \ + 1;\n        }\n    }\n    for i in 0..even_values_index_in_arr.len() {\n \
    \       if even_values_index_in_arr[i] == min_even_index_in_arr {\n          \
    \  even_values_index_in_arr[i] = even_values_index_in_arr[i] + 1;\n        }\n\
    \    }\n    for i in 0..even_values_index_in_arr.len() {\n        if even_values_index_in_arr[i]\
    \ == min_even_index_in_arr {\n            even_values_index_in_arr[i] = even_values_index_in_arr[i]\
    \ + 1;\n        }\n    }\n    for i in 0..even_values_index_in_arr.len() {\n \
    \       if even_values_index_in_arr[i] == min_even_index_in_arr {\n          \
    \  even_values_index_in_arr[i] = even_values_index_in_arr[i] + 1;\n        }\n\
    \    }\n    for i in 0..even_values_index_in_arr.len() {\n        if even_values_index_in_arr[i]\
    \ == min_even_index_in_arr {\n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmph5kaym1m.rs:98:3\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - unclosed delimiter\n...\n84 |     for i in 0..even_values_index_in_arr.len()\
    \ {\n   |                                                - unclosed delimiter\n\
    85 |         if even_values_index_in_arr[i] == min_even_index_in_arr {\n   | \
    \                                                                - this delimiter\
    \ might not be properly closed...\n86 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n98 | }\n   |   ^\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmph5kaym1m.rs:28:30\n   |\n\
    28 |     let mut min_even_index = -1;\n   |                              ^^ the\
    \ trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other\
    \ types implement trait `Neg`:\n             &f32\n             &f64\n       \
    \      &i128\n             &i16\n             &i32\n             &i64\n      \
    \       &i8\n             &isize\n           and 8 others\n\nerror[E0277]: the\
    \ trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmph5kaym1m.rs:29:37\n\
    \   |\n29 |     let mut min_even_index_in_arr = -1;\n   |                    \
    \                 ^^ the trait `Neg` is not implemented for `usize`\n   |\n  \
    \ = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph5kaym1m.rs:46:16\n   |\n26 |\
    \ fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                            \
    \  ---------- expected `Vec<isize>` because of return type\n...\n46 |        \
    \ return even_values_index;\n   |                ^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror[E0600]: cannot apply unary operator `-` to\
    \ type `usize`\n  --> /tmp/tmph5kaym1m.rs:51:26\n   |\n51 |     if mi"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = i32::MAX;\n    let mut min_idx = 0;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            if min_value < i {\n               \
    \ min_value = i;\n                min_idx = i;\n            }\n        }\n   \
    \ }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiy_0j__j.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiy_0j__j.rs:32:29\n\
    \   |\n27 |     let mut min_value = i32::MAX;\n   |                         --------\
    \ expected due to this value\n...\n32 |                 min_value = i;\n   | \
    \                            ^ expected `i32`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiy_0j__j.rs:33:27\n   |\n28 |     let mut min_idx\
    \ = 0;\n   |                       - expected due to this value\n...\n33 |   \
    \              min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \               min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiy_0j__j.rs:37:10\n   |\n37 |     vec![min_value,\
    \ min_idx]\n   |          ^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp:\
    \ you can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n37 |     vec![min_value.try_into().unwrap(), min_idx]\n   |     \
    \              ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_value = arr[0];\n    let mut smallest_index = 0;\n    let\
    \ mut even_values = false;\n    for &x in arr {\n        if x % 2 == 0 {\n   \
    \         even_values = true;\n        }\n        if x < smallest_value {\n  \
    \          smallest_value = x;\n            smallest_index = x;\n        }\n \
    \   }\n    if even_values {\n        smallest_index\n    } else {\n        smallest_index\
    \ + 1\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4qpcm2dq.rs:30:9\n   |\n\
    30 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4qpcm2dq.rs:40:9\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n40 |         smallest_index\n   |         ^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4qpcm2dq.rs:42:9\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n42\
    \ |         smallest_index + 1\n   |         ^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `isize`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut smallest_even_value = 0;\n    let\
    \ mut even_values_index = 0;\n    for i in arr.iter() {\n        if i % 2 == 0\
    \ {\n            even_values.push(i as isize);\n            if even_values_index\
    \ == 0 {\n                smallest_even_value = i as isize;\n                smallest_value\
    \ = i;\n                smallest_index = i;\n            } else {\n          \
    \      if i < smallest_even_value{\n                    smallest_even_value =\
    \ i as isize;\n                    smallest_value = i;\n                    smallest_index\
    \ = i;\n                }\n            }\n            even_values_index += 1;\n\
    \        }\n    }\n    even_values.sort();\n    even_values.dedup();\n    let\
    \ mut even_values_index = even_values.iter().position(|&x| *x == smallest_even_value);\n\
    \    even_values_index += 1;\n    even_values.retain(|&x| *x == smallest_even_value);\n\
    \    even_values.dedup();\n    even_values.retain(|&x| *x == smallest_value);\n\
    \    even_values.dedup();\n    even_values.retain(|&x| *x == smallest_index);\n\
    \    even_values.dedup();\n    even_values.retain(|&x| *x == smallest_index);\n\
    \    even_values.dedup();\n    even_values.retain(|&x| *x == smallest_index);\n\
    \    even_values.dedup();\n    even_values.retain(|&x| *x == smallest_index);\n\
    \    even_values.dedup();\n    even_values.retain(|&x| *x == smallest_index);\n\
    \    even_values.dedup();\n    even_values.retain(|&x| *x == smallest_index);\n\
    \    even_values.dedup();\n    even_values.retain(|&x| *x == smallest_index);\n\
    \    even_values.dedup();\n    even_values.retain(|&x| *x == smallest_index);\n\
    \    even_values.dedup();\n    even_values.retain(|&x| *x == smallest_index);\n\
    \    even_values.dedup();\n    even_values.retain(|&x| *x == smallest_index);\n\
    \    even_values.dedup();\n    even_values.retain(|&x| *x == smallest_index);\n\
    \    even\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `even` in this scope\n  --> /tmp/tmp3c5uvbx1.rs:78:5\n\
    \   |\n78 |     even\n   |     ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3c5uvbx1.rs:37:34\n   |\n28 |     let mut smallest_value\
    \ = arr[0];\n   |                              ------ expected due to this value\n\
    ...\n37 |                 smallest_value = i;\n   |                          \
    \        ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n37 |                 smallest_value = *i;\n   |          \
    \                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3c5uvbx1.rs:38:34\n\
    \   |\n29 |     let mut smallest_index = 0;\n   |                            \
    \  - expected due to this value\n...\n38 |                 smallest_index = i;\n\
    \   |                                  ^ expected integer, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n38 |                 smallest_index\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3c5uvbx1.rs:40:24\n   |\n40 |                 if i < smallest_even_value{\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^\n   |                       \
    \ |\n   |                        expected `&isize`, found `isize`\n   |      \
    \                  help: consider borrowing here: `&smallest_even_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3c5uvbx1.rs:42:38\n   |\n28 |     let mut smallest_value\
    \ = arr[0];\n   |                              ------ expected due to this value\n\
    ...\n42 |                     smallest_value = i;\n   |                      \
    \                ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n42 |                     smallest_value = *i;\n   |      \
    \                                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3c5uvbx1.rs:43:38\n\
    \   |\n29 |     let mut smallest_index = 0;\n   |                            \
    \  - expected due to this value\n...\n43 |                     smallest_index\
    \ = i;\n   |                                      ^ expected inte"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = -1;\n    let mut min_idx\
    \ = -1;\n    for i in arr.iter().cloned() {\n        if i % 2 == 0 {\n       \
    \     if min_value == i {\n                min_idx = i;\n            } else {\n\
    \                min_value = i;\n                min_idx = i;\n            }\n\
    \        }\n    }\n    if min_idx == -1 {\n        return vec![];\n    }\n   \
    \ let mut result = vec![];\n    for i in arr.iter().cloned() {\n        if i ==\
    \ min_idx {\n            result.push(min_value);\n        } else {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2, 3]`,\n right: `[2, 1]`', /tmp/tmpri8b2z1r.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_value = arr[0];\n    let mut\
    \ min_value_index = -1;\n    let mut min_value_index = -1;\n    for &i in arr\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ min_value == i {\n                min_value_index = i;\n            }\n    \
    \    }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n\
    \    if min_value_index == -1 {\n        return vec![];\n    }\n    let mut even_values_set\
    \ = HashSet::new();\n    for i in even_values {\n        even_values_set.insert(i);\n\
    \    }\n    let mut even_values_index = even_values_set.iter().map(|&i| i).collect::<Vec<_>>();\n\
    \    even_values_index.sort();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpzyxg_1bu.rs:62:66\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - closing delimiter possibly meant for this\n...\n62 |\
    \     let mut even_values_index = even_values_index.into_iter().map(|&i| \n  \
    \ |                                                                  ^ unclosed\
    \ delimiter\n63 | }\n   | ^ mismatched closing delimiter\n\nerror: expected expression,\
    \ found `)`\n  --> /tmp/tmpzyxg_1bu.rs:63:1\n   |\n63 | }\n   | ^ expected expression\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpzyxg_1bu.rs:45:31\n\
    \   |\n45 |     let mut even_values_set = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzyxg_1bu.rs:31:9\n   |\n31 |     for &i in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut min_value = arr[0];\n    let\
    \ mut min_index = -1;\n    for &i in arr {\n        if i % 2 == 0 {\n        \
    \    even_values.push(i);\n            if min_value == i {\n                min_index\
    \ = even_values.len() - 1;\n            }\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    if min_index == -1 {\n        return\
    \ vec![min_value];\n    }\n    let mut result = vec![min_value];\n    let mut\
    \ current_index = min_index;\n    while current_index != -1 {\n        if even_values[current_index]\
    \ % 2 == 0 {\n            result.push(even_values[current_index]);\n         \
    \   current_index += 1;\n        } else {\n            current_index -= 1;\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_nommwep.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmp_nommwep.rs:29:25\n   |\n29 | \
    \    let mut min_index = -1;\n   |                         ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmp_nommwep.rs:41:21\n   |\n41 |  \
    \   if min_index == -1 {\n   |                     ^^\n   |                  \
    \   |\n   |                     cannot apply unary operator `-`\n   |        \
    \             help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0600]: cannot apply\
    \ unary operator `-` to type `usize`\n  --> /tmp/tmp_nommwep.rs:46:28\n   |\n\
    46 |     while current_index != -1 {\n   |                            ^^\n   |\
    \                            |\n   |                            cannot apply unary\
    \ operator `-`\n   |                            help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0600.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = -1;\n    for i in arr.iter().cloned()\
    \ {\n        if i % 2 == 0 {\n            if min_value == i {\n              \
    \  min_idx = i;\n            } else {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    let mut result:\
    \ Vec<isize> = vec![];\n    if min_idx != -1 {\n        result.push(min_value);\n\
    \        result.push(min_idx);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2]`,\n right: `[2, 1]`', /tmp/tmpfrp2l0u5.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = -1;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if min_value == i {\n              \
    \  min_idx = i;\n            } else {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    let mut result =\
    \ vec![min_value, min_idx];\n    if min_idx == -1 {\n        return result;\n\
    \    }\n    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n           \
    \ if min_idx == i {\n                result.push(min_idx);\n            } else\
    \ {\n                result.push(i);\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcb1ln5cu.rs:31:29\n   |\n\
    31 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcb1ln5cu.rs:32:27\n   |\n28 |  \
    \   let mut min_idx = -1;\n   |                       -- expected due to this\
    \ value\n...\n32 |                 min_idx = i;\n   |                        \
    \   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n32 |                 min_idx = *i;\n   |                     \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcb1ln5cu.rs:34:29\n\
    \   |\n27 |     let mut min_value = arr[0];\n   |                         ------\
    \ expected due to this value\n...\n34 |                 min_value = i;\n   | \
    \                            ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n34 |                 min_value = *i;\n   | \
    \                            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcb1ln5cu.rs:35:27\n\
    \   |\n28 |     let mut min_idx = -1;\n   |                       -- expected\
    \ due to this value\n...\n35 |                 min_idx = i;\n   |            \
    \               ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n35 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcb1ln5cu.rs:45:27\n\
    \   |\n45 |             if min_idx == i {\n   |                           ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    45 |             if min_idx == *i {\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcb1ln5cu.rs:48:29\n   |\n48 |              \
    \   result.push(i);\n   |                             ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n48 |        \
    \         result.push(*i);\n   |                             +\n\nerror: a"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_value = arr[0];\n    let mut smallest_index = 0;\n    for\
    \ i in 1..arr.len() {\n        if arr[i] < smallest_value {\n            smallest_value\
    \ = arr[i];\n            smallest_index = i;\n        }\n    }\n    let mut result:\
    \ Vec<isize> = vec![];\n    for i in 0..arr.len() {\n        if arr[i] == smallest_value\
    \ {\n            result.push(smallest_index);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0j7n_ty2.rs:38:25\n   |\n\
    38 |             result.push(smallest_index);\n   |                         ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n38 |           \
    \  result.push(smallest_index.try_into().unwrap());\n   |                    \
    \                   ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![0; arr.len()];\n    let mut min_value = arr[0];\n\
    \    let mut min_index = 0;\n    for i in 0..arr.len() {\n        if arr[i] %\
    \ 2 == 0 {\n            even_values[i] = arr[i];\n            if arr[i] < min_value\
    \ {\n                min_value = arr[i];\n                min_index = i;\n   \
    \         }\n        }\n    }\n    let mut result = vec![min_value; arr.len()];\n\
    \    for i in 0..arr.len() {\n        if even_values[i] == min_value {\n     \
    \       result[i] = min_index;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc_omppmv.rs:42:25\n   |\n\
    42 |             result[i] = min_index;\n   |             ---------   ^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |             |\n   |             expected\
    \ due to the type of this binding\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2 ==\
    \ 0 {\n            even_values.push(i);\n            if i < smallest_value {\n\
    \                smallest_value = i;\n                smallest_index = i;\n  \
    \          }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = even_values.iter().position(|&x| x < smallest_value);\n\
    \    for i in even_values.iter().rev() {\n        if i % 2 == 0 {\n          \
    \  if i < smallest_value {\n                smallest_even_value = i;\n       \
    \         smallest_even_index = i;\n            }\n        }\n    }\n    let mut\
    \ result = vec![];\n    for i in even_values.iter().rev() {\n        if i == smallest_value\
    \ {\n            result.push(smallest_even_index);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjufaugkr.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpjufaugkr.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjufaugkr.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjufaugkr.rs:43:72\n  \
    \ |\n43 |     let mut smallest_even_index = even_values.iter().position(|&x| x\
    \ < smallest_value);\n   |                                                   \
    \                     ^^^^^^^^^^^^^^\n   |                                   \
    \                                     |\n   |                                \
    \                                        expected `&isize`, found `isize`\n  \
    \ |                                                                        help:\
    \ consider borrowing here: `&smallest_value`\n\nerror[E0369]: cannot mod `&&isize`\
    \ by `{integer}`\n  --> /tmp/tmpjufaugkr.rs:45:14\n   |\n45 |         if i % 2\
    \ == 0 {\n   |            - ^ - {integer}\n   |            |\n   |           \
    \ &&isize\n   |\nhelp: `%` can be used on `isize`, you can dereference `i`\n \
    \  |\n45 |         if *i % 2 == 0 {\n   |            +\n\nerror[E0308]: mismatche"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = arr[0];\n    let mut min_even_index = -1;\n    let\
    \ mut min_even_index_in_list = -1;\n    let mut min_even_index_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list = -1;\n    let mut\
    \ min_even_index_in_list_in_list_in_list_in_list = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf_w8lzjr.rs:48:63\n   |\n\
    48 |     let mut min_even_index_in_list_in_list_in_list_in_list_in_\n   |    \
    \                                                           ^ help: add `;` here\n\
    49 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf_w8lzjr.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![0; arr.len()];\n    let mut min_value = arr[0];\n\
    \    let mut min_value_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values[i] = 1;\n            if arr[i] < min_value\
    \ {\n                min_value = arr[i];\n                min_value_index = i;\n\
    \            }\n        } else {\n            even_values[i] = 0;\n        }\n\
    \    }\n    if even_values.iter().any(|&x| x == 0) {\n        return vec![];\n\
    \    }\n    even_values.iter().cloned().enumerate().filter(|&(i, _)| {\n     \
    \   if even_values[i] == 0 {\n            true\n        } else {\n           \
    \ false\n        }\n    }).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzgzkujyi.rs:44:5\n   |\n\
    26 |   fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                       \
    \         ---------- expected `Vec<isize>` because of return type\n...\n44 | /\
    \     even_values.iter().cloned().enumerate().filter(|&(i, _)| {\n45 | |     \
    \    if even_values[i] == 0 {\n46 | |             true\n47 | |         } else\
    \ {\n48 | |             false\n49 | |         }\n50 | |     }).collect::<Vec<_>>()\n\
    \   | |__________________________^ expected `isize`, found tuple\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<(usize, {integer})>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for &i in even_values {\n        if i < smallest_even_value {\n  \
    \          smallest_even_value = i;\n            smallest_even_index = i;\n  \
    \      }\n    }\n    let mut result = vec![];\n    if smallest_even_index == 0\
    \ {\n        result.push(smallest_value, smallest_index);\n    } else {\n    \
    \    result.push(smallest_even_value);\n        result.push(smallest_even_index);\n\
    \    }\n    return result;\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzd0twv0t.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzd0twv0t.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n    --> /tmp/tmpzd0twv0t.rs:52:16\n\
    \     |\n52   |         result.push(smallest_value, smallest_index);\n     | \
    \               ^^^^ --------------  -------------- supplied 2 arguments\n   \
    \  |                |\n     |                expected 1 argument\n     |\nnote:\
    \ associated function defined here\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &x in arr {\n        if x % 2 == 0 {\n\
    \            even_values.push(x);\n            if x < smallest_value {\n     \
    \           smallest_value = x;\n                smallest_index = even_values.len()\
    \ - 1;\n            }\n        }\n    }\n    even_values.sort();\n    even_values.dedup();\n\
    \    let mut result = Vec::new();\n    let mut i = 0;\n    while i < even_values.len()\
    \ {\n        if even_values[i] != smallest_value {\n            result.push((smallest_value,\
    \ smallest_index));\n            i += 1;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsg_d_zn9.rs:30:9\n   |\n\
    30 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsg_d_zn9.rs:51:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n51 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ tuple\n   |\n   = note: expected struct `Vec<isize>`\n              found struct\
    \ `Vec<(isize, usize)>`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if min_value == i {\n              \
    \  min_idx = i;\n            } else {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc1jhq4be.rs:31:29\n   |\n\
    31 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpc1jhq4be.rs:32:27\n   |\n28 |  \
    \   let mut min_idx = 0;\n   |                       - expected due to this value\n\
    ...\n32 |                 min_idx = i;\n   |                           ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |                 min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc1jhq4be.rs:34:29\n   |\n27 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n34 |                 min_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    34 |                 min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc1jhq4be.rs:35:27\n   |\n28 |     let mut min_idx\
    \ = 0;\n   |                       - expected due to this value\n...\n35 |   \
    \              min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |  \
    \               min_idx = *i;\n   |                           +\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if min_value < i {\n               \
    \ min_value = i;\n                min_idx = i;\n            }\n        }\n   \
    \ }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz27fffuv.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value < *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz27fffuv.rs:32:29\n   |\n27 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n32 |                 min_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |                 min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz27fffuv.rs:33:27\n   |\n28 |     let mut min_idx\
    \ = 0;\n   |                       - expected due to this value\n...\n33 |   \
    \              min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \               min_idx = *i;\n   |                           +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![0; arr.len()];\n    let mut min_value = arr[0];\n\
    \    let mut min_value_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values[i] = 1;\n            if arr[i] < min_value\
    \ {\n                min_value = arr[i];\n                min_value_index = i;\n\
    \            }\n        } else {\n            even_values[i] = 0;\n        }\n\
    \    }\n    let mut result = vec![min_value; min_value_index + 1];\n    for i\
    \ in 0..arr.len() {\n        if even_values[i] == 1 {\n            result[min_value_index]\
    \ = arr[i];\n            min_value_index += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 2 but the index\
    \ is 2', /tmp/tmpfmrhwc0l.rs:44:13\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2 ==\
    \ 0 {\n            even_values.push(i);\n        }\n        if i == smallest_value\
    \ {\n            smallest_index = i;\n        }\n        if i == smallest_value\
    \ {\n            smallest_value = i;\n        }\n    }\n    even_values.sort();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmptllbwvxn.rs:96:1\n   |\n96\
    \ | }\n   | ^\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmptllbwvxn.rs:34:14\n\
    \   |\n34 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmptllbwvxn.rs:35:30\n   |\n29 |     let mut smallest_index = 0;\n   |\
    \                              - expected due to this value\n...\n35 |       \
    \      smallest_index = i;\n   |                              ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |  \
    \           smallest_index = *i;\n   |                              +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptllbwvxn.rs:38:30\n   |\n28 |     let mut smallest_value\
    \ = arr[0];\n   |                              ------ expected due to this value\n\
    ...\n38 |             smallest_value = i;\n   |                              ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n38 |             smallest_value = *i;\n   |                           \
    \   +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmptllbwvxn.rs:37:14\n\
    \   |\n37 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmptllbwvxn.rs:95:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ----------"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = arr[0];\n    let mut min_even_index = -1;\n    let\
    \ mut min_even_index_in_list = -1;\n    let mut min_even_index_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list = -1;\n    let mut\
    \ min_even_index_in_list_in_list_in_list_in_list = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprcjiz2cf.rs:48:55\n   |\n\
    48 |     let mut min_even_index_in_list_in_list_in_list_in_\n   |            \
    \                                           ^ help: add `;` here\n49 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprcjiz2cf.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values.push(arr[i]);\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = smallest_index;\n    for i in 0..even_values.len()\
    \ {\n        if even_values[i] < smallest_even_value {\n            smallest_even_value\
    \ = even_values[i];\n            smallest_even_index = i;\n        }\n    }\n\
    \    vec![smallest_value, smallest_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpint61iz3.rs:50:26\n   |\n\
    50 |     vec![smallest_value, smallest_even_index]\n   |                     \
    \     ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n50 |     vec![smallest_value, smallest_even_index.try_into().unwrap()]\n\
    \   |                                             ++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter().rev() {\n        if i %\
    \ 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = 0;\n    for i in even_values.iter().rev() {\n        if\
    \ i % 2 == 0 {\n            if i < smallest_even_value {\n                smallest_even_value\
    \ = i;\n                smallest_even_index = i;\n            }\n        }\n \
    \   }\n    vec![smallest_value, smallest_even_index]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwu8u5m8f.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpwu8u5m8f.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwu8u5m8f.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpwu8u5m8f.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwu8u5m8f.rs:46:20\n   |\n\
    46 |             if i < smallest_even_value {\n   |                    ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwu8u5m8f.rs:48:39\n   |\n43 |     let mut smallest_even_index = 0;\n\
    \   |                                   - expected due to this value\n...\n48\
    \ |                 smallest_even_index = i;\n   |                           \
    \            ^ expected integer, found `&&isize`\n   |\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = -1;\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_value {\n            min_value = arr[i];\n      \
    \      min_idx = i;\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpdmz02aqb.rs:28:23\n\
    \   |\n28 |     let mut min_idx = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdmz02aqb.rs:35:21\n   |\n35 |     vec![min_value, min_idx]\n  \
    \ |                     ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n35 |     vec![min_value, min_idx.try_into().unwrap()]\n   |     \
    \                       ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values.push(i);\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    even_values.sort_unstable();\n  \
    \  even_values.dedup();\n    let mut result = Vec::new();\n    for i in even_values\
    \ {\n        result.push(i);\n    }\n    if result.len() == 0 {\n        return\
    \ result;\n    }\n    let mut smallest_value = arr[0];\n    let mut smallest_index\
    \ = 0;\n    for i in 0..result.len() {\n        if result[i] < smallest_value\
    \ {\n            smallest_value = result[i];\n            smallest_index = i;\n\
    \        }\n    }\n    result.push(smallest_value);\n    result.push(smallest_index);\n\
    \    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoflj2s_t.rs:46:16\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n46 |     \
    \    return result;\n   |                ^^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoflj2s_t.rs:51:24\n   |\n51 |\
    \         if result[i] < smallest_value {\n   |                        ^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n51 |         if\
    \ result[i] < smallest_value.try_into().unwrap() {\n   |                     \
    \                 ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoflj2s_t.rs:52:30\n   |\n48 |     let mut smallest_value = arr[0];\n\
    \   |                              ------ expected due to this value\n...\n52\
    \ |             smallest_value = result[i];\n   |                            \
    \  ^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoflj2s_t.rs:56:17\n   |\n56 |     result.push(smallest_value);\n\
    \   |                 ^^^^^^^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n56 |     result.push(smallest_value.try_into().unwrap());\n   | \
    \                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoflj2s_t.rs:58:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n58 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to 5 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_value = arr[0];\n    let mut\
    \ min_value_index = 0;\n    for i in arr.iter().rev() {\n        if i % 2 == 0\
    \ {\n            even_values.push(i);\n            if i < min_value {\n      \
    \          min_value = i;\n                min_value_index = i;\n            }\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    let mut smallest_value = min_value;\n    let mut smallest_value_index\
    \ = min_value_index;\n    for i in even_values.iter().rev() {\n        if i <\
    \ smallest_value {\n            smallest_value = i;\n            smallest_value_index\
    \ = i;\n        }\n    }\n    let mut result = vec![];\n    for i in even_values.iter().rev()\
    \ {\n        if i == smallest_value {\n            result.push(i);\n        }\n\
    \    }\n    if result.len() == 0 {\n        return vec![];\n    }\n    result.push(smallest_value);\n\
    \    result.push(smallest_value_index);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc9hxf_mg.rs:33:20\n   |\n\
    33 |             if i < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc9hxf_mg.rs:34:29\n   |\n28 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n34 |                 min_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    34 |                 min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc9hxf_mg.rs:35:35\n   |\n29 |     let mut min_value_index\
    \ = 0;\n   |                               - expected due to this value\n...\n\
    35 |                 min_value_index = i;\n   |                              \
    \     ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n35 |                 min_value_index = *i;\n   |             \
    \                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc9hxf_mg.rs:45:16\n\
    \   |\n45 |         if i < smallest_value {\n   |                ^^^^^^^^^^^^^^\
    \ expected `&&isize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc9hxf_mg.rs:46:30\n\
    \   |\n42 |     let mut smallest_value = min_value;\n   |                    \
    \          --------- expected due to this value\n...\n46 |             smallest_value\
    \ = i;\n   |                              ^ expected `isize`, found `&&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n46 |             smallest_value\
    \ = **i;\n   |                              ++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc9hxf_mg.rs:47:36\n   |\n43 |     let mut smallest_value_index\
    \ = min_value_index;\n   |                                    ---------------\
    \ expected due to this value\n...\n47 |             smallest_value_index = i;\n\
    \   |                                    ^ expected integer, found `&&isize`\n\
    \   |\nh"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2 ==\
    \ 0 {\n            even_values.push(i);\n            if i < smallest_value {\n\
    \                smallest_value = i;\n                smallest_index = i;\n  \
    \          }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = even_values.iter().position(|&x| x < smallest_value);\n\
    \    for i in even_values.iter().rev() {\n        if i % 2 == 0 {\n          \
    \  if i < smallest_value {\n                smallest_even_value = i;\n       \
    \         smallest_even_index = i;\n            }\n        }\n    }\n    let mut\
    \ result = vec![];\n    for i in even_values.iter().rev() {\n        if i == smallest_value\
    \ {\n            result.push(smallest_even_index);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg58m_co3.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpg58m_co3.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpg58m_co3.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg58m_co3.rs:43:72\n  \
    \ |\n43 |     let mut smallest_even_index = even_values.iter().position(|&x| x\
    \ < smallest_value);\n   |                                                   \
    \                     ^^^^^^^^^^^^^^\n   |                                   \
    \                                     |\n   |                                \
    \                                        expected `&isize`, found `isize`\n  \
    \ |                                                                        help:\
    \ consider borrowing here: `&smallest_value`\n\nerror[E0369]: cannot mod `&&isize`\
    \ by `{integer}`\n  --> /tmp/tmpg58m_co3.rs:45:14\n   |\n45 |         if i % 2\
    \ == 0 {\n   |            - ^ - {integer}\n   |            |\n   |           \
    \ &&isize\n   |\nhelp: `%` can be used on `isize`, you can dereference `i`\n \
    \  |\n45 |         if *i % 2 == 0 {\n   |            +\n\nerror[E0308]: mismatche"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for &i in even_values {\n        if i < smallest_even_value {\n  \
    \          smallest_even_value = i;\n            smallest_even_index = i;\n  \
    \      }\n    }\n    let mut result = vec![];\n    for &i in even_values {\n \
    \       if i == smallest_even_value {\n            result.push(i);\n         \
    \   result.push(smallest_even_index);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpejmabw68.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpejmabw68.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpejmabw68.rs:51:9\n   |\n51 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = arr[0];\n    let mut min_even_index = -1;\n    let\
    \ mut min_even_index_in_list = -1;\n    let mut even_values = vec![];\n    for\
    \ i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if min_even_index == -1 || min_even_index > i {\n               \
    \ min_even_index = i;\n                min_even_index_in_list = i;\n         \
    \   }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = -1;\n    for i in even_values.iter() {\n        if i < smallest_even_value.clone()\
    \ {\n            smallest_even_value = i;\n            smallest_even_index = i;\n\
    \        }\n    }\n    if smallest_even_index == -1 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_index_in_list = -1;\n    for i in even_values.iter()\
    \ {\n        if i == smallest_even_index {\n            smallest_even_index_in_list\
    \ = i;\n        }\n    }\n    if smallest_even_index_in_list == -1 {\n       \
    \ return vec![];\n    }\n    let mut result = vec![];\n    for i in even_values.iter()\
    \ {\n        if i == smallest_even_index {\n            result.push(smallest_even_index_in_list);\n\
    \        }\n    }\n    if result.len() == 0 {\n        return vec![];\n    }\n\
    \    return result;\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps57gsedv.rs:35:34\n   |\n\
    28 |     let mut min_even_index = -1;\n   |                              -- expected\
    \ due to this value\n...\n35 |                 min_even_index = i;\n   |     \
    \                             ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n35 |                 min_even_index\
    \ = *i;\n   |                                  +\n\nerror[E0277]: can't compare\
    \ `isize` with `&isize`\n  --> /tmp/tmps57gsedv.rs:34:55\n   |\n34 |         \
    \    if min_even_index == -1 || min_even_index > i {\n   |                   \
    \                                    ^ no implementation for `isize < &isize`\
    \ and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmps57gsedv.rs:36:42\n   |\n29 |     let mut min_even_index_in_list = -1;\n\
    \   |                                      -- expected due to this value\n...\n\
    36 |                 min_even_index_in_list = i;\n   |                       \
    \                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n36 |                 min_even_index_in_list = *i;\n   |  \
    \                                        +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps57gsedv.rs:46:16\n   |\n46 |         if i < smallest_even_value.clone()\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&&isize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps57gsedv.rs:48:35\n\
    \   |\n44 |     let mut smallest_even_index = -1;\n   |                      \
    \             -- expected due to this value\n...\n48 |             smallest_even_index\
    \ = i;\n   |                                   ^ expected integer, found `&&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n48 |             sma"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx\
    \ = arr.iter().min_by_key(|&x| {\n        if x % 2 == 0 {\n            min_value\
    \ = x;\n            min_idx = 0;\n            true\n        } else {\n       \
    \     min_value = x;\n            min_idx = 1;\n            false\n        }\n\
    \    });\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx += 1;\n    min_idx\
    \ += 1;\n    min_idx += 1;\n    min_\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `min_` in this scope\n   --> /tmp/tmpuxr7d9wi.rs:129:5\n\
    \    |\n129 |     min_\n    |     ^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuxr7d9wi.rs:31:25\n   |\n27 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n31 |             min_value = x;\n   |                         ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             min_value = *x;\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuxr7d9wi.rs:35:25\n   |\n27 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n35 |             min_value = x;\n   |                         ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |             min_value = *x;\n   |                         +\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Option<&isize>`\n\
    \  --> /tmp/tmpuxr7d9wi.rs:40:5\n   |\n40 |     min_idx += 1;\n   |     -------^^^^^\n\
    \   |     |\n   |     cannot use `+=` on type `Option<&isize>`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Option<&isize>`\n\
    \  --> /tmp/tmpuxr7d9wi.rs:41:5\n   |\n41 |     min_idx += 1;\n   |     -------^^^^^\n\
    \   |     |\n   |     cannot use `+=` on type `Option<&isize>`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Option<&isize>`\n\
    \  --> /tmp/tmpuxr7d9wi.rs:42:5\n   |\n42 |     min_idx += 1;\n   |     -------^^^^^\n\
    \   |     |\n   |     cannot use `+=` on type `Option<&isize>`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Option<&isize>`\n\
    \  --> /tmp/tmpuxr7d9wi.rs:43:5\n   |\n43 |     min_idx += 1;\n   |     -------^^^^^\n\
    \   |     |\n   |     cannot use `+=` on type `Option<&isize>`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Option<&isize>`\n\
    \  --> /tmp/tmpuxr7d9wi.rs:44:5\n   |\n44 |     min_idx += 1;\n   |     -------^^^^^\n\
    \   |     |\n   |     cannot use `"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2\
    \ == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = 0;\n    for i in even_values.iter() {\n        if i <\
    \ smallest_even_value {\n            smallest_even_value = i;\n            smallest_even_index\
    \ = i;\n        }\n    }\n    let mut result = vec![];\n    for i in even_values.iter()\
    \ {\n        if i == smallest_even_value {\n            result.push(smallest_even_index);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdodull6f.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpdodull6f.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdodull6f.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdodull6f.rs:45:16\n  \
    \ |\n45 |         if i < smallest_even_value {\n   |                ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdodull6f.rs:47:35\n   |\n43 |     let mut smallest_even_index = 0;\n\
    \   |                                   - expected due to this value\n...\n47\
    \ |             smallest_even_index = i;\n   |                               \
    \    ^ expected integer, found `&&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n47 |             smallest_even_index = **i;\n   |            \
    \                       ++\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmpdodull6f.rs:52:14\n   |\n52 |         if i == smallest_even_value\
    \ {\n   |              ^^ no implementation for `&isize == isize`\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n        }\n        if i == smallest_value {\n\
    \            smallest_index = arr.iter().position(|&i| i == smallest_value).unwrap();\n\
    \        }\n        if i == smallest_value {\n            smallest_value = i;\n\
    \        }\n    }\n    even_values.sort();\n    even_values.dedup();\n    let\
    \ mut even_values_index = even_values.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    even_values_index.sort();\n    even_values_index.dedup();\n\
    \    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp_3db2dq2.rs:56:1\n   |\n56\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp_3db2dq2.rs:55:79\n\
    \   |\n55 |     let mut even_values_index = even_values_index.iter().cloned().enumerate().\n\
    \   |                                                                        \
    \       ^ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_3db2dq2.rs:30:9\n   |\n30 |     for &i in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0369]: cannot mod `(usize,\
    \ isize)` by `{integer}`\n  --> /tmp/tmp_3db2dq2.rs:46:98\n   |\n46 |     let\
    \ mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n   |                                 \
    \                                                               - ^ - {integer}\n\
    \   |                                                                        \
    \                        |\n   |                                             \
    \                                                   (usize, isize)\n\nerror[E0369]:\
    \ cannot mod `(usize, (usize, isize))` by `{integer}`\n  --> /tmp/tmp_3db2dq2.rs:47:98\n\
    \   |\n47 |     let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n   |                                 \
    \                                                               - ^ - {integer}\n\
    \   |                                                                        \
    \                        |\n   |                                             \
    \                                                   (usize, (usize, isize))\n\n\
    error[E0369]: cannot mod `(usize, (usize, (usize, isize)))` by `{integer}`\n \
    \ --> /tmp/tmp_3db2dq2.rs:48:98\n   |\n48 |     let mut even_values_index = even_values_index.iter().cloned("
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = arr[0];\n    let mut min_even_index = -1;\n    let mut\
    \ min_even_index = -1;\n    for &x in arr {\n        if x % 2 == 0 {\n       \
    \     if min_even < x {\n                min_even = x;\n                min_even_index\
    \ = x;\n            }\n        }\n    }\n    if min_even_index == -1 {\n     \
    \   return vec![];\n    }\n    let mut even_index = -1;\n    let mut even_value\
    \ = -1;\n    for &x in arr {\n        if x % 2 == 0 {\n            if even_index\
    \ == -1 {\n                even_index = x;\n                even_value = x;\n\
    \            } else {\n                if x < even_value{\n                  \
    \  even_value = x;\n                    even_index = x;\n                }\n \
    \           }\n        }\n    }\n    let mut even_index = -1;\n    let mut even_value\
    \ = -1;\n    for &x in arr {\n        if x % 2 == 0 {\n            if even_index\
    \ == -1 {\n                even_index = x;\n                even_value = x;\n\
    \            } else {\n                if x < even_value{\n                  \
    \  even_value = x;\n                    even_index = x;\n                }\n \
    \           }\n        }\n    }\n    let mut even_index = -1;\n    let mut even_value\
    \ = -1;\n    for &x in arr {\n        if x % 2 == 0 {\n            if even_index\
    \ == -1 {\n                even_index = x;\n                even_value = x;\n\
    \            } else {\n                if x < even_value{\n                  \
    \  even_value = x;\n                    even_index = x;\n                }\n \
    \           }\n        }\n    }\n    let mut even_index = -1;\n    let mut even_value\
    \ = -1;\n    for &x in arr {\n        if x % 2 == 0 {\n            if even_index\
    \ == -1 {\n                even_index = x;\n                even_value = x;\n\
    \            } else {\n                if x < even_value{\n                  \
    \  even_value = x;\n                    even_index = x;\n                }\n \
    \           }\n        }\n    }\n    let mut even_index = -1;\n    let mut even_value\
    \ = -1;\n    for &x in arr {\n        if x % 2 == 0 {\n            if even_index\
    \ == -1 {\n                even_index = x;\n                even_value = x;\n\
    \            } else {\n                if x < even_value{\n                  \
    \  even_value = x;\n                    even_index = x;\n                }\n \
    \           }\n        }\n    }\n    let mut even_index = -1;\n    let mut even_value\
    \ = -1;\n    for &x in arr {\n        if x % 2 == 0 {\n            if even_index\
    \ == -1 {\n                even_index = x;\n                even_value = x;\n\
    \            } else {\n                if x < even_value{\n                  \
    \  even_value = x;\n                    even_index = x;\n                }\n \
    \           }\n        }\n    }\n    let mut even_index = -1;\n    let mut even_value\
    \ = -1;\n    for &x in arr {\n        if x % 2 == 0 {\n            if even\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpbftzz4rq.rs:148:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n133 |     for &x in arr\
    \ {\n    |                   - unclosed delimiter\n134 |         if x % 2 == 0\
    \ {\n    |                       - this delimiter might not be properly closed...\n\
    135 |             if even\n136 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n148 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   -->\
    \ /tmp/tmpbftzz4rq.rs:136:1\n    |\n135 |             if even\n    |         \
    \    -- this `if` expression has a condition, but no block\n136 | }\n    | ^ expected\
    \ `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbftzz4rq.rs:30:9\n   |\n\
    30 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbftzz4rq.rs:43:9\n   |\n43 |     for &x in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbftzz4rq.rs:58:9\n\
    \   |\n58 |     for &x in arr {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbftzz4rq.rs:73:9\n   |\n73 |     for &x in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the expl"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values.push(arr[i]);\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = 0;\n    for i in 0..even_values.len() {\n \
    \       if even_values[i] < smallest_even_value {\n            smallest_even_value\
    \ = even_values[i];\n            smallest_even_index = i;\n        }\n    }\n\
    \    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3xhmjxjb.rs:50:26\n   |\n\
    50 |     vec![smallest_value, smallest_index]\n   |                          ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n50 |     vec![smallest_value,\
    \ smallest_index.try_into().unwrap()]\n   |                                  \
    \      ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = arr[0];\n    let mut min_even_index = -1;\n    let\
    \ mut min_even_index_count = 0;\n    let mut min_even_index_value = arr[0];\n\
    \    for i in 1..arr.len() {\n        if arr[i] % 2 == 0 {\n            if min_even_index\
    \ == -1 || arr[i] < min_even_index_value {\n                min_even_index_value\
    \ = arr[i];\n                min_even_index = i;\n                min_even_index_count\
    \ = 1;\n            } else {\n                min_even_index_count++;\n      \
    \      }\n        } else {\n            if min_even_index == -1 || arr[i] < min_even_index_value\
    \ {\n                min_even_index_value = arr[i];\n                min_even_index\
    \ = i;\n                min_even_index_count = 1;\n            } else {\n    \
    \            min_even_index_count++;\n            }\n        }\n    }\n    if\
    \ min_even_index_count == arr.len() {\n        return vec![min_even_index_value,\
    \ min_even_index];\n    } else {\n        return vec![min_even_index_value, min_even_index];\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpqpin6rkv.rs:38:37\n\
    \   |\n38 |                 min_even_index_count++;\n   |                    \
    \                 ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n38 |                 { let tmp = min_even_index_count; min_even_index_count\
    \ += 1; tmp };\n   |                 +++++++++++                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    38 -                 min_even_index_count++;\n38 +                 min_even_index_count\
    \ += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpqpin6rkv.rs:46:37\n\
    \   |\n46 |                 min_even_index_count++;\n   |                    \
    \                 ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n46 |                 { let tmp = min_even_index_count; min_even_index_count\
    \ += 1; tmp };\n   |                 +++++++++++                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    46 -                 min_even_index_count++;\n46 +                 min_even_index_count\
    \ += 1;\n   | \n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpqpin6rkv.rs:28:30\n   |\n28 |     let mut min_even_index = -1;\n\
    \   |                              ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpqpin6rkv.rs:33:34\n   |\n33 |             if min_even_index ==\
    \ -1 || arr[i] < min_even_index_value {\n   |                                \
    \  ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0600]:\
    \ cannot apply unary operator `-` to type `usize`\n  --> /t"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter().rev() {\n        if i %\
    \ 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = even_values.iter().next().unwrap();\n    for i in even_values.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if i < smallest_even_value {\n     \
    \           smallest_even_value = i;\n                smallest_even_index = i;\n\
    \            }\n        }\n    }\n    let mut result = vec![];\n    for i in even_values.iter().rev()\
    \ {\n        if i == smallest_even_index {\n            result.push(smallest_even_value);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpppx9p0n4.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpppx9p0n4.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpppx9p0n4.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpppx9p0n4.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpppx9p0n4.rs:46:20\n   |\n\
    46 |             if i < smallest_even_value {\n   |                    ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpppx9p0n4.rs:58:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n58 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<is"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![0; arr.len()];\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values[i] = arr[i];\n            if even_values[i]\
    \ < smallest_value {\n                smallest_value = even_values[i];\n     \
    \           smallest_index = i;\n            }\n        }\n    }\n    even_values.sort();\n\
    \    even_values.dedup();\n    let mut result = vec![smallest_value, smallest_index];\n\
    \    for i in 0..even_values.len() {\n        if even_values[i] != smallest_value\
    \ {\n            result.push(even_values[i]);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqk8maoer.rs:41:43\n   |\n\
    41 |     let mut result = vec![smallest_value, smallest_index];\n   |        \
    \                                   ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2\
    \ == 0 {\n            even_values.push(i);\n        }\n        if i == smallest_value\
    \ {\n            smallest_index = i;\n        }\n        if i == smallest_value\
    \ {\n            smallest_value = i;\n        }\n    }\n    even_values.sort();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_value\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `even_value` in this scope\n  --> /tmp/tmpatxd2uxk.rs:95:5\n\
    \   |\n95 |     even_value\n   |     ^^^^^^^^^^ help: a local variable with a\
    \ similar name exists: `even_values`\n\nerror[E0277]: can't compare `&isize` with\
    \ `isize`\n  --> /tmp/tmpatxd2uxk.rs:34:14\n   |\n34 |         if i == smallest_value\
    \ {\n   |              ^^ no implementation for `&isize == isize`\n   |\n   =\
    \ help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpatxd2uxk.rs:35:30\n   |\n29 |\
    \     let mut smallest_index = 0;\n   |                              - expected\
    \ due to this value\n...\n35 |             smallest_index = i;\n   |         \
    \                     ^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n35 |             smallest_index = *i;\n   |\
    \                              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpatxd2uxk.rs:38:30\n\
    \   |\n28 |     let mut smallest_value = arr[0];\n   |                       \
    \       ------ expected due to this value\n...\n38 |             smallest_value\
    \ = i;\n   |                              ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n38 |             smallest_value\
    \ = *i;\n   |                              +\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmpatxd2uxk.rs:37:14\n   |\n37 |         if i == smallest_value\
    \ {\n   |              ^^ no implementation for `&isize == isize`\n   |\n   =\
    \ help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to 5 previous err"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = even_values.iter().position(|&i| i < smallest_value);\n    if smallest_even_index\
    \ == even_values.len() - 1 {\n        smallest_even_index = even_values.len()\
    \ - 1;\n    }\n    even_values.remove(&mut smallest_even_index);\n    even_values.remove(&mut\
    \ smallest_even_index);\n    even_values.remove(&mut smallest_even_index);\n \
    \   even_values.remove(&mut smallest_even_index);\n    even_values.remove(&mut\
    \ smallest_even_index);\n    even_values.remove(&mut smallest_even_index);\n \
    \   even_values.remove(&mut smallest_even_index);\n    even_values.remove(&mut\
    \ smallest_even_index);\n    even_values.remove(&mut smallest_even_index);\n \
    \   even_values.remove(&mut smallest_even_index);\n    even_values.remove(&mut\
    \ smallest_even_index);\n    even_values.remove(&mut smallest_even_index);\n \
    \   even_values.remove(&mut smallest_even_index);\n    even_values.remove(&mut\
    \ smallest_even_index);\n    even_values.remove(&mut smallest_even_index);\n \
    \   even_values.remove(&mut smallest_even_index);\n    even_values.remove(&mut\
    \ smallest_even_index);\n    even_values.remove(&mut smallest_even_index);\n \
    \   even_values.remove(&mut smallest_even_index);\n    even_values.remove(&mut\
    \ smallest_even_index);\n    even_values.remove(&mut smallest_even_index);\n \
    \   even_values.remove(&mut smallest_even_index);\n    even_values.remove(&mut\
    \ smallest_even_index);\n    even_values.remove(&mut smallest_even_index);\n \
    \   even_values.remove(&mut smallest_even_index);\n    even_values.remove(&mut\
    \ smallest_even_index);\n    even_values.remove(&mut smallest_even_index);\n \
    \   even_values.remove(&mut smallest_even_index);\n    even_values.remove(\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmphltql7lc.rs:75:23\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - closing delimiter possibly meant for this\n...\n75 |\
    \     even_values.remove(\n   |                       ^ unclosed delimiter\n76\
    \ | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphltql7lc.rs:30:9\n   |\n30 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphltql7lc.rs:44:31\n\
    \   |\n44 |     if smallest_even_index == even_values.len() - 1 {\n   |      \
    \                         ^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found\
    \ `usize`\n   |\n   = note: expected enum `Option<usize>`\n              found\
    \ type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n44 |     if\
    \ smallest_even_index == Some(even_values.len() - 1) {\n   |                 \
    \              +++++                     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphltql7lc.rs:45:31\n   |\n43 |     let mut smallest_even_index =\
    \ even_values.iter().position(|&i| i < smallest_value);\n   |                \
    \                   ---------------------------------------------------- expected\
    \ due to this value\n44 |     if smallest_even_index == even_values.len() - 1\
    \ {\n45 |         smallest_even_index = even_values.len() - 1;\n   |         \
    \                      ^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n45 |         smallest_even_index\
    \ = Some(even_values.len() - 1);\n   |                               +++++   \
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphltql7lc.rs:47:24\n\
    \   |\n47 |     even_values.remove(&mut smallest_even_index);\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values.push(arr[i]);\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = 0;\n    for i in 0..even_values.len() {\n \
    \       if even_values[i] < smallest_even_value {\n            smallest_even_value\
    \ = even_values[i];\n            smallest_even_index = i;\n        }\n    }\n\
    \    let mut result = vec![];\n    for i in 0..even_values.len() {\n        if\
    \ i == smallest_even_index {\n            result.push(i);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyuky5l3l.rs:56:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n56 |     result\n\
    \   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for &i in even_values {\n        if i < smallest_even_value {\n  \
    \          smallest_even_value = i;\n            smallest_even_index = i;\n  \
    \      }\n    }\n    let mut result = vec![];\n    for &i in arr {\n        if\
    \ i == smallest_value {\n            result.push(i);\n        } else if i == smallest_even_value\
    \ {\n            result.push(smallest_even_index);\n        } else {\n       \
    \     result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjnesjbmy.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjnesjbmy.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjnesjbmy.rs:51:9\n   |\n51 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for &i in even_values {\n        if i < smallest_even_value {\n  \
    \          smallest_even_value = i;\n            smallest_even_index = i;\n  \
    \      }\n    }\n    vec![smallest_value, smallest_even_index]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2x33yx8y.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2x33yx8y.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value: isize = 0;\n    let mut min_even_index: usize = 0;\n\
    \    let mut min_even_index_in_arr: usize = 0;\n    let mut min_even_index_in_arr2:\
    \ usize = 0;\n    let mut min_even_index_in_arr3: usize = 0;\n    let mut min_even_index_in_arr4:\
    \ usize = 0;\n    let mut min_even_index_in_arr5: usize = 0;\n    let mut min_even_index_in_arr6:\
    \ usize = 0;\n    let mut min_even_index_in_arr7: usize = 0;\n    let mut min_even_index_in_arr8:\
    \ usize = 0;\n    let mut min_even_index_in_arr9: usize = 0;\n    let mut min_even_index_in_arr10:\
    \ usize = 0;\n    let mut min_even_index_in_arr11: usize = 0;\n    let mut min_even_index_in_arr12:\
    \ usize = 0;\n    let mut min_even_index_in_arr13: usize = 0;\n    let mut min_even_index_in_arr14:\
    \ usize = 0;\n    let mut min_even_index_in_arr15: usize = 0;\n    let mut min_even_index_in_arr16:\
    \ usize = 0;\n    let mut min_even_index_in_arr17: usize = 0;\n    let mut min_even_index_in_arr18:\
    \ usize = 0;\n    let mut min_even_index_in_arr19: usize = 0;\n    let mut min_even_index_in_arr20:\
    \ usize = 0;\n    let mut min_even_index_in_arr21: usize = 0;\n    let mut min_even_index_in_arr22:\
    \ usize = 0;\n    let mut min_even_index_in_arr23: usize = 0;\n    let mut min_even_index_in_arr24:\
    \ usize = 0;\n    let mut min_even_index_in_arr25: usize = 0;\n    let mut min_even_index_in_arr26:\
    \ usize = 0;\n    let mut min_even_index_in_arr27: usize = 0;\n    let mut min_even_index_in_arr28:\
    \ usize = 0;\n    let mut min_even_index_in_arr29: usize = 0;\n    let mut min_even_index_in_arr30:\
    \ usize = 0;\n    let mut min_even_index_in_arr31: usize = 0;\n    let mut min_even_index_in_arr32:\
    \ usize = 0;\n    let mut min_even_index_in_arr33: usize = 0;\n    let mut min_even_index_in_arr34:\
    \ usize = 0;\n    let mut min_even_index_in_arr35: usize = 0;\n    let mut min_even\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbynfknrs.rs:64:21\n   |\n\
    64 |     let mut min_even\n   |                     ^ help: add `;` here\n65 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbynfknrs.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx2\
    \ = 0;\n    let mut min_idx3 = 0;\n    let mut min_idx4 = 0;\n    let mut min_idx5\
    \ = 0;\n    let mut min_idx6 = 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8\
    \ = 0;\n    let mut min_idx9 = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11\
    \ = 0;\n    let mut min_idx12 = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14\
    \ = 0;\n    let mut min_idx15 = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17\
    \ = 0;\n    let mut min_idx18 = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20\
    \ = 0;\n    let mut min_idx21 = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23\
    \ = 0;\n    let mut min_idx24 = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26\
    \ = 0;\n    let mut min_idx27 = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29\
    \ = 0;\n    let mut min_idx30 = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32\
    \ = 0;\n    let mut min_idx33 = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35\
    \ = 0;\n    let mut min_idx36 = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38\
    \ = 0;\n    let mut min_idx39 = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41\
    \ = 0;\n    let mut min_idx42 = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44\
    \ = 0;\n    let mut min_idx45 = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47\
    \ = 0;\n    let mut min_idx48 = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50\
    \ = 0;\n    let mut min_idx51 = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53\
    \ = 0;\n    let mut min_idx54 = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56\
    \ = 0;\n    let mut min_idx57 = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59\
    \ = 0;\n    let mut min_idx60 = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62\
    \ = 0;\n    let mut min_idx63 = 0;\n    let mut min_idx\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbi0zs98f.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbi0zs98f.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &x in arr {\n        if x % 2 == 0 {\n\
    \            even_values.push(x);\n            if x < smallest_value {\n     \
    \           smallest_value = x;\n                smallest_index = even_values.len()\
    \ - 1;\n            }\n        }\n    }\n    even_values.sort();\n    let mut\
    \ even_values_index = even_values.len();\n    if even_values.len() == 0 {\n  \
    \      return vec![];\n    }\n    if even_values[even_values_index - 1] % 2 ==\
    \ 0 {\n        even_values_index -= 1;\n    }\n    let mut even_values_index =\
    \ even_values.len();\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    if even_values[even_values_index - 1] % 2 == 0 {\n        even_values_index\
    \ -= 1;\n    }\n    let mut even_values_index = even_values.len();\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    if even_values[even_values_index\
    \ - 1] % 2 == 0 {\n        even_values_index -= 1;\n    }\n    let mut even_values_index\
    \ = even_values.len();\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    if even_values[even_values_index - 1] % 2 == 0 {\n        even_values_index\
    \ -= 1;\n    }\n    let mut even_values_index = even_values.len();\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    if even_values[even_values_index\
    \ - 1] % 2 == 0 {\n        even_values_index -= 1;\n    }\n    let mut even_values_index\
    \ = even_values.len();\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    if even_values[even_values_index - 1] % 2 == 0 {\n        even_values_index\
    \ -= 1;\n    }\n    let mut even_values_index = even_values.len();\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    if even_values[even_values_index\
    \ - 1] % 2 == 0 {\n        even_values_index -= 1;\n    }\n    let mut even_values_index\
    \ = even_values.len();\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    if even_values[even_values_index - 1] % 2 == 0 {\n        even_values_index\
    \ -= 1;\n    }\n    let mut even_values_index = even_values.len();\n    if even_values.len()\
    \ == 0 {\n        return \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpixtouyxi.rs:111:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n97  |     if even_values.len()\
    \ == 0 {\n    |                               - this delimiter might not be properly\
    \ closed...\n98  |         return \n99  | }\n    | - ...as it matches this but\
    \ it has different indentation\n...\n111 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpixtouyxi.rs:30:9\n   |\n30 |     for &x in arr {\n   |\
    \         ^^    --- this expression has type `Option<isize>`\n   |         |\n\
    \   |         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0069]: `return;` in a function whose\
    \ return type is not `()`\n  --> /tmp/tmpixtouyxi.rs:98:9\n   |\n26 | fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected\
    \ `Vec<isize>` because of this return type\n...\n98 |         return \n   |  \
    \       ^^^^^^ return type is not `()`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpixtouyxi.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |    -----                     ^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \    found unit type `()`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0069, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0069`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even_value = arr[0];\n    let mut smallest_even_index =\
    \ -1;\n    let mut smallest_index = -1;\n    let mut even_values = Vec::new();\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if i == smallest_even_value {\n            smallest_even_index\
    \ = even_values.iter().position(|&x| x == i).unwrap();\n        }\n        if\
    \ i == smallest_even_value {\n            smallest_even_value = i;\n        }\n\
    \        if i == smallest_index {\n            smallest_index = i;\n        }\n\
    \    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    if\
    \ smallest_even_index == -1 {\n        return vec![smallest_even_value];\n   \
    \ }\n    if smallest_index == -1 {\n        return vec![smallest_even_index, smallest_even_value];\n\
    \    }\n    return vec![smallest_index, smallest_even_value];\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo326fked.rs:31:9\n   |\n\
    31 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpo326fked.rs:28:35\n   |\n28 | \
    \    let mut smallest_even_index = -1;\n   |                                 \
    \  ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0600]:\
    \ cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpo326fked.rs:48:31\n\
    \   |\n48 |     if smallest_even_index == -1 {\n   |                         \
    \      ^^\n   |                               |\n   |                        \
    \       cannot apply unary operator `-`\n   |                               help:\
    \ you may have meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note:\
    \ unsigned values cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo326fked.rs:52:21\n\
    \   |\n52 |         return vec![smallest_even_index, smallest_even_value];\n \
    \  |                     ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n52 |         return vec![smallest_even_index.try_into().unwrap(),\
    \ smallest_even_value];\n   |                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0600.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = arr[0];\n    let mut min_even_index = -1;\n    let\
    \ mut min_even_index_in_arr = 0;\n    let mut min_even_index_in_arr2 = 0;\n  \
    \  let mut min_even_index_in_arr3 = 0;\n    let mut min_even_index_in_arr4 = 0;\n\
    \    let mut min_even_index_in_arr5 = 0;\n    let mut min_even_index_in_arr6 =\
    \ 0;\n    let mut min_even_index_in_arr7 = 0;\n    let mut min_even_index_in_arr8\
    \ = 0;\n    let mut min_even_index_in_arr9 = 0;\n    let mut min_even_index_in_arr10\
    \ = 0;\n    let mut min_even_index_in_arr11 = 0;\n    let mut min_even_index_in_arr12\
    \ = 0;\n    let mut min_even_index_in_arr13 = 0;\n    let mut min_even_index_in_arr14\
    \ = 0;\n    let mut min_even_index_in_arr15 = 0;\n    let mut min_even_index_in_arr16\
    \ = 0;\n    let mut min_even_index_in_arr17 = 0;\n    let mut min_even_index_in_arr18\
    \ = 0;\n    let mut min_even_index_in_arr19 = 0;\n    let mut min_even_index_in_arr20\
    \ = 0;\n    let mut min_even_index_in_arr21 = 0;\n    let mut min_even_index_in_arr22\
    \ = 0;\n    let mut min_even_index_in_arr23 = 0;\n    let mut min_even_index_in_arr24\
    \ = 0;\n    let mut min_even_index_in_arr25 = 0;\n    let mut min_even_index_in_arr26\
    \ = 0;\n    let mut min_even_index_in_arr27 = 0;\n    let mut min_even_index_in_arr28\
    \ = 0;\n    let mut min_even_index_in_arr29 = 0;\n    let mut min_even_index_in_arr30\
    \ = 0;\n    let mut min_even_index_in_arr31 = 0;\n    let mut min_even_index_in_arr32\
    \ = 0;\n    let mut min_even_index_in_arr33 = 0;\n    let mut min_even_index_in_arr34\
    \ = 0;\n    let mut min_even_index_in_arr35 = 0;\n    let mut min_even_index_in_arr36\
    \ = 0;\n    let mut min_even_index_in_arr37 = 0;\n    let mut min_even_index_in_arr38\
    \ = 0;\n    let mut min_even_index_in_arr39 = 0;\n    let mut min_even_index_in_arr40\
    \ = 0;\n    let mut min_even_index_in_arr41 = 0;\n    let mut min_even_index_in_arr42\
    \ = 0;\n    let mut min_even_index_in_arr43 = 0;\n    let mut min_even_index_in_arr44\
    \ = 0;\n    let mut min_even_index_in_arr45 = 0;\n    let mut min_even\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4xjy8ilx.rs:74:21\n   |\n\
    74 |     let mut min_even\n   |                     ^ help: add `;` here\n75 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xjy8ilx.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values.push(arr[i]);\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_value_even = even_values[0];\n\
    \    let mut smallest_index_even = 0;\n    for i in 0..even_values.len() {\n \
    \       if even_values[i] < smallest_value_even {\n            smallest_value_even\
    \ = even_values[i];\n            smallest_index_even = i;\n        }\n    }\n\
    \    vec![smallest_value, smallest_index_even]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprgd99u1r.rs:50:26\n   |\n\
    50 |     vec![smallest_value, smallest_index_even]\n   |                     \
    \     ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n50 |     vec![smallest_value, smallest_index_even.try_into().unwrap()]\n\
    \   |                                             ++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2\
    \ == 0 {\n            even_values.push(i);\n            if smallest_value < i\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ Vec::new();\n    }\n    let mut smallest_even_value = even_values[0];\n    let\
    \ mut smallest_even_index = 0;\n    for i in even_values.iter() {\n        if\
    \ i % 2 == 0 {\n            if smallest_even_value < i {\n                smallest_even_value\
    \ = i;\n                smallest_even_index = i;\n            }\n        }\n \
    \   }\n    let mut result = Vec::new();\n    for i in arr.iter() {\n        if\
    \ i == smallest_value {\n            result.push(smallest_value);\n          \
    \  result.push(smallest_index);\n        } else if i == smallest_even_value {\n\
    \            result.push(smallest_even_value);\n            result.push(smallest_even_index);\n\
    \        } else {\n            result.push(i);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3m9opvb3.rs:33:33\n   |\n\
    33 |             if smallest_value < i {\n   |                               \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n33 |             if smallest_value < *i {\n   |              \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3m9opvb3.rs:34:34\n\
    \   |\n28 |     let mut smallest_value = arr[0];\n   |                       \
    \       ------ expected due to this value\n...\n34 |                 smallest_value\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3m9opvb3.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmp3m9opvb3.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3m9opvb3.rs:48:39\n   |\n\
    43 |     let mut smallest_even_index = 0;\n   |                              \
    \     - expected due to this value\n...\n48 |                 smallest_even_index\
    \ = i;\n   |                                       ^ expected integer, found `&&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n48 |                 smallest_even_index\
    \ = **i;\n   |                                       ++\n\nerror[E0277]: can't\
    \ compare `&isize` with `isize`\n  --> /tmp/tmp3m9opvb3.rs:54:14\n   |\n54 | \
    \        if i == smallest_value {\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx\
    \ = arr.iter().min_by_key(|&x| {\n        if x.is_even() {\n            min_value\
    \ = x;\n            min_idx = x;\n            true\n        } else {\n       \
    \     false\n        }\n    });\n    min_idx.unwrap()\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_even` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmphvw5y0fp.rs:30:14\n   |\n30 |         if x.is_even()\
    \ {\n   |              ^^^^^^^ method not found in `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphvw5y0fp.rs:31:25\n   |\n27 |     let mut min_value = arr[0];\n\
    \   |                         ------ expected due to this value\n...\n31 |   \
    \          min_value = x;\n   |                         ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n31 |        \
    \     min_value = *x;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphvw5y0fp.rs:32:23\n   |\n28 |     let mut min_idx = 0;\n\
    \   |                       - expected due to this value\n...\n32 |          \
    \   min_idx = x;\n   |                       ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n32 |             min_idx\
    \ = *x;\n   |                       +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmphvw5y0fp.rs:38:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n38 |     min_idx.unwrap()\n   |     ^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found reference `&isize`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_index = 0;\n    let mut even_values\
    \ = Vec::new();\n    for i in arr.iter() {\n        if i % 2 == 0 {\n        \
    \    even_values.push(i);\n            if min_value > i {\n                min_value\
    \ = i;\n                min_index = i;\n            }\n        }\n    }\n    if\
    \ even_values.len() == 0 {\n        return vec![];\n    }\n    let mut smallest_value\
    \ = even_values[0];\n    let mut smallest_index = 0;\n    for i in even_values.iter()\
    \ {\n        if i < smallest_value {\n            smallest_value = i;\n      \
    \      smallest_index = i;\n        }\n    }\n    vec![smallest_value, smallest_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyav_2jel.rs:33:28\n   |\n\
    33 |             if min_value > i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |             if min_value > *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyav_2jel.rs:34:29\n   |\n27 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n34 |                 min_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    34 |                 min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyav_2jel.rs:35:29\n   |\n28 |     let mut min_index\
    \ = 0;\n   |                         - expected due to this value\n...\n35 | \
    \                min_index = i;\n   |                             ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |  \
    \               min_index = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyav_2jel.rs:45:16\n   |\n45 |         if i <\
    \ smallest_value {\n   |                ^^^^^^^^^^^^^^ expected `&isize`, found\
    \ `isize`\n   |\n   = note: expected reference `&&isize`\n              found\
    \ reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyav_2jel.rs:47:30\n\
    \   |\n43 |     let mut smallest_index = 0;\n   |                            \
    \  - expected due to this value\n...\n47 |             smallest_index = i;\n \
    \  |                              ^ expected integer, found `&&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n47 |             smallest_index\
    \ = **i;\n   |                              ++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyav_2jel.rs:50:10\n   |\n50 |     vec![smallest_value, smallest_index]\n\
    \   |          ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n50 |     vec![*smallest_value, smallest_index]\n\
    \   |          +\n\nerror: aborti"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if smallest_value < i {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_value_with_even_value = even_values[even_values.len()\
    \ - 1];\n    let mut smallest_index_with_even_value = even_values.len() - 1;\n\
    \    for &i in even_values {\n        if i < smallest_value_with_even_value {\n\
    \            smallest_value_with_even_value = i;\n            smallest_index_with_even_value\
    \ = i;\n        }\n    }\n    let mut even_values_without_smallest_value = even_values.clone();\n\
    \    even_values_without_smallest_value.remove(0);\n    let mut smallest_value_without_even_value\
    \ = even_values_without_smallest_value[0];\n    let mut smallest_index_without_even_value\
    \ = even_values_without_smallest_value.len() - 1;\n    for &i in even_values_without_smallest_value\
    \ {\n        if i < smallest_value_without_even_value {\n            smallest_value_without_even_value\
    \ = i;\n            smallest_index_without_even_value = i;\n        }\n    }\n\
    \    let mut even_values_without_smallest_value_with_even_value = even_values_without_smallest_value.clone();\n\
    \    even_values_without_smallest_value_with_even_value.remove(0);\n    let mut\
    \ smallest_value_without_even_value_with_even_value = even_values_without_smallest_value_with_even_value[0];\n\
    \    let mut smallest_index_without_even_value_with_even_value = even_values_without_smallest_value_with_even_value.len()\
    \ - 1;\n    for &i in even_values_without_smallest_value_with_even_value {\n \
    \       if i < smallest_value_without_even_value_with_even_value {\n         \
    \   smallest_value_without_even_value_with_even_value = i;\n            smallest_index_without_even_value_with_even_value\
    \ = i;\n        }\n    }\n    let mut even_values_without_smallest_value_without_even_value\
    \ = even_values_without_smallest_value_with_even_value.clone();\n    even_values_without_smallest_value_without_even_value.remove(0);\n\
    \    let mut smallest_value_without_even_value_without_even_value = even_values_without_smallest_value_without_even_value[0];\n\
    \    let mut smallest_index_without_even_value_without_even_value = even_values_without_smallest_value_without_even_value.len()\
    \ - 1;\n    for &i in even_values_without_\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmp6978irp5.rs:75:1\n   |\n\
    75 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6978irp5.rs:30:9\n\
    \   |\n30 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6978irp5.rs:44:9\n   |\n44 |     for &i in even_values\
    \ {\n   |         ^^    ----------- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6978irp5.rs:47:46\n   |\n43 |     let mut smallest_index_with_even_value\
    \ = even_values.len() - 1;\n   |                                             \
    \ --------------------- expected due to this value\n...\n47 |             smallest_index_with_even_value\
    \ = i;\n   |                                              ^ expected `usize`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6978irp5.rs:54:9\n\
    \   |\n54 |     for &i in even_values_without_smallest_value {\n   |         ^^\
    \    ---------------------------------- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6978irp5.rs:57:49\n   |\n53 |     let mut smallest_index_without_even_value\
    \ = even_values_without_smallest_value.len() - 1;\n   |                      \
    \                           -------------------------------------------- expected\
    \ due to this value\n...\n57 |             smallest_index_without_even_value =\
    \ i;\n   |                                                 ^ expected "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2 ==\
    \ 0 {\n            even_values.push(i);\n            if smallest_value < i {\n\
    \                smallest_value = i;\n                smallest_index = i;\n  \
    \          }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = 0;\n    for i in even_values.iter() {\n        if i %\
    \ 2 == 0 {\n            if smallest_even_value < i {\n                smallest_even_value\
    \ = i;\n                smallest_even_index = i;\n            }\n        }\n \
    \   }\n    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpizaviz6a.rs:33:33\n   |\n\
    33 |             if smallest_value < i {\n   |                               \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n33 |             if smallest_value < *i {\n   |              \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpizaviz6a.rs:34:34\n\
    \   |\n28 |     let mut smallest_value = arr[0];\n   |                       \
    \       ------ expected due to this value\n...\n34 |                 smallest_value\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpizaviz6a.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpizaviz6a.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpizaviz6a.rs:48:39\n   |\n\
    43 |     let mut smallest_even_index = 0;\n   |                              \
    \     - expected due to this value\n...\n48 |                 smallest_even_index\
    \ = i;\n   |                                       ^ expected integer, found `&&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n48 |                 smallest_even_index\
    \ = **i;\n   |                                       ++\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an er"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2 ==\
    \ 0 {\n            even_values.push(i);\n            if i < smallest_value {\n\
    \                smallest_value = i;\n                smallest_index = i;\n  \
    \          }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = 0;\n    for i in even_values.iter() {\n        if i <\
    \ smallest_even_value {\n            smallest_even_value = i;\n            smallest_even_index\
    \ = i;\n        }\n    }\n    let mut even_values_copy = even_values.clone();\n\
    \    even_values_copy.remove(smallest_even_index);\n    even_values_copy.sort();\n\
    \    let mut even_values_copy = even_values_copy.clone();\n    even_values_copy.pop();\n\
    \    even_values_copy.sort();\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.pop();\n    even_values_copy.sort();\n    let mut even_values_copy\
    \ = even_values_copy.clone();\n    even_values_copy.pop();\n    even_values_copy.sort();\n\
    \    let mut even_values_copy = even_values_copy.clone();\n    even_values_copy.pop();\n\
    \    even_values_copy.sort();\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.pop();\n    even_values_copy.sort();\n    let mut even_values_copy\
    \ = even_values_copy.clone();\n    even_values_copy.pop();\n    even_values_copy.sort();\n\
    \    let mut even_values_copy = even_values_copy.clone();\n    even_values_copy.pop();\n\
    \    even_values_copy.sort();\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.pop();\n    even_values_copy.sort();\n    let mut even_values_copy\
    \ = even_values_copy.clone();\n    even_values_copy.pop();\n    even_values_copy.sort();\n\
    \    let mut even_values_copy = even_values_copy.clone();\n    even_values_copy.pop();\n\
    \    even_values_copy.sort();\n    let mut even_values_copy = even_values_copy.clone();\n\
    \    even_values_copy.pop();\n    even_values_copy.sort();\n    let mut even_values_copy\
    \ = even_values_copy.clone();\n    even_values_copy.pop();\n    even_value\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `even_value` in this scope\n  --> /tmp/tmpbp8gx94e.rs:88:5\n\
    \   |\n88 |     even_value\n   |     ^^^^^^^^^^ help: a local variable with a\
    \ similar name exists: `even_values`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpbp8gx94e.rs:33:20\n   |\n33 |             if i < smallest_value {\n\
    \   |                    ^^^^^^^^^^^^^^\n   |                    |\n   |     \
    \               expected `&isize`, found `isize`\n   |                    help:\
    \ consider borrowing here: `&smallest_value`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbp8gx94e.rs:34:34\n   |\n28 |     let mut smallest_value = arr[0];\n\
    \   |                              ------ expected due to this value\n...\n34\
    \ |                 smallest_value = i;\n   |                                \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n34 |                 smallest_value = *i;\n   |              \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbp8gx94e.rs:35:34\n\
    \   |\n29 |     let mut smallest_index = 0;\n   |                            \
    \  - expected due to this value\n...\n35 |                 smallest_index = i;\n\
    \   |                                  ^ expected integer, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n35 |                 smallest_index\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbp8gx94e.rs:45:16\n   |\n45 |         if i < smallest_even_value\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `isize`\n\
    \   |\n   = note: expected reference `&&isize`\n              found reference\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbp8gx94e.rs:47:35\n\
    \   |\n43 |     let mut smallest_even_index = 0;\n   |                       \
    \            - expected due to this value\n...\n47 |             smallest_even_index\
    \ = i;\n   |                                   ^ expected integer, found `&&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n47 |             smallest_even_index\
    \ = **i;\n   |                             "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = arr[0];\n    let mut min_even_index = -1;\n    let\
    \ mut min_even_index_in_list = -1;\n    let mut min_even_index_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list = -1;\n    let mut\
    \ min_even_index_in_list_in_list_in_list_in_list = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = -1;\n    let mut min_even_index_in_list_in_list_in_list_in_\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr_ufm8cy.rs:48:55\n   |\n\
    48 |     let mut min_even_index_in_list_in_list_in_list_in_\n   |            \
    \                                           ^ help: add `;` here\n49 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr_ufm8cy.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = arr[0];\n    let mut min_even_index = -1;\n    let\
    \ mut min_even_index_found = false;\n    let mut even_values = Vec::new();\n \
    \   for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n            if min_even_index\
    \ == -1 || arr[i] < min_even_value{\n                min_even_value = arr[i];\n\
    \                min_even_index = i;\n                min_even_index_found = true;\n\
    \            }\n            even_values.push(arr[i]);\n        }\n    }\n    if\
    \ !min_even_index_found {\n        return Vec::new();\n    }\n    let mut even_values_sorted\
    \ = even_values.clone();\n    even_values_sorted.sort();\n    let mut min_even_value_sorted\
    \ = min_even_value;\n    let mut min_even_index_sorted = min_even_index;\n   \
    \ for i in 0..even_values_sorted.len() {\n        if even_values_sorted[i] ==\
    \ min_even_value_sorted {\n            min_even_index_sorted = i;\n        }\n\
    \    }\n    let mut even_values_sorted_copy = even_values_sorted.clone();\n  \
    \  even_values_sorted_copy.remove(&min_even_index_sorted);\n    even_values_sorted_copy.sort();\n\
    \    let mut even_values_sorted_copy = even_values_sorted_copy.clone();\n    let\
    \ mut even_values_sorted_copy = even_values_sorted_copy.clone();\n    even_values_sorted_copy.remove(&min_even_index_sorted);\n\
    \    even_values_sorted_copy.sort();\n    let mut even_values_sorted_copy = even_values_sorted_copy.clone();\n\
    \    even_values_sorted_copy.remove(&min_even_index_sorted);\n    even_values_sorted_copy.sort();\n\
    \    let mut even_values_sorted_copy = even_values_sorted_copy.clone();\n    even_values_sorted_copy.remove(&min_even_index_sorted);\n\
    \    even_values_sorted_copy.sort();\n    let mut even_values_sorted_copy = even_values_sorted_copy.clone();\n\
    \    even_values_sorted_copy.remove(&min_even_index_sorted);\n    even_values_sorted_copy.sort();\n\
    \    let mut even_values_sorted_copy = even_values_sorted_copy.clone();\n    even_values_sorted_copy.remove(&min_even_index_sorted);\n\
    \    even_values_sorted_copy.sort();\n    let mut even_values_sorted_copy = even_values_sorted_copy.clone();\n\
    \    even_values_sorted_copy.remove(&min_even_index_sorted);\n    even_values_sorted_copy.sort();\n\
    \    let mut even_values_sorted_copy = even_values_sorted_copy.clone();\n    even_values_sorted_copy.remove(&min_even_index_sorted);\n\
    \    even_values_sorted_\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `even_values_sorted_` in this scope\n \
    \ --> /tmp/tmplrzt_h1x.rs:77:5\n   |\n77 |     even_values_sorted_\n   |     ^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `even_values_sorted`\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmplrzt_h1x.rs:28:30\n\
    \   |\n28 |     let mut min_even_index = -1;\n   |                           \
    \   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmplrzt_h1x.rs:33:34\n\
    \   |\n33 |             if min_even_index == -1 || arr[i] < min_even_value{\n\
    \   |                                  ^^ the trait `Neg` is not implemented for\
    \ `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplrzt_h1x.rs:54:36\n\
    \   |\n54 |     even_values_sorted_copy.remove(&min_even_index_sorted);\n   |\
    \                                    ^^^^^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found `&usize`\n   |\nhelp: consider removing the borrow\n   |\n54 -     even_values_sorted_copy.remove(&min_even_index_sorted);\n\
    54 +     even_values_sorted_copy.remove(min_even_index_sorted);\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplrzt_h1x.rs:58:36\n   |\n58 |     even_values_sorted_copy.remove(&min_even_index_sorted);\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found `&usize`\n   |\nhelp: consider removing the borrow\n   |\n58 -     even_values_sorted_copy.remove(&min_even_index_sorted);\n\
    58 +     even_values_sorted_copy.remove(min_even_index_sorted);\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplrz"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for &i in even_values {\n        if i < smallest_even_value {\n  \
    \          smallest_even_value = i;\n            smallest_even_index = i;\n  \
    \      }\n    }\n    let mut result = vec![];\n    if smallest_even_value == smallest_value\
    \ {\n        result.push(smallest_even_index);\n    } else {\n        result.push(smallest_value);\n\
    \        result.push(smallest_even_index);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxfr179k2.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxfr179k2.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    let mut smallest_even_value = 0;\n    for &x\
    \ in arr {\n        if x % 2 == 0 {\n            even_values.push(x);\n      \
    \      if x < smallest_value {\n                smallest_value = x;\n        \
    \        smallest_index = even_values.len() - 1;\n            }\n            if\
    \ x == smallest_value {\n                smallest_even_value = x;\n          \
    \  }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut even_values_sorted = even_values.iter().cloned().collect::<Vec<isize>>();\n\
    \    even_values_sorted.sort();\n    let mut smallest_even_value_sorted = even_values_sorted[0];\n\
    \    let mut smallest_index_sorted = even_values_sorted.len() - 1;\n    for &x\
    \ in even_values_sorted {\n        if x < smallest_even_value_sorted {\n     \
    \       smallest_even_value_sorted = x;\n            smallest_index_sorted = even_values_sorted.len()\
    \ - 1;\n        }\n        if x == smallest_even_value_sorted {\n            smallest_index_sorted\
    \ = even_values_sorted.len() - 1;\n        }\n    }\n    let mut even_values_sorted_sorted\
    \ = even_values_sorted.iter().cloned().collect::<Vec<isize>>();\n    even_values_sorted_sorted.sort();\n\
    \    let mut smallest_even_value_sorted_sorted = even_values_sorted_sorted[0];\n\
    \    let mut smallest_index_sorted_sorted = even_values_sorted_sorted.len() -\
    \ 1;\n    for &x in even_values_sorted_sorted {\n        if x < smallest_even_value_sorted_sorted\
    \ {\n            smallest_even_value_sorted_sorted = x;\n            smallest_index_sorted_sorted\
    \ = even_values_sorted_sorted.len() - 1;\n        }\n        if x == smallest_even_value_sorted_sorted\
    \ {\n            smallest_index_sorted_sorted = even_values_sorted_sorted.len()\
    \ - 1;\n        }\n    }\n    let mut even_values_sorted_sorted_sorted = even_values_sorted_sorted.iter().cloned().collect::<Vec<isize>>();\n\
    \    even_values_sorted_sorted_sorted.sort();\n    let mut smallest_even_value_sorted_sorted_sorted\
    \ = even_values_sorted_sorted_sorted[0];\n    let mut smallest_index_sorted_sorted_sorted\
    \ = even_values_sorted_sorted_sorted.len() - 1;\n    for &x in even_values_sorted_sorted_sorted\
    \ {\n        if x < smallest_even_value_sorted_sorted_sorted {\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpnwx9bqr0.rs:90:3\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - unclosed delimiter\n...\n76 |     for &x in even_values_sorted_sorted_sorted\
    \ {\n   |                                                - unclosed delimiter\n\
    77 |         if x < smallest_even_value_sorted_sorted_sorted {\n   |         \
    \                                                - this delimiter might not be\
    \ properly closed...\n78 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n90 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpnwx9bqr0.rs:31:9\n   |\n31 |     for &x in arr {\n   |         ^^  \
    \  --- this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnwx9bqr0.rs:50:9\n\
    \   |\n50 |     for &x in even_values_sorted {\n   |         ^^    ------------------\
    \ this expression has type `Option<isize>`\n   |         |\n   |         expected\
    \ `isize`, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `x`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnwx9bqr0.rs:63:9\n   |\n\
    63 |     for &x in even_values_sorted_sorted {\n   |         ^^    -------------------------\
    \ this expression has type `Option<isize>`\n   |         |\n   |         expected\
    \ `isize`, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `x`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnwx9bqr0.rs:76:9\n   |\n\
    76 |     for &x in even_values_sorted_sorted_sorted {\n   |         ^^    --------------------------------\
    \ this expression has type `Option<isize>`\n   |         |\n   |         expected\
    \ `isize`, found reference\n   |         help: you can pro"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 1;\n    let mut min_idx\
    \ = 1;\n    for i in arr.iter().cloned() {\n        if i % 2 == 0 {\n        \
    \    if min_value < i {\n                min_value = i;\n                min_idx\
    \ = min_idx;\n            }\n        } else {\n            if min_value == i {\n\
    \                min_idx++;\n            }\n        }\n    }\n    if min_value\
    \ == arr[0] {\n        min_idx++;\n    }\n    vec![min_value, min_idx]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpc_lljtf6.rs:38:24\n\
    \   |\n38 |                 min_idx++;\n   |                        ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n38 |               \
    \  { let tmp = min_idx; min_idx += 1; tmp };\n   |                 +++++++++++\
    \        ~~~~~~~~~~~~~~~~~~~~~\n38 -                 min_idx++;\n38 +        \
    \         min_idx += 1;\n   | \n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmpc_lljtf6.rs:43:16\n   |\n43 |         min_idx++;\n   |        \
    \        ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    43 |         { let tmp = min_idx; min_idx += 1; tmp };\n   |         +++++++++++\
    \        ~~~~~~~~~~~~~~~~~~~~~\n43 -         min_idx++;\n43 +         min_idx\
    \ += 1;\n   | \n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = arr[0];\n    let mut min_even_index = -1;\n    let\
    \ mut min_even_index_in_list = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            if min_even_index == -1 || arr[i] < min_even_value{\n\
    \                min_even_value = arr[i];\n                min_even_index = i;\n\
    \                min_even_index_in_list = i;\n            }\n        }\n    }\n\
    \    let mut result = vec![];\n    if min_even_index != -1 {\n        result.push(min_even_value);\n\
    \        result.push(min_even_index);\n        result.push(min_even_index_in_list);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpl3okssqp.rs:28:30\n\
    \   |\n28 |     let mut min_even_index = -1;\n   |                           \
    \   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpl3okssqp.rs:32:34\n\
    \   |\n32 |             if min_even_index == -1 || arr[i] < min_even_value{\n\
    \   |                                  ^^ the trait `Neg` is not implemented for\
    \ `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmpl3okssqp.rs:29:38\n   |\n29 |     let mut min_even_index_in_list\
    \ = -1;\n   |                                      ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type\
    \ `usize`\n  --> /tmp/tmpl3okssqp.rs:40:26\n   |\n40 |     if min_even_index !=\
    \ -1 {\n   |                          ^^\n   |                          |\n  \
    \ |                          cannot apply unary operator `-`\n   |           \
    \               help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl3okssqp.rs:42:21\n   |\n42 |         result.push(min_even_index);\n\
    \   |                     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut smallest_even_value = 0;\n    for\
    \ i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if smallest_value < i {\n                smallest_value = i;\n  \
    \              smallest_index = i;\n                smallest_even_value = i;\n\
    \            }\n        } else {\n            if smallest_even_value < i {\n \
    \               smallest_even_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    even_values.sort();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `even` in this scope\n  --> /tmp/tmp97bqbuw1.rs:96:5\n\
    \   |\n96 |     even\n   |     ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp97bqbuw1.rs:34:33\n   |\n34 |             if smallest_value\
    \ < i {\n   |                                 ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n34 |             if smallest_value\
    \ < *i {\n   |                                 +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp97bqbuw1.rs:35:34\n   |\n28 |     let mut smallest_value = arr[0];\n\
    \   |                              ------ expected due to this value\n...\n35\
    \ |                 smallest_value = i;\n   |                                \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n35 |                 smallest_value = *i;\n   |              \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp97bqbuw1.rs:36:34\n\
    \   |\n29 |     let mut smallest_index = 0;\n   |                            \
    \  - expected due to this value\n...\n36 |                 smallest_index = i;\n\
    \   |                                  ^ expected integer, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n36 |                 smallest_index\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp97bqbuw1.rs:37:39\n   |\n30 |     let mut smallest_even_value =\
    \ 0;\n   |                                   - expected due to this value\n...\n\
    37 |                 smallest_even_value = i;\n   |                          \
    \             ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n37 |                 smallest_even_value = *i;\n   |     \
    \                                  +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp97bqbuw1.rs:41:39\n   |\n30 |     let mut smallest_even_value = 0;\n\
    \   |                                   - expected due to this value\n...\n41\
    \ |                 smallest_even_value = i;\n   |                           \
    \            ^ expected `isize`, found"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_value = arr[0];\n    let mut\
    \ min_value_index = -1;\n    for i in 0..arr.len() {\n        if arr[i] % 2 ==\
    \ 0 {\n            even_values.push(arr[i]);\n            if arr[i] < min_value\
    \ {\n                min_value = arr[i];\n                min_value_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_value = even_values[0];\n    let mut smallest_value_index\
    \ = -1;\n    for i in 0..even_values.len() {\n        if even_values[i] < smallest_value\
    \ {\n            smallest_value = even_values[i];\n            smallest_value_index\
    \ = i;\n        }\n    }\n    let mut result = vec![];\n    for i in 0..even_values.len()\
    \ {\n        if even_values[i] == smallest_value {\n            result.push(i);\n\
    \        }\n    }\n    if result.len() == 0 {\n        return vec![];\n    }\n\
    \    result.push(smallest_value_index);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp5d44qd87.rs:29:31\n\
    \   |\n29 |     let mut min_value_index = -1;\n   |                          \
    \     ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp5d44qd87.rs:43:36\n\
    \   |\n43 |     let mut smallest_value_index = -1;\n   |                     \
    \               ^^ the trait `Neg` is not implemented for `usize`\n   |\n   =\
    \ help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5d44qd87.rs:60:5\n   |\n26 | fn\
    \ pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n60 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<usize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values.push(arr[i]);\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = 0;\n    for i in 0..even_values.len() {\n \
    \       if even_values[i] < smallest_even_value {\n            smallest_even_value\
    \ = even_values[i];\n            smallest_even_index = i;\n        }\n    }\n\
    \    let mut result = vec![];\n    for i in 0..even_values.len() {\n        if\
    \ i == smallest_even_index {\n            result.push(i);\n        }\n    }\n\
    \    return result;\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps_41821y.rs:56:12\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n56 |     return\
    \ result;\n   |            ^^^^^^ expected `isize`, found `usize`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut min_value = arr[0];\n    let\
    \ mut min_index = -1;\n    let mut min_even_value = 0;\n    for i in 0..arr.len()\
    \ {\n        if arr[i] % 2 == 0 {\n            even_values.push(arr[i]);\n   \
    \         if arr[i] < min_value {\n                min_value = arr[i];\n     \
    \           min_index = i;\n            }\n            if arr[i] < min_even_value\
    \ {\n                min_even_value = arr[i];\n            }\n        }\n    }\n\
    \    if even_values.len() == 0 {\n        return vec![];\n    }\n    let mut even_values_iter\
    \ = even_values.iter().cloned().collect::<Vec<_>>();\n    let mut even_values_iter\
    \ = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n    let mut even_values_iter\
    \ = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n    let mut even_values_iter\
    \ = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n    let mut even_values_iter\
    \ = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n    let mut even_values_iter\
    \ = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n    let mut even_values_iter\
    \ = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n    let mut even_values_iter\
    \ = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n    let mut even_values_iter\
    \ = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n    let mut even_values_iter\
    \ = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n    let mut even_values_iter\
    \ = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n    let mut even_values_iter\
    \ = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n    let mut even_values_iter\
    \ = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n    let mut even_values_iter\
    \ = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n    let mut even_values_iter\
    \ = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n    let mut even_values_iter\
    \ = even_values_iter.\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpil6zvunw.rs:62:1\n   |\n62\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpil6zvunw.rs:61:49\n\
    \   |\n61 |     let mut even_values_iter = even_values_iter.\n   |           \
    \                                      ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  -->\
    \ /tmp/tmpil6zvunw.rs:29:25\n   |\n29 |     let mut min_index = -1;\n   |    \
    \                     ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpil6zvunw.rs:47:61\n     |\n47   |     let mut even_values_iter\
    \ = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n     |       \
    \                                                      ^^^^^^ expected reference,\
    \ found `isize`\n     |\n     = note: expected reference `&_`\n              \
    \       found type `isize`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpil6zvunw.rs:47:70\n \
    \  |\n47 |       let mut even_values_iter = even_values_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                                                        ^^^^^^^\
    \ method cannot be called on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<std::vec::IntoIter<isize> as Iterator>::Item = &_`\n           which\
    \ is required by `Cloned<std::vec::IntoIter<isize>>: Iterator`\n           `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           which is required by `&mut Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_value = arr[0];\n    let mut smallest_index = 0;\n    let\
    \ mut mut_smallest_value = smallest_value;\n    let mut mut_smallest_index = smallest_index;\n\
    \    let mut mut_mut_smallest_value = mut_smallest_value;\n    let mut mut_mut_smallest_index\
    \ = mut_smallest_index;\n    let mut mut_mut_mut_smallest_value = mut_mut_smallest_value;\n\
    \    let mut mut_mut_mut_smallest_index = mut_mut_smallest_index;\n    let mut\
    \ mut_mut_mut_mut_smallest_value = mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mut_mu\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmz87e7hy.rs:46:92\n   |\n\
    46 |     let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index = mut_mut_mut_mut_mut_mu\n\
    \   |                                                                        \
    \                    ^ help: add `;` here\n47 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `mut_mut_mut_mut_mut_mut_mut_mut_smallest_value`\
    \ in this scope\n  --> /tmp/tmpmz87e7hy.rs:45:66\n   |\n45 |     let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_mut_mut_mut_mut_smallest_value;\n   |                    \
    \                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `mut_mut_mut_mut_mut_mut_mut_smallest_value`\n\
    \nerror[E0425]: cannot find value `mut_mut_mut_mut_mut_mu` in this scope\n  -->\
    \ /tmp/tmpmz87e7hy.rs:46:70\n   |\n46 |     let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mut_mu\n   |                                             \
    \                         ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmz87e7hy.rs:26:30\n   |\n26 | fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values.push(arr[i]);\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = 0;\n    for i in 0..even_values.len() {\n \
    \       if even_values[i] < smallest_even_value {\n            smallest_even_value\
    \ = even_values[i];\n            smallest_even_index = i;\n        }\n    }\n\
    \    vec![smallest_value, smallest_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo99dj3ty.rs:50:26\n   |\n\
    50 |     vec![smallest_value, smallest_even_index]\n   |                     \
    \     ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n50 |     vec![smallest_value, smallest_even_index.try_into().unwrap()]\n\
    \   |                                             ++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = arr[0];\n    let mut min_even_index = -1;\n    let\
    \ mut min_even_index_in_arr = 0;\n    let mut even_values = vec![];\n    for i\
    \ in arr.iter().cloned() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if min_even_index == -1 || min_even_index > i {\n               \
    \ min_even_index = i;\n                min_even_index_in_arr = min_even_index_in_arr\
    \ + 1;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    if min_even_index == -1 {\n        return vec![];\n\
    \    }\n    let mut min_even_value = even_values[0];\n    let mut min_even_index\
    \ = min_even_index_in_arr;\n    for i in even_values.iter().cloned() {\n     \
    \   if i % 2 == 0 {\n            if min_even_index == -1 || min_even_index > i\
    \ {\n                min_even_index = i;\n                min_even_value = i;\n\
    \            }\n        }\n    }\n    let mut even_values = vec![];\n    for i\
    \ in arr.iter().cloned() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    if min_even_index == -1 {\n        return vec![];\n    }\n    let mut\
    \ even_values = vec![];\n    for i in even_values.iter().cloned() {\n        if\
    \ i % 2 == 0 {\n            if min_even_index == -1 || min_even_index > i {\n\
    \                min_even_index = i;\n                min_even_value = i;\n  \
    \          }\n        }\n    }\n    if min_even_index == -1 {\n        return\
    \ vec![];\n    }\n    let mut even_values = vec![];\n    for i in even_values.iter().cloned()\
    \ {\n        if i % 2 == 0 {\n            if min_even_index == -1 || min_even_index\
    \ > i {\n                min_even_index = i;\n                min_even_value =\
    \ i;\n            }\n        }\n    }\n    if min_even_index == -1 {\n       \
    \ return vec![];\n    }\n    let mut even_values = vec![];\n    for i in even_values.iter().cloned()\
    \ {\n        if i % 2 == 0 {\n            if min_even_index == -1 || min_even_index\
    \ > i {\n                min_even_index = i;\n                min_even_value =\
    \ i;\n            }\n        }\n    }\n    if min_even_index == -1 {\n       \
    \ return vec![];\n    }\n    let mut even_values = vec![];\n    for i in even_values.iter().cloned()\
    \ {\n        if i % 2 == 0 {\n            if min_even_index == -1 || min_even_index\
    \ > i {\n                min_even_index = \n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpamqwyret.rs:121:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n105 |     for i in even_values.iter().cloned()\
    \ {\n    |                                          - unclosed delimiter\n106\
    \ |         if i % 2 == 0 {\n    |                       - unclosed delimiter\n\
    107 |             if min_even_index == -1 || min_even_index > i {\n    |     \
    \                                                      - this delimiter might\
    \ not be properly closed...\n108 |                 min_even_index = \n109 | }\n\
    \    | - ...as it matches this but it has different indentation\n...\n121 | }\n\
    \    |   ^\n\nerror: expected expression, found `}`\n   --> /tmp/tmpamqwyret.rs:109:1\n\
    \    |\n109 | }\n    | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \   --> /tmp/tmpamqwyret.rs:105:5\n    |\n26  |   fn pluck(arr: Vec<isize>) ->\
    \ Vec<isize> {\n    |                                ---------- expected `Vec<isize>`\
    \ because of return type\n...\n105 | /     for i in even_values.iter().cloned()\
    \ {\n106 | |         if i % 2 == 0 {\n107 | |             if min_even_index ==\
    \ -1 || min_even_index > i {\n108 | |                 min_even_index = \n... \
    \  |\n120 | |     assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n\
    121 | | }\n    | |__^ expected struct `Vec`, found `()`\n    |\n    = note: expected\
    \ struct `Vec<isize>`\n            found unit type `()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_index = 0;\n    let mut min_even_value\
    \ = false;\n    for &i in arr {\n        if i % 2 == 0 {\n            if min_even_value{\n\
    \                min_value = i;\n                min_index = i;\n            }\n\
    \            else{\n                min_even_value = true;\n            }\n  \
    \      }\n    }\n    vec![min_value, min_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3tq0iewp.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_index = 0;\n    for &x in arr\
    \ {\n        if x % 2 == 0 {\n            if min_value < x {\n               \
    \ min_value = x;\n                min_index = x;\n            }\n        }\n \
    \   }\n    let mut result: Vec<isize> = vec![];\n    if min_value == arr[0] {\n\
    \        result.push(min_value);\n        result.push(min_index);\n    } else\
    \ {\n        let mut current_index = 0;\n        let mut current_value = min_value;\n\
    \        while current_value != arr[0] {\n            if current_index == min_index\
    \ {\n                result.push(current_value);\n                result.push(current_index);\n\
    \                break;\n            }\n            current_index += 1;\n    \
    \        current_value = arr[current_index];\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb5ikedy3.rs:29:9\n   |\n\
    29 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpb5ikedy3.rs:51:29\n   |\n51 |  \
    \           current_value = arr[current_index];\n   |                        \
    \     ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values.push(i);\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.is_empty() {\n   \
    \     return vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = even_values[0];\n    for i in even_values.iter().rev()\
    \ {\n        if i / 2 == smallest_even_value {\n            smallest_even_value\
    \ = i;\n            smallest_even_index = i;\n        }\n    }\n    even_values.remove(smallest_even_index);\n\
    \    even_values.sort();\n    even_values.reverse();\n    even_values.insert(0,\
    \ smallest_even_value);\n    even_values\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpylys7_i6.rs:46:35\n   |\n\
    42 |     let mut smallest_even_value = even_values[0];\n   |                 \
    \                  -------------- expected due to this value\n...\n46 |      \
    \       smallest_even_value = i;\n   |                                   ^ expected\
    \ `usize`, found `&usize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    46 |             smallest_even_value = *i;\n   |                             \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpylys7_i6.rs:47:35\n\
    \   |\n43 |     let mut smallest_even_index = even_values[0];\n   |          \
    \                         -------------- expected due to this value\n...\n47 |\
    \             smallest_even_index = i;\n   |                                 \
    \  ^ expected `usize`, found `&usize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n47 |             smallest_even_index = *i;\n   |             \
    \                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpylys7_i6.rs:54:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n54\
    \ |     even_values\n   |     ^^^^^^^^^^^ expected `isize`, found `usize`\n  \
    \ |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if smallest_value < i {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = even_values[0];\n    for &i in even_values {\n        if i < smallest_even_value\
    \ {\n            smallest_even_value = i;\n            smallest_even_index = i;\n\
    \        }\n    }\n    let mut even_values_index = even_values.iter().enumerate().filter(|&(_,\
    \ v)| v == smallest_even_value).map(|(_, v)| v).collect::<Vec<_>>();\n    even_values_index.sort_by_key(|&i|\
    \ i.0);\n    even_values_index.dedup();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i.1).collect::<Vec<_>>();\n    even_values_index.sort_by_key(|&i| i.0);\n  \
    \  even_values_index.dedup();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i.1).collect::<Vec<_>>();\n    even_values_index.sort_by_key(|&i| i.0);\n  \
    \  even_values_index.dedup();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i.1).collect::<Vec<_>>();\n    even_values_index.sort_by_key(|&i| i.0);\n  \
    \  even_values_index.dedup();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i.1).collect::<Vec<_>>();\n    even_values_index.sort_by_key(|&i| i.0);\n  \
    \  even_values_index.dedup();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i.1).collect::<Vec<_>>();\n    even_values_index.sort_by_key(|&i| i.0);\n  \
    \  even_values_index.dedup();\n    let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i.1).collect::<Vec<_>>();\n    even_value\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `even_value` in this scope\n  --> /tmp/tmpu6cni8zp.rs:69:5\n\
    \   |\n69 |     even_value\n   |     ^^^^^^^^^^ help: a local variable with a\
    \ similar name exists: `even_values`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpu6cni8zp.rs:30:9\n   |\n30 |     for &i in arr {\n   |         ^^  \
    \  --- this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu6cni8zp.rs:44:9\n\
    \   |\n44 |     for &i in even_values {\n   |         ^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpu6cni8zp.rs:50:83\n\
    \   |\n50 |     let mut even_values_index = even_values.iter().enumerate().filter(|&(_,\
    \ v)| v == smallest_even_value).map(|(_, v)| v).collect::<Vec<_...\n   |     \
    \                                                                            \
    \  ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0609]: no field `0` on type\
    \ `&isize`\n  --> /tmp/tmpu6cni8zp.rs:51:42\n   |\n51 |     even_values_index.sort_by_key(|&i|\
    \ i.0);\n   |                                          ^\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpu6cni8zp.rs:53:74\n\
    \   |\n53 |     let mut even_values_index = even_values_index.into_iter().map(|&i|\
    \ i.1).collect::<Vec<_>>();\n   |                                        "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = arr[0];\n    let mut min_even_index = -1;\n    let\
    \ mut min_even_index_in_arr = 0;\n    let mut min_even_index_in_arr2 = 0;\n  \
    \  let mut min_even_index_in_arr3 = 0;\n    let mut min_even_index_in_arr4 = 0;\n\
    \    let mut min_even_index_in_arr5 = 0;\n    let mut min_even_index_in_arr6 =\
    \ 0;\n    let mut min_even_index_in_arr7 = 0;\n    let mut min_even_index_in_arr8\
    \ = 0;\n    let mut min_even_index_in_arr9 = 0;\n    let mut min_even_index_in_arr10\
    \ = 0;\n    let mut min_even_index_in_arr11 = 0;\n    let mut min_even_index_in_arr12\
    \ = 0;\n    let mut min_even_index_in_arr13 = 0;\n    let mut min_even_index_in_arr14\
    \ = 0;\n    let mut min_even_index_in_arr15 = 0;\n    let mut min_even_index_in_arr16\
    \ = 0;\n    let mut min_even_index_in_arr17 = 0;\n    let mut min_even_index_in_arr18\
    \ = 0;\n    let mut min_even_index_in_arr19 = 0;\n    let mut min_even_index_in_arr20\
    \ = 0;\n    let mut min_even_index_in_arr21 = 0;\n    let mut min_even_index_in_arr22\
    \ = 0;\n    let mut min_even_index_in_arr23 = 0;\n    let mut min_even_index_in_arr24\
    \ = 0;\n    let mut min_even_index_in_arr25 = 0;\n    let mut min_even_index_in_arr26\
    \ = 0;\n    let mut min_even_index_in_arr27 = 0;\n    let mut min_even_index_in_arr28\
    \ = 0;\n    let mut min_even_index_in_arr29 = 0;\n    let mut min_even_index_in_arr30\
    \ = 0;\n    let mut min_even_index_in_arr31 = 0;\n    let mut min_even_index_in_arr32\
    \ = 0;\n    let mut min_even_index_in_arr33 = 0;\n    let mut min_even_index_in_arr34\
    \ = 0;\n    let mut min_even_index_in_arr35 = 0;\n    let mut min_even_index_in_arr36\
    \ = 0;\n    let mut min_even_index_in_arr37 = 0;\n    let mut min_even_index_in_arr38\
    \ = 0;\n    let mut min_even_index_in_arr39 = 0;\n    let mut min_even_index_in_arr40\
    \ = 0;\n    let mut min_even_index_in_arr41 = 0;\n    let mut min_even_index_in_arr42\
    \ = 0;\n    let mut min_even_index_in_arr43 = 0;\n    let mut min_even_index_in_arr44\
    \ = 0;\n    let mut min_even_index_in_arr45 = 0;\n    let mut min_even\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaowsmzaz.rs:74:21\n   |\n\
    74 |     let mut min_even\n   |                     ^ help: add `;` here\n75 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaowsmzaz.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 1;\n    for &i in arr\
    \ {\n        if i % 2 == 0 {\n            if min_value % 2 == 0 {\n          \
    \      min_value = i;\n                min_idx = i;\n            }\n        }\
    \ else {\n            if min_value % 2 != 0 {\n                min_value = i;\n\
    \                min_idx = i;\n            }\n        }\n    }\n    let mut result\
    \ = vec![min_value, min_idx];\n    if min_value == arr[0] {\n        result =\
    \ vec![min_value, min_idx];\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo8yxwd0i.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter().rev() {\n        if i %\
    \ 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = even_values.iter().next().unwrap();\n    for i in even_values.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if i < smallest_even_value {\n     \
    \           smallest_even_value = i;\n                smallest_even_index = i;\n\
    \            }\n        }\n    }\n    let mut even_values_iter = even_values.iter().rev();\n\
    \    let mut even_values_iter = even_values_iter.peekable();\n    let mut even_values_iter\
    \ = even_values_iter.peekable();\n    let mut even_values_iter = even_values_iter.peekable();\n\
    \    let mut even_values_iter = even_values_iter.peekable();\n    let mut even_values_iter\
    \ = even_values_iter.peekable();\n    let mut even_values_iter = even_values_iter.peekable();\n\
    \    let mut even_values_iter = even_values_iter.peekable();\n    let mut even_values_iter\
    \ = even_values_iter.peekable();\n    let mut even_values_iter = even_values_iter.peekable();\n\
    \    let mut even_values_iter = even_values_iter.peekable();\n    let mut even_values_iter\
    \ = even_values_iter.peekable();\n    let mut even_values_iter = even_values_iter.peekable();\n\
    \    let mut even_values_iter = even_values_iter.peekable();\n    let mut even_values_iter\
    \ = even_values_iter.peekable();\n    let mut even_values_iter = even_values_iter.peekable();\n\
    \    let mut even_values_iter = even_values_iter.peekable();\n    let mut even_values_iter\
    \ = even_values_iter.peekable();\n    let mut even_values_iter = even_values_iter.peekable();\n\
    \    let mut even_values_iter = even_values_iter.peekable();\n    let mut even_values_iter\
    \ = even_values_iter.peekable();\n    let mut even_values_iter = even_values_iter.peekable();\n\
    \    let mut even_values_iter = even_values_iter.peekable();\n    let mut even_values_iter\
    \ = even_values_iter.peek\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpckk7tuby.rs:75:53\n   |\n\
    75 |     let mut even_values_iter = even_values_iter.peek\n   |              \
    \                                       ^ help: add `;` here\n76 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpckk7tuby.rs:33:20\n \
    \  |\n33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpckk7tuby.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpckk7tuby.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpckk7tuby.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpckk7tuby.rs:46:20\n   |\n\
    46 |             if i < smallest_even_value {\n   |                    ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0615]: attempted to take value\
    \ of method `peek` on type `Peekable<Pee"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_val = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx\
    \ = arr.iter().min_by_key(|&x| {\n        if x % 2 == 0 {\n            x.to_isize()\
    \ < min_val\n        } else {\n            x.to_isize() == min_val\n        }\n\
    \    });\n    min_idx\n        .to_vec()\n        .iter()\n        .map(|&x| x.to_isize())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_isize` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpqts57znu.rs:31:15\n   |\n31 |             x.to_isize()\
    \ < min_val\n   |               ^^^^^^^^ method not found in `&isize`\n\nerror[E0599]:\
    \ no method named `to_isize` found for reference `&isize` in the current scope\n\
    \  --> /tmp/tmpqts57znu.rs:33:15\n   |\n33 |             x.to_isize() == min_val\n\
    \   |               ^^^^^^^^ method not found in `&isize`\n\nerror[E0599]: no\
    \ method named `to_vec` found for enum `Option` in the current scope\n  --> /tmp/tmpqts57znu.rs:37:10\n\
    \   |\n37 |         .to_vec()\n   |          ^^^^^^ method not found in `Option<&isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &x in arr {\n        if x % 2 == 0 {\n\
    \            even_values.push(x);\n            if x < smallest_value {\n     \
    \           smallest_value = x;\n                smallest_index = even_values.len()\
    \ - 1;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_value_with_even_value = even_values[smallest_index];\n\
    \    let mut smallest_index_with_even_value = smallest_index;\n    for &x in even_values\
    \ {\n        if x < smallest_value_with_even_value {\n            smallest_value_with_even_value\
    \ = x;\n            smallest_index_with_even_value = even_values.len() - 1;\n\
    \        }\n    }\n    let mut even_values_without_smallest_value = even_values.clone();\n\
    \    even_values_without_smallest_value.remove(&smallest_index_with_even_value);\n\
    \    even_values_without_smallest_value.remove(0);\n    return even_values_without_smallest_value;\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbq5nbq06.rs:30:9\n   |\n\
    30 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbq5nbq06.rs:44:9\n   |\n44 |     for &x in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbq5nbq06.rs:51:47\n   |\n51 |     even_values_without_smallest_value.remove(&smallest_index_with_even_value);\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&usize`\n   |\nhelp: consider removing the borrow\n\
    \   |\n51 -     even_values_without_smallest_value.remove(&smallest_index_with_even_value);\n\
    51 +     even_values_without_smallest_value.remove(smallest_index_with_even_value);\n\
    \   | \n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_idx = -1;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n    \
    \        even_values.push(i);\n            if i < min_value {\n              \
    \  min_value = i;\n                min_idx = i;\n            }\n        }\n  \
    \  }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    let\
    \ mut even_values_iter = even_values.iter();\n    let mut smallest_value = even_values_iter.next().unwrap();\n\
    \    let mut smallest_idx = -1;\n    for i in even_values_iter {\n        if i\
    \ < smallest_value {\n            smallest_value = i;\n            smallest_idx\
    \ = i;\n        }\n    }\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut smallest_value = even_values_iter.next().unwrap();\n    let mut smallest_idx\
    \ = -1;\n    for i in even_values_iter {\n        if i < smallest_value {\n  \
    \          smallest_value = i;\n            smallest_idx = i;\n        }\n   \
    \ }\n    let mut even_values_iter = even_values.iter();\n    let mut smallest_value\
    \ = even_values_iter.next().unwrap();\n    let mut smallest_idx = -1;\n    for\
    \ i in even_values_iter {\n        if i < smallest_value {\n            smallest_value\
    \ = i;\n            smallest_idx = i;\n        }\n    }\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut smallest_value = even_values_iter.next().unwrap();\n\
    \    let mut smallest_idx = -1;\n    for i in even_values_iter {\n        if i\
    \ < smallest_value {\n            smallest_value = i;\n            smallest_idx\
    \ = i;\n        }\n    }\n    let mut even_values_iter = even_values.iter();\n\
    \    let mut smallest_value = even_values_iter.next().unwrap();\n    let mut smallest_idx\
    \ = -1;\n    for i in even_values_iter {\n        if i < smallest_value {\n  \
    \          smallest_value = i;\n            smallest_idx = i;\n        }\n   \
    \ }\n    let mut even_values_iter = even_values.iter();\n    let mut smallest_value\
    \ = even_values_iter.next().unwrap();\n    let mut smallest_idx = -1;\n    for\
    \ i in even_values_iter {\n        if i < smallest_value {\n            smallest_value\
    \ = i;\n            smallest_idx = i;\n        }\n    }\n    let mut even_values_iter\
    \ = even_values.iter();\n    let mut smallest_value = even_values_iter.next().unwrap();\n\
    \    let mut smallest_idx = -1;\n    for i in even_values_iter {\n\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpio2lqlw2.rs:113:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n99  |     for i in even_values_iter\
    \ {\n    |                               - this delimiter might not be properly\
    \ closed...\n100 | \n101 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n113 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpio2lqlw2.rs:33:20\n   |\n33 |             if i < min_value {\n   | \
    \                   ^^^^^^^^^ expected `&isize`, found `i32`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpio2lqlw2.rs:34:29\n   |\n28 |     let mut min_value\
    \ = i32::MAX;\n   |                         -------- expected due to this value\n\
    ...\n34 |                 min_value = i;\n   |                             ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpio2lqlw2.rs:35:27\n\
    \   |\n29 |     let mut min_idx = -1;\n   |                       -- expected\
    \ due to this value\n...\n35 |                 min_idx = i;\n   |            \
    \               ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n35 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpio2lqlw2.rs:48:28\n\
    \   |\n44 |     let mut smallest_idx = -1;\n   |                            --\
    \ expected due to this value\n...\n48 |             smallest_idx = i;\n   |  \
    \                          ^ expected integer, found `&&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n48 |             smallest_idx = **i;\n   | \
    \                           ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpio2lqlw2.rs:57:28\n\
    \   |\n53 |     let mut smallest_idx = -1;\n   |                            --\
    \ expected due to this value\n...\n57 |             smallest_idx = i;\n   |  \
    \                          ^ expected integer, found `&&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n57 |             smallest_idx = **i;\n   | \
    \                           ++"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    even_values.sort();\n    even_values.dedup();\n\
    \    let mut even_values_index = 0;\n    let mut even_values_value = even_values[even_values_index];\n\
    \    let mut even_values_index = even_values_index + 1;\n    let mut even_values_value\
    \ = even_values[even_values_index];\n    let mut even_values_index = even_values_index\
    \ + 1;\n    let mut even_values_value = even_values[even_values_index];\n    let\
    \ mut even_values_index = even_values_index + 1;\n    let mut even_values_value\
    \ = even_values[even_values_index];\n    let mut even_values_index = even_values_index\
    \ + 1;\n    let mut even_values_value = even_values[even_values_index];\n    let\
    \ mut even_values_index = even_values_index + 1;\n    let mut even_values_value\
    \ = even_values[even_values_index];\n    let mut even_values_index = even_values_index\
    \ + 1;\n    let mut even_values_value = even_values[even_values_index];\n    let\
    \ mut even_values_index = even_values_index + 1;\n    let mut even_values_value\
    \ = even_values[even_values_index];\n    let mut even_values_index = even_values_index\
    \ + 1;\n    let mut even_values_value = even_values[even_values_index];\n    let\
    \ mut even_values_index = even_values_index + 1;\n    let mut even_values_value\
    \ = even_values[even_values_index];\n    let mut even_values_index = even_values_index\
    \ + 1;\n    let mut even_values_value = even_values[even_values_index];\n    let\
    \ mut even_values_index = even_values_index + 1;\n    let mut even_values_value\
    \ = even_values[even_values_index];\n    let mut even_values_index = even_values_index\
    \ + 1;\n    let mut even_values_value = even_values[even_values_index];\n    let\
    \ mut even_values_index = even_values_index + 1;\n    let mut even_values_value\
    \ = even_values[even_values_index];\n    let mut even_values_index = even_values_index\
    \ + 1;\n    let mut even_values_value = even_values[even_values_\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpul06r9gf.rs:71:1\n   |\n71 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpul06r9gf.rs:70:44\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                                         - closing delimiter possibly\
    \ meant for this\n...\n70 |     let mut even_values_value = even_values[even_values_\n\
    \   |                                            ^ unclosed delimiter\n71 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpul06r9gf.rs:30:9\n   |\n30 |     for &i in arr {\n   |         ^^  \
    \  --- this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = -1;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = -1;\n    for &i in even_values {\n        if i < smallest_even_value {\n \
    \           smallest_even_value = i;\n            smallest_even_index = i;\n \
    \       }\n    }\n    let mut result = vec![];\n    if smallest_even_index ==\
    \ -1 {\n        result.push(smallest_value, smallest_index);\n    } else {\n \
    \       result.push(smallest_even_value);\n        result.push(smallest_even_index);\n\
    \    }\n    return result;\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzofdpwrk.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzofdpwrk.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n    --> /tmp/tmpzofdpwrk.rs:52:16\n\
    \     |\n52   |         result.push(smallest_value, smallest_index);\n     | \
    \               ^^^^ --------------  -------------- supplied 2 arguments\n   \
    \  |                |\n     |                expected 1 argument\n     |\nnote:\
    \ associated function defined here\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for &i in even_values {\n        if i < smallest_even_value {\n  \
    \          smallest_even_value = i;\n            smallest_even_index = i;\n  \
    \      }\n    }\n    let mut result = vec![];\n    if smallest_even_value == smallest_value\
    \ {\n        result.push(smallest_even_index, smallest_value);\n    } else {\n\
    \        result.push(smallest_even_index);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphuyyuzqb.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphuyyuzqb.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n    --> /tmp/tmphuyyuzqb.rs:52:16\n\
    \     |\n52   |         result.push(smallest_even_index, smallest_value);\n  \
    \   |                ^^^^ -------------------  -------------- supplied 2 arguments\n\
    \     |                |\n     |                expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_val = arr[0];\n    let mut min_idx = -1;\n    for &i in arr {\n\
    \        if i % 2 == 0 {\n            if min_val < i {\n                min_val\
    \ = i;\n                min_idx = i;\n            }\n        }\n    }\n    if\
    \ min_val == arr[0] {\n        return vec![];\n    }\n    let mut ans = vec![];\n\
    \    for i in 0..arr.len() {\n        if i % 2 == 0 {\n            if min_val\
    \ == i {\n                ans.push(min_idx);\n            }\n        }\n    }\n\
    \    ans\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5hh6k33b.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5hh6k33b.rs:43:27\n   |\n43 |             if min_val == i {\n \
    \  |                           ^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n43 |             if min_val == i.try_into().unwrap() {\n   |    \
    \                        ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut min_value = arr[0];\n    let\
    \ mut min_index = 0;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n   \
    \         even_values.push(i);\n            if i < min_value {\n             \
    \   min_value = i;\n                min_index = i;\n            }\n        }\n\
    \    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    let\
    \ mut smallest_value = even_values[0];\n    let mut smallest_index = 0;\n    for\
    \ i in even_values.iter() {\n        if i < smallest_value {\n            smallest_value\
    \ = i;\n            smallest_index = i;\n        }\n    }\n    let mut result\
    \ = vec![];\n    for i in even_values.iter() {\n        if i == smallest_value\
    \ {\n            result.push(smallest_index, i);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0exhhde0.rs:33:20\n   |\n\
    33 |             if i < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0exhhde0.rs:34:29\n   |\n28 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n34 |                 min_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    34 |                 min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0exhhde0.rs:35:29\n   |\n29 |     let mut min_index\
    \ = 0;\n   |                         - expected due to this value\n...\n35 | \
    \                min_index = i;\n   |                             ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |  \
    \               min_index = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0exhhde0.rs:45:16\n   |\n45 |         if i <\
    \ smallest_value {\n   |                ^^^^^^^^^^^^^^ expected `&isize`, found\
    \ `isize`\n   |\n   = note: expected reference `&&isize`\n              found\
    \ reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0exhhde0.rs:47:30\n\
    \   |\n43 |     let mut smallest_index = 0;\n   |                            \
    \  - expected due to this value\n...\n47 |             smallest_index = i;\n \
    \  |                              ^ expected integer, found `&&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n47 |             smallest_index\
    \ = **i;\n   |                              ++\n\nerror[E0277]: can't compare\
    \ `&isize` with `isize`\n  --> /tmp/tmp0exhhde0.rs:52:14\n   |\n52 |         if\
    \ i == smallest_value {\n   |              ^^ no implementation for `&isize ==\
    \ isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for\
    \ `&isize`\n   = help: the following other types implem"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.is_empty() {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_node_index\
    \ = even_values.iter().position(|&i| i % 2 == 0).unwrap();\n    for &i in even_values\
    \ {\n        if i < smallest_even_value {\n            smallest_even_value = i;\n\
    \            smallest_even_node_index = i;\n        }\n    }\n    even_values.remove(&mut\
    \ smallest_even_node_index);\n    even_values.sort_unstable();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpb7_8mf4c.rs:94:1\n   |\n94\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb7_8mf4c.rs:30:9\n\
    \   |\n30 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb7_8mf4c.rs:44:9\n   |\n44 |     for &i in even_values\
    \ {\n   |         ^^    ----------- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpb7_8mf4c.rs:47:40\n   |\n43 |     let mut smallest_even_node_index\
    \ = even_values.iter().position(|&i| i % 2 == 0).unwrap();\n   |             \
    \                           -----------------------------------------------------\
    \ expected due to this value\n...\n47 |             smallest_even_node_index =\
    \ i;\n   |                                        ^ expected `usize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpb7_8mf4c.rs:50:24\n   |\n50 |\
    \     even_values.remove(&mut smallest_even_node_index);\n   |               \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&mut usize`\n\
    \   |\nhelp: consider removing the borrow\n   |\n50 -     even_values.remove(&mut\
    \ smallest_even_node_index);\n50 +     even_values.remove(smallest_even_node_index);\n\
    \   | \n\nerror: aborting due to 5 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2 ==\
    \ 0 {\n            even_values.push(i);\n            if i < smallest_value {\n\
    \                smallest_value = i;\n                smallest_index = i;\n  \
    \          }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = even_values.iter().position(|x| x == smallest_value);\n\
    \    for i in even_values.iter().rev() {\n        if i % 2 == 0 {\n          \
    \  if i < smallest_even_value {\n                smallest_even_value = i;\n  \
    \              smallest_even_index = i;\n            }\n        }\n    }\n   \
    \ let mut result = vec![];\n    for i in even_values.iter() {\n        if i ==\
    \ smallest_value {\n            result.push(i);\n        }\n    }\n    if result.len()\
    \ == 0 {\n        return vec![];\n    }\n    result.push(smallest_value);\n  \
    \  result.push(smallest_index);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj64020ff.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpj64020ff.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpj64020ff.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0277]: can't compare `&&isize` with `isize`\n  --> /tmp/tmpj64020ff.rs:43:69\n\
    \   |\n43 |     let mut smallest_even_index = even_values.iter().position(|x|\
    \ x == smallest_value);\n   |                                                \
    \                     ^^ no implementation for `&&isize == isize`\n   |\n   =\
    \ help: the trait `PartialEq<isize>` is not implemented for `&&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpj64020ff.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for &i in even_values {\n        if i < smallest_even_value {\n  \
    \          smallest_even_value = i;\n            smallest_even_index = i;\n  \
    \      }\n    }\n    let mut result = vec![];\n    if smallest_even_index == 0\
    \ {\n        result.push(smallest_value);\n        result.push(smallest_index);\n\
    \    } else {\n        result.push(smallest_value);\n        result.push(smallest_even_index);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpabg2h7nk.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpabg2h7nk.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even_value = arr[0];\n    let mut smallest_even_index =\
    \ -1;\n    let mut smallest_even_index_in_list = -1;\n    let mut smallest_even_index_in_list_in_list\
    \ = -1;\n    let mut smallest_even_index_in_list_in_list_in_list = -1;\n    for\
    \ &i in arr {\n        if i % 2 == 0 {\n            if smallest_even_index ==\
    \ -1 || smallest_even_value < i {\n                smallest_even_value = i;\n\
    \                smallest_even_index = i;\n            }\n        } else {\n \
    \           if smallest_even_index_in_list == -1 || smallest_even_value < i {\n\
    \                smallest_even_index_in_list = i;\n                smallest_even_index_in_list_in_list\
    \ = i;\n            }\n        }\n    }\n    if smallest_even_index != -1 {\n\
    \        let mut smallest_even_index_in_list_in_list_in_list_in_list = smallest_even_index_in_list_in_list;\n\
    \        for &i in arr {\n            if i % 2 == 0 {\n                if smallest_even_index_in_list_in_list\
    \ == -1 || smallest_even_value < i {\n                    smallest_even_index_in_list_in_list\
    \ = i;\n                    smallest_even_index_in_list_in_list_in_list = i;\n\
    \                }\n            } else {\n                if smallest_even_index_in_list_in_list_in_list\
    \ == -1 || smallest_even_value < i {\n                    smallest_even_index_in_list_in_list_in_list\
    \ = i;\n                    smallest_even_index_in_list_in_list_in_list_in_list\
    \ = i;\n                }\n            }\n        }\n        if smallest_even_index_in_list_in_list_in_list\
    \ != -1 {\n            let mut smallest_even_index_in_list_in_list_in_list_in_list_in_list\
    \ = smallest_even_index_in_list_in_list_in_list_in_list;\n            for &i in\
    \ arr {\n                if i % 2 == 0 {\n                    if smallest_even_index_in_list_in_list_in_list_in_list\
    \ == -1 || smallest_even_value < i {\n                        smallest_even_index_in_list_in_list_in_list_in_list\
    \ = i;\n                        smallest_even_index_in_list_in_list_in_list_in_list_in_list\
    \ = i;\n                    }\n                } else {\n                    if\
    \ smallest_even_index_in_list_in_list_in_list_in_list == -1 || smallest_even_value\
    \ < i {\n                        smallest_even_index_in_list_in_list_in_list_in_list_in_list\
    \ = i;\n                        smallest_even_index_in_list_in_list_in_list_in_list_in_list\
    \ = i;\n                    }\n                }\n            }\n            if\
    \ smallest_even_index_in_list_in_list_in_list_in_list != -1 {\n              \
    \  let mut smallest_even_index_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = smalle\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1qt77orh.rs:89:3\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - unclosed delimiter\n...\n45 |     if smallest_even_index\
    \ != -1 {\n   |                                  - unclosed delimiter\n...\n60\
    \ |         if smallest_even_index_in_list_in_list_in_list != -1 {\n   |     \
    \                                                         - unclosed delimiter\n\
    ...\n75 |             if smallest_even_index_in_list_in_list_in_list_in_list !=\
    \ -1 {\n   |                                                                 \
    \         - this delimiter might not be properly closed...\n76 |             \
    \    let mut smallest_even_index_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = smalle\n77 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n89 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp1qt77orh.rs:76:101\n\
    \   |\n76 |                 let mut smallest_even_index_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = smalle\n   |                                                             \
    \                                        ^ help: add `;` here\n77 | }\n   | -\
    \ unexpected token\n\nerror[E0425]: cannot find value `smalle` in this scope\n\
    \  --> /tmp/tmp1qt77orh.rs:76:95\n   |\n76 |                 let mut smallest_even_index_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = smalle\n   |                                                             \
    \                                  ^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1qt77orh.rs:32:9\n   |\n32 |     for &i in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1qt77orh.rs:47:13\n   |\n47 |         for &i in arr {\n   |   \
    \          ^^    --- this expression has type `Option<isiz"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter().rev() {\n        if i %\
    \ 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = even_values.iter().rev().next().unwrap();\n    for i in\
    \ even_values.iter().rev() {\n        if i % 2 == 0 {\n            if i < smallest_even_value\
    \ {\n                smallest_even_value = i;\n                smallest_even_index\
    \ = i;\n            }\n        }\n    }\n    even_values.remove(smallest_even_index);\n\
    \    even_values.insert(0, smallest_even_value);\n    even_values.insert(0, smallest_index);\n\
    \    return even_values;\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1at6qni1.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp1at6qni1.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1at6qni1.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmp1at6qni1.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1at6qni1.rs:46:20\n   |\n\
    46 |             if i < smallest_even_value {\n   |                    ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp1at6qni1.rs:52:24\n   |\n52 |     even_values.remove(smallest_even_index);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1at6qni1.rs:54:27\n   |\n54 |\
    \     even_values.insert(0, smallest_ind"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value: isize = 0;\n    let mut min_even_index: usize = 0;\n\
    \    let mut min_value: isize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmfvc4e4b.rs:83:17\n   |\n\
    83 |     let mut min_\n   |                 ^ help: add `;` here\n84 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmfvc4e4b.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx2\
    \ = 0;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n            if min_value\
    \ % 2 == 0 {\n                if min_idx == i {\n                    min_idx2\
    \ = i;\n                }\n            } else {\n                if min_idx2 ==\
    \ i {\n                    min_idx = i;\n                }\n            }\n  \
    \      } else {\n            if min_value % 2 != 0 {\n                if min_idx2\
    \ == i {\n                    min_idx = i;\n                }\n            }\n\
    \        }\n        min_value = i;\n    }\n    let mut ret: Vec<isize> = vec![];\n\
    \    if min_idx2 == min_idx {\n        ret.push(min_idx);\n    } else {\n    \
    \    ret.push(min_idx2);\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpxxguds_b.rs:33:28\n\
    \   |\n33 |                 if min_idx == i {\n   |                          \
    \  ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxxguds_b.rs:34:32\n   |\n29 |     let mut min_idx2 = 0;\n   |      \
    \                  - expected due to this value\n...\n34 |                   \
    \  min_idx2 = i;\n   |                                ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n34 |        \
    \             min_idx2 = *i;\n   |                                +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxxguds_b.rs:38:31\n   |\n28 |     let mut min_idx\
    \ = 0;\n   |                       - expected due to this value\n...\n38 |   \
    \                  min_idx = i;\n   |                               ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    38 |                     min_idx = *i;\n   |                               +\n\
    \nerror[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpxxguds_b.rs:37:29\n\
    \   |\n37 |                 if min_idx2 == i {\n   |                         \
    \    ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxxguds_b.rs:43:32\n   |\n43 |                 if min_idx2 == i {\n \
    \  |                                ^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n4"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut smallest_even_value = 0;\n    let\
    \ mut even_values_index = 0;\n    for &x in arr {\n        if x % 2 == 0 {\n \
    \           even_values.push(x);\n            if smallest_value == x {\n     \
    \           smallest_even_value = x;\n                smallest_index = even_values_index;\n\
    \            }\n            even_values_index += 1;\n        }\n    }\n    if\
    \ even_values_index == 0 {\n        return vec![];\n    }\n    if even_values_index\
    \ == even_values.len() {\n        return vec![smallest_even_value];\n    }\n \
    \   if even_values_index > even_values.len() {\n        return vec![];\n    }\n\
    \    if even_values_index == even_values.len() - 1 {\n        if even_values[even_values_index]\
    \ % 2 == 0 {\n            return vec![smallest_even_value];\n        }\n    }\n\
    \    let mut even_values_index = even_values_index - 1;\n    let mut even_values_value\
    \ = even_values[even_values_index];\n    let mut even_values_index = even_values_index\
    \ - 1;\n    let mut even_values_value = even_values[even_values_index];\n    let\
    \ mut even_values_index = even_values_index - 1;\n    let mut even_values_value\
    \ = even_values[even_values_index];\n    let mut even_values_index = even_values_index\
    \ - 1;\n    let mut even_values_value = even_values[even_values_index];\n    let\
    \ mut even_values_index = even_values_index - 1;\n    let mut even_values_value\
    \ = even_values[even_values_index];\n    let mut even_values_index = even_values_index\
    \ - 1;\n    let mut even_values_value = even_values[even_values_index];\n    let\
    \ mut even_values_index = even_values_index - 1;\n    let mut even_values_value\
    \ = even_values[even_values_index];\n    let mut even_values_index = even_values_index\
    \ - 1;\n    let mut even_values_value = even_values[even_values_index];\n    let\
    \ mut even_values_index = even_values_index - 1;\n    let mut even_values_value\
    \ = even_values[even_values_index];\n    let mut even_values_index = even_values_index\
    \ - 1;\n    let mut even_values_value = even_values[even_values_index];\n    let\
    \ mut even_values_index = even_values_index - 1;\n    let \n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfe5za0vg.rs:78:1\n  \
    \ |\n78 | }\n   | ^ expected pattern\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfe5za0vg.rs:32:9\n   |\n32 |     for &x in arr {\n   |         ^^  \
    \  --- this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2\
    \ == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = 0;\n    for i in even_values.iter() {\n        if i %\
    \ 2 == 0 {\n            if i < smallest_even_value {\n                smallest_even_value\
    \ = i;\n                smallest_even_index = i;\n            }\n        }\n \
    \   }\n    let mut smallest_even_index_in_list = smallest_index;\n    for i in\
    \ even_values.iter() {\n        if i == smallest_even_value {\n            smallest_even_index_in_list\
    \ = i;\n        }\n    }\n    let mut result = vec![];\n    for i in even_values.iter()\
    \ {\n        if i == smallest_even_value {\n            result.push(i);\n    \
    \    }\n    }\n    result.push(smallest_even_value);\n    result.push(smallest_even_index_in_list);\n\
    \    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6794wvit.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp6794wvit.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6794wvit.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmp6794wvit.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6794wvit.rs:46:20\n   |\n\
    46 |             if i < smallest_even_value {\n   |                    ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6794wvit.rs:48:39\n   |\n43 |     let mut smallest_even_index = 0;\n\
    \   |                                   - expected due to this value\n...\n48\
    \ |                 smallest_even_index = i;\n   |                           \
    \            ^ expected integer, found `&&isize`\n   |\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2\
    \ == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = 0;\n    for i in even_values.iter() {\n        if i %\
    \ 2 == 0 {\n            if i < smallest_even_value {\n                smallest_even_value\
    \ = i;\n                smallest_even_index = i;\n            }\n        }\n \
    \   }\n    let mut result = vec![];\n    for i in 0..arr.len() {\n        if arr[i]\
    \ == smallest_even_value {\n            result.push(smallest_even_index);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxw4awxs2.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpxw4awxs2.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxw4awxs2.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpxw4awxs2.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxw4awxs2.rs:46:20\n   |\n\
    46 |             if i < smallest_even_value {\n   |                    ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxw4awxs2.rs:48:39\n   |\n43 |     let mut smallest_even_index = 0;\n\
    \   |                                   - expected due to this value\n...\n48\
    \ |                 smallest_even_index = i;\n   |                           \
    \            ^ expected integer, found `&&isize`\n   |\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![0; arr.len()];\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values[i] = 1;\n            if arr[i] < smallest_value\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        } else {\n            even_values[i] = 0;\n   \
    \     }\n    }\n    if even_values.iter().any(|&x| x == 0) {\n        return vec![];\n\
    \    }\n    even_values.iter().cloned().filter(|&x| x == 1).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, {integer}>\
    \ as Iterator>::Item == &&_`\n  --> /tmp/tmp0iklmmz_.rs:44:53\n   |\n44 |    \
    \ even_values.iter().cloned().filter(|&x| x == 1).cloned().collect()\n   |   \
    \                                                  ^^^^^^ expected reference,\
    \ found integer\n   |\n   = note: expected reference `&&_`\n              found\
    \ reference `&{integer}`\n   = note: required because of the requirements on the\
    \ impl of `Iterator` for `Cloned<std::slice::Iter<'_, {integer}>>`\n   = note:\
    \ 1 redundant requirement hidden\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Filter<Cloned<std::slice::Iter<'_, {integer}>>,\
    \ [closure@/tmp/tmp0iklmmz_.rs:44:40: 44:51]>`\n\nerror[E0631]: type mismatch\
    \ in closure arguments\n  --> /tmp/tmp0iklmmz_.rs:44:53\n   |\n44 |     even_values.iter().cloned().filter(|&x|\
    \ x == 1).cloned().collect()\n   |                                        -----------\
    \  ^^^^^^ expected signature of `for<'r> fn(&'r &_) -> _`\n   |              \
    \                          |\n   |                                        found\
    \ signature of `for<'r> fn(&'r {integer}) -> _`\n   |\n   = note: required because\
    \ of the requirements on the impl of `Iterator` for `Filter<Cloned<std::slice::Iter<'_,\
    \ {integer}>>, [closure@/tmp/tmp0iklmmz_.rs:44:40: 44:51]>`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<Filter<Cloned<std::slice::Iter<'_,\
    \ {integer}>>, [closure@/tmp/tmp0iklmmz_.rs:44:40: 44:51]>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmp0iklmmz_.rs:44:62\n   |\n44 |        even_values.iter().cloned().filter(|&x|\
    \ x == 1).cloned().collect()\n   |                                           \
    \                      ^^^^^^^ method cannot be called on `Cloned<Filter<Cloned<std::slice::Iter<'_,\
    \ {integer}>>, [closure@/tmp/tmp0iklmmz_.rs:44:40: 44:51]>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<Filter<Cloned<std::slice::Iter<'_, {integer}>>, [closure@/tmp/tmp0iklmmz_.rs:44:40:\
    \ 44:51]> as Iter"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_value = arr[0];\n    let mut\
    \ min_index = -1;\n    for i in arr.iter().cloned() {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < min_value {\n          \
    \      min_value = i;\n                min_index = i;\n            }\n       \
    \ }\n    }\n    if even_values.is_empty() {\n        return vec![];\n    }\n \
    \   let mut smallest_value = even_values[0];\n    let mut smallest_index = -1;\n\
    \    for i in even_values.iter().cloned() {\n        if i < smallest_value {\n\
    \            smallest_value = i;\n            smallest_index = i;\n        }\n\
    \    }\n    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2]`,\n right: `[2, 1]`', /tmp/tmpioastih_.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = -1;\n    let mut min_idx2\
    \ = -1;\n    for i in 0..arr.len() {\n        if arr[i] < min_value {\n      \
    \      min_value = arr[i];\n            min_idx = i;\n        }\n        if arr[i]\
    \ < min_value {\n            min_idx2 = i;\n        }\n    }\n    let mut ret:\
    \ Vec<isize> = vec![];\n    if min_idx2 == min_idx {\n        ret.push(min_value);\n\
    \    } else {\n        ret.push(min_value);\n        ret.push(min_idx2);\n   \
    \ }\n    ret\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp51b_md46.rs:28:23\n\
    \   |\n28 |     let mut min_idx = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmp51b_md46.rs:29:24\n   |\n29 | \
    \    let mut min_idx2 = -1;\n   |                        ^^ the trait `Neg` is\
    \ not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp51b_md46.rs:44:18\n   |\n44 |         ret.push(min_idx2);\n   |\
    \                  ^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n44 |         ret.push(min_idx2.try_into().unwrap());\n   |            \
    \              ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![0; arr.len()];\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even_values[i] = arr[i];\n            if even_values[i]\
    \ < smallest_value {\n                smallest_value = even_values[i];\n     \
    \           smallest_index = i;\n            }\n        }\n    }\n    even_values.sort_unstable();\n\
    \    even_values.dedup();\n    let mut result: Vec<isize> = vec![smallest_value,\
    \ smallest_index];\n    for i in 0..arr.len() {\n        if even_values[i] !=\
    \ arr[i] {\n            result.push(arr[i]);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxboh0w7h.rs:41:55\n   |\n\
    41 |     let mut result: Vec<isize> = vec![smallest_value, smallest_index];\n\
    \   |                                                       ^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n41 |     let mut result:\
    \ Vec<isize> = vec![smallest_value, smallest_index.try_into().unwrap()];\n   |\
    \                                                                     ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_index = 0;\n    for &x in arr\
    \ {\n        if x % 2 == 0 {\n            min_value = x;\n            min_index\
    \ = arr.iter().position(|&x| x == min_value).unwrap();\n        }\n    }\n   \
    \ vec![min_value, min_index]\n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp57w072rd.rs:29:9\n   |\n\
    29 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp57w072rd.rs:35:21\n   |\n35 |     vec![min_value, min_index]\n\
    \   |                     ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n35 |     vec![min_value, min_index.try_into().unwrap()]\n   |   \
    \                           ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut smallest_even_value = 0;\n    for\
    \ &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n   \
    \         if smallest_value <= i {\n                smallest_value = i;\n    \
    \            smallest_index = i;\n            }\n            if smallest_even_value\
    \ <= i {\n                smallest_even_value = i;\n            }\n        }\n\
    \    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    let\
    \ mut even_values_sorted = even_values.clone();\n    even_values_sorted.sort();\n\
    \    let mut smallest_even_value_sorted = even_values_sorted[0];\n    let mut\
    \ smallest_index_sorted = even_values_sorted.len();\n    for i in even_values_sorted.iter()\
    \ {\n        if smallest_even_value_sorted > i {\n            smallest_even_value_sorted\
    \ = i;\n            smallest_index_sorted = i;\n        }\n    }\n    let mut\
    \ even_values_sorted_copy = even_values_sorted.clone();\n    even_values_sorted_copy.sort();\n\
    \    let mut smallest_even_value_sorted_copy = even_values_sorted_copy[0];\n \
    \   let mut smallest_index_sorted_copy = even_values_sorted_copy.len();\n    for\
    \ i in even_values_sorted_copy.iter() {\n        if smallest_even_value_sorted_copy\
    \ > i {\n            smallest_even_value_sorted_copy = i;\n            smallest_index_sorted_copy\
    \ = i;\n        }\n    }\n    let mut even_values_sorted_copy = even_values_sorted.clone();\n\
    \    even_values_sorted_copy.sort();\n    let mut smallest_even_value_sorted_copy\
    \ = even_values_sorted_copy[0];\n    let mut smallest_index_sorted_copy = even_values_sorted_copy.len();\n\
    \    for i in even_values_sorted_copy.iter() {\n        if smallest_even_value_sorted_copy\
    \ > i {\n            smallest_even_value_sorted_copy = i;\n            smallest_index_sorted_copy\
    \ = i;\n        }\n    }\n    let mut even_values_sorted_copy = even_values_sorted.clone();\n\
    \    even_values_sorted_copy.sort();\n    let mut smallest_even_value_sorted_copy\
    \ = even_values_sorted_copy[0];\n    let mut smallest_index_sorted_copy = even_values_sorted_copy.len();\n\
    \    for i in even_values_sorted_copy.iter() {\n        if smallest_even_value_sorted_copy\
    \ > i {\n            smallest_even_value_sorted_copy = i;\n            smallest_index_sorted_copy\
    \ = i;\n        }\n    }\n    let mut even_values_sorted_copy = even_values_sorted.clone();\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq4brzmr0.rs:31:9\n   |\n\
    31 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpq4brzmr0.rs:51:41\n   |\n51 |         if smallest_even_value_sorted\
    \ > i {\n   |                                         ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n51 |        \
    \ if smallest_even_value_sorted > *i {\n   |                                 \
    \        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq4brzmr0.rs:52:42\n\
    \   |\n48 |     let mut smallest_even_value_sorted = even_values_sorted[0];\n\
    \   |                                          --------------------- expected\
    \ due to this value\n...\n52 |             smallest_even_value_sorted = i;\n \
    \  |                                          ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n52 |             smallest_even_value_sorted\
    \ = *i;\n   |                                          +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq4brzmr0.rs:53:37\n   |\n49 |     let mut smallest_index_sorted\
    \ = even_values_sorted.len();\n   |                                     ------------------------\
    \ expected due to this value\n...\n53 |             smallest_index_sorted = i;\n\
    \   |                                     ^ expected `usize`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpq4brzmr0.rs:61:46\n   |\n61 |\
    \         if smallest_even_value_sorted_copy > i {\n   |                     \
    \                         ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n61 |         if smallest_even_value_sorted_copy\
    \ > *i {\n   |                                              +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq4brzmr0.rs:62:47\n   |\n58 |     let mut smallest_even_value_sorted"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n        }\n        if i == smallest_value {\n\
    \            smallest_index = arr.iter().position(|&i| i == smallest_value).unwrap();\n\
    \        }\n        if i == smallest_value {\n            smallest_value = i;\n\
    \        }\n    }\n    if even_values.is_empty() {\n        return vec![];\n \
    \   }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = even_values.iter().position(|&i| i == smallest_even_value).unwrap();\n   \
    \ if smallest_even_index == 0 {\n        return vec![];\n    }\n    let mut even_values_copy\
    \ = even_values.clone();\n    even_values_copy.remove(even_values_copy.len() -\
    \ 1);\n    even_values_copy.sort();\n    even_values_copy.push(smallest_even_value);\n\
    \    even_values_copy.sort();\n    even_values_copy.push(smallest_even_index);\n\
    \    even_values_copy\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjok_rodb.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjok_rodb.rs:54:27\n   |\n54 |     even_values_copy.push(smallest_even_index);\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n54 |     even_values_copy.push(smallest_even_index.try_into().unwrap());\n\
    \   |                                              ++++++++++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_value = arr[0];\n    let mut\
    \ min_value_index = -1;\n    for i in 0..arr.len() {\n        if arr[i] % 2 ==\
    \ 0 {\n            even_values.push(i);\n            if arr[i] < min_value {\n\
    \                min_value = arr[i];\n                min_value_index = i;\n \
    \           }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_value = min_value;\n    let mut smallest_value_index\
    \ = min_value_index;\n    for i in even_values.iter() {\n        if arr[i] < smallest_value\
    \ {\n            smallest_value = arr[i];\n            smallest_value_index =\
    \ i;\n        }\n    }\n    let mut result = vec![];\n    for i in even_values.iter()\
    \ {\n        if i == smallest_value_index {\n            result.push(smallest_value);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpk3pvq86s.rs:29:31\n\
    \   |\n29 |     let mut min_value_index = -1;\n   |                          \
    \     ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0277]: the type `[isize]` cannot be indexed by `&usize`\n  --> /tmp/tmpk3pvq86s.rs:45:12\n\
    \   |\n45 |         if arr[i] < smallest_value {\n   |            ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `&usize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&usize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `&usize`\n  --> /tmp/tmpk3pvq86s.rs:46:30\n\
    \   |\n46 |             smallest_value = arr[i];\n   |                       \
    \       ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `&usize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&usize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpk3pvq86s.rs:47:36\n   |\n43 |\
    \     let mut smallest_value_index = min_value_index;\n   |                  \
    \                  --------------- expected due to this value\n...\n47 |     \
    \        smallest_value_index = i;\n   |                                    ^\
    \ expected `usize`, found `&usize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n47 |             smallest_value_index = *i;\n   |                     \
    \               +\n\nerror[E0277]: can't compare `&usize` with `usize`\n  -->\
    \ /tmp/tmpk3pvq86s.rs:52:14\n   |\n52 |         if i == smallest_value_index {\n\
    \   |              ^^ no implementation for `&usiz"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2 ==\
    \ 0 {\n            even_values.push(i);\n            if smallest_value < i {\n\
    \                smallest_value = i;\n                smallest_index = i;\n  \
    \          }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = 0;\n    for i in even_values.iter() {\n        if i %\
    \ 2 == 0 {\n            if smallest_even_value < i {\n                smallest_even_value\
    \ = i;\n                smallest_even_index = i;\n            }\n        }\n \
    \   }\n    let mut result = vec![];\n    for i in arr.iter() {\n        if i ==\
    \ smallest_value {\n            result.push(smallest_even_index);\n        }\n\
    \    }\n    return result;\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxwa8bo9b.rs:33:33\n   |\n\
    33 |             if smallest_value < i {\n   |                               \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n33 |             if smallest_value < *i {\n   |              \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxwa8bo9b.rs:34:34\n\
    \   |\n28 |     let mut smallest_value = arr[0];\n   |                       \
    \       ------ expected due to this value\n...\n34 |                 smallest_value\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxwa8bo9b.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpxwa8bo9b.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxwa8bo9b.rs:48:39\n   |\n\
    43 |     let mut smallest_even_index = 0;\n   |                              \
    \     - expected due to this value\n...\n48 |                 smallest_even_index\
    \ = i;\n   |                                       ^ expected integer, found `&&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n48 |                 smallest_even_index\
    \ = **i;\n   |                                       ++\n\nerror[E0277]: can't\
    \ compare `&isize` with `isize`\n  --> /tmp/tmpxwa8bo9b.rs:54:14\n   |\n54 | \
    \        if i == smallest_value {\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.is_empty() {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for &i in even_values {\n        if i < smallest_even_value {\n  \
    \          smallest_even_value = i;\n            smallest_even_index = i;\n  \
    \      }\n    }\n    let mut result = vec![];\n    if smallest_even_value == smallest_value\
    \ {\n        result.push(smallest_even_index);\n    } else {\n        result.push(smallest_value);\n\
    \        result.push(smallest_even_index);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgxx_42gk.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgxx_42gk.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![0; arr.len()];\n    let mut min_value = arr[0];\n\
    \    let mut min_index = -1;\n    for i in 0..arr.len() {\n        if arr[i] %\
    \ 2 == 0 {\n            even_values[i] = arr[i];\n            if arr[i] < min_value\
    \ {\n                min_value = arr[i];\n                min_index = i;\n   \
    \         }\n        }\n    }\n    if min_index == -1 {\n        return vec![];\n\
    \    }\n    let mut even_values_sorted = vec![0; arr.len()];\n    for i in 0..arr.len()\
    \ {\n        if even_values[i] < min_value {\n            even_values_sorted[i]\
    \ = even_values[i];\n        }\n    }\n    let mut min_value_sorted = min_value;\n\
    \    let mut min_index_sorted = min_index;\n    for i in 0..arr.len() {\n    \
    \    if even_values_sorted[i] < min_value_sorted {\n            min_value_sorted\
    \ = even_values_sorted[i];\n            min_index_sorted = i;\n        }\n   \
    \ }\n    let mut even_values_sorted_sorted = even_values_sorted;\n    for i in\
    \ 0..arr.len() {\n        if even_values_sorted_sorted[i] < min_value_sorted {\n\
    \            even_values_sorted_sorted[i] = even_values_sorted[i];\n        }\n\
    \    }\n    let mut min_value_sorted_sorted = min_value_sorted;\n    let mut min_index_sorted_sorted\
    \ = min_index_sorted;\n    for i in 0..arr.len() {\n        if even_values_sorted_sorted[i]\
    \ < min_value_sorted_sorted {\n            min_value_sorted_sorted = even_values_sorted_sorted[i];\n\
    \            min_index_sorted_sorted = i;\n        }\n    }\n    let mut even_values_sorted_sorted_sorted\
    \ = even_values_sorted_sorted;\n    for i in 0..arr.len() {\n        if even_values_sorted_sorted_sorted[i]\
    \ < min_value_sorted_sorted {\n            even_values_sorted_sorted_sorted[i]\
    \ = even_values_sorted_sorted[i];\n        }\n    }\n    let mut min_value_sorted_sorted_sorted\
    \ = min_value_sorted_sorted;\n    let mut min_index_sorted_sorted_sorted = min_index_sorted_sorted;\n\
    \    for i in 0..arr.len() {\n        if even_values_sorted_sorted_sorted[i] <\
    \ min_value_sorted_sorted_sorted {\n            min_value_sorted_sorted_sorted\
    \ = even_values_sorted_sorted_sorted[i];\n            min_index_sorted_sorted_sorted\
    \ = i;\n        }\n    }\n    let mut even_values_sorted_sorted_sorted_sorted\
    \ = even_values_sorted_sorted_sorted;\n    for i in 0..arr.len() {\n        if\
    \ even_values_sorted_sorted_sorted_sorted[i] < min_value_sorted_sorted_sorted\
    \ {\n            even_values_sorted_sorted_sorted_sorted[i] = even_values_sorted_sorted_sorted[i];\n\
    \        }\n\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9sd4nupk.rs:102:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n85  |     for i in 0..arr.len()\
    \ {\n    |                           - this delimiter might not be properly closed...\n\
    ...\n90  | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n102 | }\n    |   ^\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmp9sd4nupk.rs:29:25\n   |\n29 |     let mut min_index = -1;\n   |\
    \                         ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmp9sd4nupk.rs:39:21\n   |\n39 |     if min_index == -1 {\n   |  \
    \                   ^^\n   |                     |\n   |                     cannot\
    \ apply unary operator `-`\n   |                     help: you may have meant\
    \ the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values\
    \ cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9sd4nupk.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0600.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_values.push(i);\n            if i < smallest_value {\n     \
    \           smallest_value = i;\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for &i in even_values {\n        if i < smallest_even_value {\n  \
    \          smallest_even_value = i;\n            smallest_even_index = i;\n  \
    \      }\n    }\n    let mut result = vec![];\n    if smallest_even_index == smallest_index\
    \ {\n        result.push(smallest_even_value);\n    } else {\n        result.push(smallest_even_index,\
    \ smallest_index);\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdqp5_por.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdqp5_por.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n    --> /tmp/tmpdqp5_por.rs:54:16\n\
    \     |\n54   |         result.push(smallest_even_index, smallest_index);\n  \
    \   |                ^^^^ -------------------  -------------- supplied 2 arguments\n\
    \     |                |\n     |                expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
