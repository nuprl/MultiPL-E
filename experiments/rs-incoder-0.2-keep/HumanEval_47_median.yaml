name: HumanEval_47_median
language: rust
prompt: "/// Return median of elements in the list l.\n/// >>> median([3, 1, 2, 4,\
  \ 5])\n/// 3\n/// >>> median([-10, 4, 6, 1000, 10, 20])\n/// 15.0\nfn median(l:\
  \ Vec<isize>) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = median;\n    assert_eq!(candidate(vec![3,\
  \ 1, 2, 4, 5]), 3.0);\n    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]),\
  \ 8.0);\n    assert_eq!(candidate(vec![5]), 5.0);\n    assert_eq!(candidate(vec![6,\
  \ 5]), 5.5);\n    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);\n}\n"
completions: ["    l.iter().fold(f64::NEG_INFINITY,\n                  |median, elem|\
    \ median + elem) / l.len()", "    let mut s = l.iter().cloned().collect::<Vec<_>>();\n\
    \    s.sort();\n    s.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    let len = l.len();\n    if len % 2 == 0 {\n     \
    \   l.len() / 2\n    } else {\n        l.len() / 2 + 1\n    }", "    let mut l\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len().checked_div(2).unwrap();\n\
    \    l.len() / 2", "    l.iter().fold(f64::nan(), |a, b| {\n        a.checked_add(b).unwrap().sqrt().ok_or(\"\
    nan\")\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n   \
    \ l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::nan(), |a, b| {\n  \
    \      match b {\n            None => a,\n            Some(x) => if x < a { a\
    \ } else { x },\n        }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a,\
    \ b| {\n        if a < b {\n            a\n        } else {\n            b\n \
    \       }\n    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if *a < *b {\n \
    \           a\n        } else {\n            b\n        }\n    })", "    l.iter().fold(f64::nan(),\
    \ |a, b| {\n        b.checked_add(a).unwrap_or(f64::nan())\n    })", "    let\
    \ mut s = l.iter().fold(0, |sum, el| sum + el);\n    let mut mid = s.div(2);\n\
    \    if s.is_odd() {\n        mid = mid.ceil();\n    }\n    mid", "    let mut\
    \ l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len().checked_div(2).unwrap();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    let len = l.len();\n    l.len().checked_div(2).unwrap();\n\
    \    let mid = len / 2;\n    l.iter_mut().skip(mid).take(mid).fold(0.0, |acc,\
    \ x| acc + x.into());", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", '    l.iter().fold(0.0, |sum, el| sum + el)
    / l.len()', "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if\
    \ a < b {\n            a\n        } else {\n            b\n        }\n    })",
  "    l.iter().fold(f64::nan(), |a, b| {\n        match b {\n            None =>\
    \ a,\n            Some(x) => if x < a { a } else { x },\n        }\n    })", '    l.iter().fold(f64::NEG_INFINITY,
    |a, b| a.checked_add(f64::from(a) + f64::from(b)).unwrap())', "    let mut l =\
    \ l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2", " \
    \   l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if *a > *b {\n        \
    \    a\n        } else {\n            b\n        }\n    })", "    let mut l =\
    \ l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    let mut mid = l.len() / 2;\n    l.swap(0, mid);\n    l.iter().cloned().median().unwrap()",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len().checked_div(2).unwrap();\n\
    \    l.len() / 2", "    l.iter().fold(f64::nan(), |a, b| {\n        b.checked_add(a).unwrap_or(b)\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len().checked_div(2).unwrap();\n    l.len() / 2", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len().checked_div(2).unwrap();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\n\
    \                  |median, e| median + e / 2)", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort_unstable();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().check();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a < b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if\
    \ *a > *b {\n            a\n        } else {\n            b\n        }\n    })",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    let\
    \ n = l.len();\n    l.iter().skip(n / 2).take(n - n / 2).fold(0.0, |a, b| a +\
    \ b) / 2.0", "    let mut l = l.to_vec();\n    l.sort();\n    l.len().check();\n\
    \    l.len() / 2", "    l.iter().fold(f64::nan, |a, b| {\n        a.checked_add(b).unwrap().sqrt()\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if\
    \ a < b {\n            a\n        } else {\n            b\n        }\n    })",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if a < b {\n \
    \           a\n        } else {\n            b\n        }\n    })", "    let mut\
    \ l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len().checked_div(2).unwrap();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    l.iter().fold(f64::nan(), |a, b| {\n        match b {\n           \
    \ Some(x) => Some(x.clone()),\n            None => Some(a.clone()),\n        }\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len().check();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if *a < *b {\n            a\n        } else {\n          \
    \  b\n        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        if\
    \ *a < *b {\n            a\n        } else {\n            b\n        }\n    })",
  '    l.iter().fold(0.0, |sum, e| sum + e) / l.len()', "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().check();\n    l.len() / 2", "    l.iter().fold(f64::nan(),\
    \ |a, b| {\n        b.checked_add(a).unwrap_or(a)\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().checked_div(2).unwrap_or(l.len() / 2)", "    let mut\
    \ s = l.iter().fold(0, |a, b| a + b);\n    s /= l.len() as f64;\n    s", "   \
    \ let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len().checked_div(2).unwrap();\n\
    \    l.len() as f64 / 2.0", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().checked_div(2).unwrap();\n    l.len() / 2", "    let\
    \ mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    let mid = l.len() / 2;\n    l.swap(0, mid);\n    l.iter().cloned().median().unwrap()",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len().check();\n\
    \    l.len() / 2.0", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        match\
    \ b {\n            a if a < b => a,\n            a if a > b => b,\n          \
    \  _ => a + b,\n        }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a,\
    \ b| {\n        a.checked_add(b).expect(\"overflow\")\n    })", "    let mut l\
    \ = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        if\
    \ *a < *b {\n            a\n        } else {\n            b\n        }\n    })",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len().checked_div(2).unwrap();\n\
    \    l.len() / 2", '    l.iter().fold(f64::NEG_INFINITY, |acc, x| acc + x / 2)',
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len().checked_div(2).unwrap();\n\
    \    l.len() as f64 / 2.0", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    let mid = l.len() / 2;\n    l.swap(0, mid);\n   \
    \ l.iter().cloned().fold(0.0, |acc, x| acc + x)", "    l.iter().fold(\n      \
    \  l.len() / 2.0,\n        |a, b| if b < a { b } else { a },\n    )", "    let\
    \ mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() /\
    \ 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if a < b {\n   \
    \         a\n        } else {\n            b\n        }\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a > b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(f64::nan(), |a, b| {\n        b.checked_add(a).unwrap_or(a)\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    l.iter().fold(\n        l.len() / 2,\n        |a, b| {\n\
    \            if *a > *b {\n                b\n            } else {\n         \
    \       a\n            }\n        },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().check();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    l.iter().fold(f64::nan(), |a,\
    \ b| {\n        a.checked_add(f64::from(b.next()))\n    }).unwrap()", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a > b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    l.iter().fold(f64::nan(), |a, b| {\n        a.checked_add(b).unwrap().sqrt().ok_or(\"\
    nan\")\n    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2",
  "    l.iter().fold(0.0, |a, b| {\n        b.iter().fold(a, |c, d| {\n          \
    \  d if c < a else c\n        })\n    })", "    l.iter().fold(f64::nan(), |a,\
    \ b| {\n        a.checked_add(b).unwrap().sqrt().ok()\n    })", "    let mut l\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2", " \
    \   let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len().check();\n\
    \    l.len() / 2.0", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(b).unwrap())\n\
    \    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        match b {\n\
    \            Some(x) => Some(x.checked_div(a as f64).unwrap()),\n            None\
    \ => Some(a as f64),\n        }\n    })", "    l.iter().fold(0.0, |a, b| {\n \
    \       b.checked_add(a).unwrap()\n    }) / l.len()", "    l.iter().fold(\n  \
    \      l.len() / 2.0,\n        |acc, x| if x < acc {\n            x\n        }\
    \ else {\n            acc\n        }\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        if a < b {\n            a\n        } else {\n            b\n    \
    \    }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n   \
    \ l.sort();\n    l.len().check();\n    l.len() / 2", "    l.iter().fold(\n   \
    \     l.len() / 2.0,\n        |a, b| {\n            if a > b {\n             \
    \   a\n            } else {\n                b\n            }\n        },\n  \
    \  )", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let\
    \ mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len().check();\n\
    \    l.len() / 2.0", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    let mut mid = l.len() / 2;\n    l.swap(0, mid);\n\
    \    let mut low = l[0];\n    let mut high = l[mid];\n    while high - low > 1\
    \ {\n        let mid = l.len() / 2;\n        l.swap(0, mid);\n        low = l[0];\n\
    \        high = l[mid];\n    }\n    low", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().check();\n    l.len() / 2.0", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::nan(), |a, b| {\n  \
    \      b.is_nan() ? a : f64::from(b.partial_cmp(&a).unwrap().unwrap()) + f64::from(b.partial_cmp(&a).unwrap().unwrap())\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        b.checked_add(a).unwrap_or(a)\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        match\
    \ b {\n            Some(x) => a + x,\n            None => a,\n        }\n    })",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        match\
    \ b {\n            a if a < b => a,\n            a if a > b => b,\n          \
    \  _ => a + b,\n        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().checked_div(2).unwrap();\n    l.len() / 2", "    l.iter().fold(f64::nan(),\
    \ |a, b| {\n        match b {\n            None => a,\n            Some(b) =>\
    \ b as f64 + a as f64 / 2,\n        }\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        a.checked_add(b).expect(\"overflow\")\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if *a < *b {\n            a\n        } else {\n          \
    \  b\n        }\n    })", "    l.iter().fold(0.0, |sum, el| {\n        sum + el\
    \ / 2.0\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n  \
    \  l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n\
    \        if a > b {\n            a\n        } else {\n            b\n        }\n\
    \    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "   \
    \ l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        b.checked_add(a).unwrap_or(f64::NEG_INFINITY)\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", '    l.iter().fold(f64::NEG_INFINITY, |acc, x| acc + x)', " \
    \   l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        a.checked_add(f64::from(b.floor()\
    \ as f64)).unwrap()\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().check();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        a.checked_add(b).unwrap().sqrt().ok()\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if b < a {\n            a\n        } else {\n            b\n\
    \        }\n    })", '    l.iter().fold(f64::nan(), |m, x| if x < m { x } else
    { m })', "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    l.iter().fold(0.0, |sum, el| {\n        match sum {\n            0.0\
    \ => el,\n            x => if x < el { x } else { el },\n        }\n    })", '    l.iter().fold(f64::NEG_INFINITY,
    |a, b| a.checked_add(f64::from(a) + f64::from(b)).unwrap())', "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if *a > *b {\n            a\n        } else {\n          \
    \  b\n        }\n    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len()\
    \ / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort_unstable();\n    l.len().checked_div(2).unwrap();\n    l.len() as f64\
    \ / 2.0", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        match b {\n\
    \            None => a,\n            Some(x) => if x < a { a } else { x },\n \
    \       }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().check();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |acc, x| {\n        match x {\n            x if x < acc.0 => x,\n          \
    \  x if x > acc.0 => acc,\n            _ => acc,\n        }\n    })", '    l.iter().fold(0.0,
    |sum, el| sum + el) / l.len()', "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n\
    \        b.checked_add(a).unwrap()\n    })", "    l.iter().fold(f64::nan(), |a,\
    \ b| {\n        match b {\n            None => a,\n            Some(x) => x.partial_cmp(&a).unwrap().unwrap(),\n\
    \        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", '    l.iter().fold(f64::NEG_INFINITY, |acc,
    x| acc + x / 2)', "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n  \
    \  l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\n      \
    \            |median, item| {\n                      if median == f64::NEG_INFINITY\
    \ {\n                          median = item\n                      } else {\n\
    \                          if item < median {\n                              median\
    \ = item\n                          }\n                      }\n             \
    \         median\n                  })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", '    l.iter().fold(f64::NEG_INFINITY, |acc,
    x| acc + f64::from(x.median()))', "    l.iter().fold(f64::nan(), |a, b| {\n  \
    \      a.checked_add(b).expect(\"overflow\")\n    })", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if\
    \ a < b {\n            a\n        } else {\n            b\n        }\n    })",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(\n        l.len() / 2.0,\n        |acc, x| if x < acc\
    \ {\n            x\n        } else {\n            acc\n        }\n    )", "  \
    \  let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len().checked_div(2).unwrap();\n\
    \    l.len() as f64 / 2.0", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().checked_div(2).unwrap();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\n\
    \                  |median, e| median + (e as f64 / l.len()))", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        a.checked_add(b).unwrap().sqrt().ok()\n    })", "    let mut\
    \ l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n    l.len()\
    \ / 2", "    l.iter().fold(f64::nan(), |a, b| {\n        b.checked_add(a).unwrap_or(f64::nan())\n\
    \    })", "    l.iter().fold(f64::nan(), |a, b| {\n        if a < b {\n      \
    \      a\n        } else {\n            b\n        }\n    })", "    l.iter().fold(f64::nan(),\
    \ |a, b| {\n        b.checked_add(a).unwrap_or(a)\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().checked_div(2).unwrap();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        a.checked_add(f64::from(a) + f64::from(b)).unwrap()\n    })",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(f64::nan(), |a, b| {\n        a.checked_add(f64::from(b.next()))\n\
    \    }).unwrap()", "    l.iter().fold(\n        l.len() / 2.0,\n        |acc,\
    \ x| if x < acc {\n            acc\n        } else {\n            x\n        },\n\
    \    )", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if a < b {\n\
    \            a\n        } else {\n            b\n        }\n    })", "    let\
    \ mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len().checked_div(2).unwrap();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        match\
    \ b {\n            None => a,\n            Some(x) => if x < a { a } else { x\
    \ },\n        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::nan(), |a, b| {\n  \
    \      a.checked_add(b).unwrap().sqrt().ok()\n    })", '    l.iter().fold(0.0,
    |acc, x| acc + x / l.len())', "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n\
    \        match b {\n            a if a < b => a,\n            a if a > b => b,\n\
    \            _ => a + b,\n        }\n    })", "    l.iter().fold(0.0, |a, b| {\n\
    \        if a > b {\n            a\n        } else {\n            b\n        }\n\
    \    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        b.checked_add(a).unwrap_or(f64::NEG_INFINITY)\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b|\
    \ {\n            match b {\n                0 => a,\n                a => a -\
    \ b,\n            }\n        },\n    )", "    l.iter().fold(\n        l.len()\
    \ / 2.0,\n        |a, b| {\n            if a > b {\n                a\n      \
    \      } else {\n                b\n            }\n        },\n    )", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a < b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    l.iter().fold(f64::nan(), |a, b| {\n        match b\
    \ {\n            None => a,\n            Some(x) => if x < a { a } else { x },\n\
    \        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    l.iter().fold(\n        l.len() / 2.0,\n\
    \        |a, b| {\n            a + (b - a as f64) / 2.0\n        }\n    )", " \
    \   let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len().check();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        a.checked_add(b).expect(\"overflow\")\n    })", "    let mut l =\
    \ l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2", " \
    \   let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len().checked_div(2).unwrap();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        match b {\n            a if a < b => a,\n            a if a > b =>\
    \ b,\n            _ => a + b,\n        }\n    })", '    l.iter().fold(0.0, |sum,
    e| sum + e) / l.len()', "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().check();\n    l.len() / 2", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len().check();\n    l.len() / 2.0", '    l.iter().fold(f64::NEG_INFINITY,
    |acc, x| acc + x / 2)', "    l.iter().fold(f64::nan(), |a, b| {\n        b.checked_add(a).unwrap_or(a)\n\
    \    })"]
stop_tokens:
- "\n}"
