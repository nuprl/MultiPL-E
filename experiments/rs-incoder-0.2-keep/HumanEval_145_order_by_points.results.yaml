name: HumanEval_145_order_by_points
language: rust
results:
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for &n in &nums_copy {\n            sum\
    \ += *n as isize;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpaqavreus.rs:13:20\n\
    \   |\n13 |             sum += *n as isize;\n   |                    ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for i in nums_sorted.iter() {\n        sum += *i;\n    }\n\
    \    nums_sorted.sort_by_key(|x| {\n        sum - x.to_digits(10)\n    });\n \
    \   nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmphju5563q.rs:15:17\n   |\n15 |         sum\
    \ - x.to_digits(10)\n   |                 ^^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut index = 0;\n\
    \    while nums_copy.len() > 0 {\n        sum += nums_copy.pop().unwrap();\n \
    \       if sum < 0 {\n            sum = 0;\n            index += 1;\n        }\n\
    \        if index == nums_sorted.len() {\n            nums_sorted.push(nums_copy.pop().unwrap());\n\
    \        }\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpmx_1lhwr.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_unstable_by(|a,\
    \ b| {\n        let mut a_digits = a.to_digits();\n        let mut b_digits =\
    \ b.to_digits();\n        let mut sum = 0;\n        while a_digits.len() > 0 ||\
    \ b_digits.len() > 0 {\n            sum += a_digits.pop() + b_digits.pop();\n\
    \        }\n        sum\n    });\n    sorted_nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpj2i3qie6.rs:11:30\n   |\n11 |         let\
    \ mut a_digits = a.to_digits();\n   |                              ^^^^^^^^^ method\
    \ not found in `&isize`\n\nerror[E0599]: no method named `to_digits` found for\
    \ reference `&isize` in the current scope\n  --> /tmp/tmpj2i3qie6.rs:12:30\n \
    \  |\n12 |         let mut b_digits = b.to_digits();\n   |                   \
    \           ^^^^^^^^^ method not found in `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj2i3qie6.rs:17:9\n   |\n17 |         sum\n   |        \
    \ ^^^ expected enum `std::cmp::Ordering`, found integer\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x.to_digits().unwrap().sum()\n    });\n    nums_copy\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpadew6kc5.rs:17:17\n   |\n17 |         sum\
    \ - x.to_digits().unwrap().sum()\n   |                 ^^^^^^^^^ method not found\
    \ in `&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut max_sum = 0;\n    let mut min_sum = 0;\n    let mut\
    \ max_index = -1;\n    let mut min_index = -1;\n    let mut max_value = nums_copy[0];\n\
    \    let mut min_value = nums_copy[0];\n    for i in nums_copy.iter() {\n    \
    \    sum += *i;\n        if sum > max_sum {\n            max_sum = sum;\n    \
    \        max_index = i;\n        }\n        if sum < min_sum {\n            min_sum\
    \ = sum;\n            min_index = i;\n        }\n    }\n    for i in nums_copy.iter()\
    \ {\n        if *i < min_value {\n            min_value = *i;\n            min_index\
    \ = i;\n        }\n        if *i > max_value {\n            max_value = *i;\n\
    \            max_index = i;\n        }\n    }\n    nums_copy.swap_remove(min_index);\n\
    \    nums_copy.swap_remove(max_index);\n    nums_copy.swap_remove(min_value);\n\
    \    nums_copy.swap_remove(max_value);\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7cdow3qa.rs:21:25\n   |\n\
    13 |     let mut max_index = -1;\n   |                         -- expected due\
    \ to this value\n...\n21 |             max_index = i;\n   |                  \
    \       ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n21 |             max_index = *i;\n   |                   \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7cdow3qa.rs:25:25\n\
    \   |\n14 |     let mut min_index = -1;\n   |                         -- expected\
    \ due to this value\n...\n25 |             min_index = i;\n   |              \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n25 |             min_index = *i;\n   |                   \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7cdow3qa.rs:31:25\n\
    \   |\n14 |     let mut min_index = -1;\n   |                         -- expected\
    \ due to this value\n...\n31 |             min_index = i;\n   |              \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n31 |             min_index = *i;\n   |                   \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7cdow3qa.rs:35:25\n\
    \   |\n13 |     let mut max_index = -1;\n   |                         -- expected\
    \ due to this value\n...\n35 |             max_index = i;\n   |              \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n35 |             max_index = *i;\n   |                   \
    \      +\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  -->\
    \ /tmp/tmp7cdow3qa.rs:14:25\n   |\n14 |     let mut min_index = -1;\n   |    \
    \                     ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp7cdow3qa.rs:13:25\n\
    \   |\n13 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_unstable_by(|a,\
    \ b| {\n        let mut a_digits = a.to_digits();\n        let mut b_digits =\
    \ b.to_digits();\n        let mut sum = 0;\n        while a_digits.pop() > 0 {\n\
    \            sum += a_digits.pop();\n        }\n        while b_digits.pop() >\
    \ 0 {\n            sum += b_digits.pop();\n        }\n        sum\n    });\n \
    \   nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpqjrzgym6.rs:11:30\n   |\n11 |         let\
    \ mut a_digits = a.to_digits();\n   |                              ^^^^^^^^^ method\
    \ not found in `&isize`\n\nerror[E0599]: no method named `to_digits` found for\
    \ reference `&isize` in the current scope\n  --> /tmp/tmpqjrzgym6.rs:12:30\n \
    \  |\n12 |         let mut b_digits = b.to_digits();\n   |                   \
    \           ^^^^^^^^^ method not found in `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqjrzgym6.rs:20:9\n   |\n20 |         sum\n   |        \
    \ ^^^ expected enum `std::cmp::Ordering`, found integer\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by(|a, b| {\n        let mut sum:\
    \ isize = 0;\n        let mut digits = a.to_string().chars().map(|c| {\n     \
    \       sum += *c as isize;\n            sum\n        });\n        let mut digits2\
    \ = b.to_string().chars().map(|c| {\n            sum += *c as isize;\n       \
    \     sum\n        });\n        digits.cmp(&digits2).unwrap()\n    });\n    nums\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpl9aqpqwr.rs:12:20\n\
    \   |\n12 |             sum += *c as isize;\n   |                    ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpl9aqpqwr.rs:16:20\n   |\n\
    16 |             sum += *c as isize;\n   |                    ^^\n\nerror[E0277]:\
    \ `&Map<Chars<'_>, [closure@/tmp/tmpl9aqpqwr.rs:15:53: 18:10]>` is not an iterator\n\
    \    --> /tmp/tmpl9aqpqwr.rs:19:20\n     |\n19   |         digits.cmp(&digits2).unwrap()\n\
    \     |                --- ^^^^^^^^ `&Map<Chars<'_>, [closure@/tmp/tmpl9aqpqwr.rs:15:53:\
    \ 18:10]>` is not an iterator\n     |                |\n     |               \
    \ required by a bound introduced by this call\n     |\n     = help: the trait\
    \ `Iterator` is not implemented for `&Map<Chars<'_>, [closure@/tmp/tmpl9aqpqwr.rs:15:53:\
    \ 18:10]>`\n     = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&Map<Chars<'_>, [closure@/tmp/tmpl9aqpqwr.rs:15:53: 18:10]>`\nnote: required\
    \ by a bound in `std::iter::Iterator::cmp`\nhelp: consider dereferencing here\n\
    \     |\n19   |         digits.cmp(*&digits2).unwrap()\n     |               \
    \     +\nhelp: consider removing the leading `&`-reference\n     |\n19   -   \
    \      digits.cmp(&digits2).unwrap()\n19   +         digits.cmp(digits2).unwrap()\n\
    \     | \n\nerror[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmpl9aqpqwr.rs:19:30\n   |\n19 |         digits.cmp(&digits2).unwrap()\n\
    \   |                              ^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    let mut result\
    \ = Vec::new();\n    while sum != 0 {\n        let index = nums_copy.iter().position(|&x|\
    \ x == sum).unwrap();\n        result.push(nums_copy[index]);\n        sum -=\
    \ nums_copy[index];\n        nums_copy.remove(&nums_copy[index]);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpht_rbnmd.rs:21:26\n   |\n\
    21 |         nums_copy.remove(&nums_copy[index]);\n   |                      \
    \    ^^^^^^^^^^^^^^^^^ expected `usize`, found `&isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmppgsqvd18.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmppgsqvd18.rs:12:18\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n10  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n13  | |             sum += x;\n14  | |\
    \         }\n15  | |         sum\n16  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmppgsqvd18.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n11 | |    \
    \     let mut sum = 0;\n12 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n13 | |             sum +=\
    \ x;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmppgsqvd18.rs:17:5\n   |\n9  |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .enumerate()\n\
    \        .sort_by(|(idx, &n), (_, n2)| {\n            n.checked_add(n2).ok()\n\
    \        })\n        .map(|(idx, &n)| idx)\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmp07_7mawl.rs:12:10\n   |\n12 |         .sort_by(|(idx,\
    \ &n), (_, n2)| {\n   |          ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    for num in nums_copy {\n        sum += num;\n    }\n    nums_copy.sort_by_key(|num|\
    \ {\n        sum - num\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `nums_copy`\n   --> /tmp/tmp02jf_f1s.rs:14:5\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ move occurs because `nums_copy` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n10  |       let mut sum = 0;\n11  |       for num in nums_copy\
    \ {\n    |                  --------- `nums_copy` moved due to this implicit call\
    \ to `.into_iter()`\n...\n14  | /     nums_copy.sort_by_key(|num| {\n15  | | \
    \        sum - num\n16  | |     });\n    | |______^ value borrowed here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `nums_copy`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n11  |     for num in &nums_copy\
    \ {\n    |                +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp__axp1fj.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmp__axp1fj.rs:12:18\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n10  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n13  | |             sum += x;\n14  | |\
    \         }\n15  | |         sum\n16  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmp__axp1fj.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n11 | |    \
    \     let mut sum = 0;\n12 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n13 | |             sum +=\
    \ x;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmp__axp1fj.rs:17:5\n   |\n9  |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut index = 0;\n\
    \    while nums_copy.len() > 0 {\n        sum += nums_copy.pop().unwrap();\n \
    \       index += 1;\n        if sum < 0 {\n            sum *= -1;\n          \
    \  nums_sorted.push(-index);\n        }\n    }\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12, -1]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpdmpod13u.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    nums_copy.sort_by_key(|&x|\
    \ {\n        sum - x.to_digits(10)\n    });\n    nums_copy\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpazyf302j.rs:17:17\n   |\n17 |         sum - x.to_digits(10)\n\
    \   |                 ^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums = nums.clone();\n    let mut sum\
    \ = 0;\n    let mut min_sum = nums.iter().fold(0, |sum, x| sum + x);\n    let\
    \ mut max_sum = nums.iter().fold(0, |sum, x| sum + x);\n    let mut min_idx =\
    \ nums.iter().cloned().min_by_key(|x| sum + x).unwrap();\n    let mut max_idx\
    \ = nums.iter().cloned().max_by_key(|x| sum + x).unwrap();\n    while min_sum\
    \ != max_sum {\n        if min_sum < max_sum {\n            if min_sum < max_sum\
    \ {\n                let mut min_idx = nums.iter().cloned().min_by_key(|x| sum\
    \ + x).unwrap();\n                let mut max_idx = nums.iter().cloned().max_by_key(|x|\
    \ sum + x).unwrap();\n                while min_sum != max_sum {\n           \
    \         let mut min_sum = nums.iter().fold(0, |sum, x| sum + x);\n         \
    \           let mut max_sum = nums.iter().fold(0, |sum, x| sum + x);\n       \
    \             while min_sum != max_sum {\n                        if min_sum <\
    \ max_sum {\n                            let mut min_idx = nums.iter().cloned().min_by_key(|x|\
    \ sum + x).unwrap();\n                            let mut max_idx = nums.iter().cloned().max_by_key(|x|\
    \ sum + x).unwrap();\n                            while min_sum != max_sum {\n\
    \                                let mut min_sum = nums.iter().fold(0, |sum, x|\
    \ sum + x);\n                                let mut max_sum = nums.iter().fold(0,\
    \ |sum, x| sum + x);\n                                while min_sum != max_sum\
    \ {\n                                    let mut min_idx = nums.iter().cloned().min_by_key(|x|\
    \ sum + x).unwrap();\n                                    let mut max_idx = nums.iter().cloned().max_by_key(|x|\
    \ sum + x).unwrap();\n                                    while min_sum != max_sum\
    \ {\n                                        let mut min_sum = nums.iter().fold(0,\
    \ |sum, x| sum + x);\n                                        let mut max_sum\
    \ = nums.iter().fold(0, |sum, x| sum + x);\n                                 \
    \       while min_sum != max_sum {\n                                         \
    \   if min_sum < max_sum {\n                                                let\
    \ mut min_idx = nums.iter().cloned().min_by_key(|x| sum + x).unwrap();\n     \
    \                                           let mut max_idx = nums.iter().cloned().max_\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpeiygk4y3.rs:50:3\n\
    \   |\n8  | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n15 |\
    \     while min_sum != max_sum {\n   |                              - unclosed\
    \ delimiter\n16 |         if min_sum < max_sum {\n   |                       \
    \       - unclosed delimiter\n17 |             if min_sum < max_sum {\n   |  \
    \                                - unclosed delimiter\n...\n20 |             \
    \    while min_sum != max_sum {\n   |                                        \
    \  - unclosed delimiter\n...\n23 |                     while min_sum != max_sum\
    \ {\n   |                                              - unclosed delimiter\n\
    24 |                         if min_sum < max_sum {\n   |                    \
    \                          - unclosed delimiter\n...\n27 |                   \
    \          while min_sum != max_sum {\n   |                                  \
    \                    - unclosed delimiter\n...\n30 |                         \
    \        while min_sum != max_sum {\n   |                                    \
    \                      - unclosed delimiter\n...\n33 |                       \
    \              while min_sum != max_sum {\n   |                              \
    \                                - unclosed delimiter\n...\n36 |             \
    \                            while min_sum != max_sum {\n   |                \
    \                                                  - unclosed delimiter\n37 |\
    \                                             if min_sum < max_sum {\n   |   \
    \                                                               - this delimiter\
    \ might not be properly closed...\n...\n40 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n50 | }\n   |   ^\n\nerror: expected `;`,\
    \ found `}`\n  --> /tmp/tmpeiygk4y3.rs:39:92\n   |\n39 |                     \
    \                            let mut max_idx = nums.iter().cloned().max_\n   |\
    \                                                                            \
    \                ^ help: a"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for n in nums_sorted {\n        sum += n;\n    }\n    let\
    \ mut nums_sorted_by_sum: Vec<isize> = nums_sorted.clone();\n    let mut index\
    \ = 0;\n    while index < nums_sorted.len() {\n        let mut found = false;\n\
    \        for n in nums_sorted_by_sum {\n            if n == sum {\n          \
    \      nums_sorted_by_sum.swap(index, n);\n                found = true;\n   \
    \             break;\n            }\n        }\n        if !found {\n        \
    \    nums_sorted_by_sum.push(nums_sorted[index]);\n            index += 1;\n \
    \       }\n    }\n    nums_sorted_by_sum\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwu6eyqh3.rs:20:48\n   |\n\
    20 |                 nums_sorted_by_sum.swap(index, n);\n   |                \
    \                                ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n20 |                 nums_sorted_by_sum.swap(index, n.try_into().unwrap());\n\
    \   |                                                 ++++++++++++++++++++\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index +=\n            match nums_copy[index]\
    \ % 10 {\n                0 => 1,\n                1 => 2,\n                2\
    \ => 3,\n                3 => 4,\n                4 => 5,\n                5 =>\
    \ 6,\n                6 => 7,\n                7 => 8,\n                8 => 9,\n\
    \                _ => panic!(\"invalid input\"),\n            };\n    }\n    nums_copy.sort_by_key(|x|\
    \ sum + x);\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'invalid input', /tmp/tmp0nxyxgpw.rs:25:22\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by_key(|x| {\n        let mut sum\
    \ = 0;\n        for &d in &nums {\n            sum += d;\n        }\n        sum\n\
    \    });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n \
    \   assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n --> /tmp/tmpbyopvfsm.rs:9:23\n  |\n9 |\
    \     nums.sort_by_key(|x| {\n  |                       ^ help: if this is intentional,\
    \ prefix it with an underscore: `_x`\n  |\n  = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `nums` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpbyopvfsm.rs:9:5\n   |\n8  |   fn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      ---- help: consider changing\
    \ this to be mutable: `mut nums`\n9  | /     nums.sort_by_key(|x| {\n10 | |  \
    \       let mut sum = 0;\n11 | |         for &d in &nums {\n12 | |           \
    \  sum += d;\n13 | |         }\n14 | |         sum\n15 | |     });\n   | |______^\
    \ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `nums` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmpbyopvfsm.rs:9:22\n   |\n\
    9  |       nums.sort_by_key(|x| {\n   |       -    ----------- ^^^ immutable borrow\
    \ occurs here\n   |       |    |\n   |  _____|    mutable borrow later used by\
    \ call\n   | |\n10 | |         let mut sum = 0;\n11 | |         for &d in &nums\
    \ {\n   | |                    ---- second borrow occurs due to use of `nums`\
    \ in closure\n12 | |             sum += d;\n13 | |         }\n14 | |         sum\n\
    15 | |     });\n   | |______- mutable borrow occurs here\n\nerror: aborting due\
    \ to 2 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0502, E0596.\nFor more information about an error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for &i in nums_copy {\n            sum\
    \ += i;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n  \
    \  let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgr2qsrz9.rs:12:13\n   |\n\
    12 |         for &i in nums_copy {\n   |             ^^    --------- this expression\
    \ has type `Option<isize>`\n   |             |\n   |             expected `isize`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `i`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while nums_copy.len() > 0 {\n    \
    \    sum += nums_copy.pop().unwrap();\n        if index == nums_copy.len() {\n\
    \            break;\n        }\n        index += 1;\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x.digits().sum()\n    });\n    nums_copy\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpkp7iq3_9.rs:20:17\n   |\n20 |         sum -\
    \ x.digits().sum()\n   |                 ^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums {\n            sum += x;\n\
    \        }\n        sum\n    });\n    sorted_nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpit3d_x5f.rs:10:30\n   |\n\
    10 |     sorted_nums.sort_by_key(|x| {\n   |                              ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpit3d_x5f.rs:12:18\n\
    \    |\n8   |   fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    |  \
    \                    ---- captured outer variable\n9   |       let mut sorted_nums\
    \ = nums.clone();\n10  |       sorted_nums.sort_by_key(|x| {\n    |  _____________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums {\n    | |   \
    \               ^^^^\n    | |                  |\n    | |                  `nums`\
    \ moved due to this implicit call to `.into_iter()`\n    | |                 \
    \ move occurs because `nums` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n13  | |             sum += x;\n14  | |         }\n15  | |    \
    \     sum\n16  | |     });\n    | |_____- captured by this `FnMut` closure\n \
    \   |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n12  |         for x in &nums {\n\
    \    |                  +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut max_sum =\
    \ 0;\n    let mut max_index = 0;\n    let mut min_sum = 0;\n    let mut min_index\
    \ = 0;\n    for i in nums_copy {\n        sum += i;\n        if sum > max_sum\
    \ {\n            max_sum = sum;\n            max_index = i;\n        }\n     \
    \   if sum < min_sum {\n            min_sum = sum;\n            min_index = i;\n\
    \        }\n    }\n    for i in nums_copy {\n        if i == max_index {\n   \
    \         nums_sorted.swap(i, max_index);\n        }\n    }\n    for i in nums_copy\
    \ {\n        if i == min_index {\n            nums_sorted.swap(i, min_index);\n\
    \        }\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg4hptvxj.rs:29:30\n   |\n\
    29 |             nums_sorted.swap(i, max_index);\n   |                       \
    \       ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n29 |      \
    \       nums_sorted.swap(i.try_into().unwrap(), max_index);\n   |            \
    \                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpg4hptvxj.rs:29:33\n   |\n29 |             nums_sorted.swap(i, max_index);\n\
    \   |                                 ^^^^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n29 |             nums_sorted.swap(i, max_index.try_into().unwrap());\n\
    \   |                                          ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg4hptvxj.rs:34:30\n   |\n34 |             nums_sorted.swap(i,\
    \ min_index);\n   |                              ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n34 |             nums_sorted.swap(i.try_into().unwrap(),\
    \ min_index);\n   |                               ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg4hptvxj.rs:34:33\n   |\n34 |             nums_sorted.swap(i,\
    \ min_index);\n   |                                 ^^^^^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n34 |             nums_sorted.swap(i,\
    \ min_index.try_into().unwrap());\n   |                                      \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for &n in &nums_copy {\n            sum\
    \ += n.digits().iter().sum();\n        }\n        sum\n    });\n    nums_copy\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpxoyw1224.rs:13:22\n   |\n13 |             sum += n.digits().iter().sum();\n\
    \   |                      ^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for n in nums_sorted {\n        sum += n;\n    }\n    nums_sorted.sort_unstable_by(|a,\
    \ b| {\n        sum.partial_cmp(&a + b).unwrap()\n    });\n    nums_sorted\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&isize` to `&&isize`\n  --> /tmp/tmp_zmybgln.rs:15:28\n\
    \   |\n15 |         sum.partial_cmp(&a + b).unwrap()\n   |                   \
    \      -- ^ - &isize\n   |                         |\n   |                   \
    \      &&isize\n   |\nhelp: `+` can be used on `isize`, you can dereference `&a`\n\
    \   |\n15 |         sum.partial_cmp(*&a + b).unwrap()\n   |                  \
    \       +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    let mut nums_copy\
    \ = nums.clone();\n    nums_copy.sort_by_key(|x| {\n        sum += x;\n      \
    \  sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-1, -11, -12, 11, 1]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp8v7bbgq_.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_unstable_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_sorted {\n            sum\
    \ += x;\n        }\n        sum\n    });\n    nums_sorted\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp7lfhjk10.rs:10:39\n   |\n\
    10 |     nums_sorted.sort_unstable_by_key(|x| {\n   |                        \
    \               ^ help: if this is intentional, prefix it with an underscore:\
    \ `_x`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0507]:\
    \ cannot move out of `nums_sorted`, a captured variable in an `FnMut` closure\n\
    \   --> /tmp/tmp7lfhjk10.rs:12:18\n    |\n9   |       let mut nums_sorted = nums.clone();\n\
    \    |           --------------- captured outer variable\n10  |       nums_sorted.sort_unstable_by_key(|x|\
    \ {\n    |  ______________________________________-\n11  | |         let mut sum\
    \ = 0;\n12  | |         for x in nums_sorted {\n    | |                  ^^^^^^^^^^^\n\
    \    | |                  |\n    | |                  `nums_sorted` moved due\
    \ to this implicit call to `.into_iter()`\n    | |                  move occurs\
    \ because `nums_sorted` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n13  | |             sum += x;\n14  | |         }\n15  | |         sum\n\
    16  | |     });\n    | |_____- captured by this `FnMut` closure\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `nums_sorted`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |         for x in &nums_sorted {\n    |   \
    \               +\n\nerror[E0505]: cannot move out of `nums_sorted` because it\
    \ is borrowed\n  --> /tmp/tmp7lfhjk10.rs:10:38\n   |\n10 |       nums_sorted.sort_unstable_by_key(|x|\
    \ {\n   |       -                                ^^^ move out of `nums_sorted`\
    \ occurs here\n   |  _____|\n   | |\n11 | |         let mut sum = 0;\n12 | | \
    \        for x in nums_sorted {\n   | |                  ----------- move occurs\
    \ due to use in closure\n13 | |             sum += x;\n14 | |         }\n15 |\
    \ |         sum\n16 | |     });\n   | |______- borrow of `nums_sorted` occurs\
    \ here\n\nerror[E0382]: use of moved value: `nums_sorted`\n  --> /tmp/tmp7lfhjk10.rs:17:5\n\
    \   |\n9  |     let mut nums_sorted = nums.clone();\n   |         -----------"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut max_sum =\
    \ 0;\n    let mut max_index = 0;\n    let mut min_sum = 0;\n    let mut min_index\
    \ = 0;\n    for i in nums_copy {\n        sum += i;\n        if sum > max_sum\
    \ {\n            max_sum = sum;\n            max_index = i;\n        }\n     \
    \   if sum < min_sum {\n            min_sum = sum;\n            min_index = i;\n\
    \        }\n    }\n    for i in nums_copy {\n        if i != max_index {\n   \
    \         nums_sorted.swap(i, max_index);\n        }\n    }\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ukn9x6o.rs:29:30\n   |\n\
    29 |             nums_sorted.swap(i, max_index);\n   |                       \
    \       ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n29 |      \
    \       nums_sorted.swap(i.try_into().unwrap(), max_index);\n   |            \
    \                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp4ukn9x6o.rs:29:33\n   |\n29 |             nums_sorted.swap(i, max_index);\n\
    \   |                                 ^^^^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n29 |             nums_sorted.swap(i, max_index.try_into().unwrap());\n\
    \   |                                          ++++++++++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut index = 0;\n\
    \    while nums_sorted.len() > 0 {\n        sum += nums_sorted.pop();\n      \
    \  if sum < 0 {\n            sum = 0;\n        }\n        if index == nums_sorted.len()\
    \ {\n            index = 0;\n        }\n        if sum == 0 {\n            nums_sorted.push(nums_sorted.pop());\n\
    \        }\n        index += 1;\n    }\n    nums_sorted.reverse();\n    nums_copy\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `Option<isize>` to `{integer}`\n  --> /tmp/tmp4wyjc5y6.rs:14:13\n\
    \   |\n14 |         sum += nums_sorted.pop();\n   |             ^^ no implementation\
    \ for `{integer} += Option<isize>`\n   |\n   = help: the trait `AddAssign<Option<isize>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4wyjc5y6.rs:22:30\n\
    \   |\n22 |             nums_sorted.push(nums_sorted.pop());\n   |           \
    \                   ^^^^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = nums.iter().min().unwrap();\n    let mut\
    \ max_sum = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min_by_key(|&x|\
    \ x).unwrap();\n    let mut max_idx = nums.iter().max_by_key(|&x| x).unwrap();\n\
    \n    while nums_copy.len() > 0 {\n        let mut idx = nums_copy.iter().position(|&x|\
    \ x >= sum).unwrap();\n        if idx < nums.len() {\n            sum = sum +\
    \ nums[idx];\n            nums_copy.remove(&idx);\n        } else {\n        \
    \    break;\n        }\n    }\n\n    while nums_copy.len() > 0 {\n        let\
    \ mut idx = nums_copy.iter().position(|&x| x <= sum).unwrap();\n        if idx\
    \ < nums.len() {\n            sum = sum - nums[idx];\n            nums_copy.remove(&idx);\n\
    \        } else {\n            break;\n        }\n    }\n\n    while nums_copy.len()\
    \ > 0 {\n        let mut idx = nums_copy.iter().position(|&x| x >= sum).unwrap();\n\
    \        if idx < nums.len() {\n            sum = sum + nums[idx];\n         \
    \   nums_copy.remove(&idx);\n        } else {\n            break;\n        }\n\
    \    }\n\n    while nums_copy.len() > 0 {\n        let mut idx = nums_copy.iter().position(|&x|\
    \ x <= sum).unwrap();\n        if idx < nums.len() {\n            sum = sum -\
    \ nums[idx];\n            nums_copy.remove(&idx);\n        } else {\n        \
    \    break;\n        }\n    }\n\n    while nums_copy.len() > 0 {\n        let\
    \ mut idx = nums_copy.iter().position(|&x| x >= sum).unwrap();\n        if idx\
    \ < nums.len() {\n            sum = sum + nums[idx];\n            nums_copy.remove(&idx);\n\
    \        } else {\n            break;\n        }\n    }\n\n    while nums_copy.len()\
    \ > 0 {\n        let mut idx = nums_copy.iter().position(|&x| x <= sum).unwrap();\n\
    \        if idx < nums.len() {\n            sum = sum - nums[idx];\n         \
    \   nums_copy.remove(&idx);\n        } else {\n            break;\n        }\n\
    \    }\n\n    while nums_copy.len() > 0 {\n        let mut idx = nums_copy.iter().position(|&x|\
    \ x >= sum).unwrap();\n        if idx < nums.len() {\n            sum = sum +\
    \ nums[idx];\n            nums_copy.remove(&idx);\n        } else {\n        \
    \    break;\n        }\n    }\n\n    while nums_copy.len() > 0 {\n\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpth23j9ao.rs:98:3\n\
    \   |\n8  | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n86 |\
    \     while nums_copy.len() > 0 {\n   |                               - this delimiter\
    \ might not be properly closed...\n87 | \n88 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n98 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpth23j9ao.rs:20:30\n   |\n20 |             nums_copy.remove(&idx);\n\
    \   |                              ^^^^ expected `usize`, found `&usize`\n   |\n\
    help: consider removing the borrow\n   |\n20 -             nums_copy.remove(&idx);\n\
    20 +             nums_copy.remove(idx);\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpth23j9ao.rs:30:30\n   |\n30 |             nums_copy.remove(&idx);\n\
    \   |                              ^^^^ expected `usize`, found `&usize`\n   |\n\
    help: consider removing the borrow\n   |\n30 -             nums_copy.remove(&idx);\n\
    30 +             nums_copy.remove(idx);\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpth23j9ao.rs:40:30\n   |\n40 |             nums_copy.remove(&idx);\n\
    \   |                              ^^^^ expected `usize`, found `&usize`\n   |\n\
    help: consider removing the borrow\n   |\n40 -             nums_copy.remove(&idx);\n\
    40 +             nums_copy.remove(idx);\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpth23j9ao.rs:50:30\n   |\n50 |             nums_copy.remove(&idx);\n\
    \   |                              ^^^^ expected `usize`, found `&usize`\n   |\n\
    help: consider removing the borrow\n   |\n50 -             nums_copy.remove(&idx);\n\
    50 +             nums_copy.remove(idx);\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpth23j9ao.rs:60:30\n   |\n60 |             nums_copy.remove(&idx);\n\
    \   |                              ^^^^ expected `usize`, found `&usize`\n   |\n\
    help: consider removing the borrow\n   |\n60 -             nums_copy.remove(&idx);\n\
    60 +             nums_copy.remove(idx);\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by(|a, b| {\n        let mut sum\
    \ = 0;\n        for &n in &[a, b] {\n            sum += *n as isize;\n       \
    \ }\n        sum\n    });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphfu6gr_w.rs:14:9\n   |\n\
    14 |         sum\n   |         ^^^ expected enum `std::cmp::Ordering`, found `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums = nums.clone();\n    let mut sum\
    \ = 0;\n    let mut min_sum = nums.iter().fold(0, |sum, num| sum + num);\n   \
    \ let mut min_idx = nums.iter().cloned().min_by_key(|&x| {\n        sum += x;\n\
    \        sum\n    });\n    let mut max_idx = nums.iter().cloned().max_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    });\n    while min_sum > 0 {\n      \
    \  let idx = nums.iter().cloned().position(|&x| {\n            sum += x;\n   \
    \         sum\n        });\n        if idx != min_idx {\n            nums[min_idx]\
    \ = nums[idx];\n            min_idx = idx;\n        }\n        let idx = nums.iter().cloned().position(|&x|\
    \ {\n            sum += x;\n            sum\n        });\n        if idx != max_idx\
    \ {\n            nums[max_idx] = nums[idx];\n            max_idx = idx;\n    \
    \    }\n    }\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjthc2d5n.rs:21:50\n   |\n\
    21 |         let idx = nums.iter().cloned().position(|&x| {\n   |            \
    \                                      ^--\n   |                             \
    \                     ||\n   |                                               \
    \   |expected due to this\n   |                                              \
    \    expected `isize`, found reference\n   |                                 \
    \                 help: did you mean `x`: `&isize`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjthc2d5n.rs:23:13\n   |\n23 |             sum\n   |           \
    \  ^^^ expected `bool`, found `isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjthc2d5n.rs:25:19\n   |\n25 |         if idx != min_idx {\n   |    \
    \               ^^^^^^^ expected `usize`, found `isize`\n   |\n   = note: expected\
    \ enum `Option<usize>`\n              found enum `Option<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `Option<isize>`\n  --> /tmp/tmpjthc2d5n.rs:26:13\n\
    \   |\n26 |             nums[min_idx] = nums[idx];\n   |             ^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `Option<isize>`\n   = note:\
    \ required because of the requirements on the impl of `Index<Option<isize>>` for\
    \ `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `Option<usize>`\n\
    \  --> /tmp/tmpjthc2d5n.rs:26:29\n   |\n26 |             nums[min_idx] = nums[idx];\n\
    \   |                             ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `Option<usize>`\n   = note: required because of the requirements\
    \ on the impl of `Index<Option<usize>>` for `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjthc2d5n.rs:27:23\n   |\n12 |       let mut min_idx = nums.iter().cloned().min_by_key(|&x|\
    \ {\n   |  _______________________-\n13 | |         sum += x;\n14 | |        \
    \ sum\n15 | |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for &num in nums_sorted {\n        sum += num;\n    }\n  \
    \  nums_sorted.sort_by_key(|&num| {\n        sum - num\n    });\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmzmu79qy.rs:11:9\n   |\n\
    11 |     for &num in nums_sorted {\n   |         ^^^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpfltcbb4_.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpfltcbb4_.rs:12:18\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n10  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n13  | |             sum += x;\n14  | |\
    \         }\n15  | |         sum\n16  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpfltcbb4_.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n11 | |    \
    \     let mut sum = 0;\n12 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n13 | |             sum +=\
    \ x;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpfltcbb4_.rs:17:5\n   |\n9  |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for &num in nums_sorted {\n        sum += num;\n    }\n  \
    \  nums_sorted.sort_by_key(|&num| {\n        sum - num\n    });\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5zmw0bw2.rs:11:9\n   |\n\
    11 |     for &num in nums_sorted {\n   |         ^^^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for &n in &nums_copy {\n            sum\
    \ += *n as isize;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmptn9rgaxi.rs:13:20\n\
    \   |\n13 |             sum += *n as isize;\n   |                    ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in &mut sorted_nums {\n         \
    \   sum += *x;\n        }\n        sum\n    });\n    sorted_nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmprm1kqsgs.rs:10:30\n   |\n\
    10 |     sorted_nums.sort_by_key(|x| {\n   |                              ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0499]: cannot borrow `sorted_nums`\
    \ as mutable more than once at a time\n  --> /tmp/tmprm1kqsgs.rs:10:29\n   |\n\
    10 |       sorted_nums.sort_by_key(|x| {\n   |       -           ----------- ^^^\
    \ second mutable borrow occurs here\n   |       |           |\n   |  _____|  \
    \         first borrow later used by call\n   | |\n11 | |         let mut sum\
    \ = 0;\n12 | |         for x in &mut sorted_nums {\n   | |                   \
    \    ----------- second borrow occurs due to use of `sorted_nums` in closure\n\
    13 | |             sum += *x;\n14 | |         }\n15 | |         sum\n16 | |  \
    \   });\n   | |______- first mutable borrow occurs here\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0499`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x.to_digits(10)\n    });\n    nums_copy\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpf1ik9k9a.rs:17:17\n   |\n17 |         sum\
    \ - x.to_digits(10)\n   |                 ^^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpp4us38pk.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpp4us38pk.rs:12:18\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n10  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n13  | |             sum += x;\n14  | |\
    \         }\n15  | |         sum\n16  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpp4us38pk.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n11 | |    \
    \     let mut sum = 0;\n12 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n13 | |             sum +=\
    \ x;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpp4us38pk.rs:17:5\n   |\n9  |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = nums.iter().min().unwrap();\n    let mut\
    \ max_sum = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min_by_key(|&x|\
    \ x).unwrap();\n    let mut max_idx = nums.iter().max_by_key(|&x| x).unwrap();\n\
    \n    while nums_copy.len() > 0 {\n        let mut idx = nums_copy.iter().position(|&x|\
    \ x == 0).unwrap();\n        let mut num = nums_copy[idx];\n        let mut digit\
    \ = num % 10;\n        sum += digit;\n        nums_copy.remove(&idx);\n      \
    \  if sum < min_sum {\n            min_sum = sum;\n            min_idx = idx;\n\
    \        }\n        if sum > max_sum {\n            max_sum = sum;\n         \
    \   max_idx = idx;\n        }\n    }\n    nums_copy.push(min_idx);\n    nums_copy.push(max_idx);\n\
    \    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp35iugbjh.rs:21:26\n   |\n\
    21 |         nums_copy.remove(&idx);\n   |                          ^^^^ expected\
    \ `usize`, found `&usize`\n   |\nhelp: consider removing the borrow\n   |\n21\
    \ -         nums_copy.remove(&idx);\n21 +         nums_copy.remove(idx);\n   |\
    \ \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp35iugbjh.rs:22:18\n   |\n\
    22 |         if sum < min_sum {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |  \
    \       if sum < *min_sum {\n   |                  +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp35iugbjh.rs:23:23\n   |\n11 |     let mut min_sum = nums.iter().min().unwrap();\n\
    \   |                       -------------------------- expected due to this value\n\
    ...\n23 |             min_sum = sum;\n   |                       ^^^\n   |   \
    \                    |\n   |                       expected `&isize`, found `isize`\n\
    \   |                       help: consider borrowing here: `&sum`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp35iugbjh.rs:24:23\n   |\n13 |     let mut min_idx\
    \ = nums.iter().min_by_key(|&x| x).unwrap();\n   |                       ---------------------------------------\
    \ expected due to this value\n...\n24 |             min_idx = idx;\n   |     \
    \                  ^^^ expected `&isize`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp35iugbjh.rs:26:18\n   |\n26 |         if sum > max_sum\
    \ {\n   |                  ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n26 |         if sum > *max_sum {\n\
    \   |                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp35iugbjh.rs:27:23\n\
    \   |\n12 |     let mut max_sum = nums.iter().max().unwrap();\n   |          \
    \             -------------------------- expected due to this value\n...\n27 |\
    \             max_sum = sum;\n   |                       ^^^\n   |           \
    \            |\n   |                       expected `&isize`, found `isize`\n\
    \   |                       help: consider borrowing here: `&sum`\n\nerror[E0308]:\
    \ mismatched "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_unstable_by(|a,\
    \ b| {\n        let mut a_digits = a.to_digits();\n        let mut b_digits =\
    \ b.to_digits();\n        a_digits.iter().zip(b_digits.iter()).for_each(|(a_digit,\
    \ b_digit)| {\n            if a_digit + b_digit > 0 {\n                a_digit\
    \ = a_digit + b_digit - 10;\n                b_digit = b_digit - 10;\n       \
    \     }\n            a_digit = a_digit as isize;\n            b_digit = b_digit\
    \ as isize;\n            if a_digit > b_digit {\n                1\n         \
    \   } else {\n                -1\n            }\n        });\n        a_digits.iter().zip(b_digits.iter()).sum()\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpdv3q_ewy.rs:11:30\n   |\n11 |         let\
    \ mut a_digits = a.to_digits();\n   |                              ^^^^^^^^^ method\
    \ not found in `&isize`\n\nerror[E0599]: no method named `to_digits` found for\
    \ reference `&isize` in the current scope\n  --> /tmp/tmpdv3q_ewy.rs:12:30\n \
    \  |\n12 |         let mut b_digits = b.to_digits();\n   |                   \
    \           ^^^^^^^^^ method not found in `&isize`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    let mut nums_copy\
    \ = nums.clone();\n    nums_copy.sort();\n    let mut index = 0;\n    while index\
    \ < nums_copy.len() {\n        nums_copy[index] -= sum;\n        index += 1;\n\
    \    }\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 11, 13, 23]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp4hi4g9co.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = 0;\n    let mut min_idx = -1;\n    let mut\
    \ max_idx = -1;\n    for &i in nums_copy {\n        sum += i;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_idx = i;\n        }\n\
    \        if sum > max_sum {\n            max_sum = sum;\n            max_idx =\
    \ i;\n        }\n    }\n    if min_sum == 0 {\n        return nums_copy;\n   \
    \ }\n    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut\
    \ min_sum = 0;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n    for\
    \ &i in nums_copy {\n        sum += i;\n        if sum < min_sum {\n         \
    \   min_sum = sum;\n            min_idx = i;\n        }\n        if sum > max_sum\
    \ {\n            max_sum = sum;\n            max_idx = i;\n        }\n    }\n\
    \    if min_sum == 0 {\n        return nums_copy;\n    }\n    let mut nums_copy\
    \ = nums.clone();\n    let mut sum = 0;\n    let mut min_sum = 0;\n    let mut\
    \ min_idx = -1;\n    let mut max_idx = -1;\n    for &i in nums_copy {\n      \
    \  sum += i;\n        if sum < min_sum {\n            min_sum = sum;\n       \
    \     min_idx = i;\n        }\n        if sum > max_sum {\n            max_sum\
    \ = sum;\n            max_idx = i;\n        }\n    }\n    if min_sum == 0 {\n\
    \        return nums_copy;\n    }\n    let mut nums_copy = nums.clone();\n   \
    \ let mut sum = 0;\n    let mut min_sum = 0;\n    let mut min_idx = -1;\n    let\
    \ mut max_idx = -1;\n    for &i in nums_copy {\n        sum += i;\n        if\
    \ sum < min_sum {\n            min_sum = sum;\n            min_idx = i;\n    \
    \    }\n        if sum > max_sum {\n            max_sum = sum;\n            max_idx\
    \ = i;\n        }\n    }\n    if min_sum == 0 {\n        return nums_copy;\n \
    \   }\n    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut\
    \ min_sum = 0;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n    for\
    \ &i in nums_copy {\n        sum += i;\n        if sum < min_sum {\n         \
    \   min_sum = sum;\n            min_idx = i;\n        }\n        if sum > max_sum\
    \ {\n            max_sum = sum;\n            max_idx = i;\n        }\n    }\n\
    \    if min_sum == 0 {\n        return nums_copy;\n    }\n    let mut nums_copy\
    \ = num\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n   --> /tmp/tmpl0bpahnr.rs:104:28\n   \
    \ |\n104 |     let mut nums_copy = num\n    |                            ^ help:\
    \ add `;` here\n105 | }\n    | - unexpected token\n\nerror[E0425]: cannot find\
    \ value `max_sum` in this scope\n  --> /tmp/tmpl0bpahnr.rs:20:18\n   |\n20 | \
    \        if sum > max_sum {\n   |                  ^^^^^^^ help: a local variable\
    \ with a similar name exists: `min_sum`\n\nerror[E0425]: cannot find value `max_sum`\
    \ in this scope\n  --> /tmp/tmpl0bpahnr.rs:21:13\n   |\n21 |             max_sum\
    \ = sum;\n   |             ^^^^^^^ help: a local variable with a similar name\
    \ exists: `min_sum`\n\nerror[E0425]: cannot find value `max_sum` in this scope\n\
    \  --> /tmp/tmpl0bpahnr.rs:39:18\n   |\n39 |         if sum > max_sum {\n   |\
    \                  ^^^^^^^ help: a local variable with a similar name exists:\
    \ `min_sum`\n\nerror[E0425]: cannot find value `max_sum` in this scope\n  -->\
    \ /tmp/tmpl0bpahnr.rs:40:13\n   |\n40 |             max_sum = sum;\n   |     \
    \        ^^^^^^^ help: a local variable with a similar name exists: `min_sum`\n\
    \nerror[E0425]: cannot find value `max_sum` in this scope\n  --> /tmp/tmpl0bpahnr.rs:58:18\n\
    \   |\n58 |         if sum > max_sum {\n   |                  ^^^^^^^ help: a\
    \ local variable with a similar name exists: `min_sum`\n\nerror[E0425]: cannot\
    \ find value `max_sum` in this scope\n  --> /tmp/tmpl0bpahnr.rs:59:13\n   |\n\
    59 |             max_sum = sum;\n   |             ^^^^^^^ help: a local variable\
    \ with a similar name exists: `min_sum`\n\nerror[E0425]: cannot find value `max_sum`\
    \ in this scope\n  --> /tmp/tmpl0bpahnr.rs:77:18\n   |\n77 |         if sum >\
    \ max_sum {\n   |                  ^^^^^^^ help: a local variable with a similar\
    \ name exists: `min_sum`\n\nerror[E0425]: cannot find value `max_sum` in this\
    \ scope\n  --> /tmp/tmpl0bpahnr.rs:78:13\n   |\n78 |             max_sum = sum;\n\
    \   |             ^^^^^^^ help: a local variable with a similar name exists: `min_sum`\n\
    \nerror[E0425]: cannot find value `max_sum` in this scope\n  --> /tmp/tmpl0bpahnr.rs:96:18\n\
    \   |\n96 |         if sum > max_sum {\n   |          "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_unstable_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_sorted {\n            sum\
    \ += x;\n        }\n        sum\n    });\n    nums_sorted\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpuid1y8nl.rs:10:39\n   |\n\
    10 |     nums_sorted.sort_unstable_by_key(|x| {\n   |                        \
    \               ^ help: if this is intentional, prefix it with an underscore:\
    \ `_x`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0507]:\
    \ cannot move out of `nums_sorted`, a captured variable in an `FnMut` closure\n\
    \   --> /tmp/tmpuid1y8nl.rs:12:18\n    |\n9   |       let mut nums_sorted = nums.clone();\n\
    \    |           --------------- captured outer variable\n10  |       nums_sorted.sort_unstable_by_key(|x|\
    \ {\n    |  ______________________________________-\n11  | |         let mut sum\
    \ = 0;\n12  | |         for x in nums_sorted {\n    | |                  ^^^^^^^^^^^\n\
    \    | |                  |\n    | |                  `nums_sorted` moved due\
    \ to this implicit call to `.into_iter()`\n    | |                  move occurs\
    \ because `nums_sorted` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n13  | |             sum += x;\n14  | |         }\n15  | |         sum\n\
    16  | |     });\n    | |_____- captured by this `FnMut` closure\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `nums_sorted`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |         for x in &nums_sorted {\n    |   \
    \               +\n\nerror[E0505]: cannot move out of `nums_sorted` because it\
    \ is borrowed\n  --> /tmp/tmpuid1y8nl.rs:10:38\n   |\n10 |       nums_sorted.sort_unstable_by_key(|x|\
    \ {\n   |       -                                ^^^ move out of `nums_sorted`\
    \ occurs here\n   |  _____|\n   | |\n11 | |         let mut sum = 0;\n12 | | \
    \        for x in nums_sorted {\n   | |                  ----------- move occurs\
    \ due to use in closure\n13 | |             sum += x;\n14 | |         }\n15 |\
    \ |         sum\n16 | |     });\n   | |______- borrow of `nums_sorted` occurs\
    \ here\n\nerror[E0382]: use of moved value: `nums_sorted`\n  --> /tmp/tmpuid1y8nl.rs:17:5\n\
    \   |\n9  |     let mut nums_sorted = nums.clone();\n   |         -----------"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for &n in &nums_copy {\n            sum\
    \ += *n as isize;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpsbt18__f.rs:13:20\n\
    \   |\n13 |             sum += *n as isize;\n   |                    ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut max_sum =\
    \ 0;\n    let mut max_index = 0;\n    let mut min_sum = 0;\n    let mut min_index\
    \ = 0;\n    for i in nums_copy {\n        sum += i;\n        if sum > max_sum\
    \ {\n            max_sum = sum;\n            max_index = i;\n        }\n     \
    \   if sum < min_sum {\n            min_sum = sum;\n            min_index = i;\n\
    \        }\n    }\n    for i in nums_copy {\n        if i == max_index {\n   \
    \         nums_sorted.swap(i, max_index);\n        }\n    }\n    for i in nums_copy\
    \ {\n        if i == min_index {\n            nums_sorted.swap(i, min_index);\n\
    \        }\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptngegm1k.rs:29:30\n   |\n\
    29 |             nums_sorted.swap(i, max_index);\n   |                       \
    \       ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n29 |      \
    \       nums_sorted.swap(i.try_into().unwrap(), max_index);\n   |            \
    \                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmptngegm1k.rs:29:33\n   |\n29 |             nums_sorted.swap(i, max_index);\n\
    \   |                                 ^^^^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n29 |             nums_sorted.swap(i, max_index.try_into().unwrap());\n\
    \   |                                          ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptngegm1k.rs:34:30\n   |\n34 |             nums_sorted.swap(i,\
    \ min_index);\n   |                              ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n34 |             nums_sorted.swap(i.try_into().unwrap(),\
    \ min_index);\n   |                               ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptngegm1k.rs:34:33\n   |\n34 |             nums_sorted.swap(i,\
    \ min_index);\n   |                                 ^^^^^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n34 |             nums_sorted.swap(i,\
    \ min_index.try_into().unwrap());\n   |                                      \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums = nums.clone();\n    let mut sum\
    \ = 0;\n    let mut index = 0;\n    while index < nums.len() {\n        sum +=\
    \ nums[index];\n        index += 1; // skip the element with same sum\n    }\n\
    \    nums.sort_by_key(|x| {\n        sum - x.digits().sum()\n    });\n    nums\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpiw7um7v0.rs:17:17\n   |\n17 |         sum -\
    \ x.digits().sum()\n   |                 ^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut index = 0;\n\
    \    while index < nums_copy.len() {\n        sum += nums_copy[index];\n     \
    \   if sum < 0 {\n            sum = 0;\n        }\n        if sum > 0 {\n    \
    \        nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \        }\n        index += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n  \
    \  let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpictadmmr.rs:9:9\n\
    \  |\n9 |     let mut nums_copy = nums.clone();\n  |         ----^^^^^^^^^\n \
    \ |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpictadmmr.rs:19:37\n   |\n19 |\
    \             nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |             ------------------------^^^^^^^^^^^^^^^^^^----------------------------------\n\
    \   |             |           |           |\n   |             |           |  \
    \         immutable borrow occurs here\n   |             |           mutable borrow\
    \ later used by call\n   |             mutable borrow occurs here\n   |\nhelp:\
    \ try adding a local storing this argument...\n  --> /tmp/tmpictadmmr.rs:19:37\n\
    \   |\n19 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n   |                                     ^^^^^^^^^^^^^^^^^^\n\
    help: ...and then using that local as the argument to this call\n  --> /tmp/tmpictadmmr.rs:19:13\n\
    \   |\n19 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for &num in nums_sorted {\n        sum += num;\n    }\n  \
    \  nums_sorted.sort_by_key(|&num| {\n        sum - num\n    });\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptxi9nx8n.rs:11:9\n   |\n\
    11 |     for &num in nums_sorted {\n   |         ^^^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index +=\n            match nums_copy[index]\
    \ % 10 {\n                0 => 1,\n                1 => 2,\n                2\
    \ => 3,\n                3 => 4,\n                4 => 5,\n                5 =>\
    \ 6,\n                6 => 7,\n                7 => 8,\n                8 => 9,\n\
    \                _ => panic!(\"Invalid input\"),\n            };\n    }\n    nums_copy.sort_by_key(|x|\
    \ sum + x);\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'Invalid input', /tmp/tmpifi5pyr9.rs:25:22\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x.to_digits().unwrap().sum()\n    });\n    nums_copy\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp5g53rzat.rs:17:17\n   |\n17 |         sum\
    \ - x.to_digits().unwrap().sum()\n   |                 ^^^^^^^^^ method not found\
    \ in `&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmplv7gkfrw.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmplv7gkfrw.rs:12:18\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n10  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n13  | |             sum += x;\n14  | |\
    \         }\n15  | |         sum\n16  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmplv7gkfrw.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n11 | |    \
    \     let mut sum = 0;\n12 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n13 | |             sum +=\
    \ x;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmplv7gkfrw.rs:17:5\n   |\n9  |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x;\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp5lw38z_5.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut max_sum =\
    \ 0;\n    let mut min_sum = 0;\n    let mut max_index = -1;\n    let mut min_index\
    \ = -1;\n    let mut max_value = nums_copy[0];\n    let mut min_value = nums_copy[0];\n\
    \    let mut max_digit = 0;\n    let mut min_digit = 0;\n    let mut max_digits\
    \ = 0;\n    let mut min_digits = 0;\n    let mut max_digits_sum = 0;\n    let\
    \ mut min_digits_sum = 0;\n    let mut max_digits_sums = 0;\n    let mut min_digits_sums\
    \ = 0;\n    let mut max_digits_sums_sum = 0;\n    let mut min_digits_sums_sum\
    \ = 0;\n    let mut max_digits_sums_sums = 0;\n    let mut min_digits_sums_sums\
    \ = 0;\n    let mut max_digits_sums_sums_sum = 0;\n    let mut min_digits_sums_sums_sum\
    \ = 0;\n    let mut max_digits_sums_sums_sums = 0;\n    let mut min_digits_sums_sums_sums\
    \ = 0;\n    let mut max_digits_sums_sums_sums_sum = 0;\n    let mut min_digits_sums_sums_sums_sum\
    \ = 0;\n    let mut max_digits_sums_sums_sums_sums = 0;\n    let mut min_digits_sums_sums_sums_sums\
    \ = 0;\n    let mut max_digits_sums_sums_sums_sums_sum = 0;\n    let mut min_digits_sums_sums_sums_sums_sum\
    \ = 0;\n    let mut max_digits_sums_sums_sums_sums_sums = 0;\n    let mut min_digits_sums_sums_sums_sums_sums\
    \ = 0;\n    let mut max_digits_sums_sums_sums_sums_sums_sum = 0;\n    let mut\
    \ min_digits_sums_sums_sums_sums_sums_sum = 0;\n    let mut max_digits_sums_sums_sums_sums_sums_sums\
    \ = 0;\n    let mut min_digits_sums_sums_sums_sums_sums_sums = 0;\n    let mut\
    \ max_digits_sums_sums_sums_sums_sums_sums_sum = 0;\n    let mut min_digits_sums_sums_sums_sums_sums_sums_sum\
    \ = 0;\n    let mut max_digits_sums_sums_sums_sums_sums_sums_sums = 0;\n    let\
    \ mut min_digits_sums_sums_\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpn8q7825k.rs:49:34\n   |\n\
    49 |     let mut min_digits_sums_sums_\n   |                                 \
    \ ^ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpn8q7825k.rs:8:41\n  |\n8 | fn order_by_points(nums: Vec<isize>)\
    \ -> Vec<isize> {\n  |    ---------------                      ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for num in nums_sorted {\n        sum += num;\n    }\n   \
    \ let mut nums_sorted_by_sum: Vec<isize> = nums_sorted.clone();\n    let mut nums_sorted_by_sum_index:\
    \ Vec<usize> = nums_sorted.clone();\n    let mut index = 0;\n    while index <\
    \ nums_sorted.len() {\n        let mut index_to_remove = index;\n        let mut\
    \ index_to_remove_by_sum = 0;\n        while index_to_remove < nums_sorted.len()\
    \ {\n            let mut num = nums_sorted[index_to_remove];\n            if nums_sorted_by_sum[index_to_remove_by_sum]\
    \ == sum {\n                nums_sorted_by_sum[index_to_remove_by_sum] = num;\n\
    \                nums_sorted_by_sum_index[index_to_remove_by_sum] = index;\n \
    \               index_to_remove_by_sum += 1;\n            } else {\n         \
    \       index_to_remove += 1;\n            }\n        }\n        index += 1;\n\
    \    }\n    nums_sorted_by_sum.sort_unstable();\n    nums_sorted_by_sum_index.sort_unstable();\n\
    \    nums_sorted_by_sum.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmghqfs44.rs:15:52\n   |\n\
    15 |     let mut nums_sorted_by_sum_index: Vec<usize> = nums_sorted.clone();\n\
    \   |                                       ----------   ^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |                                       |\n   | \
    \                                      expected due to this\n   |\n   = note:\
    \ expected struct `Vec<usize>`\n              found struct `Vec<isize>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    nums_copy.sort_by_key(|&x|\
    \ {\n        sum - x.to_digits(10);\n    });\n    nums_copy\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmprnnaox21.rs:17:17\n   |\n17 |         sum - x.to_digits(10);\n\
    \   |                 ^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = 0;\n    let mut min_idx = nums.len() - 1;\n\
    \    let mut min_val = nums_copy[min_idx];\n    let mut min_idx = nums.len() -\
    \ 1;\n    let mut min_val = nums_copy[min_idx];\n    for &i in nums_copy {\n \
    \       sum += i;\n        if sum < min_sum {\n            min_sum = sum;\n  \
    \          min_idx = i;\n            min_val = i;\n        }\n    }\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n  \
    \  nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n  \
    \  nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n  \
    \  nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n  \
    \  nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n  \
    \  nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n  \
    \  nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n  \
    \  nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n  \
    \  nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnz0ep8kr.rs:16:9\n   |\n\
    16 |     for &i in nums_copy {\n   |         ^^    --------- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnz0ep8kr.rs:21:23\n   |\n15 |     let mut min_val\
    \ = nums_copy[min_idx];\n   |                       ------------------ expected\
    \ due to this value\n...\n21 |             min_val = i;\n   |                \
    \       ^ expected `isize`, found `usize`\n\nerror[E0615]: attempted to take value\
    \ of method `swap_remove` on type `Vec<isize>`\n  --> /tmp/tmpnz0ep8kr.rs:64:15\n\
    \   |\n64 |     nums_copy.swap_remove\n   |               ^^^^^^^^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n64 |    \
    \ nums_copy.swap_remove(_)\n   |                          +++\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0615.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut max_sum = 0;\n    let mut max_index = 0;\n    let\
    \ mut min_sum = 0;\n    let mut min_index = 0;\n    let mut min_value = nums_copy[0];\n\
    \    let mut max_value = nums_copy[0];\n    let mut min_value = nums_copy[0];\n\
    \    let mut max_value = nums_copy[0];\n    for &num in nums_copy {\n        sum\
    \ += num;\n        if sum > max_sum {\n            max_sum = sum;\n          \
    \  max_index = num;\n        }\n        if sum < min_sum {\n            min_sum\
    \ = sum;\n            min_index = num;\n        }\n        if num < min_value\
    \ {\n            min_value = num;\n            min_index = num;\n        }\n \
    \       if num > max_value {\n            max_value = num;\n            max_index\
    \ = num;\n        }\n    }\n    let mut nums_copy = nums.clone();\n    let mut\
    \ sum = 0;\n    let mut max_sum = 0;\n    let mut max_index = 0;\n    let mut\
    \ min_sum = 0;\n    let mut min_index = 0;\n    let mut min_value = nums_copy[0];\n\
    \    let mut max_value = nums_copy[0];\n    let mut min_value = nums_copy[0];\n\
    \    let mut max_value = nums_copy[0];\n    for &num in nums_copy {\n        sum\
    \ += num;\n        if sum > max_sum {\n            max_sum = sum;\n          \
    \  max_index = num;\n        }\n        if sum < min_sum {\n            min_sum\
    \ = sum;\n            min_index = num;\n        }\n        if num < min_value\
    \ {\n            min_value = num;\n            min_index = num;\n        }\n \
    \       if num > max_value {\n            max_value = num;\n            max_index\
    \ = num;\n        }\n    }\n    let mut nums_copy = nums.clone();\n    let mut\
    \ sum = 0;\n    let mut max_sum = 0;\n    let mut max_index = 0;\n    let mut\
    \ min_sum = 0;\n    let mut min_index = 0;\n    let mut min_value = nums_copy[0];\n\
    \    let mut max_value = nums_copy[0];\n    let mut min_value = nums_copy[0];\n\
    \    let mut max_value = nums_copy[0];\n    for &num in nums_copy {\n        sum\
    \ += num;\n        if sum > max_sum {\n            max_sum = sum;\n          \
    \  max_index = num;\n        }\n        if sum < min_sum {\n            min_sum\
    \ = sum;\n            min_index = num;\n        }\n        if num < min_value\
    \ {\n            min_value = num;\n            min_index = num;\n        }\n \
    \       if num > max_value \n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpv0xf2wcf.rs:102:3\n\
    \    |\n8   | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    |    \
    \                                                - unclosed delimiter\n...\n77\
    \  |     for &num in nums_copy {\n    |                           - this delimiter\
    \ might not be properly closed...\n...\n92  | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n102 | }\n    |   ^\n\nerror: expected\
    \ `{`, found `}`\n  --> /tmp/tmpv0xf2wcf.rs:92:1\n   |\n91 |         if num >\
    \ max_value \n   |         -- this `if` expression has a condition, but no block\n\
    92 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv0xf2wcf.rs:19:9\n\
    \   |\n19 |     for &num in nums_copy {\n   |         ^^^^    --------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpv0xf2wcf.rs:48:9\n   |\n48 |   \
    \  for &num in nums_copy {\n   |         ^^^^    --------- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv0xf2wcf.rs:77:9\n   |\n77 |     for &num in\
    \ nums_copy {\n   |         ^^^^    --------- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `num`\n   |\n   = note: \
    \  expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpv0xf2wcf.rs:8:41\n  |\n8 | fn order_by_points(nums: Vec<isize>)\
    \ -> Vec<isize> {\n  |    ---------------                      ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `re"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = nums.iter().min().unwrap();\n    let mut\
    \ max_sum = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min_by_key(|&x|\
    \ x).unwrap();\n    let mut max_idx = nums.iter().max_by_key(|&x| x).unwrap();\n\
    \    while nums_copy.len() > 0 {\n        let mut idx = nums_copy.iter().position(|&x|\
    \ x > 0).unwrap();\n        if sum < nums_copy[idx] {\n            sum += nums_copy[idx];\n\
    \            min_sum = min_sum < nums_copy[idx] ? min_sum : nums_copy[idx];\n\
    \            min_idx = min_idx < idx ? min_idx : idx;\n        }\n        else\
    \ {\n            sum -= nums_copy[idx];\n            max_sum = max_sum > nums_copy[idx]\
    \ ? max_sum : nums_copy[idx];\n            max_idx = max_idx > idx ? max_idx :\
    \ idx;\n        }\n        nums_copy.remove(&idx);\n    }\n    if min_sum < max_sum\
    \ {\n        nums.swap_remove(min_idx, max_idx);\n    }\n    nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `min_sum`\n\
    \  --> /tmp/tmpgy6iy47k.rs:19:50\n   |\n19 |             min_sum = min_sum < nums_copy[idx]\
    \ ? min_sum : nums_copy[idx];\n   |                                          \
    \        ^^^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror:\
    \ expected one of `.`, `;`, `?`, `}`, or an operator, found `max_sum`\n  --> /tmp/tmpgy6iy47k.rs:24:50\n\
    \   |\n24 |             max_sum = max_sum > nums_copy[idx] ? max_sum : nums_copy[idx];\n\
    \   |                                                  ^^^^^^^ expected one of\
    \ `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpgy6iy47k.rs:27:26\n   |\n27 |         nums_copy.remove(&idx);\n   |\
    \                          ^^^^ expected `usize`, found `&usize`\n   |\nhelp:\
    \ consider removing the borrow\n   |\n27 -         nums_copy.remove(&idx);\n27\
    \ +         nums_copy.remove(idx);\n   | \n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n    --> /tmp/tmpgy6iy47k.rs:30:14\n\
    \     |\n30   |         nums.swap_remove(min_idx, max_idx);\n     |          \
    \    ^^^^^^^^^^^ -------  ------- supplied 2 arguments\n     |              |\n\
    \     |              expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for &n in &nums_copy {\n            sum\
    \ += *n as isize;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp67_7ek7n.rs:13:20\n\
    \   |\n13 |             sum += *n as isize;\n   |                    ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = 0;\n    let mut min_idx = nums.len();\n\
    \    for &i in nums_copy {\n        sum += i;\n        if sum < min_sum {\n  \
    \          min_sum = sum;\n            min_idx = i;\n        }\n    }\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.sort_unstable();\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg40uiwuj.rs:13:9\n   |\n\
    13 |     for &i in nums_copy {\n   |         ^^    --------- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1; // skip the digit we just\
    \ added\n        while index < nums_copy.len() {\n            let digit = nums_copy[index];\n\
    \            if digit < 0 {\n                nums_copy[index] = -digit;\n    \
    \            sum += -digit;\n                break;\n            }\n         \
    \   sum += digit;\n            index += 1; // skip the digit we just added\n \
    \       }\n        if sum < 0 {\n            nums_copy = nums_copy.iter().rev().collect();\n\
    \            sum = 0;\n        }\n    }\n    nums_copy.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmpp2r81yp1.rs:26:48\n     |\n\
    26   |             nums_copy = nums_copy.iter().rev().collect();\n     |     \
    \                                           ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in &mut sorted_nums {\n         \
    \   sum += *x;\n        }\n        sum\n    });\n    sorted_nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp2a0e8rk6.rs:10:30\n   |\n\
    10 |     sorted_nums.sort_by_key(|x| {\n   |                              ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0499]: cannot borrow `sorted_nums`\
    \ as mutable more than once at a time\n  --> /tmp/tmp2a0e8rk6.rs:10:29\n   |\n\
    10 |       sorted_nums.sort_by_key(|x| {\n   |       -           ----------- ^^^\
    \ second mutable borrow occurs here\n   |       |           |\n   |  _____|  \
    \         first borrow later used by call\n   | |\n11 | |         let mut sum\
    \ = 0;\n12 | |         for x in &mut sorted_nums {\n   | |                   \
    \    ----------- second borrow occurs due to use of `sorted_nums` in closure\n\
    13 | |             sum += *x;\n14 | |         }\n15 | |         sum\n16 | |  \
    \   });\n   | |______- first mutable borrow occurs here\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0499`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for &i in nums_sorted {\n        sum += i;\n    }\n    nums_sorted.sort_by_key(|&i|\
    \ {\n        sum - i;\n    });\n    nums_sorted\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv3lrkxyo.rs:11:9\n   |\n\
    11 |     for &i in nums_sorted {\n   |         ^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut index = 0;\n\
    \    while nums_copy.len() > 0 {\n        sum += nums_copy.pop().unwrap();\n \
    \       if sum < 0 {\n            sum = 0;\n        }\n        if index == nums_sorted.len()\
    \ {\n            nums_sorted.push(nums_copy.pop().unwrap());\n        }\n    \
    \    index += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpwlgsv9nf.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ *x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmppa1lrv9x.rs:13:20\n\
    \   |\n13 |             sum += *x;\n   |                    ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    let mut nums_copy\
    \ = nums_copy.clone();\n    nums_copy.sort();\n    let mut index = 0;\n    while\
    \ index < nums_copy.len() {\n        nums_copy[index] -= sum;\n        index +=\
    \ 1;\n    }\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 11, 13, 23]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpwcp9b0f9.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for &d in &nums_copy {\n            sum\
    \ += d;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n  \
    \  let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpq1168qom.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0502]: cannot borrow `nums_copy`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpq1168qom.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -         -----------\
    \ ^^^ immutable borrow occurs here\n   |       |         |\n   |  _____|     \
    \    mutable borrow later used by call\n   | |\n11 | |         let mut sum = 0;\n\
    12 | |         for &d in &nums_copy {\n   | |                    --------- second\
    \ borrow occurs due to use of `nums_copy` in closure\n13 | |             sum +=\
    \ d;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- mutable\
    \ borrow occurs here\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for &d in &nums_copy {\n            sum\
    \ += *d;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n \
    \   let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpg28p6e_x.rs:13:20\n\
    \   |\n13 |             sum += *d;\n   |                    ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by(|a, b| {\n        let mut sum\
    \ = 0;\n        for &n in &[a, b] {\n            sum += *n as isize;\n       \
    \ }\n        sum\n    });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp45d4igb8.rs:14:9\n   |\n\
    14 |         sum\n   |         ^^^ expected enum `std::cmp::Ordering`, found `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp9qk3jssn.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmp9qk3jssn.rs:12:18\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n10  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n13  | |             sum += x;\n14  | |\
    \         }\n15  | |         sum\n16  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmp9qk3jssn.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n11 | |    \
    \     let mut sum = 0;\n12 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n13 | |             sum +=\
    \ x;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmp9qk3jssn.rs:17:5\n   |\n9  |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums = nums.clone();\n    let mut sum\
    \ = 0;\n    let mut max_sum = 0;\n    let mut min_sum = 0;\n    let mut min_idx\
    \ = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx\
    \ = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx\
    \ = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx\
    \ = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx\
    \ = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx\
    \ = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx\
    \ = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx\
    \ = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx\
    \ = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx\
    \ = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx\
    \ = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx\
    \ = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx\
    \ = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx\
    \ = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx\
    \ = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx\
    \ = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx\
    \ = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx\
    \ = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx\
    \ = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx\
    \ = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx\
    \ = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx\
    \ = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx\
    \ = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpd526sj1o.rs:8:41\n  |\n8 |\
    \ fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n  |    ---------------\
    \                      ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for &n in nums_sorted {\n        sum += n;\n    }\n    nums_sorted.sort_by_key(|&n|\
    \ {\n        sum - n\n    });\n    nums_sorted\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpabrf_j4q.rs:11:9\n   |\n\
    11 |     for &n in nums_sorted {\n   |         ^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `n`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut max_sum =\
    \ 0;\n    let mut min_sum = std::i32::MAX;\n    let mut min_idx = -1;\n    let\
    \ mut max_idx = -1;\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n   \
    \ let mut min_val = std::i32::MAX;\n    let mut max_val = std::i32::MIN;\n   \
    \ let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    let mut min_idx = -1;\n    let mut\
    \ max_idx = -1;\n    let mut min_val = std::i32::MAX;\n    let mut max_val = std::i32::MIN;\n\
    \    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    let mut min_idx = -1;\n    let mut\
    \ max_idx = -1;\n    let mut min_val = std::i32::MAX;\n    let mut max_val = std::i32::MIN;\n\
    \    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    let mut min_idx = -1;\n    let mut\
    \ max_idx = -1;\n    let mut min_val = std::i32::MAX;\n    let mut max_val = std::i32::MIN;\n\
    \    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    let mut min_idx = -1;\n    let mut\
    \ max_idx = -1;\n    let mut min_val = std::i32::MAX;\n    let mut max_val = std::i32::MIN;\n\
    \    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    let mut min_idx = -1;\n    let mut\
    \ max_idx = -1;\n    let mut min_val = std::i32::MAX;\n    let mut max_val = std::i32::MIN;\n\
    \    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7kz2yy5q.rs:8:41\n  |\n8 |\
    \ fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n  |    ---------------\
    \                      ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums = nums.clone();\n    let mut sum\
    \ = 0;\n    let mut index = 0;\n    while index < nums.len() {\n        sum +=\
    \ nums[index];\n        index += 1; // skip the digit to compare with next one\n\
    \    }\n    nums.sort_by_key(|x| {\n        sum - x.to_digits() as isize\n   \
    \ });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp92t653_y.rs:17:17\n   |\n17 |         sum\
    \ - x.to_digits() as isize\n   |                 ^^^^^^^^^ method not found in\
    \ `&isize`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1; // skip the digit to sum\n\
    \        while index < nums_copy.len() {\n            if nums_copy[index] == 0\
    \ {\n                nums_copy[index] = nums_copy[index - 1];\n              \
    \  nums_copy[index - 1] = 0;\n                index -= 1;\n            } else\
    \ {\n                break;\n            }\n        }\n    }\n    nums_copy.sort();\n\
    \    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-12, -11, -1, 1, 11]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp7n2sbp08.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums_copy.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_sorted.len() {\n        sum += nums_sorted[index];\n\
    \        if sum < 0 {\n            sum = 0;\n        }\n        if sum > 0 {\n\
    \            nums_sorted.swap(index, index + 1);\n            index += 1;\n  \
    \      }\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 5 but the index\
    \ is 5', /tmp/tmpba8gle7n.rs:19:25\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_unstable_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for &n in &nums_copy {\n            sum\
    \ += *n as isize;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpmpfgifo0.rs:13:20\n\
    \   |\n13 |             sum += *n as isize;\n   |                    ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut max_sum = 0;\n    let mut min_sum = 0;\n    let mut\
    \ max_index = -1;\n    let mut min_index = -1;\n    let mut max_value = nums_copy[0];\n\
    \    let mut min_value = nums_copy[0];\n    let mut max_index = -1;\n    let mut\
    \ min_index = -1;\n    let mut max_value = nums_copy[0];\n    let mut min_value\
    \ = nums_copy[0];\n    for &i in nums_copy {\n        sum += i;\n        if sum\
    \ > max_sum {\n            max_sum = sum;\n            max_index = i;\n      \
    \  }\n        if sum < min_sum {\n            min_sum = sum;\n            min_index\
    \ = i;\n        }\n    }\n    let mut nums_copy = nums.clone();\n    let mut sum\
    \ = 0;\n    let mut max_sum = 0;\n    let mut min_sum = 0;\n    let mut max_index\
    \ = -1;\n    let mut min_index = -1;\n    let mut max_value = nums_copy[0];\n\
    \    let mut min_value = nums_copy[0];\n    let mut max_index = -1;\n    let mut\
    \ min_index = -1;\n    let mut max_value = nums_copy[0];\n    let mut min_value\
    \ = nums_copy[0];\n    for &i in nums_copy {\n        sum += i;\n        if sum\
    \ > max_sum {\n            max_sum = sum;\n            max_index = i;\n      \
    \  }\n        if sum < min_sum {\n            min_sum = sum;\n            min_index\
    \ = i;\n        }\n    }\n    let mut nums_copy = nums.clone();\n    let mut sum\
    \ = 0;\n    let mut max_sum = 0;\n    let mut min_sum = 0;\n    let mut max_index\
    \ = -1;\n    let mut min_index = -1;\n    let mut max_value = nums_copy[0];\n\
    \    let mut min_value = nums_copy[0];\n    let mut max_index = -1;\n    let mut\
    \ min_index = -1;\n    let mut max_value = nums_copy[0];\n    let mut min_value\
    \ = nums_copy[0];\n    for &i in nums_copy {\n        sum += i;\n        if sum\
    \ > max_sum {\n            max_sum = sum;\n            max_index = i;\n      \
    \  }\n        if sum < min_sum {\n            min_sum = sum;\n            min_index\
    \ = i;\n        }\n    }\n    let mut nums_copy = nums.clone();\n    let mut sum\
    \ = 0;\n    let mut max_sum = 0;\n    let mut min_sum = 0;\n    let mut max_index\
    \ = -1;\n    let mut min_index = -1;\n    let mut max_value = nums_copy[0];\n\
    \    let mut min_value = nums_copy[0];\n    let mut max_\n}\n\nfn main() {\n \
    \   let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpe62mm8zq.rs:86:17\n   |\n\
    86 |     let mut max_\n   |                 ^ help: add `;` here\n87 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe62mm8zq.rs:21:9\n\
    \   |\n21 |     for &i in nums_copy {\n   |         ^^    --------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpe62mm8zq.rs:44:9\n   |\n44 |   \
    \  for &i in nums_copy {\n   |         ^^    --------- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe62mm8zq.rs:67:9\n   |\n67 |     for &i in nums_copy\
    \ {\n   |         ^^    --------- this expression has type `Option<isize>`\n \
    \  |         |\n   |         expected `isize`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpe62mm8zq.rs:8:41\n  |\n8 | fn order_by_points(nums: Vec<isize>)\
    \ -> Vec<isize> {\n  |    ---------------                      ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 5 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x.to_digits().unwrap().sum()\n    });\n    nums_copy\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpf2_60jfh.rs:17:17\n   |\n17 |         sum\
    \ - x.to_digits().unwrap().sum()\n   |                 ^^^^^^^^^ method not found\
    \ in `&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for i in nums_sorted.iter() {\n        sum += *i;\n      \
    \  nums_sorted.swap(i, nums_sorted.iter().position(|&x| x > sum).unwrap());\n\
    \    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp975_q52r.rs:13:26\n   |\n\
    13 |         nums_sorted.swap(i, nums_sorted.iter().position(|&x| x > sum).unwrap());\n\
    \   |                          ^ expected `usize`, found `&isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut nums_sorted_by_sum: Vec<isize>\
    \ = nums.clone();\n    let mut nums_sorted_by_sum_by_index: Vec<isize> = nums.clone();\n\
    \    let mut nums_sorted_by_sum_by_index: Vec<isize> = nums.clone();\n    let\
    \ mut nums_sorted_by_sum_by_index: Vec<isize> = nums.clone();\n    let mut nums_sorted_by_sum_by_index:\
    \ Vec<isize> = nums.clone();\n    let mut nums_sorted_by_sum_by_index: Vec<isize>\
    \ = nums.clone();\n    let mut nums_sorted_by_sum_by_index: Vec<isize> = nums.clone();\n\
    \    let mut nums_sorted_by_sum_by_index: Vec<isize> = nums.clone();\n    let\
    \ mut nums_sorted_by_sum_by_index: Vec<isize> = nums.clone();\n    let mut nums_sorted_by_sum_by_index:\
    \ Vec<isize> = nums.clone();\n    let mut nums_sorted_by_sum_by_index: Vec<isize>\
    \ = nums.clone();\n    let mut nums_sorted_by_sum_by_index: Vec<isize> = nums.clone();\n\
    \    let mut nums_sorted_by_sum_by_index: Vec<isize> = nums.clone();\n    let\
    \ mut nums_sorted_by_sum_by_index: Vec<isize> = nums.clone();\n    let mut nums_sorted_by_sum_by_index:\
    \ Vec<isize> = nums.clone();\n    let mut nums_sorted_by_sum_by_index: Vec<isize>\
    \ = nums.clone();\n    let mut nums_sorted_by_sum_by_index: Vec<isize> = nums.clone();\n\
    \    let mut nums_sorted_by_sum_by_index: Vec<isize> = nums.clone();\n    let\
    \ mut nums_sorted_by_sum_by_index: Vec<isize> = nums.clone();\n    let mut nums_sorted_by_sum_by_index:\
    \ Vec<isize> = nums.clone();\n    let mut nums_sorted_by_sum_by_index: Vec<isize>\
    \ = nums.clone();\n    let mut nums_sorted_by_sum_by_index: Vec<isize> = nums.clone();\n\
    \    let mut nums_sorted_by_sum_by_index: Vec<isize> = nums.clone();\n    let\
    \ mut nums_sorted_by_sum_by_index: Vec<isize> = nums.clone();\n    let mut nums_sorted_by_sum_by_index:\
    \ Vec<\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `>`, a const expression, lifetime, or type, found\
    \ `}`\n  --> /tmp/tmp6ic3zoiu.rs:36:1\n   |\n35 |     let mut nums_sorted_by_sum_by_index:\
    \ Vec<\n   |         -------------------------------      - expected one of `>`,\
    \ a const expression, lifetime, or type\n   |         |\n   |         while parsing\
    \ the type for `mut nums_sorted_by_sum_by_index`\n36 | }\n   | ^ unexpected token\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x.digits().sum::<usize>()\n    });\n    nums_copy\n}\n\nfn\
    \ main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpmyfyr8x0.rs:17:17\n   |\n17 |         sum -\
    \ x.digits().sum::<usize>()\n   |                 ^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_unstable_by_key(|x|\
    \ {\n        x.checked_mul(10).ok_or(\"invalid number\")\n    });\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-12, -11, -1, 1, 11]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpfqrd3hvi.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = nums_copy.len();\n    let mut min_idx =\
    \ nums_copy.len();\n    let mut min_val = nums_copy[0];\n    for &i in nums_copy\
    \ {\n        sum += i;\n        if sum < min_sum {\n            min_sum = sum;\n\
    \            min_idx = i;\n            min_val = i;\n        }\n    }\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(0);\n    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(0);\n\
    \    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(0);\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(0);\n    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(0);\n\
    \    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(0);\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(0);\n    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(0);\n\
    \    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(0);\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(0);\n    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(0);\n\
    \    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(0);\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(0);\n    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(0);\n\
    \    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(0);\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(0);\n    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(0);\n\
    \    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(0);\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(0);\n    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(0);\n\
    \    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(0);\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(0);\n    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(0);\n\
    \    nums_copy.swap_remove(min_idx);\n    nums_copy.swap_remove(0);\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(0);\n    nums_copy.\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp9qi2q7fz.rs:73:1\n   |\n73\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9qi2q7fz.rs:14:9\n\
    \   |\n14 |     for &i in nums_copy {\n   |         ^^    --------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9qi2q7fz.rs:19:23\n   |\n13 |  \
    \   let mut min_val = nums_copy[0];\n   |                       ------------ expected\
    \ due to this value\n...\n19 |             min_val = i;\n   |                \
    \       ^ expected `isize`, found `usize`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for &n in &nums_sorted {\n        sum += n;\n    }\n    nums_sorted.sort_by_key(|&n|\
    \ {\n        sum.partial_cmp(&n)\n    });\n    nums_sorted\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpaj12z9bw.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x.to_digits().unwrap().sum()\n    });\n    nums_copy\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpthx9bo02.rs:17:17\n   |\n17 |         sum\
    \ - x.to_digits().unwrap().sum()\n   |                 ^^^^^^^^^ method not found\
    \ in `&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x;\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp6a3x3v_b.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp9zv_0ib3.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmp9zv_0ib3.rs:12:18\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n10  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n13  | |             sum += x;\n14  | |\
    \         }\n15  | |         sum\n16  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmp9zv_0ib3.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n11 | |    \
    \     let mut sum = 0;\n12 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n13 | |             sum +=\
    \ x;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmp9zv_0ib3.rs:17:5\n   |\n9  |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_unstable_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for &n in &nums_copy {\n            sum\
    \ += *n as isize;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpd9tprnr6.rs:13:20\n\
    \   |\n13 |             sum += *n as isize;\n   |                    ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut max_sum =\
    \ 0;\n    let mut min_sum = std::i32::MAX;\n    let mut max_index = -1;\n    let\
    \ mut min_index = -1;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mut max_value\
    \ = std::i32::MIN;\n    let mut min_value = std::i32::MAX;\n    let mu\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo_fti00b.rs:57:11\n   |\n\
    57 |     let mu\n   |           ^ help: add `;` here\n58 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpo_fti00b.rs:8:41\n  |\n\
    8 | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n  |    ---------------\
    \                      ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1; // skip the digit already\
    \ processed\n        if sum < 0 {\n            sum = 0;\n            index -=\
    \ 1;\n        }\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x.digits().sum::<isize>()\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpdv00ye0b.rs:21:17\n   |\n21 |         sum -\
    \ x.digits().sum::<isize>()\n   |                 ^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for &i in nums_sorted {\n        sum += i;\n    }\n    nums_sorted.sort_by_key(|&i|\
    \ {\n        sum - i;\n    });\n    nums_sorted\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpehtf7eyz.rs:11:9\n   |\n\
    11 |     for &i in nums_sorted {\n   |         ^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    for &num in nums_copy {\n        sum += num;\n    }\n    let\
    \ mut nums_sorted = nums_copy.clone();\n    let mut i = 0;\n    while i < nums_sorted.len()\
    \ {\n        let mut j = i;\n        while j < nums_sorted.len() && sum < nums_sorted[j]\
    \ {\n            sum += nums_sorted[j];\n            j += 1;\n        }\n    \
    \    if j == nums_sorted.len() {\n            nums_sorted.push(nums_sorted[i]);\n\
    \            nums_sorted.pop();\n        } else {\n            nums_sorted[i]\
    \ = nums_sorted[j];\n            nums_sorted.swap(i, j);\n        }\n        i\
    \ += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo8qiitfm.rs:11:9\n   |\n\
    11 |     for &num in nums_copy {\n   |         ^^^^    --------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1; // skip the element which\
    \ already has sum\n    }\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        let mut index = 0;\n        while index\
    \ < nums_copy.len() {\n            sum += nums_copy[index];\n            index\
    \ += 1; // skip the element which already has sum\n        }\n        sum\n  \
    \  });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpnoatip59.rs:17:28\n   |\n\
    17 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nwarning: variable `sum` is assigned\
    \ to, but never used\n  --> /tmp/tmpnoatip59.rs:10:13\n   |\n10 |     let mut\
    \ sum = 0;\n   |             ^^^\n   |\n   = note: consider using `_sum` instead\n\
    \nwarning: variable does not need to be mutable\n --> /tmp/tmpnoatip59.rs:9:9\n\
    \  |\n9 |     let mut nums_copy = nums.clone();\n  |         ----^^^^^^^^^\n \
    \ |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_copy` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpnoatip59.rs:17:27\n   |\n17 |\
    \       nums_copy.sort_by_key(|x| {\n   |       -         ----------- ^^^ immutable\
    \ borrow occurs here\n   |       |         |\n   |  _____|         mutable borrow\
    \ later used by call\n   | |\n18 | |         let mut sum = 0;\n19 | |        \
    \ let mut index = 0;\n20 | |         while index < nums_copy.len() {\n   | | \
    \                      --------- second borrow occurs due to use of `nums_copy`\
    \ in closure\n...  |\n24 | |         sum\n25 | |     });\n   | |______- mutable\
    \ borrow occurs here\n\nerror: aborting due to previous error; 3 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by_key(|x| {\n        let mut sum\
    \ = 0;\n        for &n in &nums {\n            sum += n.digits();\n        }\n\
    \        sum\n    });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp6oakkdem.rs:12:22\n   |\n12 |             sum += n.digits();\n\
    \   |                      ^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        let digit = nums_copy[index].checked_sub(10).unwrap();\n        sum +=\
    \ digit;\n        if sum > 0 {\n            break;\n        }\n        index +=\
    \ 1; // skip the digit to compare with the next one\n    }\n    nums_copy.sort_by_key(|x|\
    \ x.checked_sub(10).unwrap());\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-12, -11, -1, 1, 11]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp2lmmw9ra.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut index = 0;\n\
    \    while index < nums_copy.len() {\n        sum += nums_copy[index];\n     \
    \   if sum < 0 {\n            sum = 0;\n            index += 1;\n        } else\
    \ {\n            nums_sorted.swap(index, nums_sorted.iter().position(|&x| x ==\
    \ sum).unwrap());\n            index += 1;\n        }\n    }\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpvzenk_vy.rs:9:9\n\
    \  |\n9 |     let mut nums_copy = nums.clone();\n  |         ----^^^^^^^^^\n \
    \ |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpvzenk_vy.rs:19:37\n   |\n19 |\
    \             nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |             ------------------------^^^^^^^^^^^^^^^^^^----------------------------------\n\
    \   |             |           |           |\n   |             |           |  \
    \         immutable borrow occurs here\n   |             |           mutable borrow\
    \ later used by call\n   |             mutable borrow occurs here\n   |\nhelp:\
    \ try adding a local storing this argument...\n  --> /tmp/tmpvzenk_vy.rs:19:37\n\
    \   |\n19 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n   |                                     ^^^^^^^^^^^^^^^^^^\n\
    help: ...and then using that local as the argument to this call\n  --> /tmp/tmpvzenk_vy.rs:19:13\n\
    \   |\n19 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut min_sum =\
    \ nums.iter().fold(0, |sum, num| sum + num);\n    let mut max_sum = nums.iter().fold(0,\
    \ |sum, num| sum + num);\n    let mut min_num = nums.iter().fold(0, |sum, num|\
    \ sum + num);\n    let mut max_num = nums.iter().fold(0, |sum, num| sum + num);\n\
    \    let mut min_idx = nums.iter().fold(0, |sum, num| sum + num);\n    let mut\
    \ max_idx = nums.iter().fold(0, |sum, num| sum + num);\n    let mut min_idx =\
    \ nums.iter().fold(0, |sum, num| sum + num);\n    let mut max_idx = nums.iter().fold(0,\
    \ |sum, num| sum + num);\n    let mut min_idx = nums.iter().fold(0, |sum, num|\
    \ sum + num);\n    let mut max_idx = nums.iter().fold(0, |sum, num| sum + num);\n\
    \    let mut min_idx = nums.iter().fold(0, |sum, num| sum + num);\n    let mut\
    \ max_idx = nums.iter().fold(0, |sum, num| sum + num);\n    let mut min_idx =\
    \ nums.iter().fold(0, |sum, num| sum + num);\n    let mut max_idx = nums.iter().fold(0,\
    \ |sum, num| sum + num);\n    let mut min_idx = nums.iter().fold(0, |sum, num|\
    \ sum + num);\n    let mut max_idx = nums.iter().fold(0, |sum, num| sum + num);\n\
    \    let mut min_idx = nums.iter().fold(0, |sum, num| sum + num);\n    let mut\
    \ max_idx = nums.iter().fold(0, |sum, num| sum + num);\n    let mut min_idx =\
    \ nums.iter().fold(0, |sum, num| sum + num);\n    let mut max_idx = nums.iter().fold(0,\
    \ |sum, num| sum + num);\n    let mut min_idx = nums.iter().fold(0, |sum, num|\
    \ sum + num);\n    let mut max_idx = nums.iter().fold(0, |sum, num| sum + num);\n\
    \    let \n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpam2j13nv.rs:35:1\n  \
    \ |\n35 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for num in nums_sorted {\n        sum += num;\n    }\n   \
    \ nums_sorted.sort_by_key(|num| {\n        sum.partial_cmp(&num).unwrap()\n  \
    \  });\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `nums_sorted`\n   --> /tmp/tmp2ffbtx65.rs:14:5\n\
    \    |\n9   |       let mut nums_sorted = nums.clone();\n    |           ---------------\
    \ move occurs because `nums_sorted` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n10  |       let mut sum = 0;\n11  |       for num in nums_sorted\
    \ {\n    |                  ----------- `nums_sorted` moved due to this implicit\
    \ call to `.into_iter()`\n...\n14  | /     nums_sorted.sort_by_key(|num| {\n15\
    \  | |         sum.partial_cmp(&num).unwrap()\n16  | |     });\n    | |______^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `nums_sorted`\nhelp: consider iterating over\
    \ a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n11  |     for num in &nums_sorted {\n    |                +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = 0;\n    let mut min_idx = -1;\n    let mut\
    \ max_idx = -1;\n    let mut max_sum = 0;\n    let mut min_idx = -1;\n    for\
    \ &i in nums_copy {\n        sum += i;\n        if sum < min_sum {\n         \
    \   min_sum = sum;\n            min_idx = i;\n        }\n        if sum > max_sum\
    \ {\n            max_sum = sum;\n            max_idx = i;\n        }\n    }\n\
    \    nums_copy.sort_by_key(|&i| {\n        let mut sum = 0;\n        for &j in\
    \ nums_copy {\n            sum += j;\n            if i == j {\n              \
    \  return i;\n            }\n        }\n        sum\n    });\n    nums_copy[min_idx..max_idx].cloned()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp09u6du0k.rs:16:9\n   |\n\
    16 |     for &i in nums_copy {\n   |         ^^    --------- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp09u6du0k.rs:29:13\n   |\n29 |         for &j\
    \ in nums_copy {\n   |             ^^    --------- this expression has type `Option<isize>`\n\
    \   |             |\n   |             expected `isize`, found reference\n   |\
    \             help: you can probably remove the explicit borrow: `j`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp09u6du0k.rs:13:23\n\
    \   |\n13 |     let mut max_idx = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmp09u6du0k.rs:15:23\n   |\n15 | \
    \    let mut min_idx = -1;\n   |                       ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0599]: `[isize]` is not an\
    \ iterator\n  --> /tmp/tmp09u6du0k.rs:37:33\n   |\n37 |     nums_copy[min_idx..max_idx].cloned()\n\
    \   |                                 ^^^^^^ `[isize]` is not an iterator; try\
    \ calling `.into_iter()` or `.iter()`\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `[isize]: Iterator`\n           which is required\
    \ by `&mut [isize]: Iterator`\n\nerror: abor"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    let mut min_sum = 0;\n    while index\
    \ < nums_copy.len() {\n        sum += nums_copy[index];\n        if sum < min_sum\
    \ {\n            min_sum = sum;\n        }\n        index += 1;\n    }\n    let\
    \ mut result = Vec::new();\n    while index < nums_copy.len() {\n        let mut\
    \ index = index;\n        while index < nums_copy.len() {\n            if nums_copy[index]\
    \ == 0 {\n                index += 1;\n                continue;\n           \
    \ }\n            break;\n        }\n        result.push(nums_copy[index]);\n \
    \       index += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpfhxtbq1j.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1; // skip the digit to compare\
    \ with next one\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x;\n  \
    \  });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpddo321z_.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ *x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpn54p6_0t.rs:13:20\n\
    \   |\n13 |             sum += *x;\n   |                    ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_unstable_by_key(|x|\
    \ {\n        x.checked_mul(10).ok_or(\"Invalid number\")\n    });\n    nums_copy\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-12, -11, -1, 1, 11]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpqn7a747n.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums_copy.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \        index += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpmd29hwel.rs:9:9\n\
    \  |\n9 |     let mut nums_copy = nums.clone();\n  |         ----^^^^^^^^^\n \
    \ |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpmd29hwel.rs:15:33\n   |\n15 |\
    \         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |         ------------------------^^^^^^^^^^^^^^^^^^----------------------------------\n\
    \   |         |           |           |\n   |         |           |          \
    \ immutable borrow occurs here\n   |         |           mutable borrow later\
    \ used by call\n   |         mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpmd29hwel.rs:15:33\n   |\n15\
    \ |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmpmd29hwel.rs:15:9\n  \
    \ |\n15 |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x ==\
    \ sum).unwrap());\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for num in nums_sorted {\n        sum += num;\n    }\n   \
    \ let mut index = 0;\n    while index < nums_sorted.len() {\n        let mut cur\
    \ = nums_sorted[index];\n        let mut next = nums_sorted[index + 1];\n    \
    \    while cur + next > sum {\n            nums_sorted.swap(index + 1, index);\n\
    \            sum += nums_sorted[index + 1];\n            index += 1;\n       \
    \ }\n        index += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp9_zy1pj2.rs:16:13\n\
    \   |\n16 |         let mut cur = nums_sorted[index];\n   |             ----^^^\n\
    \   |             |\n   |             help: remove this `mut`\n   |\n   = note:\
    \ `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be\
    \ mutable\n  --> /tmp/tmp9_zy1pj2.rs:17:13\n   |\n17 |         let mut next =\
    \ nums_sorted[index + 1];\n   |             ----^^^^\n   |             |\n   |\
    \             help: remove this `mut`\n\nerror[E0382]: borrow of moved value:\
    \ `nums_sorted`\n   --> /tmp/tmp9_zy1pj2.rs:15:19\n    |\n9   |     let mut nums_sorted\
    \ = nums.clone();\n    |         --------------- move occurs because `nums_sorted`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n10  |    \
    \ let mut sum = 0;\n11  |     for num in nums_sorted {\n    |                -----------\
    \ `nums_sorted` moved due to this implicit call to `.into_iter()`\n...\n15  |\
    \     while index < nums_sorted.len() {\n    |                   ^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `nums_sorted`\nhelp: consider iterating over\
    \ a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n11  |     for num in &nums_sorted {\n    |                +\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by_key(|x| {\n        let mut sum\
    \ = 0;\n        for &n in &nums {\n            sum += *n as isize;\n        }\n\
    \        sum\n    });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp08q49heu.rs:12:20\n\
    \   |\n12 |             sum += *n as isize;\n   |                    ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut max_sum = 0;\n    let mut min_sum = 0;\n    let mut\
    \ max_index = -1;\n    let mut min_index = -1;\n    let mut min_value = nums_copy[0];\n\
    \    let mut max_value = nums_copy[0];\n    for &num in nums_copy {\n        sum\
    \ += num;\n        if sum > max_sum {\n            max_sum = sum;\n          \
    \  max_index = num;\n        }\n        if sum < min_sum {\n            min_sum\
    \ = sum;\n            min_index = num;\n        }\n    }\n    if max_sum < min_sum\
    \ {\n        let mut temp = max_index;\n        max_index = min_index;\n     \
    \   min_index = temp;\n    }\n    let mut result = vec![];\n    let mut i = 0;\n\
    \    while i < nums.len() {\n        let num = nums[i];\n        if num == max_index\
    \ {\n            result.push(max_value);\n            i += 1;\n        } else\
    \ if num == min_index {\n            result.push(min_value);\n            i +=\
    \ 1;\n        } else {\n            result.push(num);\n            i += 1;\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt5ye_5gc.rs:17:9\n   |\n\
    17 |     for &num in nums_copy {\n   |         ^^^^    --------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for &d in &x {\n            sum += d as\
    \ isize;\n        }\n        sum\n    });\n    sorted_nums\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&&isize` is not an iterator\n  --> /tmp/tmpagnfu7rk.rs:12:19\n\
    \   |\n12 |         for &d in &x {\n   |                   ^^ `&&isize` is not\
    \ an iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&&isize`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    let mut nums_copy\
    \ = nums.clone();\n    nums_copy.sort_by_key(|x| {\n        sum - x.checked_mul(10).unwrap()\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 1, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp9krbp3m_.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1; // skip the digit\n   \
    \     while index < nums_copy.len() && sum > 0 {\n            sum += nums_copy[index];\n\
    \            index += 1; // skip the digit\n        }\n        if index == nums_copy.len()\
    \ {\n            break;\n        }\n        nums_copy.swap(index, nums_copy.len()\
    \ - 1);\n        index -= 1;\n    }\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `nums_copy` as immutable because it is also\
    \ borrowed as mutable\n  --> /tmp/tmpz1nqw7ak.rs:22:31\n   |\n22 |         nums_copy.swap(index,\
    \ nums_copy.len() - 1);\n   |         ----------------------^^^^^^^^^^^^^^^-----\n\
    \   |         |         |           |\n   |         |         |           immutable\
    \ borrow occurs here\n   |         |         mutable borrow later used by call\n\
    \   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing\
    \ this argument...\n  --> /tmp/tmpz1nqw7ak.rs:22:31\n   |\n22 |         nums_copy.swap(index,\
    \ nums_copy.len() - 1);\n   |                               ^^^^^^^^^^^^^^^\n\
    help: ...and then using that local as the argument to this call\n  --> /tmp/tmpz1nqw7ak.rs:22:9\n\
    \   |\n22 |         nums_copy.swap(index, nums_copy.len() - 1);\n   |        \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by(|a,\
    \ b| {\n        let mut a_digits = a.to_digits();\n        let mut b_digits =\
    \ b.to_digits();\n        a_digits.iter().zip(b_digits.iter()).fold(0, |sum, (a,\
    \ b)| *sum + a.checked_add(b).unwrap())\n    });\n    sorted_nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpptkc_f91.rs:11:30\n   |\n11 |         let\
    \ mut a_digits = a.to_digits();\n   |                              ^^^^^^^^^ method\
    \ not found in `&isize`\n\nerror[E0599]: no method named `to_digits` found for\
    \ reference `&isize` in the current scope\n  --> /tmp/tmpptkc_f91.rs:12:30\n \
    \  |\n12 |         let mut b_digits = b.to_digits();\n   |                   \
    \           ^^^^^^^^^ method not found in `&isize`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = 0;\n    let mut min_idx = nums.len();\n\
    \    let mut max_idx = nums.len();\n    let mut max_sum = 0;\n    for &i in nums_copy\
    \ {\n        sum += i;\n        if sum < min_sum {\n            min_sum = sum;\n\
    \            min_idx = i;\n        }\n        if sum > max_sum {\n           \
    \ max_sum = sum;\n            max_idx = i;\n        }\n    }\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(max_idx);\n    nums_copy.sort_unstable_by_key(|&i|\
    \ {\n        sum - i;\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp260sv8c9.rs:15:9\n   |\n\
    15 |     for &i in nums_copy {\n   |         ^^    --------- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp260sv8c9.rs:29:15\n   |\n29 |         sum -\
    \ i;\n   |               ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ subtract `isize` from `usize`\n  --> /tmp/tmp260sv8c9.rs:29:13\n   |\n29 | \
    \        sum - i;\n   |             ^ no implementation for `usize - isize`\n\
    \   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `Sub<Rhs>`:\n             <&'a\
    \ f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128\
    \ as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as\
    \ Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums {\n            sum += x;\n\
    \        }\n        sum\n    });\n    sorted_nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpdspbrpxx.rs:10:30\n   |\n\
    10 |     sorted_nums.sort_by_key(|x| {\n   |                              ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpdspbrpxx.rs:12:18\n\
    \    |\n8   |   fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    |  \
    \                    ---- captured outer variable\n9   |       let mut sorted_nums\
    \ = nums.clone();\n10  |       sorted_nums.sort_by_key(|x| {\n    |  _____________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums {\n    | |   \
    \               ^^^^\n    | |                  |\n    | |                  `nums`\
    \ moved due to this implicit call to `.into_iter()`\n    | |                 \
    \ move occurs because `nums` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n13  | |             sum += x;\n14  | |         }\n15  | |    \
    \     sum\n16  | |     });\n    | |_____- captured by this `FnMut` closure\n \
    \   |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n12  |         for x in &nums {\n\
    \    |                  +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut max_sum =\
    \ 0;\n    let mut max_index = 0;\n    let mut min_sum = 0;\n    let mut min_index\
    \ = 0;\n    for i in nums_copy.iter() {\n        sum += *i;\n        if sum >\
    \ max_sum {\n            max_sum = sum;\n            max_index = i;\n        }\n\
    \        if sum < min_sum {\n            min_sum = sum;\n            min_index\
    \ = i;\n        }\n    }\n    for i in nums_sorted.iter_mut() {\n        *i =\
    \ *max_index;\n    }\n    nums_sorted.swap_remove(min_index);\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7_1st2ca.rs:20:25\n   |\n\
    13 |     let mut max_index = 0;\n   |                         - expected due to\
    \ this value\n...\n20 |             max_index = i;\n   |                     \
    \    ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n20 |             max_index = *i;\n   |                       \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7_1st2ca.rs:24:25\n   |\n\
    15 |     let mut min_index = 0;\n   |                         - expected due to\
    \ this value\n...\n24 |             min_index = i;\n   |                     \
    \    ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n24 |             min_index = *i;\n   |                       \
    \  +\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp7_1st2ca.rs:28:14\n\
    \   |\n28 |         *i = *max_index;\n   |              ^^^^^^^^^^\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = nums.iter().min().unwrap();\n    let mut\
    \ max_sum = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = num\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp07uomqju.rs:46:26\n   |\n\
    46 |     let mut max_idx = num\n   |                          ^ help: add `;`\
    \ here\n47 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `num`\
    \ in this scope\n  --> /tmp/tmp07uomqju.rs:46:23\n   |\n46 |     let mut max_idx\
    \ = num\n   |                       ^^^ help: a local variable with a similar\
    \ name exists: `nums`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp07uomqju.rs:8:41\n\
    \  |\n8 | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n  |    ---------------\
    \                      ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    for &num in nums_copy {\n        sum += num;\n    }\n    nums_copy.sort_by_key(|&num|\
    \ {\n        sum - num\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb3pgh3fc.rs:11:9\n   |\n\
    11 |     for &num in nums_copy {\n   |         ^^^^    --------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for num in nums_sorted {\n        sum += num;\n    }\n   \
    \ nums_sorted.sort_by_key(|num| {\n        sum - num\n    });\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `nums_sorted`\n   --> /tmp/tmpulwlbs62.rs:14:5\n\
    \    |\n9   |       let mut nums_sorted = nums.clone();\n    |           ---------------\
    \ move occurs because `nums_sorted` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n10  |       let mut sum = 0;\n11  |       for num in nums_sorted\
    \ {\n    |                  ----------- `nums_sorted` moved due to this implicit\
    \ call to `.into_iter()`\n...\n14  | /     nums_sorted.sort_by_key(|num| {\n15\
    \  | |         sum - num\n16  | |     });\n    | |______^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `nums_sorted`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n11  |     for num in &nums_sorted\
    \ {\n    |                +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for num in nums_sorted {\n        sum += num;\n    }\n   \
    \ nums_sorted.sort_by_key(|num| {\n        sum.partial_cmp(num).unwrap()\n   \
    \ });\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `nums_sorted`\n   --> /tmp/tmp6_ny_ixo.rs:14:5\n\
    \    |\n9   |       let mut nums_sorted = nums.clone();\n    |           ---------------\
    \ move occurs because `nums_sorted` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n10  |       let mut sum = 0;\n11  |       for num in nums_sorted\
    \ {\n    |                  ----------- `nums_sorted` moved due to this implicit\
    \ call to `.into_iter()`\n...\n14  | /     nums_sorted.sort_by_key(|num| {\n15\
    \  | |         sum.partial_cmp(num).unwrap()\n16  | |     });\n    | |______^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `nums_sorted`\nhelp: consider iterating over\
    \ a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n11  |     for num in &nums_sorted {\n    |                +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x.to_digits(10)\n    });\n    nums_copy\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpaua4jhwk.rs:17:17\n   |\n17 |         sum\
    \ - x.to_digits(10)\n   |                 ^^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in &mut sorted_nums {\n         \
    \   sum += *x;\n        }\n        sum\n    });\n    sorted_nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmphmfk2az_.rs:10:30\n   |\n\
    10 |     sorted_nums.sort_by_key(|x| {\n   |                              ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0499]: cannot borrow `sorted_nums`\
    \ as mutable more than once at a time\n  --> /tmp/tmphmfk2az_.rs:10:29\n   |\n\
    10 |       sorted_nums.sort_by_key(|x| {\n   |       -           ----------- ^^^\
    \ second mutable borrow occurs here\n   |       |           |\n   |  _____|  \
    \         first borrow later used by call\n   | |\n11 | |         let mut sum\
    \ = 0;\n12 | |         for x in &mut sorted_nums {\n   | |                   \
    \    ----------- second borrow occurs due to use of `sorted_nums` in closure\n\
    13 | |             sum += *x;\n14 | |         }\n15 | |         sum\n16 | |  \
    \   });\n   | |______- first mutable borrow occurs here\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0499`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut index = 0;\n\
    \    while nums_copy.len() > 0 {\n        sum += nums_copy.remove(0);\n      \
    \  if sum < 0 {\n            sum = 0;\n        }\n        if index == nums_sorted.len()\
    \ {\n            nums_sorted.push(nums_copy.remove(0));\n        }\n        index\
    \ += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpnd88zw5m.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_unstable_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for &d in &nums_sorted {\n            sum\
    \ += d;\n        }\n        sum\n    });\n    nums_sorted\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmppgdo_obb.rs:10:39\n   |\n\
    10 |     nums_sorted.sort_unstable_by_key(|x| {\n   |                        \
    \               ^ help: if this is intentional, prefix it with an underscore:\
    \ `_x`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0502]:\
    \ cannot borrow `nums_sorted` as immutable because it is also borrowed as mutable\n\
    \  --> /tmp/tmppgdo_obb.rs:10:38\n   |\n10 |       nums_sorted.sort_unstable_by_key(|x|\
    \ {\n   |       -           -------------------- ^^^ immutable borrow occurs here\n\
    \   |       |           |\n   |  _____|           mutable borrow later used by\
    \ call\n   | |\n11 | |         let mut sum = 0;\n12 | |         for &d in &nums_sorted\
    \ {\n   | |                    ----------- second borrow occurs due to use of\
    \ `nums_sorted` in closure\n13 | |             sum += d;\n14 | |         }\n15\
    \ | |         sum\n16 | |     });\n   | |______- mutable borrow occurs here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in &mut sorted_nums {\n         \
    \   sum += *x;\n        }\n        sum\n    });\n    sorted_nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpyh0tlt8f.rs:10:30\n   |\n\
    10 |     sorted_nums.sort_by_key(|x| {\n   |                              ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0499]: cannot borrow `sorted_nums`\
    \ as mutable more than once at a time\n  --> /tmp/tmpyh0tlt8f.rs:10:29\n   |\n\
    10 |       sorted_nums.sort_by_key(|x| {\n   |       -           ----------- ^^^\
    \ second mutable borrow occurs here\n   |       |           |\n   |  _____|  \
    \         first borrow later used by call\n   | |\n11 | |         let mut sum\
    \ = 0;\n12 | |         for x in &mut sorted_nums {\n   | |                   \
    \    ----------- second borrow occurs due to use of `sorted_nums` in closure\n\
    13 | |             sum += *x;\n14 | |         }\n15 | |         sum\n16 | |  \
    \   });\n   | |______- first mutable borrow occurs here\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0499`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for num in nums_sorted {\n        sum += num;\n    }\n   \
    \ nums_sorted.sort_by_key(|num| {\n        sum - num\n    });\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `nums_sorted`\n   --> /tmp/tmp6z7jqyss.rs:14:5\n\
    \    |\n9   |       let mut nums_sorted = nums.clone();\n    |           ---------------\
    \ move occurs because `nums_sorted` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n10  |       let mut sum = 0;\n11  |       for num in nums_sorted\
    \ {\n    |                  ----------- `nums_sorted` moved due to this implicit\
    \ call to `.into_iter()`\n...\n14  | /     nums_sorted.sort_by_key(|num| {\n15\
    \  | |         sum - num\n16  | |     });\n    | |______^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `nums_sorted`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n11  |     for num in &nums_sorted\
    \ {\n    |                +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = 0;\n    let mut min_idx = nums.len();\n\
    \    for &i in nums_copy {\n        sum += i;\n        if sum < min_sum {\n  \
    \          min_sum = sum;\n            min_idx = i;\n        }\n    }\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.sort_unstable();\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv3t9sngw.rs:13:9\n   |\n\
    13 |     for &i in nums_copy {\n   |         ^^    --------- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for i in nums_sorted.iter() {\n        sum += *i;\n      \
    \  nums_sorted.swap(i, nums_sorted.iter().position(|&x| x > sum).unwrap());\n\
    \    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgftqdixb.rs:13:26\n   |\n\
    13 |         nums_sorted.swap(i, nums_sorted.iter().position(|&x| x > sum).unwrap());\n\
    \   |                          ^ expected `usize`, found `&isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp9yadhdwq.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmp9yadhdwq.rs:12:18\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n10  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n13  | |             sum += x;\n14  | |\
    \         }\n15  | |         sum\n16  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmp9yadhdwq.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n11 | |    \
    \     let mut sum = 0;\n12 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n13 | |             sum +=\
    \ x;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmp9yadhdwq.rs:17:5\n   |\n9  |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut max_sum =\
    \ 0;\n    let mut min_sum = 0;\n    let mut max_index = 0;\n    let mut min_index\
    \ = 0;\n    let mut max_point = 0;\n    let mut min_point = 0;\n    let mut max_point2\
    \ = 0;\n    let mut min_point2 = 0;\n    let mut max_point3 = 0;\n    let mut\
    \ min_point3 = 0;\n    let mut max_point4 = 0;\n    let mut min_point4 = 0;\n\
    \    let mut max_point5 = 0;\n    let mut min_point5 = 0;\n    let mut max_point6\
    \ = 0;\n    let mut min_point6 = 0;\n    let mut max_point7 = 0;\n    let mut\
    \ min_point7 = 0;\n    let mut max_point8 = 0;\n    let mut min_point8 = 0;\n\
    \    let mut max_point9 = 0;\n    let mut min_point9 = 0;\n    let mut max_point10\
    \ = 0;\n    let mut min_point10 = 0;\n    let mut max_point11 = 0;\n    let mut\
    \ min_point11 = 0;\n    let mut max_point12 = 0;\n    let mut min_point12 = 0;\n\
    \    let mut max_point13 = 0;\n    let mut min_point13 = 0;\n    let mut max_point14\
    \ = 0;\n    let mut min_point14 = 0;\n    let mut max_point15 = 0;\n    let mut\
    \ min_point15 = 0;\n    let mut max_point16 = 0;\n    let mut min_point16 = 0;\n\
    \    let mut max_point17 = 0;\n    let mut min_point17 = 0;\n    let mut max_point18\
    \ = 0;\n    let mut min_point18 = 0;\n    let mut max_point19 = 0;\n    let mut\
    \ min_point19 = 0;\n    let mut max_point20 = 0;\n    let mut min_point20 = 0;\n\
    \    let mut max_point21 = 0;\n    let mut min_point21 = 0;\n    let mut max_point22\
    \ = 0;\n    let mut min_point22 = 0;\n    let mut max_point23 = 0;\n    let mut\
    \ min_point23 = 0;\n    let mut max_point24 = 0;\n    let mut min_point24 = 0;\n\
    \    let mut max_point25 = 0;\n    let mut min_point25 = 0;\n    let mut max_point26\
    \ = 0;\n    let mut min_point26 = 0;\n    let mut max_point27 = 0;\n    let mut\
    \ min_point27 = 0;\n    let mut max_point28 = 0;\n    let mut min_point28 = 0;\n\
    \    let mut max_point29 = 0;\n    let mut min_point29 = 0;\n    let mut \n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpd6z7staf.rs:75:1\n\
    \   |\n75 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut nums_sum = 0;\n    let mut nums_index\
    \ = 0;\n    while nums_index < nums_copy.len() {\n        let mut nums_sum_copy\
    \ = 0;\n        while nums_sum_copy < nums_sum {\n            let mut nums_sum_copy2\
    \ = nums_sum;\n            while nums_sum_copy < nums_sum + nums_copy[nums_index]\
    \ {\n                nums_sum += nums_copy[nums_index];\n                nums_sum_copy\
    \ += nums_copy[nums_index];\n                nums_index += 1;\n            }\n\
    \        }\n        nums_sorted.push(nums_index);\n        nums_sum += nums_copy[nums_index];\n\
    \        nums_index += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvuidnp1d.rs:23:26\n   |\n\
    23 |         nums_sorted.push(nums_index);\n   |                          ^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n23 |         nums_sorted.push(nums_index.try_into().unwrap());\n\
    \   |                                    ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for &num in nums_sorted {\n        sum += num;\n    }\n  \
    \  let mut index = 0;\n    while index < nums_sorted.len() {\n        let mut\
    \ min_sum = sum;\n        let mut min_idx = index;\n        for &num in nums_sorted\
    \ {\n            if num < min_sum {\n                min_sum = num;\n        \
    \        min_idx = index;\n            }\n            index += 1;\n        }\n\
    \        nums_sorted.swap(min_idx, index);\n        index -= 1;\n    }\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuxy88ygy.rs:11:9\n   |\n\
    11 |     for &num in nums_sorted {\n   |         ^^^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpuxy88ygy.rs:18:13\n   |\n18 |  \
    \       for &num in nums_sorted {\n   |             ^^^^    ----------- this expression\
    \ has type `Option<isize>`\n   |             |\n   |             expected `isize`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `num`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpjfs32is8.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpjfs32is8.rs:12:18\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n10  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n13  | |             sum += x;\n14  | |\
    \         }\n15  | |         sum\n16  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpjfs32is8.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n11 | |    \
    \     let mut sum = 0;\n12 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n13 | |             sum +=\
    \ x;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpjfs32is8.rs:17:5\n   |\n9  |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut max_sum = 0;\n    let mut min_sum = 0;\n    let mut\
    \ max_index = -1;\n    let mut min_index = -1;\n    let mut max_value = nums_copy[0];\n\
    \    let mut min_value = nums_copy[0];\n    let mut max_digit = 0;\n    let mut\
    \ min_digit = 0;\n    for i in nums_copy.iter() {\n        sum += *i;\n      \
    \  if sum > max_sum {\n            max_sum = sum;\n            max_index = i;\n\
    \        }\n        if sum < min_sum {\n            min_sum = sum;\n         \
    \   min_index = i;\n        }\n        if *i > max_value {\n            max_value\
    \ = *i;\n        }\n        if *i < min_value {\n            min_value = *i;\n\
    \        }\n        if *i > max_digit {\n            max_digit = *i;\n       \
    \ }\n        if *i < min_digit {\n            min_digit = *i;\n        }\n   \
    \ }\n    nums_copy.swap_remove(max_index);\n    nums_copy.swap_remove(min_index);\n\
    \    nums_copy.swap_remove(max_digit);\n    nums_copy.swap_remove(min_digit);\n\
    \    nums_copy.swap_remove(max_value);\n    nums_copy.swap_remove(min_value);\n\
    \    nums_copy.swap_remove(max_sum);\n    nums_copy.swap_remove(min_sum);\n  \
    \  nums_copy.swap_remove(max_index);\n    nums_copy.swap_remove(min_index);\n\
    \    nums_copy.swap_remove(max_digit);\n    nums_copy.swap_remove(min_digit);\n\
    \    nums_copy.swap_remove(max_value);\n    nums_copy.swap_remove(min_value);\n\
    \    nums_copy.swap_remove(max_sum);\n    nums_copy.swap_remove(min_sum);\n  \
    \  nums_copy.swap_remove(max_index);\n    nums_copy.swap_remove(min_index);\n\
    \    nums_copy.swap_remove(max_digit);\n    nums_copy.swap_remove(min_digit);\n\
    \    nums_copy.swap_remove(max_value);\n    nums_copy.swap_remove(min_value);\n\
    \    nums_copy.swap_remove(max_sum);\n    nums_copy.swap_remove(min_sum);\n  \
    \  nums_copy.swap_remove(max_index);\n    nums_copy.swap_remove(min_index);\n\
    \    nums_copy.swap_remove(max_digit);\n    nums_copy.swap_remove(min_digit);\n\
    \    nums_copy.swap_remove(max_value);\n    nums_copy.swap_remove(min_value);\n\
    \    nums_copy.swap_remove(max_sum);\n    nums_copy.swap_remove(min_sum);\n  \
    \  nums_copy.swap_remove(max_index);\n    nums_copy.swap_remove(min_index);\n\
    \    nums_copy.swap\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5tnfq1ay.rs:23:25\n   |\n\
    13 |     let mut max_index = -1;\n   |                         -- expected due\
    \ to this value\n...\n23 |             max_index = i;\n   |                  \
    \       ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n23 |             max_index = *i;\n   |                   \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5tnfq1ay.rs:27:25\n\
    \   |\n14 |     let mut min_index = -1;\n   |                         -- expected\
    \ due to this value\n...\n27 |             min_index = i;\n   |              \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n27 |             min_index = *i;\n   |                   \
    \      +\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  -->\
    \ /tmp/tmp5tnfq1ay.rs:13:25\n   |\n13 |     let mut max_index = -1;\n   |    \
    \                     ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp5tnfq1ay.rs:14:25\n\
    \   |\n14 |     let mut min_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5tnfq1ay.rs:44:27\n   |\n44 |     nums_copy.swap_remove(max_digit);\n\
    \   |                           ^^^^^^^^^ expected `usize`, found `isize`\n  \
    \ |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n44 |     nums_copy.swap_remove(max_digit.try_into().unwrap());\n\
    \   |                                    ++++++++++++++++++++"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    let mut result\
    \ = vec![];\n    while sum > 0 {\n        let mut index = nums_copy.len();\n \
    \       while index > 0 {\n            if nums_copy[index - 1] > sum {\n     \
    \           index -= 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        result.push(nums_copy[index]);\n        sum -= nums_copy[index];\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = order_by_points;\n \
    \   assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp0oflwcw_.rs:34:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp3ua83ywb.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmp3ua83ywb.rs:12:18\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n10  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n13  | |             sum += x;\n14  | |\
    \         }\n15  | |         sum\n16  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmp3ua83ywb.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n11 | |    \
    \     let mut sum = 0;\n12 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n13 | |             sum +=\
    \ x;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmp3ua83ywb.rs:17:5\n   |\n9  |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by_key(|x| {\n        let mut sum\
    \ = 0;\n        for x in nums {\n            sum += x;\n        }\n        sum\n\
    \    });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n \
    \   assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n --> /tmp/tmpxxbh7p7_.rs:9:23\n  |\n9 |\
    \     nums.sort_by_key(|x| {\n  |                       ^ help: if this is intentional,\
    \ prefix it with an underscore: `_x`\n  |\n  = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0507]: cannot move out of `nums`, a captured variable\
    \ in an `FnMut` closure\n   --> /tmp/tmpxxbh7p7_.rs:11:18\n    |\n8   |   fn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    |                      ---- captured outer\
    \ variable\n9   |       nums.sort_by_key(|x| {\n    |  ______________________-\n\
    10  | |         let mut sum = 0;\n11  | |         for x in nums {\n    | |   \
    \               ^^^^\n    | |                  |\n    | |                  `nums`\
    \ moved due to this implicit call to `.into_iter()`\n    | |                 \
    \ move occurs because `nums` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n12  | |             sum += x;\n13  | |         }\n14  | |    \
    \     sum\n15  | |     });\n    | |_____- captured by this `FnMut` closure\n \
    \   |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n11  |         for x in &nums {\n\
    \    |                  +\n\nerror[E0596]: cannot borrow `nums` as mutable, as\
    \ it is not declared as mutable\n  --> /tmp/tmpxxbh7p7_.rs:9:5\n   |\n8  |   fn\
    \ order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |                    \
    \  ---- help: consider changing this to be mutable: `mut nums`\n9  | /     nums.sort_by_key(|x|\
    \ {\n10 | |         let mut sum = 0;\n11 | |         for x in nums {\n12 | | \
    \            sum += x;\n13 | |         }\n14 | |         sum\n15 | |     });\n\
    \   | |______^ cannot borrow as mutable\n\nerror[E0505]: cannot move out of `nums`\
    \ because it is borrowed\n  --> /tmp/tmpxxbh7p7_.rs:9:22\n   |\n9  |       nums.sort_by_key(|x|\
    \ {\n   |       -                ^^^ move out of `nums` occurs here\n   |  _____|\n\
    \   | |\n10 | |         let mut sum = 0;\n11 | |         for x in nums {\n   |\
    \ |                  ---- move occ"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_unstable_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for &d in &nums_sorted {\n            sum\
    \ += d;\n        }\n        sum\n    });\n    nums_sorted\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpyu8r0qg1.rs:10:39\n   |\n\
    10 |     nums_sorted.sort_unstable_by_key(|x| {\n   |                        \
    \               ^ help: if this is intentional, prefix it with an underscore:\
    \ `_x`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0502]:\
    \ cannot borrow `nums_sorted` as immutable because it is also borrowed as mutable\n\
    \  --> /tmp/tmpyu8r0qg1.rs:10:38\n   |\n10 |       nums_sorted.sort_unstable_by_key(|x|\
    \ {\n   |       -           -------------------- ^^^ immutable borrow occurs here\n\
    \   |       |           |\n   |  _____|           mutable borrow later used by\
    \ call\n   | |\n11 | |         let mut sum = 0;\n12 | |         for &d in &nums_sorted\
    \ {\n   | |                    ----------- second borrow occurs due to use of\
    \ `nums_sorted` in closure\n13 | |             sum += d;\n14 | |         }\n15\
    \ | |         sum\n16 | |     });\n   | |______- mutable borrow occurs here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by(|a, b| {\n        let mut sum\
    \ = 0;\n        for &n in &[a, b] {\n            sum += *n as isize;\n       \
    \ }\n        sum\n    });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppp0ws4x2.rs:14:9\n   |\n\
    14 |         sum\n   |         ^^^ expected enum `std::cmp::Ordering`, found `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut index = 0;\n\
    \    while nums_copy.len() > 0 {\n        let mut num = nums_copy.remove(0);\n\
    \        sum += num;\n        nums_sorted.push(num);\n        while nums_sorted.len()\
    \ > 0 && sum > nums_sorted[0] {\n            nums_sorted.pop();\n            index\
    \ += 1;\n        }\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpxd2_at35.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut max_sum =\
    \ 0;\n    let mut min_sum = 0;\n    let mut min_idx = nums.len();\n    let mut\
    \ max_idx = nums.len();\n    let mut min_val = nums.len();\n    let mut max_val\
    \ = nums.len();\n    let mut min_idx = nums.len();\n    let mut max_idx = nums.len();\n\
    \    let mut min_val = nums.len();\n    let mut max_val = nums.len();\n    let\
    \ mut min_idx = nums.len();\n    let mut max_idx = nums.len();\n    let mut min_val\
    \ = nums.len();\n    let mut max_val = nums.len();\n    let mut min_idx = nums.len();\n\
    \    let mut max_idx = nums.len();\n    let mut min_val = nums.len();\n    let\
    \ mut max_val = nums.len();\n    let mut min_idx = nums.len();\n    let mut max_idx\
    \ = nums.len();\n    let mut min_val = nums.len();\n    let mut max_val = nums.len();\n\
    \    let mut min_idx = nums.len();\n    let mut max_idx = nums.len();\n    let\
    \ mut min_val = nums.len();\n    let mut max_val = nums.len();\n    let mut min_idx\
    \ = nums.len();\n    let mut max_idx = nums.len();\n    let mut min_val = nums.len();\n\
    \    let mut max_val = nums.len();\n    let mut min_idx = nums.len();\n    let\
    \ mut max_idx = nums.len();\n    let mut min_val = nums.len();\n    let mut max_val\
    \ = nums.len();\n    let mut min_idx = nums.len();\n    let mut max_idx = nums.len();\n\
    \    let mut min_val = nums.len();\n    let mut max_val = nums.len();\n    let\
    \ mut min_idx = nums.len();\n    let mut max_idx = nums.len();\n    let mut min_val\
    \ = nums.len();\n    let mut max_val = nums.len();\n    let mut min_idx = nums.len();\n\
    \    let mut max_idx = nums.len();\n    let mut min_val = nums.len();\n    let\
    \ mut max_val = nums.len();\n    let mut min_idx = nums.len();\n    let mut max_idx\
    \ = nums.len();\n    let mut min_val = nums.len();\n    let \n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp_72yj3xm.rs:62:1\n  \
    \ |\n62 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for num in nums_sorted {\n        sum += num;\n    }\n   \
    \ nums_sorted.sort_by_key(|num| {\n        sum - num\n    });\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `nums_sorted`\n   --> /tmp/tmpfh03f0ie.rs:14:5\n\
    \    |\n9   |       let mut nums_sorted = nums.clone();\n    |           ---------------\
    \ move occurs because `nums_sorted` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n10  |       let mut sum = 0;\n11  |       for num in nums_sorted\
    \ {\n    |                  ----------- `nums_sorted` moved due to this implicit\
    \ call to `.into_iter()`\n...\n14  | /     nums_sorted.sort_by_key(|num| {\n15\
    \  | |         sum - num\n16  | |     });\n    | |______^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `nums_sorted`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n11  |     for num in &nums_sorted\
    \ {\n    |                +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpumyjzfgd.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpumyjzfgd.rs:12:18\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n10  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n13  | |             sum += x;\n14  | |\
    \         }\n15  | |         sum\n16  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpumyjzfgd.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n11 | |    \
    \     let mut sum = 0;\n12 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n13 | |             sum +=\
    \ x;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpumyjzfgd.rs:17:5\n   |\n9  |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for &i in nums_sorted {\n        sum += i;\n    }\n    nums_sorted.sort_by_key(|&i|\
    \ {\n        sum - i;\n    });\n    nums_sorted\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxo5iim2c.rs:11:9\n   |\n\
    11 |     for &i in nums_sorted {\n   |         ^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ *x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp4ts723wv.rs:13:20\n\
    \   |\n13 |             sum += *x;\n   |                    ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_unstable_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums {\n            sum += x;\n\
    \        }\n        sum\n    });\n    sorted_nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp30096z22.rs:10:39\n   |\n\
    10 |     sorted_nums.sort_unstable_by_key(|x| {\n   |                        \
    \               ^ help: if this is intentional, prefix it with an underscore:\
    \ `_x`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0507]:\
    \ cannot move out of `nums`, a captured variable in an `FnMut` closure\n   -->\
    \ /tmp/tmp30096z22.rs:12:18\n    |\n8   |   fn order_by_points(nums: Vec<isize>)\
    \ -> Vec<isize> {\n    |                      ---- captured outer variable\n9\
    \   |       let mut sorted_nums = nums.clone();\n10  |       sorted_nums.sort_unstable_by_key(|x|\
    \ {\n    |  ______________________________________-\n11  | |         let mut sum\
    \ = 0;\n12  | |         for x in nums {\n    | |                  ^^^^\n    |\
    \ |                  |\n    | |                  `nums` moved due to this implicit\
    \ call to `.into_iter()`\n    | |                  move occurs because `nums`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n13  | |  \
    \           sum += x;\n14  | |         }\n15  | |         sum\n16  | |     });\n\
    \    | |_____- captured by this `FnMut` closure\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n12  |         for x in &nums {\n    |                  +\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    let mut nums_copy\
    \ = nums.clone();\n    nums_copy.sort();\n    let mut index = 0;\n    while index\
    \ < nums_copy.len() {\n        if nums_copy[index] == sum {\n            nums_copy[index]\
    \ = index;\n        }\n        index += 1;\n    }\n    nums_copy\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz2sz962d.rs:21:32\n   |\n\
    21 |             nums_copy[index] = index;\n   |             ----------------\
    \   ^^^^^ expected `isize`, found `usize`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for &num in nums_sorted {\n        sum += num;\n    }\n  \
    \  nums_sorted.sort_by_key(|&num| {\n        sum.partial_cmp(&num).unwrap()\n\
    \    });\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpklrlwga9.rs:11:9\n   |\n\
    11 |     for &num in nums_sorted {\n   |         ^^^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_unstable_by(|a,\
    \ b| {\n        let mut a_digits = a.to_digits();\n        let mut b_digits =\
    \ b.to_digits();\n        loop {\n            if a_digits.is_empty() {\n     \
    \           return b_digits.is_empty();\n            }\n            if b_digits.is_empty()\
    \ {\n                return a_digits.is_empty();\n            }\n            if\
    \ a_digits[0] < b_digits[0] {\n                return true;\n            }\n \
    \           if a_digits[0] > b_digits[0] {\n                return false;\n  \
    \          }\n            a_digits = a_digits.remove(0);\n            b_digits\
    \ = b_digits.remove(0);\n        }\n    });\n    sorted_nums\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmph1ssy_21.rs:11:30\n   |\n11 |         let\
    \ mut a_digits = a.to_digits();\n   |                              ^^^^^^^^^ method\
    \ not found in `&isize`\n\nerror[E0599]: no method named `to_digits` found for\
    \ reference `&isize` in the current scope\n  --> /tmp/tmph1ssy_21.rs:12:30\n \
    \  |\n12 |         let mut b_digits = b.to_digits();\n   |                   \
    \           ^^^^^^^^^ method not found in `&isize`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index +=\n            match nums_copy[index]\
    \ % 10 {\n                0 => 1,\n                1 => 2,\n                2\
    \ => 3,\n                3 => 4,\n                4 => 5,\n                5 =>\
    \ 6,\n                6 => 7,\n                7 => 8,\n                8 => 9,\n\
    \                _ => panic!(\"Invalid input\"),\n            };\n    }\n    nums_copy.sort_by_key(|&x|\
    \ sum + x);\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'Invalid input', /tmp/tmp50d6_t9o.rs:25:22\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .enumerate()\n\
    \        .sort_by(|(idx, _), &x| {\n            let mut sum = 0;\n           \
    \ for &d in &x {\n                sum += *d as usize;\n            }\n       \
    \     sum\n        })\n        .map(|(idx, _)| idx)\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmp_4zxg9kd.rs:12:10\n   |\n12 |         .sort_by(|(idx,\
    \ _), &x| {\n   |          ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    for n in nums_copy {\n        sum += n;\n    }\n    nums_copy.sort_by_key(|n|\
    \ {\n        sum - n\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `nums_copy`\n   --> /tmp/tmpcpxkzuua.rs:14:5\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ move occurs because `nums_copy` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n10  |       let mut sum = 0;\n11  |       for n in nums_copy\
    \ {\n    |                --------- `nums_copy` moved due to this implicit call\
    \ to `.into_iter()`\n...\n14  | /     nums_copy.sort_by_key(|n| {\n15  | |   \
    \      sum - n\n16  | |     });\n    | |______^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `nums_copy`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n11  |     for n in &nums_copy {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut max_sum =\
    \ 0;\n    let mut min_sum = 0;\n    let mut max_index = -1;\n    let mut min_index\
    \ = -1;\n    for i in nums_copy {\n        sum += i;\n        if sum > max_sum\
    \ {\n            max_sum = sum;\n            max_index = i;\n        }\n     \
    \   if sum < min_sum {\n            min_sum = sum;\n            min_index = i;\n\
    \        }\n    }\n    for i in nums_copy {\n        if i == max_index {\n   \
    \         nums_sorted.swap(i, max_index);\n        }\n        if i == min_index\
    \ {\n            nums_sorted.swap(i, min_index);\n        }\n    }\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdoo9fs_g.rs:29:30\n   |\n\
    29 |             nums_sorted.swap(i, max_index);\n   |                       \
    \       ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n29 |      \
    \       nums_sorted.swap(i.try_into().unwrap(), max_index);\n   |            \
    \                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpdoo9fs_g.rs:29:33\n   |\n29 |             nums_sorted.swap(i, max_index);\n\
    \   |                                 ^^^^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n29 |             nums_sorted.swap(i, max_index.try_into().unwrap());\n\
    \   |                                          ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdoo9fs_g.rs:32:30\n   |\n32 |             nums_sorted.swap(i,\
    \ min_index);\n   |                              ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n32 |             nums_sorted.swap(i.try_into().unwrap(),\
    \ min_index);\n   |                               ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdoo9fs_g.rs:32:33\n   |\n32 |             nums_sorted.swap(i,\
    \ min_index);\n   |                                 ^^^^^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n32 |             nums_sorted.swap(i,\
    \ min_index.try_into().unwrap());\n   |                                      \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .enumerate()\n\
    \        .sort_by(|(idx, &n), (_, sum)| sum.partial_cmp(&n))\n        .map(|(idx,\
    \ n)| idx)\n        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmpdkkwoksb.rs:12:10\n   |\n12 |         .sort_by(|(idx,\
    \ &n), (_, sum)| sum.partial_cmp(&n))\n   |          ^^^^^^^ method not found\
    \ in `Enumerate<std::slice::Iter<'_, isize>>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp4227e77v.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmp4227e77v.rs:12:18\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n10  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n13  | |             sum += x;\n14  | |\
    \         }\n15  | |         sum\n16  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmp4227e77v.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n11 | |    \
    \     let mut sum = 0;\n12 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n13 | |             sum +=\
    \ x;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmp4227e77v.rs:17:5\n   |\n9  |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in &mut sorted_nums {\n         \
    \   sum += *x;\n        }\n        sum\n    });\n    sorted_nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmppe91ktjt.rs:10:30\n   |\n\
    10 |     sorted_nums.sort_by_key(|x| {\n   |                              ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0499]: cannot borrow `sorted_nums`\
    \ as mutable more than once at a time\n  --> /tmp/tmppe91ktjt.rs:10:29\n   |\n\
    10 |       sorted_nums.sort_by_key(|x| {\n   |       -           ----------- ^^^\
    \ second mutable borrow occurs here\n   |       |           |\n   |  _____|  \
    \         first borrow later used by call\n   | |\n11 | |         let mut sum\
    \ = 0;\n12 | |         for x in &mut sorted_nums {\n   | |                   \
    \    ----------- second borrow occurs due to use of `sorted_nums` in closure\n\
    13 | |             sum += *x;\n14 | |         }\n15 | |         sum\n16 | |  \
    \   });\n   | |______- first mutable borrow occurs here\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0499`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_unstable_by(|a,\
    \ b| {\n        let mut a_digits = a.to_string().chars().map(|c| c - '0').collect::<Vec<_>>();\n\
    \        let mut b_digits = b.to_string().chars().map(|c| c - '0').collect::<Vec<_>>();\n\
    \        a_digits.iter().zip(b_digits.iter()).map(|(a, b)| a + b).collect::<Vec<_>>()\n\
    \    });\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpsmw51ajo.rs:11:60\n\
    \   |\n11 |         let mut a_digits = a.to_string().chars().map(|c| c - '0').collect::<Vec<_>>();\n\
    \   |                                                          - ^ --- char\n\
    \   |                                                          |\n   |       \
    \                                                   char\n\nerror[E0369]: cannot\
    \ subtract `char` from `char`\n  --> /tmp/tmpsmw51ajo.rs:12:60\n   |\n12 |   \
    \      let mut b_digits = b.to_string().chars().map(|c| c - '0').collect::<Vec<_>>();\n\
    \   |                                                          - ^ --- char\n\
    \   |                                                          |\n   |       \
    \                                                   char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsmw51ajo.rs:13:9\n   |\n13 |         a_digits.iter().zip(b_digits.iter()).map(|(a,\
    \ b)| a + b).collect::<Vec<_>>()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found struct `Vec`\n   |\n   = note: expected\
    \ enum `std::cmp::Ordering`\n            found struct `Vec<_>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = 0;\n    let mut min_idx = nums.len() - 1;\n\
    \    let mut min_val = nums[min_idx];\n    let mut max_val = nums[0];\n\n    for\
    \ &num in nums_copy {\n        sum += num;\n        if sum < min_sum {\n     \
    \       min_sum = sum;\n            min_idx = nums.iter().position(|&num| num\
    \ < min_val);\n            min_val = nums[min_idx];\n        }\n        if sum\
    \ > max_sum {\n            max_sum = sum;\n            max_idx = nums.iter().position(|&num|\
    \ num > max_val);\n            max_val = nums[max_idx];\n        }\n    }\n\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy[min_idx] = min_val;\n  \
    \  nums_copy[max_idx] = max_val;\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `max_sum` in this scope\n  --> /tmp/tmpa9p1u_ee.rs:23:18\n\
    \   |\n23 |         if sum > max_sum {\n   |                  ^^^^^^^ help: a\
    \ local variable with a similar name exists: `min_sum`\n\nerror[E0425]: cannot\
    \ find value `max_sum` in this scope\n  --> /tmp/tmpa9p1u_ee.rs:24:13\n   |\n\
    24 |             max_sum = sum;\n   |             ^^^^^^^ help: a local variable\
    \ with a similar name exists: `min_sum`\n\nerror[E0425]: cannot find value `max_idx`\
    \ in this scope\n  --> /tmp/tmpa9p1u_ee.rs:25:13\n   |\n25 |             max_idx\
    \ = nums.iter().position(|&num| num > max_val);\n   |             ^^^^^^^ help:\
    \ a local variable with a similar name exists: `min_idx`\n\nerror[E0425]: cannot\
    \ find value `max_idx` in this scope\n  --> /tmp/tmpa9p1u_ee.rs:26:28\n   |\n\
    26 |             max_val = nums[max_idx];\n   |                            ^^^^^^^\
    \ help: a local variable with a similar name exists: `min_idx`\n\nerror[E0425]:\
    \ cannot find value `max_idx` in this scope\n  --> /tmp/tmpa9p1u_ee.rs:32:15\n\
    \   |\n32 |     nums_copy[max_idx] = max_val;\n   |               ^^^^^^^ help:\
    \ a local variable with a similar name exists: `min_idx`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa9p1u_ee.rs:16:9\n   |\n16 |     for &num in nums_copy\
    \ {\n   |         ^^^^    --------- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `num`\n   |\n   = note: \
    \  expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa9p1u_ee.rs:20:23\n   |\n12 |     let mut min_idx = nums.len()\
    \ - 1;\n   |                       -------------- expected due to this value\n\
    ...\n20 |             min_idx = nums.iter().position(|&num| num < min_val);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n     \
    \         found enum `Option<usize>`\n\nerror: aborting due to 7 previous errors\n\
    \nSome errors have detailed explanations: E0308, E"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmponhiyv2h.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmponhiyv2h.rs:12:18\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n10  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n13  | |             sum += x;\n14  | |\
    \         }\n15  | |         sum\n16  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmponhiyv2h.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n11 | |    \
    \     let mut sum = 0;\n12 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n13 | |             sum +=\
    \ x;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmponhiyv2h.rs:17:5\n   |\n9  |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ *x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpkf9ltys4.rs:13:20\n\
    \   |\n13 |             sum += *x;\n   |                    ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for i in nums_sorted.iter() {\n        sum += *i;\n      \
    \  nums_sorted.swap(i, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt9qglkng.rs:13:26\n   |\n\
    13 |         nums_sorted.swap(i, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |                          ^ expected `usize`, found `&isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for i in nums_sorted.iter() {\n        sum += *i;\n    }\n\
    \    for i in nums_sorted.iter_mut() {\n        *i += sum;\n    }\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-11, -1, -13, -23, -24]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp1_hfxidq.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for &n in nums_sorted {\n        sum += n;\n    }\n    let\
    \ mut i = 0;\n    while i < nums_sorted.len() {\n        if sum < nums_sorted[i]\
    \ {\n            nums_sorted.swap(i, nums_sorted.len() - 1);\n            i -=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkqm2wywi.rs:11:9\n   |\n\
    11 |     for &n in nums_sorted {\n   |         ^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `n`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x.to_digits().unwrap().sum()\n    });\n    nums_copy\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp50cgs3_x.rs:17:17\n   |\n17 |         sum\
    \ - x.to_digits().unwrap().sum()\n   |                 ^^^^^^^^^ method not found\
    \ in `&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for &n in nums_sorted {\n        sum += n;\n    }\n    nums_sorted.sort_by_key(|&n|\
    \ {\n        sum - n\n    });\n    nums_sorted\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuyfbbwmg.rs:11:9\n   |\n\
    11 |     for &n in nums_sorted {\n   |         ^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `n`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        let num = nums_copy[index];\n        sum += num;\n        if sum > 0\
    \ {\n            nums_copy[index] = sum % 10;\n            sum = (sum / 10).floor();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    nums_copy.sort_by_key(|x|\
    \ x.cmp(&nums[nums.iter().position(|y| x.cmp(y)).unwrap()]));\n    nums_copy\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `floor` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpr4a1q776.rs:17:30\n   |\n17 |             sum = (sum /\
    \ 10).floor();\n   |                              ^^^^^ help: there is an associated\
    \ function with a similar name: `div_floor`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpr4a1q776.rs:22:68\n   |\n22 |     nums_copy.sort_by_key(|x| x.cmp(&nums[nums.iter().position(|y|\
    \ x.cmp(y)).unwrap()]));\n   |                                               \
    \                     ^^^^^^^^ expected `bool`, found enum `std::cmp::Ordering`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .cloned()\n\
    \        .enumerate()\n        .map(|(i, &x)| {\n            let mut sum = 0;\n\
    \            for d in x.to_string().chars().filter(|&c| c != '0') {\n        \
    \        sum += *d as usize;\n            }\n            (*i, sum)\n        })\n\
    \        .sort_by_key(|&(i, sum)| sum)\n        .map(|i| nums[*i])\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpew44hgro.rs:13:19\n   |\n\
    13 |         .map(|(i, &x)| {\n   |                   ^^- expected due to this\n\
    \   |                   |\n   |                   expected `isize`, found reference\n\
    \   |                   help: you can probably remove the explicit borrow: `x`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpew44hgro.rs:18:14\n\
    \   |\n18 |             (*i, sum)\n   |              ^^\n\nerror[E0599]: no method\
    \ named `sort_by_key` found for struct `Map` in the current scope\n  --> /tmp/tmpew44hgro.rs:20:10\n\
    \   |\n20 |         .sort_by_key(|&(i, sum)| sum)\n   |          ^^^^^^^^^^^ method\
    \ not found in `Map<Enumerate<Cloned<std::slice::Iter<'_, isize>>>, _>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ *x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmptl6zjgl2.rs:13:20\n\
    \   |\n13 |             sum += *x;\n   |                    ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut min_sum =\
    \ 0;\n    let mut min_num = 0;\n    let mut min_num_index = 0;\n    let mut max_sum\
    \ = 0;\n    let mut max_num = 0;\n    let mut max_num_index = 0;\n    for i in\
    \ nums_copy.iter() {\n        sum += *i;\n        if sum < min_sum {\n       \
    \     min_sum = sum;\n            min_num = *i;\n            min_num_index = i;\n\
    \        }\n        if sum > max_sum {\n            max_sum = sum;\n         \
    \   max_num = *i;\n            max_num_index = i;\n        }\n    }\n    for i\
    \ in nums_sorted.iter_mut() {\n        *i = min_num_index;\n    }\n    for i in\
    \ nums_sorted.iter() {\n        *i = max_num_index;\n    }\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_pytkm0.rs:23:29\n   |\n\
    14 |     let mut min_num_index = 0;\n   |                             - expected\
    \ due to this value\n...\n23 |             min_num_index = i;\n   |          \
    \                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n23 |             min_num_index = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf_pytkm0.rs:28:29\n\
    \   |\n17 |     let mut max_num_index = 0;\n   |                             -\
    \ expected due to this value\n...\n28 |             max_num_index = i;\n   | \
    \                            ^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n28 |             max_num_index = *i;\n   | \
    \                            +\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for num in nums_sorted {\n        sum += num;\n    }\n   \
    \ let mut nums_sorted = nums_sorted.iter().cloned().collect::<Vec<_>>();\n   \
    \ nums_sorted.sort_by_key(|num| {\n        let mut num = 0;\n        for digit\
    \ in num.digits().cloned() {\n            num += digit;\n        }\n        num\n\
    \    });\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for type `{integer}` in the\
    \ current scope\n  --> /tmp/tmpac9ug9ih.rs:17:26\n   |\n17 |         for digit\
    \ in num.digits().cloned() {\n   |                          ^^^^^^ method not\
    \ found in `{integer}`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index +=\n            match nums_copy[index]\
    \ % 10 {\n                0 => 1,\n                1 => 2,\n                2\
    \ => 3,\n                3 => 4,\n                4 => 5,\n                5 =>\
    \ 6,\n                6 => 7,\n                7 => 8,\n                8 => 9,\n\
    \                _ => panic!(\"invalid input\"),\n            };\n    }\n    nums_copy.sort_by_key(|x|\
    \ sum - x);\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'invalid input', /tmp/tmpgzbn3rhg.rs:25:22\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .cloned()\n\
    \        .enumerate()\n        .sort_by(|(idx, &n), &(_, n2)| {\n            let\
    \ mut sum = 0;\n            for d in n.digits() {\n                sum += d;\n\
    \            }\n            sum\n        })\n        .map(|(idx, &n)| nums[idx])\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmpzh4c364p.rs:13:10\n   |\n13 |         .sort_by(|(idx,\
    \ &n), &(_, n2)| {\n   |          ^^^^^^^ method not found in `Enumerate<Cloned<std::slice::Iter<'_,\
    \ isize>>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_unstable_by(|a,\
    \ b| {\n        let mut a_digits = a.to_digits();\n        let mut b_digits =\
    \ b.to_digits();\n        a_digits.iter().zip(b_digits.iter()).for_each(|(a_digit,\
    \ b_digit)| {\n            if a_digit > b_digit {\n                *a_digit =\
    \ *b_digit;\n                *b_digit = a_digit;\n            }\n        });\n\
    \        a_digits.iter().sum::<isize>()\n    });\n    sorted_nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpuq5gln7w.rs:11:30\n   |\n11 |         let\
    \ mut a_digits = a.to_digits();\n   |                              ^^^^^^^^^ method\
    \ not found in `&isize`\n\nerror[E0599]: no method named `to_digits` found for\
    \ reference `&isize` in the current scope\n  --> /tmp/tmpuq5gln7w.rs:12:30\n \
    \  |\n12 |         let mut b_digits = b.to_digits();\n   |                   \
    \           ^^^^^^^^^ method not found in `&isize`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    let mut nums_copy\
    \ = nums.clone();\n    nums_copy.sort();\n    let mut index = 0;\n    while index\
    \ < nums_copy.len() {\n        if nums_copy[index] != sum {\n            nums_copy[index]\
    \ = nums_copy[index] - sum;\n            nums_copy[index + 1] = nums_copy[index\
    \ + 1] + sum;\n        }\n        index += 1;\n    }\n    nums_copy\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 5 but the index\
    \ is 5', /tmp/tmpa1zckgqz.rs:22:36\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    for num in nums_copy {\n        sum += num;\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x;\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `nums_copy`\n   --> /tmp/tmpiluofntm.rs:14:5\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ move occurs because `nums_copy` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n10  |       let mut sum = 0;\n11  |       for num in nums_copy\
    \ {\n    |                  --------- `nums_copy` moved due to this implicit call\
    \ to `.into_iter()`\n...\n14  | /     nums_copy.sort_by_key(|x| {\n15  | |   \
    \      sum - x;\n16  | |     });\n    | |______^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `nums_copy`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n11  |     for num in &nums_copy\
    \ {\n    |                +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = 0;\n    let mut min_idx = -1;\n    let mut\
    \ max_sum = 0;\n    let mut max_idx = -1;\n    for i in nums_copy.iter() {\n \
    \       sum += *i;\n        if sum < min_sum {\n            min_sum = sum;\n \
    \           min_idx = i;\n        }\n        if sum > max_sum {\n            max_sum\
    \ = sum;\n            max_idx = i;\n        }\n    }\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy.swap_remove(max_idx);\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpslkyi0hk.rs:19:23\n   |\n\
    12 |     let mut min_idx = -1;\n   |                       -- expected due to\
    \ this value\n...\n19 |             min_idx = i;\n   |                       ^\
    \ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n19 |             min_idx = *i;\n   |                       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpslkyi0hk.rs:23:23\n   |\n14 |     let mut max_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n23 | \
    \            max_idx = i;\n   |                       ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |        \
    \     max_idx = *i;\n   |                       +\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpslkyi0hk.rs:12:23\n   |\n12 | \
    \    let mut min_idx = -1;\n   |                       ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmpslkyi0hk.rs:14:23\n   |\n14 |     let mut\
    \ max_idx = -1;\n   |                       ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp3arqgril.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmp3arqgril.rs:12:18\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n10  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n13  | |             sum += x;\n14  | |\
    \         }\n15  | |         sum\n16  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmp3arqgril.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n11 | |    \
    \     let mut sum = 0;\n12 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n13 | |             sum +=\
    \ x;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmp3arqgril.rs:17:5\n   |\n9  |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_unstable_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_sorted {\n            sum\
    \ += x;\n        }\n        sum\n    });\n    nums_sorted\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpmkgku6lp.rs:10:39\n   |\n\
    10 |     nums_sorted.sort_unstable_by_key(|x| {\n   |                        \
    \               ^ help: if this is intentional, prefix it with an underscore:\
    \ `_x`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0507]:\
    \ cannot move out of `nums_sorted`, a captured variable in an `FnMut` closure\n\
    \   --> /tmp/tmpmkgku6lp.rs:12:18\n    |\n9   |       let mut nums_sorted = nums.clone();\n\
    \    |           --------------- captured outer variable\n10  |       nums_sorted.sort_unstable_by_key(|x|\
    \ {\n    |  ______________________________________-\n11  | |         let mut sum\
    \ = 0;\n12  | |         for x in nums_sorted {\n    | |                  ^^^^^^^^^^^\n\
    \    | |                  |\n    | |                  `nums_sorted` moved due\
    \ to this implicit call to `.into_iter()`\n    | |                  move occurs\
    \ because `nums_sorted` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n13  | |             sum += x;\n14  | |         }\n15  | |         sum\n\
    16  | |     });\n    | |_____- captured by this `FnMut` closure\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `nums_sorted`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |         for x in &nums_sorted {\n    |   \
    \               +\n\nerror[E0505]: cannot move out of `nums_sorted` because it\
    \ is borrowed\n  --> /tmp/tmpmkgku6lp.rs:10:38\n   |\n10 |       nums_sorted.sort_unstable_by_key(|x|\
    \ {\n   |       -                                ^^^ move out of `nums_sorted`\
    \ occurs here\n   |  _____|\n   | |\n11 | |         let mut sum = 0;\n12 | | \
    \        for x in nums_sorted {\n   | |                  ----------- move occurs\
    \ due to use in closure\n13 | |             sum += x;\n14 | |         }\n15 |\
    \ |         sum\n16 | |     });\n   | |______- borrow of `nums_sorted` occurs\
    \ here\n\nerror[E0382]: use of moved value: `nums_sorted`\n  --> /tmp/tmpmkgku6lp.rs:17:5\n\
    \   |\n9  |     let mut nums_sorted = nums.clone();\n   |         -----------"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = nums.iter().fold(0, |sum, num| sum + num);\n\
    \    let mut min_idx = nums.iter().cloned().min_by_key(|&x| {\n        sum +=\
    \ x;\n        sum\n    });\n    let mut min_idx = min_idx.unwrap();\n    let mut\
    \ min_val = nums_copy[min_idx];\n    let mut min_idx = nums.iter().cloned().min_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    });\n    let mut min_idx = min_idx.unwrap();\n\
    \    let mut min_val = nums_copy[min_idx];\n    let mut min_idx = nums.iter().cloned().min_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    });\n    let mut min_idx = min_idx.unwrap();\n\
    \    let mut min_val = nums_copy[min_idx];\n    let mut min_idx = nums.iter().cloned().min_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    });\n    let mut min_idx = min_idx.unwrap();\n\
    \    let mut min_val = nums_copy[min_idx];\n    let mut min_idx = nums.iter().cloned().min_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    });\n    let mut min_idx = min_idx.unwrap();\n\
    \    let mut min_val = nums_copy[min_idx];\n    let mut min_idx = nums.iter().cloned().min_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    });\n    let mut min_idx = min_idx.unwrap();\n\
    \    let mut min_val = nums_copy[min_idx];\n    let mut min_idx = nums.iter().cloned().min_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    });\n    let mut min_idx = min_idx.unwrap();\n\
    \    let mut min_val = nums_copy[min_idx];\n    let mut min_idx = nums.iter().cloned().min_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    });\n    let mut min_idx = min_idx.unwrap();\n\
    \    let mut min_val = nums_copy[min_idx];\n    let mut min_idx = nums.iter().cloned().min_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    });\n    let mut min_idx = min_idx.unwrap();\n\
    \    let \n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpcs9s8yi1.rs:66:1\n  \
    \ |\n66 | }\n   | ^ expected pattern\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpcs9s8yi1.rs:17:23\n   |\n17 |     let mut\
    \ min_val = nums_copy[min_idx];\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpcs9s8yi1.rs:23:23\n\
    \   |\n23 |     let mut min_val = nums_copy[min_idx];\n   |                  \
    \     ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpcs9s8yi1.rs:29:23\n\
    \   |\n29 |     let mut min_val = nums_copy[min_idx];\n   |                  \
    \     ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpcs9s8yi1.rs:35:23\n\
    \   |\n35 |     let mut min_val = nums_copy[min_idx];\n   |                  \
    \     ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<is"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1; // skip the digit already\
    \ processed\n    }\n    let mut result = vec![];\n    while nums_copy.len() >\
    \ 0 {\n        let mut cur = nums_copy.clone();\n        let mut cur_index = 0;\n\
    \        while cur_index < cur.len() {\n            let digit = cur[cur_index];\n\
    \            if digit > 0 {\n                cur.swap(cur_index, cur_index + 1);\n\
    \                cur_index += 1;\n            } else {\n                cur.swap(cur_index,\
    \ cur_index - 1);\n                cur_index -= 1;\n            }\n        }\n\
    \        result.push(sum);\n        nums_copy = cur;\n        sum = 0;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 5 but the index\
    \ is 5', /tmp/tmptjag_zw7.rs:23:21\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    for n in nums_copy {\n        sum += n;\n    }\n    let mut\
    \ nums_sorted = nums.clone();\n    nums_sorted.sort_unstable_by(|a, b| {\n   \
    \     sum.partial_cmp(&a + b).unwrap()\n    });\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&isize` to `&&isize`\n  --> /tmp/tmpeaaxj8yv.rs:16:28\n\
    \   |\n16 |         sum.partial_cmp(&a + b).unwrap()\n   |                   \
    \      -- ^ - &isize\n   |                         |\n   |                   \
    \      &&isize\n   |\nhelp: `+` can be used on `isize`, you can dereference `&a`\n\
    \   |\n16 |         sum.partial_cmp(*&a + b).unwrap()\n   |                  \
    \       +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for i in nums_sorted.iter() {\n        sum += *i;\n      \
    \  nums_sorted.swap(i, nums_sorted.iter().position(|&x| x > sum).unwrap());\n\
    \    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn9nqey9d.rs:13:26\n   |\n\
    13 |         nums_sorted.swap(i, nums_sorted.iter().position(|&x| x > sum).unwrap());\n\
    \   |                          ^ expected `usize`, found `&isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums = nums.clone();\n    let mut sum\
    \ = 0;\n    let mut index = 0;\n    while index < nums.len() {\n        sum +=\
    \ nums[index];\n        if sum < 0 {\n            sum = 0;\n            index\
    \ += 1;\n        } else {\n            sum += 1;\n            index += 1;\n  \
    \      }\n    }\n    let mut result = nums.clone();\n    result.sort_unstable_by_key(|x|\
    \ {\n        let mut sum = 0;\n        let mut index = 0;\n        while index\
    \ < nums.len() {\n            sum += nums[index];\n            if sum < 0 {\n\
    \                sum = 0;\n                index += 1;\n            } else {\n\
    \                sum += 1;\n                index += 1;\n            }\n     \
    \   }\n        sum\n    });\n    result\n}\n\nfn main() {\n    let candidate =\
    \ order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpn2lj0wpo.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = nums.iter().min().unwrap();\n    let mut\
    \ max_sum = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = num\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpz9bclu1t.rs:46:26\n   |\n\
    46 |     let mut max_idx = num\n   |                          ^ help: add `;`\
    \ here\n47 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `num`\
    \ in this scope\n  --> /tmp/tmpz9bclu1t.rs:46:23\n   |\n46 |     let mut max_idx\
    \ = num\n   |                       ^^^ help: a local variable with a similar\
    \ name exists: `nums`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpz9bclu1t.rs:8:41\n\
    \  |\n8 | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n  |    ---------------\
    \                      ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    nums_copy.sort_by_key(|&x|\
    \ {\n        sum - x;\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp04ix0ku1.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1; // skip the digit we already\
    \ have\n        if sum < 0 {\n            sum = 0;\n        }\n    }\n    let\
    \ mut result = nums.clone();\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        let mut found = false;\n        while !found && index < nums_copy.len()\
    \ {\n            sum += nums_copy[index];\n            index += 1; // skip the\
    \ digit we already have\n            if sum < 0 {\n                sum = 0;\n\
    \            }\n            if sum == 0 {\n                found = true;\n   \
    \         }\n        }\n        if !found {\n            result.push(nums_copy[index]);\n\
    \        }\n        index += 1; // skip the digit we already have\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp243u1337.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    for &num in nums_copy {\n        sum += num;\n    }\n    let\
    \ mut nums_copy = nums.clone();\n    nums_copy.sort();\n    let mut index = 0;\n\
    \    let mut nums_copy = nums.clone();\n    while nums_copy.len() > 0 {\n    \
    \    let mut nums_copy = nums.clone();\n        let mut num = 0;\n        while\
    \ nums_copy.len() > 0 {\n            num = nums_copy.pop().unwrap();\n       \
    \     if num > 0 {\n                nums_copy.push(num - 1);\n            }\n\
    \        }\n        nums_copy.push(num);\n        nums_copy.sort();\n        if\
    \ nums_copy.len() > 0 {\n            sum += nums_copy.pop().unwrap();\n      \
    \  }\n        nums_copy.sort();\n        index += 1;\n    }\n    nums_copy.sort();\n\
    \    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1tcldp4g.rs:11:9\n   |\n\
    11 |     for &num in nums_copy {\n   |         ^^^^    --------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for num in nums_sorted {\n        sum += num;\n    }\n   \
    \ nums_sorted.sort_by_key(|num| {\n        sum - num\n    });\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `nums_sorted`\n   --> /tmp/tmp4lprjduq.rs:14:5\n\
    \    |\n9   |       let mut nums_sorted = nums.clone();\n    |           ---------------\
    \ move occurs because `nums_sorted` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n10  |       let mut sum = 0;\n11  |       for num in nums_sorted\
    \ {\n    |                  ----------- `nums_sorted` moved due to this implicit\
    \ call to `.into_iter()`\n...\n14  | /     nums_sorted.sort_by_key(|num| {\n15\
    \  | |         sum - num\n16  | |     });\n    | |______^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `nums_sorted`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n11  |     for num in &nums_sorted\
    \ {\n    |                +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpri9buyk8.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpri9buyk8.rs:12:18\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n10  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n13  | |             sum += x;\n14  | |\
    \         }\n15  | |         sum\n16  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpri9buyk8.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n11 | |    \
    \     let mut sum = 0;\n12 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n13 | |             sum +=\
    \ x;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpri9buyk8.rs:17:5\n   |\n9  |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ *x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp0vsv594f.rs:13:20\n\
    \   |\n13 |             sum += *x;\n   |                    ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = nums.iter().fold(0, |sum, i| sum + i);\n\
    \    let mut min_idx = nums.iter().cloned().min_by_key(|i| {\n        sum += i;\n\
    \        sum\n    });\n    let mut max_idx = nums.iter().cloned().max_by_key(|i|\
    \ {\n        sum += i;\n        sum\n    });\n    while nums_copy.len() > 0 {\n\
    \        let mut idx = nums_copy.iter().cloned().find(|&i| {\n            sum\
    \ += i;\n            sum\n        });\n        if idx != min_idx {\n         \
    \   min_idx = idx;\n            min_sum = nums[idx];\n        }\n        let mut\
    \ idx = nums_copy.iter().cloned().find(|&i| {\n            sum += i;\n       \
    \     sum\n        });\n        if idx != max_idx {\n            max_idx = idx;\n\
    \            max_sum = nums[idx];\n        }\n        nums_copy.remove(0);\n \
    \   }\n    let mut nums_copy = nums.clone();\n    while nums_copy.len() > 0 {\n\
    \        let mut idx = nums_copy.iter().cloned().find(|&i| {\n            sum\
    \ += i;\n            sum\n        });\n        nums_copy.remove(0);\n        if\
    \ idx != min_idx {\n            min_idx = idx;\n            min_sum = nums[idx];\n\
    \        }\n        if idx != max_idx {\n            max_idx = idx;\n        \
    \    max_sum = nums[idx];\n        }\n    }\n    if min_sum < 0 {\n        min_sum\
    \ = 0;\n    }\n    if max_sum < 0 {\n        max_sum = 0;\n    }\n    if min_sum\
    \ > max_sum {\n        let tmp = min_sum;\n        min_sum = max_sum;\n      \
    \  max_sum = tmp;\n    }\n    if min_sum == max_sum {\n        min_idx\n    }\
    \ else {\n        let mut min_idx = nums.iter().cloned().min_by_key(|i| {\n  \
    \          sum += i;\n            sum\n        });\n        let mut max_idx =\
    \ nums.iter().cloned().max_by_key(|i| {\n            sum += i;\n            sum\n\
    \        });\n        if min_sum < max_sum {\n            if min_idx != max_idx\
    \ {\n                min_idx = max_idx;\n                min_sum = max_sum;\n\
    \            }\n        } else {\n            if max_idx != min_idx {\n      \
    \          max_idx = min_idx;\n                max_sum = min_sum;\n          \
    \  }\n        }\n    }\n    nums[min_idx..max_idx]\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `max_sum` in this scope\n  --> /tmp/tmpzf_5bpxo.rs:35:13\n\
    \   |\n35 |             max_sum = nums[idx];\n   |             ^^^^^^^ help: a\
    \ local variable with a similar name exists: `min_sum`\n\nerror[E0425]: cannot\
    \ find value `max_sum` in this scope\n  --> /tmp/tmpzf_5bpxo.rs:52:13\n   |\n\
    52 |             max_sum = nums[idx];\n   |             ^^^^^^^ help: a local\
    \ variable with a similar name exists: `min_sum`\n\nerror[E0425]: cannot find\
    \ value `max_sum` in this scope\n  --> /tmp/tmpzf_5bpxo.rs:58:8\n   |\n58 |  \
    \   if max_sum < 0 {\n   |        ^^^^^^^ help: a local variable with a similar\
    \ name exists: `min_sum`\n\nerror[E0425]: cannot find value `max_sum` in this\
    \ scope\n  --> /tmp/tmpzf_5bpxo.rs:59:9\n   |\n59 |         max_sum = 0;\n   |\
    \         ^^^^^^^ help: a local variable with a similar name exists: `min_sum`\n\
    \nerror[E0425]: cannot find value `max_sum` in this scope\n  --> /tmp/tmpzf_5bpxo.rs:61:18\n\
    \   |\n61 |     if min_sum > max_sum {\n   |                  ^^^^^^^ help: a\
    \ local variable with a similar name exists: `min_sum`\n\nerror[E0425]: cannot\
    \ find value `max_sum` in this scope\n  --> /tmp/tmpzf_5bpxo.rs:63:19\n   |\n\
    63 |         min_sum = max_sum;\n   |                   ^^^^^^^ help: a local\
    \ variable with a similar name exists: `min_sum`\n\nerror[E0425]: cannot find\
    \ value `max_sum` in this scope\n  --> /tmp/tmpzf_5bpxo.rs:64:9\n   |\n64 |  \
    \       max_sum = tmp;\n   |         ^^^^^^^ help: a local variable with a similar\
    \ name exists: `min_sum`\n\nerror[E0425]: cannot find value `max_sum` in this\
    \ scope\n  --> /tmp/tmpzf_5bpxo.rs:66:19\n   |\n66 |     if min_sum == max_sum\
    \ {\n   |                   ^^^^^^^ help: a local variable with a similar name\
    \ exists: `min_sum`\n\nerror[E0425]: cannot find value `max_sum` in this scope\n\
    \  --> /tmp/tmpzf_5bpxo.rs:77:22\n   |\n77 |         if min_sum < max_sum {\n\
    \   |                      ^^^^^^^ help: a local variable with a similar name\
    \ exists: `min_sum`\n\nerror[E0425]: cannot find value `max_sum` in this scope\n\
    \  --> /tmp/tmpzf_5bpxo.rs:80:27\n   |\n80 |                 min_sum = max_s"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut index = 0;\n\
    \    while index < nums_copy.len() {\n        sum += nums_copy[index];\n     \
    \   if sum < 0 {\n            sum = 0;\n            index += 1;\n        } else\
    \ {\n            nums_sorted.swap(index, index + 1);\n            index += 1;\n\
    \        }\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, -1, -11, -12, 1]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpyyetzahb.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    for num in nums_copy\
    \ {\n        sum += num;\n        nums_sorted.remove(num);\n    }\n    nums_sorted.sort_unstable_by_key(|num|\
    \ sum - num);\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplrah_tpd.rs:14:28\n   |\n\
    14 |         nums_sorted.remove(num);\n   |                            ^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n14 |         nums_sorted.remove(num.try_into().unwrap());\n\
    \   |                               ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut max_sum =\
    \ 0;\n    let mut max_index = 0;\n    for i in nums_copy.iter() {\n        sum\
    \ += *i;\n        if sum > max_sum {\n            max_sum = sum;\n           \
    \ max_index = i;\n        }\n    }\n    for i in nums_copy.iter_mut() {\n    \
    \    *i = *max_index;\n    }\n    nums_sorted.sort_unstable();\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6wce1v6f.rs:18:25\n   |\n\
    13 |     let mut max_index = 0;\n   |                         - expected due to\
    \ this value\n...\n18 |             max_index = i;\n   |                     \
    \    ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n18 |             max_index = *i;\n   |                       \
    \  +\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp6wce1v6f.rs:22:14\n\
    \   |\n22 |         *i = *max_index;\n   |              ^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp_a9dp83r.rs:10:28\n   |\n\
    10 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmp_a9dp83r.rs:12:18\n\
    \    |\n9   |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n10  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    11  | |         let mut sum = 0;\n12  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n13  | |             sum += x;\n14  | |\
    \         }\n15  | |         sum\n16  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmp_a9dp83r.rs:10:27\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n11 | |    \
    \     let mut sum = 0;\n12 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n13 | |             sum +=\
    \ x;\n14 | |         }\n15 | |         sum\n16 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmp_a9dp83r.rs:17:5\n   |\n9  |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_unstable_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_copy {\n            sum +=\
    \ *x;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpa43l5pxj.rs:13:20\n\
    \   |\n13 |             sum += *x;\n   |                    ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    for i in nums_sorted.iter() {\n        sum += *i;\n      \
    \  nums_sorted.swap(i, nums_sorted.iter().position(|&x| x > sum).unwrap());\n\
    \    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo9icv2rl.rs:13:26\n   |\n\
    13 |         nums_sorted.swap(i, nums_sorted.iter().position(|&x| x > sum).unwrap());\n\
    \   |                          ^ expected `usize`, found `&isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = 0;\n    let mut min_idx = nums.len() - 1;\n\
    \    let mut max_sum = 0;\n    let mut max_idx = nums.len() - 1;\n\n    while\
    \ nums_copy.len() > 0 {\n        let mut idx = nums_copy.len() - 1;\n        let\
    \ mut digit = nums_copy[idx];\n        while idx > 0 && digit < 0 {\n        \
    \    idx -= 1;\n            digit = nums_copy[idx];\n        }\n        sum +=\
    \ digit;\n        if sum < min_sum {\n            min_sum = sum;\n           \
    \ min_idx = idx;\n        }\n        if sum > max_sum {\n            max_sum =\
    \ sum;\n            max_idx = idx;\n        }\n        nums_copy.remove(&idx);\n\
    \    }\n\n    if min_sum < 0 {\n        nums_copy.push(0);\n    }\n    if max_sum\
    \ > 0 {\n        nums_copy.push(0);\n    }\n\n    if min_sum < max_sum {\n   \
    \     nums_copy.swap(min_idx, max_idx);\n    }\n\n    nums_copy\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy4dhdgmi.rs:32:26\n   |\n\
    32 |         nums_copy.remove(&idx);\n   |                          ^^^^ expected\
    \ `usize`, found `&usize`\n   |\nhelp: consider removing the borrow\n   |\n32\
    \ -         nums_copy.remove(&idx);\n32 +         nums_copy.remove(idx);\n   |\
    \ \n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .enumerate()\n\
    \        .sort_by(|(idx, _), &x| {\n            let mut sum = 0;\n           \
    \ for &d in &nums[idx] {\n                sum += d;\n            }\n         \
    \   sum\n        })\n        .map(|(idx, _)| nums[idx])\n}\n\nfn main() {\n  \
    \  let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmphj15sdh2.rs:12:10\n   |\n12 |         .sort_by(|(idx,\
    \ _), &x| {\n   |          ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        index += 1;\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x.to_digits(10)\n    });\n    nums_copy\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp8drsm6gf.rs:17:17\n   |\n17 |         sum\
    \ - x.to_digits(10)\n   |                 ^^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
