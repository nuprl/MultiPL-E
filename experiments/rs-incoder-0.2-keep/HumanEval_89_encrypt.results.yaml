name: HumanEval_89_encrypt
language: rust
results:
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ let mut result = String::new();\n    for c in s.chars() {\n        let index\
    \ = alphabet.iter().position(|&x| x == c).unwrap();\n        result += alphabet.iter().skip(index).take(2).collect::<String>();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp92ushe9g.rs:15:19\n   |\n\
    15 |         result += alphabet.iter().skip(index).take(2).collect::<String>();\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                   |\n   |                   expected `&str`, found struct\
    \ `String`\n   |                   help: consider borrowing here: `&alphabet.iter().skip(index).take(2).collect::<String>()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        let index = alphabet.iter().position(|x| x == c).unwrap();\n\
    \        result.push((alphabet.len() - index) as char);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4cb409z6.rs:15:52\n\
    \   |\n15 |         let index = alphabet.iter().position(|x| x == c).unwrap();\n\
    \   |                                                    ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0604]: only `u8` can be cast as `char`, not `usize`\n  --> /tmp/tmp4cb409z6.rs:16:21\n\
    \   |\n16 |         result.push((alphabet.len() - index) as char);\n   |     \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try\
    \ `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmp4cb409z6.rs:16:21\n  \
    \ |\n16 |         result.push((alphabet.len() - index) as char);\n   |       \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0604.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(alphabet[alphabet.index(c) + 1]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpmefstu64.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)\
    \ + 1]);\n   |                                       ^^^^^ method not found in\
    \ `Vec<char>`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmph4vm1d2y.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate();\n    let mut result = String::new();\n\
    \    for c in s.chars() {\n        let mut index = alphabet.index(c);\n      \
    \  index.rotate_left();\n        result.push(alphabet[index]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpzojwhn91.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>();\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    \n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv484jp7h.rs:12:19\n   |\n\
    12 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv484jp7h.rs:13:19\n   |\n13 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv484jp7h.rs:14:19\n   |\n14 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv484jp7h.rs:15:19\n   |\n15 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv484jp7h.rs:16:19\n   |\n16 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv484jp7h.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv484jp7h.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv484jp7h.rs:19:19\n   |\n19 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note:"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate();\n    let mut result = String::new();\n\
    \    for c in s.chars() {\n        let mut new_c = c;\n        alphabet.shift_down();\n\
    \        new_c = alphabet.chars().next().unwrap().to_string() + new_c;\n     \
    \   result.push(new_c);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpaybuexsq.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppd332clu.rs:10:26\n   |\n\
    10 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(alphabet[alphabet.len() - alphabet.iter().rev().next().unwrap()\
    \ - 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `&char` from `usize`\n  --> /tmp/tmplx92yxnp.rs:15:45\n\
    \   |\n15 |         result.push(alphabet[alphabet.len() - alphabet.iter().rev().next().unwrap()\
    \ - 1]);\n   |                                             ^ no implementation\
    \ for `usize - &char`\n   |\n   = help: the trait `Sub<&char>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ let mut result = String::new();\n    let mut shift = 0;\n    for c in s.chars()\
    \ {\n        let index = alphabet.iter().position(|&x| x == c).unwrap();\n   \
    \     alphabet[index] = alphabet[index + 1];\n        alphabet[index + 1] = c;\n\
    \        shift += 2;\n    }\n    for c in alphabet {\n        result.push(c);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp7wal64jm.rs:15:59\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<char>>();\n    alphabet.rotate_left(2);\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpceureef_.rs:68:1\n   |\n68\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpceureef_.rs:13:19\n\
    \   |\n13 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpceureef_.rs:14:19\n   |\n14 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpceureef_.rs:15:19\n   |\n15 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpceureef_.rs:16:19\n   |\n16 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpceureef_.rs:17:19\n   |\n17 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpceureef_.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpceureef_.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpceureef_.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |       "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.swap_remove(alphabet.iter().cloned().skip(alphabet.len()/2));\n   \
    \ alphabet.swap_remove(alphabet.iter().cloned().skip(alphabet.len()/2));\n   \
    \ let mut result = String::new();\n    for c in s.chars() {\n        let mut index\
    \ = alphabet.iter().position(|x| x == c).unwrap();\n        index = alphabet.iter().position(|x|\
    \ x == c.to_ascii_lowercase()).unwrap();\n        result.push((alphabet[index]\
    \ + alphabet[index+1]).to_string());\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv13vjecy.rs:12:26\n   |\n\
    12 |     alphabet.swap_remove(alphabet.iter().cloned().skip(alphabet.len()/2));\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found struct `Skip`\n   |\n   = note: expected type `usize`\n\
    \            found struct `Skip<Cloned<std::slice::Iter<'_, char>>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv13vjecy.rs:13:26\n   |\n13 |     alphabet.swap_remove(alphabet.iter().cloned().skip(alphabet.len()/2));\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found struct `Skip`\n   |\n   = note: expected type `usize`\n\
    \            found struct `Skip<Cloned<std::slice::Iter<'_, char>>>`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpv13vjecy.rs:16:56\n   |\n16\
    \ |         let mut index = alphabet.iter().position(|x| x == c).unwrap();\n \
    \  |                                                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpv13vjecy.rs:17:48\n\
    \   |\n17 |         index = alphabet.iter().position(|x| x == c.to_ascii_lowercase()).unwrap();\n\
    \   |                                                ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpv13vjecy.rs:18:38\n \
    \  |\n18 |         result.push((alphabet[index] + alphabet[index+1]).to_string());\n\
    \   |                      --------------- ^ ----------------- char\n   |    \
    \                  |\n   |                      char\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 'v', 'u', 't', 's', 'r', 'q', 'p',\
    \ 'o', 'n', 'm', 'l', 'k', 'j', 'h', 'i', 'e', 'f', 'g', 'h', 'j', 'k', 'l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'y', 'x', 'z'];\n    alphabet.rotate_left(2);\n\
    \    alphabet.push(alphabet[0]);\n    alphabet.push(alphabet[1]);\n    alphabet.push(alphabet[2]);\n\
    \    alphabet.push(alphabet[3]);\n    alphabet.push(alphabet[4]);\n    alphabet.push(alphabet[5]);\n\
    \    alphabet.push(alphabet[6]);\n    alphabet.push(alphabet[7]);\n    alphabet.push(alphabet[8]);\n\
    \    alphabet.push(alphabet[9]);\n    alphabet.push(alphabet[10]);\n    alphabet.push(alphabet[11]);\n\
    \    alphabet.push(alphabet[12]);\n    alphabet.push(alphabet[13]);\n    alphabet.push(alphabet[14]);\n\
    \    alphabet.push(alphabet[15]);\n    alphabet.push(alphabet[16]);\n    alphabet.push(alphabet[17]);\n\
    \    alphabet.push(alphabet[18]);\n    alphabet.push(alphabet[19]);\n    alphabet.push(alphabet[20]);\n\
    \    alphabet.push(alphabet[21]);\n    alphabet.push(alphabet[22]);\n    alphabet.push(alphabet[23]);\n\
    \    alphabet.push(alphabet[24]);\n    alphabet.push(alphabet[25]);\n    alphabet.push(alphabet[26]);\n\
    \    alphabet.push(alphabet[27]);\n    alphabet.push(alphabet[28]);\n    alphabet.push(alphabet[29]);\n\
    \    alphabet.push(alphabet[30]);\n    alphabet.push(alphabet[31]);\n    alphabet.push(alphabet[32]);\n\
    \    alphabet.push(alphabet[33]);\n    alphabet.push(alphabet[34]);\n    alphabet.push(alphabet[35]);\n\
    \    alphabet.push(alphabet[36]);\n    alphabet.push(alphabet[37]);\n    alphabet.push(alphabet[38]);\n\
    \    alphabet.push(alphabet[39]);\n    alphabet.push(alphabet[40]);\n    alphabet.push(alphabet[41]);\n\
    \    alphabet.push(alphabet[42]);\n    alphabet.push(alphabet[43]);\n    alphabet.push(alphabet[44]);\n\
    \    alphabet.push(alphabet[45]);\n    alphabet.push(alphabet[46]);\n    alphabet.push(alphabet[47]);\n\
    \    alphabet.push(alphabet[48]);\n    alphabet.push(alphabet[49]);\n\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6maiec5u.rs:10:26\n   |\n\
    10 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<char>>();\n    alphabet.rotate_left(2);\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv37d8y9_.rs:13:19\n   |\n\
    13 |     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n13 |     alphabet.push(*alphabet.last().unwrap());\n   |              \
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv37d8y9_.rs:14:19\n \
    \  |\n14 |     alphabet.push(alphabet.last().unwrap());\n   |                \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n14 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv37d8y9_.rs:15:19\n\
    \   |\n15 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n15 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv37d8y9_.rs:16:19\n\
    \   |\n16 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n16 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv37d8y9_.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n17 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv37d8y9_.rs:18:19\n\
    \   |\n18 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv37d8y9_.rs:19:19\n\
    \   |\n19 |     alphabet.push(alphabet.last"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate(2);\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(alphabet[alphabet.len() - alphabet.index(c)]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate` found for struct `Vec<char>` in\
    \ the current scope\n  --> /tmp/tmp8xy12wjy.rs:12:14\n   |\n12 |     alphabet.rotate(2);\n\
    \   |              ^^^^^^ help: there is an associated function with a similar\
    \ name: `rotate_left`\n\nerror[E0599]: no method named `index` found for struct\
    \ `Vec<char>` in the current scope\n  --> /tmp/tmp8xy12wjy.rs:15:56\n   |\n15\
    \ |         result.push(alphabet[alphabet.len() - alphabet.index(c)]);\n   | \
    \                                                       ^^^^^ method not found\
    \ in `Vec<char>`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\
    \    alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c\
    \ in s.chars() {\n        result.push(alphabet[alphabet.index(c) + 1]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp6qii73ka.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)\
    \ + 1]);\n   |                                       ^^^^^ method not found in\
    \ `Vec<char>`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.rotate_left(2);\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpe03lutki.rs:68:1\n   |\n68\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe03lutki.rs:13:19\n\
    \   |\n13 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe03lutki.rs:14:19\n   |\n14 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe03lutki.rs:15:19\n   |\n15 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe03lutki.rs:16:19\n   |\n16 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe03lutki.rs:17:19\n   |\n17 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe03lutki.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe03lutki.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe03lutki.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |       "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.rotate_left(2);\n  \
    \  alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptwxov3li.rs:13:19\n   |\n\
    13 |     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n13 |     alphabet.push(*alphabet.last().unwrap());\n   |              \
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptwxov3li.rs:14:19\n \
    \  |\n14 |     alphabet.push(alphabet.last().unwrap());\n   |                \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n14 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptwxov3li.rs:15:19\n\
    \   |\n15 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n15 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptwxov3li.rs:16:19\n\
    \   |\n16 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n16 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptwxov3li.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n17 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptwxov3li.rs:18:19\n\
    \   |\n18 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptwxov3li.rs:19:19\n\
    \   |\n19 |     alphabet.push(alphabet.last"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(alphabet[alphabet.index(c) + 1]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp7e_d0wqj.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)\
    \ + 1]);\n   |                                       ^^^^^ method not found in\
    \ `Vec<char>`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphab\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpschtv512.rs:67:18\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n67 |     alphabet.push(alphab\n\
    \   |                  ^ unclosed delimiter\n68 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0425]: cannot find value `alphab` in this scope\n  --> /tmp/tmpschtv512.rs:67:19\n\
    \   |\n67 |     alphabet.push(alphab\n   |                   ^^^^^^ help: a local\
    \ variable with a similar name exists: `alphabet`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpschtv512.rs:13:19\n   |\n13 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found\
    \ enum `Option`\n   |\n   = note: expected struct `std::ops::Range<char>`\n  \
    \              found enum `Option<&std::ops::Range<char>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpschtv512.rs:14:19\n   |\n14 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found\
    \ enum `Option`\n   |\n   = note: expected struct `std::ops::Range<char>`\n  \
    \              found enum `Option<&std::ops::Range<char>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpschtv512.rs:15:19\n   |\n15 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found\
    \ enum `Option`\n   |\n   = note: expected struct `std::ops::Range<char>`\n  \
    \              found enum `Option<&std::ops::Range<char>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpschtv512.rs:16:19\n   |\n16 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found\
    \ enum `Option`\n   |\n   = note: expected struct `std::ops::Range<char>`\n  \
    \              found enum `Option<&std::ops::Range<char>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpschtv512.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found\
    \ enum `Option`\n   |\n   = note: expected struct"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r', 'q', 'p', 'o',\
    \ 'n', 'm', 'l', 'k', 'j', 'h', 'i', 'a'];\n    alphabet.rotate_left(2);\n   \
    \ let mut result = String::new();\n    for c in s.chars() {\n        result.push(alphabet[alphabet.index(c)]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpkmi_7abq.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)]);\n\
    \   |                                       ^^^^^ method not found in `Vec<char>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `swap` on type `Vec<char>`\n\
    \  --> /tmp/tmp_bme1u97.rs:53:14\n   |\n53 |     alphabet.swap\n   |         \
    \     ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n\
    \   |\n53 |     alphabet.swap(_, _)\n   |                  ++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().map(|c| c as char).collect::<Vec<_>>();\n    alphabet.rotate_left(2);\n\
    \    alphabet.iter().map(|c| c as char).collect::<String>()\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0606]: casting `&char` as `char` is invalid\n  --> /tmp/tmp5nxvjjmq.rs:13:29\n\
    \   |\n13 |     alphabet.iter().map(|c| c as char).collect::<String>()\n   | \
    \                            ^^^^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0606`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<char>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet =\
    \ alphabet.iter().cloned().collect::<Vec<char>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet =\
    \ alphabet.iter().cloned().collect::<Vec<char>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet =\
    \ alphabet.iter().cloned().collect::<Vec<char>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet =\
    \ alphabet.iter().cloned().collect::<Vec<char>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet =\
    \ alphabet.iter().cloned().collect::<Vec<char>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet =\
    \ alphabet.iter().cloned().collect::<Vec<char>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet =\
    \ alphabet.iter().cloned().collect::<Vec<char>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet =\
    \ alphabet.iter().cloned().collect::<Vec<char>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet =\
    \ alphabet.iter().cloned().collect::<Vec<char>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet =\
    \ alphabet.iter().cloned().collect::<Vec<char>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet =\
    \ alphabet.iter().cloned().collect::<Vec<char>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6me0fazh.rs:10:26\n   |\n\
    10 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().map(|c| c as u32).collect::<Vec<_>>();\n    alphabet.rotate_left(2);\n\
    \    alphabet.iter().map(|c| c as char).collect::<Vec<_>>().join(\"\").to_string()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: the method `join` exists for struct `Vec<char>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmpne0xndt_.rs:13:60\n   |\n13 |\
    \     alphabet.iter().map(|c| c as char).collect::<Vec<_>>().join(\"\").to_string()\n\
    \   |                                                            ^^^^ method cannot\
    \ be called on `Vec<char>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `[char]: Join<_>`\n\n\
    error[E0606]: casting `&u32` as `char` is invalid\n  --> /tmp/tmpne0xndt_.rs:13:29\n\
    \   |\n13 |     alphabet.iter().map(|c| c as char).collect::<Vec<_>>().join(\"\
    \").to_string()\n   |                             -^^^^^^^^\n   |            \
    \                 |\n   |                             cannot cast `&u32` as `char`\n\
    \   |                             help: dereference the expression: `*c`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0606.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate(2);\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(alphabet[alphabet.index(c) + 1]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate` found for struct `Vec<char>` in\
    \ the current scope\n  --> /tmp/tmpn1uaewl4.rs:12:14\n   |\n12 |     alphabet.rotate(2);\n\
    \   |              ^^^^^^ help: there is an associated function with a similar\
    \ name: `rotate_left`\n\nerror[E0599]: no method named `index` found for struct\
    \ `Vec<char>` in the current scope\n  --> /tmp/tmpn1uaewl4.rs:15:39\n   |\n15\
    \ |         result.push(alphabet[alphabet.index(c) + 1]);\n   |              \
    \                         ^^^^^ method not found in `Vec<char>`\n   |\n   = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1\
    \  | use std::ops::Index;\n   |\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r', 'q', 'p', 'o',\
    \ 'n', 'm', 'l', 'k', 'j', 'i', 'h', 'g', 'f', 'e', 'd', 'c', 'b', 'a'];\n   \
    \ alphabet.rotate_left(2);\n    alphabet.push(alphabet[0]);\n    alphabet.push(alphabet[1]);\n\
    \    alphabet.push(alphabet[2]);\n    alphabet.push(alphabet[3]);\n    alphabet.push(alphabet[4]);\n\
    \    alphabet.push(alphabet[5]);\n    alphabet.push(alphabet[6]);\n    alphabet.push(alphabet[7]);\n\
    \    alphabet.push(alphabet[8]);\n    alphabet.push(alphabet[9]);\n    alphabet.push(alphabet[10]);\n\
    \    alphabet.push(alphabet[11]);\n    alphabet.push(alphabet[12]);\n    alphabet.push(alphabet[13]);\n\
    \    alphabet.push(alphabet[14]);\n    alphabet.push(alphabet[15]);\n    alphabet.push(alphabet[16]);\n\
    \    alphabet.push(alphabet[17]);\n    alphabet.push(alphabet[18]);\n    alphabet.push(alphabet[19]);\n\
    \    alphabet.push(alphabet[20]);\n    alphabet.push(alphabet[21]);\n    alphabet.push(alphabet[22]);\n\
    \    alphabet.push(alphabet[23]);\n    alphabet.push(alphabet[24]);\n    alphabet.push(alphabet[25]);\n\
    \    alphabet.push(alphabet[26]);\n    alphabet.push(alphabet[27]);\n    alphabet.push(alphabet[28]);\n\
    \    alphabet.push(alphabet[29]);\n    alphabet.push(alphabet[30]);\n    alphabet.push(alphabet[31]);\n\
    \    alphabet.push(alphabet[32]);\n    alphabet.push(alphabet[33]);\n    alphabet.push(alphabet[34]);\n\
    \    alphabet.push(alphabet[35]);\n    alphabet.push(alphabet[36]);\n    alphabet.push(alphabet[37]);\n\
    \    alphabet.push(alphabet[38]);\n    alphabet.push(alphabet[39]);\n    alphabet.push(alphabet[40]);\n\
    \    alphabet.push(alphabet[41]);\n    alphabet.push(alphabet[42]);\n    alphabet.push(alphabet[43]);\n\
    \    alphabet.push(alphabet[44]);\n    alphabet.push(alphabet[45]);\n    alphabet.push(alphabet[46]);\n\
    \    alphabet.push(alphabet[47]);\n    alphabet.push(alphabet[48]);\n    alphabet.push(alphabet[49]);\n\
    \    alphabet.push(alphabet[50]);\n    alphabet.push(alphabet[51]);\n    alphabet.push(alphabet\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp0y592v9o.rs:65:18\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n65 |     alphabet.push(alphabet\n\
    \   |                  ^ unclosed delimiter\n66 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0y592v9o.rs:65:19\n\
    \   |\n65 |     alphabet.push(alphabet\n   |                   ^^^^^^^^ expected\
    \ `char`, found struct `Vec`\n   |\n   = note: expected type `char`\n        \
    \    found struct `Vec<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0y592v9o.rs:65:5\n\
    \   |\n10 |   fn encrypt(s: String) -> String {\n   |                        \
    \    ------ expected `String` because of return type\n...\n65 | /     alphabet.push(alphabet\n\
    66 | | }\n   | |_^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<char>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `swap` on type `Vec<char>`\n\
    \  --> /tmp/tmpf6ebtwjv.rs:53:14\n   |\n53 |     alphabet.swap\n   |         \
    \     ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n\
    \   |\n53 |     alphabet.swap(_, _)\n   |                  ++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ let mut result = String::new();\n    for c in s.chars() {\n        let mut i\
    \ = alphabet.iter().position(|&x| x == c).unwrap();\n        let mut j = alphabet.iter().position(|&x|\
    \ x == c).unwrap();\n        let mut k = alphabet.iter().position(|&x| x == c).unwrap();\n\
    \        if i == 0 {\n            i += 2;\n        }\n        if j == 0 {\n  \
    \          j += 2;\n        }\n        if k == 0 {\n            k += 2;\n    \
    \    }\n        result.push_str(&alphabet[(i + k + j) % alphabet.len()]);\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuxcoxn99.rs:26:25\n   |\n\
    26 |         result.push_str(&alphabet[(i + k + j) % alphabet.len()]);\n   | \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r', 'q', 'p', 'o',\
    \ 'n', 'm', 'l', 'k', 'j', 'i', 'h', 'g', 'f', 'e', 'd', 'c', 'b', 'a'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(alphabet[alphabet.index(c) + 1]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmppm_4om92.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)\
    \ + 1]);\n   |                                       ^^^^^ method not found in\
    \ `Vec<char>`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push((alphabet.last() + alphabet.first()).chars().nth(alphabet.index(c)\
    \ + 1).unwrap());\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `Option<&char>` to `Option<&char>`\n  --> /tmp/tmpat0sg75a.rs:15:38\n\
    \   |\n15 |         result.push((alphabet.last() + alphabet.first()).chars().nth(alphabet.index(c)\
    \ + 1).unwrap());\n   |                      --------------- ^ ----------------\
    \ Option<&char>\n   |                      |\n   |                      Option<&char>\n\
    \nerror[E0599]: no method named `index` found for struct `Vec<char>` in the current\
    \ scope\n  --> /tmp/tmpat0sg75a.rs:15:79\n   |\n15 |         result.push((alphabet.last()\
    \ + alphabet.first()).chars().nth(alphabet.index(c) + 1).unwrap());\n   |    \
    \                                                                           ^^^^^\
    \ method not found in `Vec<char>`\n   |\n   = help: items from traits can only\
    \ be used if the trait is in scope\nhelp: the following trait is implemented but\
    \ not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0369, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(*alphabet.iter().find(|&x| x == c).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1u0ambg2.rs:15:50\n\
    \   |\n15 |         result.push(*alphabet.iter().find(|&x| x == c).unwrap());\n\
    \   |                                                  ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        let mut c = c.to_ascii_lowercase();\n\
    \        c.rotate_left(2);\n        result.push(c);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpz0h8mn3p.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0599]:\
    \ no method named `rotate_left` found for type `char` in the current scope\n \
    \ --> /tmp/tmpz0h8mn3p.rs:16:11\n   |\n16 |         c.rotate_left(2);\n   |  \
    \         ^^^^^^^^^^^ method not found in `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y',\
    \ 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w',\
    \ 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y',\
    \ 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y',\
    \ 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w',\
    \ 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y',\
    \ 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y',\
    \ 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w',\
    \ 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y',\
    \ 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y',\
    \ 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w',\
    \ 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y',\
    \ 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y',\
    \ 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w',\
    \ 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y',\
    \ 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y',\
    \ 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w',\
    \ 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y',\
    \ 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y',\
    \ 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w',\
    \ 'u', 'v', '\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpo86ju422.rs:11:1619\n\
    \   |\n11 | ... 'v', 'u', 'y', 'v', 'x', 'w', 'y', 'z', 'y', 'x', 'w', 'u', 'v',\
    \ '\n   |                                                                    \
    \  ^\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push_str(&alphabet[alphabet.index(c)]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpxlpeh5wo.rs:15:44\n   |\n15 |         result.push_str(&alphabet[alphabet.index(c)]);\n\
    \   |                                            ^^^^^ method not found in `Vec<char>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n    let\
    \ mut result = String::new();\n    for c in s.chars() {\n        result.push((alphabet.iter().find(|&x|\
    \ x == c).unwrap() + 2) % 26);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&std::ops::Range<char>` with `char`\n  -->\
    \ /tmp/tmp_c7v64kb.rs:15:50\n   |\n15 |         result.push((alphabet.iter().find(|&x|\
    \ x == c).unwrap() + 2) % 26);\n   |                                         \
    \         ^^ no implementation for `&std::ops::Range<char> == char`\n   |\n  \
    \ = help: the trait `PartialEq<char>` is not implemented for `&std::ops::Range<char>`\n\
    \   = help: the trait `PartialEq` is implemented for `std::ops::Range<Idx>`\n\n\
    error[E0369]: cannot add `{integer}` to `&std::ops::Range<char>`\n  --> /tmp/tmp_c7v64kb.rs:15:65\n\
    \   |\n15 |         result.push((alphabet.iter().find(|&x| x == c).unwrap() +\
    \ 2) % 26);\n   |                      ------------------------------------------\
    \ ^ - {integer}\n   |                      |\n   |                      &std::ops::Range<char>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.iter().for_each(|c| {\n        if s.chars().any(|c| c == c) {\n\
    \            alphabet.push(c);\n        }\n    });\n    alphabet.iter().for_each(|c|\
    \ {\n        if s.chars().any(|c| c == c) {\n            alphabet.push(c);\n \
    \       }\n    });\n    alphabet.iter().for_each(|c| {\n        if s.chars().any(|c|\
    \ c == c) {\n            alphabet.push(c);\n        }\n    });\n    alphabet.iter().for_each(|c|\
    \ {\n        if s.chars().any(|c| c == c) {\n            alphabet.push(c);\n \
    \       }\n    });\n    alphabet.iter().for_each(|c| {\n        if s.chars().any(|c|\
    \ c == c) {\n            alphabet.push(c);\n        }\n    });\n    alphabet.iter().for_each(|c|\
    \ {\n        if s.chars().any(|c| c == c) {\n            alphabet.push(c);\n \
    \       }\n    });\n    alphabet.iter().for_each(|c| {\n        if s.chars().any(|c|\
    \ c == c) {\n            alphabet.push(c);\n        }\n    });\n    alphabet.iter().for_each(|c|\
    \ {\n        if s.chars().any(|c| c == c) {\n            alphabet.push(c);\n \
    \       }\n    });\n    alphabet.iter().for_each(|c| {\n        if s.chars().any(|c|\
    \ c == c) {\n            alphabet.push(c);\n        }\n    });\n    alphabet.iter().for_each(|c|\
    \ {\n        if s.chars().any(|c| c == c) {\n            alphabet.push(c);\n \
    \       }\n    });\n    alphabet.iter().for_each(|c| {\n        if s.chars().any(|c|\
    \ c == c) {\n            alphabet.push(c);\n        }\n    });\n    alphabet.iter().for_each(|c|\
    \ {\n        if s.chars().any(|c| c == c) {\n            alphabet.push(c);\n \
    \       }\n    });\n    alphabet.iter().for_each(|c| {\n        if s.chars().any(|c|\
    \ c == c) {\n            alphabet.push(c);\n        }\n    });\n    alphabet.iter().for_each(|c|\
    \ {\n        if s.chars().any(|c| c == c) {\n            alphabet.push(c);\n \
    \       }\n    });\n    alphabet.iter().for_each(|c| {\n        if s.chars().any(|c|\
    \ c == c) {\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpuzbh4x0w.rs:98:3\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - unclosed delimiter\n...\n84 |     alphabet.iter().for_each(|c| {\n \
    \  |                             -    - unclosed delimiter\n   |             \
    \                |\n   |                             unclosed delimiter\n85 |\
    \         if s.chars().any(|c| c == c) {\n   |                               \
    \       - this delimiter might not be properly closed...\n86 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n98 | }\n   |   ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpuzbh4x0w.rs:16:27\n   |\n16 |  \
    \           alphabet.push(c);\n   |                           ^ expected struct\
    \ `std::ops::Range`, found reference\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \           found reference `&std::ops::Range<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuzbh4x0w.rs:21:27\n   |\n21 |             alphabet.push(c);\n\
    \   |                           ^ expected struct `std::ops::Range`, found reference\n\
    \   |\n   = note: expected struct `std::ops::Range<char>`\n           found reference\
    \ `&std::ops::Range<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuzbh4x0w.rs:26:27\n\
    \   |\n26 |             alphabet.push(c);\n   |                           ^ expected\
    \ struct `std::ops::Range`, found reference\n   |\n   = note: expected struct\
    \ `std::ops::Range<char>`\n           found reference `&std::ops::Range<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpuzbh4x0w.rs:31:27\n   |\n31 |\
    \             alphabet.push(c);\n   |                           ^ expected struct\
    \ `std::ops::Range`, found reference\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \           found reference `&std::ops::Range<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuzbh4x0w.rs:36:27\n   |\n36 |             alphabet.push(c);\n\
    \   |                           ^ expected struct `std::ops::Range`, found reference\n\
    \   |\n   = note: expected struct `std::ops::Range<char>`\n           found referenc"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.first());\n    alphabet.push(alphabet.first());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n   \
    \ alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n \
    \   alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n   \
    \ alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n \
    \   alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n   \
    \ alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n \
    \   alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n   \
    \ alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n \
    \   alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n   \
    \ alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n \
    \   alphabet.push(alphab\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpg041nht6.rs:67:18\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n67 |     alphabet.push(alphab\n\
    \   |                  ^ unclosed delimiter\n68 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0425]: cannot find value `alphab` in this scope\n  --> /tmp/tmpg041nht6.rs:67:19\n\
    \   |\n67 |     alphabet.push(alphab\n   |                   ^^^^^^ help: a local\
    \ variable with a similar name exists: `alphabet`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg041nht6.rs:13:19\n   |\n13 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found\
    \ enum `Option`\n   |\n   = note: expected struct `std::ops::Range<char>`\n  \
    \              found enum `Option<&std::ops::Range<char>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg041nht6.rs:14:19\n   |\n14 |     alphabet.push(alphabet.first());\n\
    \   |                   ^^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found\
    \ enum `Option`\n   |\n   = note: expected struct `std::ops::Range<char>`\n  \
    \              found enum `Option<&std::ops::Range<char>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg041nht6.rs:15:19\n   |\n15 |     alphabet.push(alphabet.first());\n\
    \   |                   ^^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found\
    \ enum `Option`\n   |\n   = note: expected struct `std::ops::Range<char>`\n  \
    \              found enum `Option<&std::ops::Range<char>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg041nht6.rs:16:19\n   |\n16 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found\
    \ enum `Option`\n   |\n   = note: expected struct `std::ops::Range<char>`\n  \
    \              found enum `Option<&std::ops::Range<char>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg041nht6.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found\
    \ enum `Option`\n   |\n   = note: expected st"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `swap` on type `Vec<char>`\n\
    \  --> /tmp/tmpgurv5e_2.rs:53:14\n   |\n53 |     alphabet.swap\n   |         \
    \     ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n\
    \   |\n53 |     alphabet.swap(_, _)\n   |                  ++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push((alphabet.iter().find(|&x| x == c).unwrap()\
    \ + 2) as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0iyyf7oz.rs:15:50\n\
    \   |\n15 |         result.push((alphabet.iter().find(|&x| x == c).unwrap() +\
    \ 2) as char);\n   |                                                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0369]: cannot add `{integer}` to `&char`\n  --> /tmp/tmp0iyyf7oz.rs:15:65\n\
    \   |\n15 |         result.push((alphabet.iter().find(|&x| x == c).unwrap() +\
    \ 2) as char);\n   |                      ------------------------------------------\
    \ ^ - {integer}\n   |                      |\n   |                      &char\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 't', 's', 'r', 'q', 'p', 'o', 'n',\
    \ 'm', 'l', 'k', 'j', 'i', 'h', 'g', 'f', 'e', 'd', 'c', 'b', 'a'];\n    alphabet.sort_unstable();\n\
    \    let mut result = String::new();\n    for c in s.chars() {\n        let index\
    \ = alphabet.iter().position(|&x| x == c).unwrap();\n        result.push_str(&alphabet[(index\
    \ * 2)..(index * 2 + 2)]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq1j__v83.rs:16:25\n   |\n\
    16 |         result.push_str(&alphabet[(index * 2)..(index * 2 + 2)]);\n   | \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found slice `[char]`\n   |\n   = note: expected reference `&str`\n         \
    \     found reference `&[char]`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(alphabet[alphabet.index(c) + 1]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp9qk9n5bq.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)\
    \ + 1]);\n   |                                       ^^^^^ method not found in\
    \ `Vec<char>`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate_left(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        let index = alphabet.iter().position(|&x|\
    \ x == c).unwrap();\n        result.push_str(&alphabet[index..alphabet.len() -\
    \ index]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk1jn2_g3.rs:15:56\n   |\n\
    15 |         let index = alphabet.iter().position(|&x| x == c).unwrap();\n   |\
    \                                                        ^ expected struct `std::ops::Range`,\
    \ found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n   \
    \             found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk1jn2_g3.rs:16:25\n\
    \   |\n16 |         result.push_str(&alphabet[index..alphabet.len() - index]);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found slice\n   |\n   = note: expected reference `&str`\n           \
    \   found reference `&[std::ops::Range<char>]`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ let mut alphabet2 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',\
    \ 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet3 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet4 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet5 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet6 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet7 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet8 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet9 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet10 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet11 = vec!['A', 'B', 'C', 'D', 'E\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp_giypieu.rs:22:1\n   |\n22 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp_giypieu.rs:21:30\n   |\n10 | fn encrypt(s: String) -> String {\n  \
    \ |                                 - closing delimiter possibly meant for this\n\
    ...\n21 |     let mut alphabet11 = vec!['A', 'B', 'C', 'D', 'E\n   |         \
    \                     ^ unclosed delimiter\n22 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpy41k7594.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate_left(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        result.push((alphabet.iter().find(|&x|\
    \ x == c).unwrap() + 2) % 26 + 'A');\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&std::ops::Range<char>` with `char`\n  -->\
    \ /tmp/tmp0_v1vk6r.rs:15:50\n   |\n15 |         result.push((alphabet.iter().find(|&x|\
    \ x == c).unwrap() + 2) % 26 + 'A');\n   |                                   \
    \               ^^ no implementation for `&std::ops::Range<char> == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `&std::ops::Range<char>`\n\
    \   = help: the trait `PartialEq` is implemented for `std::ops::Range<Idx>`\n\n\
    error[E0369]: cannot add `{integer}` to `&std::ops::Range<char>`\n  --> /tmp/tmp0_v1vk6r.rs:15:65\n\
    \   |\n15 |         result.push((alphabet.iter().find(|&x| x == c).unwrap() +\
    \ 2) % 26 + 'A');\n   |                      ------------------------------------------\
    \ ^ - {integer}\n   |                      |\n   |                      &std::ops::Range<char>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n\
    \    alphabet.iter().map(|c| c.to_string()).collect::<Vec<_>>().join(\"\")\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2opf72h9.rs:13:19\n   |\n\
    13 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2opf72h9.rs:14:19\n   |\n14 |     alphabet.push(alphabet.first());\n\
    \   |                   ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        let c = alphabet.find(c);\n\
    \        result.push(c);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp1tbp8goo.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % \n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpkthkhlrt.rs:47:18\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n47 |     alphabet.push((alphabet.last()\
    \ + 2) % \n   |                  ^ unclosed delimiter\n48 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror: expected expression, found `)`\n  --> /tmp/tmpkthkhlrt.rs:48:1\n\
    \   |\n48 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkthkhlrt.rs:12:19\n   |\n12 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<&char>`\n  --> /tmp/tmpkthkhlrt.rs:13:36\n\
    \   |\n13 |     alphabet.push((alphabet.last() + 2) % 26);\n   |             \
    \       --------------- ^ - {integer}\n   |                    |\n   |       \
    \             Option<&char>\n\nerror[E0369]: cannot add `{integer}` to `Option<&char>`\n\
    \  --> /tmp/tmpkthkhlrt.rs:14:36\n   |\n14 |     alphabet.push((alphabet.last()\
    \ + 2) % 26);\n   |                    --------------- ^ - {integer}\n   |   \
    \                 |\n   |                    Option<&char>\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<&char>`\n  --> /tmp/tmpkthkhlrt.rs:15:36\n   |\n\
    15 |     alphabet.push((alphabet.last() + 2) % 26);\n   |                    ---------------\
    \ ^ - {integer}\n   |                    |\n   |                    Option<&char>\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<&char>`\n  --> /tmp/tmpkthkhlrt.rs:16:36\n\
    \   |\n16 |     alphabet.push((alphabet.last() + 2) % 26);\n   |             \
    \       --------------- ^ - {integer}\n   |                    |\n   |       \
    \             Option<&char>\n\nerror[E0369]: cannot add `{integer}` to `Option<&char>`\n\
    \  --> /tmp/tmpkthkhlrt.rs:17:36\n   |\n17 |     alphabet.push((alphabet.last()\
    \ + 2) % 26);\n   |                    --------------- ^ - {integer}\n   |   \
    \                 |\n   |                    Option<&char>\n\nerror[E0369]: cann"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmplmfjltvv.rs:66:18\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n66 |     alphabet.push(alphabet.clone\n\
    \   |                  ^ unclosed delimiter\n67 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplmfjltvv.rs:12:19\n\
    \   |\n12 |     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `std::ops::Range<_>`\n              found struct `Vec<std::ops::Range<_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplmfjltvv.rs:13:19\n   |\n13 |\
    \     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `std::ops::Range<_>`\n              found struct `Vec<std::ops::Range<_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplmfjltvv.rs:14:19\n   |\n14 |\
    \     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `std::ops::Range<_>`\n              found struct `Vec<std::ops::Range<_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplmfjltvv.rs:15:19\n   |\n15 |\
    \     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `std::ops::Range<_>`\n              found struct `Vec<std::ops::Range<_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplmfjltvv.rs:16:19\n   |\n16 |\
    \     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `std::ops::Range<_>`\n              found struct `Vec<std::ops::Range<_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplmfjltvv.rs:17:19\n   |\n17 |\
    \     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 'v', 't', 's', 'r', 'q', 'p', 'o',\
    \ 'n', 'm', 'l', 'k', 'j', 'i', 'h', 'g', 'f', 'e', 'd', 'c', 'b', 'a'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push((alphabet.iter().find(|&x| x == c).unwrap()\
    \ + 2) % 26);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmph40fh91d.rs:15:50\n\
    \   |\n15 |         result.push((alphabet.iter().find(|&x| x == c).unwrap() +\
    \ 2) % 26);\n   |                                                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0369]: cannot add `{integer}` to `&char`\n  --> /tmp/tmph40fh91d.rs:15:65\n\
    \   |\n15 |         result.push((alphabet.iter().find(|&x| x == c).unwrap() +\
    \ 2) % 26);\n   |                      ------------------------------------------\
    \ ^ - {integer}\n   |                      |\n   |                      &char\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>();\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    \n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5h3yqo5k.rs:12:19\n   |\n\
    12 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5h3yqo5k.rs:13:19\n   |\n13 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5h3yqo5k.rs:14:19\n   |\n14 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5h3yqo5k.rs:15:19\n   |\n15 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5h3yqo5k.rs:16:19\n   |\n16 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5h3yqo5k.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5h3yqo5k.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5h3yqo5k.rs:19:19\n   |\n19 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note:"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 'v', 't', 's', 'r', 'q', 'p', 'o',\
    \ 'n', 'm', 'l', 'k', 'j', 'h', 'i', 'a'];\n    alphabet.rotate_left(2);\n   \
    \ let mut result = String::new();\n    for c in s.chars() {\n        result.push_str(&alphabet[alphabet.index(c)\
    \ + alphabet.len()]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpmgbyv5sk.rs:15:44\n   |\n15 |         result.push_str(&alphabet[alphabet.index(c)\
    \ + alphabet.len()]);\n   |                                            ^^^^^ method\
    \ not found in `Vec<char>`\n   |\n   = help: items from traits can only be used\
    \ if the trait is in scope\nhelp: the following trait is implemented but not in\
    \ scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphab\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpehvwkyub.rs:67:18\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n67 |     alphabet.push(alphab\n\
    \   |                  ^ unclosed delimiter\n68 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0425]: cannot find value `alphab` in this scope\n  --> /tmp/tmpehvwkyub.rs:67:19\n\
    \   |\n67 |     alphabet.push(alphab\n   |                   ^^^^^^ help: a local\
    \ variable with a similar name exists: `alphabet`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpehvwkyub.rs:13:19\n   |\n13 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found\
    \ enum `Option`\n   |\n   = note: expected struct `std::ops::Range<char>`\n  \
    \              found enum `Option<&std::ops::Range<char>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpehvwkyub.rs:14:19\n   |\n14 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found\
    \ enum `Option`\n   |\n   = note: expected struct `std::ops::Range<char>`\n  \
    \              found enum `Option<&std::ops::Range<char>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpehvwkyub.rs:15:19\n   |\n15 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found\
    \ enum `Option`\n   |\n   = note: expected struct `std::ops::Range<char>`\n  \
    \              found enum `Option<&std::ops::Range<char>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpehvwkyub.rs:16:19\n   |\n16 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found\
    \ enum `Option`\n   |\n   = note: expected struct `std::ops::Range<char>`\n  \
    \              found enum `Option<&std::ops::Range<char>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpehvwkyub.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found\
    \ enum `Option`\n   |\n   = note: expected struct"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    let mut cipher\
    \ = String::new();\n    cipher.push_str(s);\n    for c in cipher.chars() {\n \
    \       cipher.push(alphabet.index(c));\n    }\n    cipher\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp4r4f_dus.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4r4f_dus.rs:14:21\n   |\n14 |     cipher.push_str(s);\n\
    \   |                     ^\n   |                     |\n   |                \
    \     expected `&str`, found struct `String`\n   |                     help: consider\
    \ borrowing here: `&s`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.push('A');\n    alphabet.push('B');\n\
    \    alphabet.push('C');\n    alphabet.push('D');\n    alphabet.push('E');\n \
    \   alphabet.push('F');\n    alphabet.push('G');\n    alphabet.push('H');\n  \
    \  alphabet.push('I');\n    alphabet.push('J');\n    alphabet.push('K');\n   \
    \ alphabet.push('L');\n    alphabet.push('M');\n    alphabet.push('N');\n    alphabet.push('O');\n\
    \    alphabet.push('A');\n    alphabet.push('B');\n    alphabet.push('C');\n \
    \   alphabet.push('D');\n    alphabet.push('E');\n    alphabet.push('F');\n  \
    \  alphabet.push('G');\n    alphabet.push('H');\n    alphabet.push('I');\n   \
    \ alphabet.push('J');\n    alphabet.push('K');\n    alphabet.push('L');\n    alphabet.push('M');\n\
    \    alphabet.push('N');\n    alphabet.push('O');\n    alphabet.push('A');\n \
    \   alphabet.push('B');\n    alphabet.push('C');\n    alphabet.push('D');\n  \
    \  alphabet.push('E');\n    alphabet.push('F');\n    alphabet.push('G');\n   \
    \ alphabet.push('H');\n    alphabet.push('I');\n    alphabet.push('J');\n    alphabet.push('K');\n\
    \    alphabet.push('L');\n    alphabet.push('M');\n    alphabet.push('N');\n \
    \   alphabet.push('O');\n    alphabet.push('A');\n    alphabet.push('B');\n  \
    \  alphabet.push('C');\n    alphabet.push('D');\n    alphabet.push('E');\n   \
    \ alphabet.push('F');\n    alphabet.push('G');\n    alphabet.push('H');\n    alphabet.push('I');\n\
    \    alphabet.push('J');\n    alphabet.push('K');\n    alphabet.push('L');\n \
    \   alphabet.push('M');\n    alphabet.push('N');\n    alphabet.push('O');\n  \
    \  alphabet.push('A');\n    alphabet.push('B');\n    alphabet.push('C');\n   \
    \ alphabet.push('D');\n    alphabet.push('E');\n    alphabet.push('F');\n    alphabet.push('G');\n\
    \    alphabet.push('H');\n    alphabet.push('I');\n    alphabet.push('J');\n \
    \   alphabet.push('K');\n    \n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvtq68df7.rs:12:19\n   |\n\
    12 |     alphabet.push('A');\n   |                   ^^^ expected struct `std::ops::Range`,\
    \ found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n   \
    \             found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvtq68df7.rs:13:19\n\
    \   |\n13 |     alphabet.push('B');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvtq68df7.rs:14:19\n\
    \   |\n14 |     alphabet.push('C');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvtq68df7.rs:15:19\n\
    \   |\n15 |     alphabet.push('D');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvtq68df7.rs:16:19\n\
    \   |\n16 |     alphabet.push('E');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvtq68df7.rs:17:19\n\
    \   |\n17 |     alphabet.push('F');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvtq68df7.rs:18:19\n\
    \   |\n18 |     alphabet.push('G');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvtq68df7.rs:19:19\n\
    \   |\n19 |     alphabet.push('H');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `st"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n    let\
    \ mut result = String::new();\n    for c in s.chars() {\n        result.push((alphabet.iter().find(|&x|\
    \ x == c).unwrap() + 2) % 26);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&std::ops::Range<char>` with `char`\n  -->\
    \ /tmp/tmpy_2kib2h.rs:15:50\n   |\n15 |         result.push((alphabet.iter().find(|&x|\
    \ x == c).unwrap() + 2) % 26);\n   |                                         \
    \         ^^ no implementation for `&std::ops::Range<char> == char`\n   |\n  \
    \ = help: the trait `PartialEq<char>` is not implemented for `&std::ops::Range<char>`\n\
    \   = help: the trait `PartialEq` is implemented for `std::ops::Range<Idx>`\n\n\
    error[E0369]: cannot add `{integer}` to `&std::ops::Range<char>`\n  --> /tmp/tmpy_2kib2h.rs:15:65\n\
    \   |\n15 |         result.push((alphabet.iter().find(|&x| x == c).unwrap() +\
    \ 2) % 26);\n   |                      ------------------------------------------\
    \ ^ - {integer}\n   |                      |\n   |                      &std::ops::Range<char>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpga4knt9w.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 't', 's', 'r', 'q', 'p', 'o', 'n',\
    \ 'm', 'l', 'k', 'j', 'h', 'i', 'a'];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.first());\n    let mut result = String::new();\n \
    \   for c in s.chars() {\n        result.push(alphabet[alphabet.index(c)]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn48bk13s.rs:13:19\n   |\n\
    13 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpn48bk13s.rs:14:19\n   |\n14 |     alphabet.push(alphabet.first());\n\
    \   |                   ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0599]: no method named `index` found for struct `Vec<char>` in the current\
    \ scope\n  --> /tmp/tmpn48bk13s.rs:17:39\n   |\n17 |         result.push(alphabet[alphabet.index(c)]);\n\
    \   |                                       ^^^^^ method not found in `Vec<char>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().map(|c| c as char).collect::<Vec<_>>();\n    alphabet.rotate_left(2);\n\
    \    alphabet.iter().map(|c| c as char).collect::<Vec<_>>()\n        .iter()\n\
    \        .zip(alphabet.iter().map(|c| c as char).collect::<Vec<_>>())\n      \
    \  .map(|(a, b)| {\n            match a as char {\n                'a' as char\
    \ => b as char,\n                'b' as char => b as char,\n                'c'\
    \ as char => b as char,\n                'd' as char => b as char,\n         \
    \       'e' as char => b as char,\n                'f' as char => b as char,\n\
    \                'g' as char => b as char,\n                'h' as char => b as\
    \ char,\n                'i' as char => b as char,\n                'j' as char\
    \ => b as char,\n                'k' as char => b as char,\n                'l'\
    \ as char => b as char,\n                'm' as char => b as char,\n         \
    \       'n' as char => b as char,\n                'o' as char => b as char,\n\
    \                'p' as char => b as char,\n                'q' as char => b as\
    \ char,\n                'r' as char => b as char,\n                's' as char\
    \ => b as char,\n                't' as char => b as char,\n                'u'\
    \ as char => b as char,\n                'v' as char => b as char,\n         \
    \       'w' as char => b as char,\n                'x' as char => b as char,\n\
    \                'y' as char => b as char,\n                'z' as char => b as\
    \ char,\n                _ => panic!(\"Encrypt alphabet is invalid\"),\n     \
    \       }\n        }).collect::<Vec<_>>()\n        .iter()\n        .map(|c| c\
    \ as char).collect::<Vec<_>>()\n        .iter()\n        .map(|c| c as char).collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| c as char).collect::<Vec<_>>()\n        .iter()\n\
    \        .map(|c| c as char).collect::<Vec<_>>()\n        .iter()\n        .map(|c|\
    \ c as char).collect::<Vec<_>>()\n        .iter()\n        .map(|c| c as char).collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpko7vg81w.rs:60:13\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n60 |         .map(|\n\
    \   |             ^ unclosed delimiter\n61 | }\n   | ^ mismatched closing delimiter\n\
    \nerror: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found keyword\
    \ `as`\n  --> /tmp/tmpko7vg81w.rs:18:21\n   |\n18 |                 'a' as char\
    \ => b as char,\n   |                     ^^ expected one of `...`, `..=`, `..`,\
    \ `=>`, `if`, or `|`\n\nerror: expected `|`, found `)`\n  --> /tmp/tmpko7vg81w.rs:61:1\n\
    \   |\n60 |         .map(|\n   |               - expected `|`\n61 | }\n   | ^\
    \ unexpected token\n\nerror: aborting due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n    let\
    \ mut result = String::new();\n    for c in s.chars() {\n        let index = alphabet.iter().position(|&x|\
    \ x == c).unwrap();\n        result.push((alphabet.len() - index) as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3x5z5v6c.rs:15:56\n   |\n\
    15 |         let index = alphabet.iter().position(|&x| x == c).unwrap();\n   |\
    \                                                        ^ expected struct `std::ops::Range`,\
    \ found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n   \
    \             found type `char`\n\nerror[E0604]: only `u8` can be cast as `char`,\
    \ not `usize`\n  --> /tmp/tmp3x5z5v6c.rs:16:21\n   |\n16 |         result.push((alphabet.len()\
    \ - index) as char);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmp3x5z5v6c.rs:16:21\n   |\n16 |         result.push((alphabet.len() -\
    \ index) as char);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0604.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 'i', 'o', 'p', 'h', 's', 'f', 'd',\
    \ 'g', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\
    \ 'y', 'z'];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last().unwrap());\n\
    \    let mut cipher = s.chars().map(|c| alphabet.iter().position(|a| a == c).unwrap()).collect::<Vec<usize>>();\n\
    \    cipher.sort_unstable();\n    cipher.reverse();\n    let mut result = String::new();\n\
    \    for c in cipher {\n        result.push(*c);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi_ch5kg7.rs:13:19\n   |\n\
    13 |     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n13 |     alphabet.push(*alphabet.last().unwrap());\n   |              \
    \     +\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpi_ch5kg7.rs:14:71\n\
    \   |\n14 |     let mut cipher = s.chars().map(|c| alphabet.iter().position(|a|\
    \ a == c).unwrap()).collect::<Vec<usize>>();\n   |                           \
    \                                            ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0614]: type\
    \ `usize` cannot be dereferenced\n  --> /tmp/tmpi_ch5kg7.rs:19:21\n   |\n19 |\
    \         result.push(*c);\n   |                     ^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0614.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    let mut result =\
    \ String::new();\n    for c in s.chars() {\n        result.push(alphabet[alphabet.index(c)\
    \ + alphabet.len() - alphabet.index(c) - 1]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp0o3rqxwy.rs:16:39\n   |\n16 |         result.push(alphabet[alphabet.index(c)\
    \ + alphabet.len() - alphabet.index(c) - 1]);\n   |                          \
    \             ^^^^^ method not found in `Vec<char>`\n   |\n   = help: items from\
    \ traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use\
    \ std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct\
    \ `Vec<char>` in the current scope\n  --> /tmp/tmp0o3rqxwy.rs:16:76\n   |\n16\
    \ |         result.push(alphabet[alphabet.index(c) + alphabet.len() - alphabet.index(c)\
    \ - 1]);\n   |                                                               \
    \             ^^^^^ method not found in `Vec<char>`\n   |\n   = help: items from\
    \ traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use\
    \ std::ops::Index;\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.rotate_left(2);\n  \
    \  alphabet.iter().cloned().collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp5n3rmlss.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n    let\
    \ mut result = String::new();\n    for c in s.chars() {\n        result.push((alphabet.iter().position(|x|\
    \ x == c).unwrap() + 2) as char);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&std::ops::Range<char>` with `char`\n  -->\
    \ /tmp/tmpjcbrorv2.rs:15:53\n   |\n15 |         result.push((alphabet.iter().position(|x|\
    \ x == c).unwrap() + 2) as char);\n   |                                      \
    \               ^^ no implementation for `&std::ops::Range<char> == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `&std::ops::Range<char>`\n\
    \   = help: the trait `PartialEq` is implemented for `std::ops::Range<Idx>`\n\n\
    error[E0604]: only `u8` can be cast as `char`, not `usize`\n  --> /tmp/tmpjcbrorv2.rs:15:21\n\
    \   |\n15 |         result.push((alphabet.iter().position(|x| x == c).unwrap()\
    \ + 2) as char);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpjcbrorv2.rs:15:21\n   |\n15 |         result.push((alphabet.iter().position(|x|\
    \ x == c).unwrap() + 2) as char);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0604.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        let index = alphabet.iter().position(|&x| x == c).unwrap();\n\
    \        result.push((index as char).to_string());\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn96bu2jz.rs:16:21\n   |\n\
    16 |         result.push((index as char).to_string());\n   |                 \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0604]:\
    \ only `u8` can be cast as `char`, not `usize`\n  --> /tmp/tmpn96bu2jz.rs:16:21\n\
    \   |\n16 |         result.push((index as char).to_string());\n   |          \
    \           ^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32` instead\
    \ (via a `u32`)\n  --> /tmp/tmpn96bu2jz.rs:16:21\n   |\n16 |         result.push((index\
    \ as char).to_string());\n   |                     ^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0604.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push((alphabet.iter().find(|&x| x == c).unwrap()\
    \ + 2) % 26);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzh83szdz.rs:15:50\n\
    \   |\n15 |         result.push((alphabet.iter().find(|&x| x == c).unwrap() +\
    \ 2) % 26);\n   |                                                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0369]: cannot add `{integer}` to `&char`\n  --> /tmp/tmpzh83szdz.rs:15:65\n\
    \   |\n15 |         result.push((alphabet.iter().find(|&x| x == c).unwrap() +\
    \ 2) % 26);\n   |                      ------------------------------------------\
    \ ^ - {integer}\n   |                      |\n   |                      &char\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.sort_unstable();\n    let\
    \ mut result = String::new();\n    for c in s.chars() {\n        let index = alphabet.iter().position(|x|\
    \ x == c).unwrap();\n        result.push_str(&alphabet[index + 2]);\n        result.push_str(&alphabet[index\
    \ + 1]);\n        result.push_str(&alphabet[index]);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `std::ops::Range<char>: Ord` is not satisfied\n\
    \    --> /tmp/tmpq6p8mu0a.rs:12:14\n     |\n12   |     alphabet.sort_unstable();\n\
    \     |              ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `std::ops::Range<char>`\n\
    \     |\nnote: required by a bound in `core::slice::<impl [T]>::sort_unstable`\n\
    \nerror[E0277]: can't compare `&std::ops::Range<char>` with `char`\n  --> /tmp/tmpq6p8mu0a.rs:15:52\n\
    \   |\n15 |         let index = alphabet.iter().position(|x| x == c).unwrap();\n\
    \   |                                                    ^^ no implementation\
    \ for `&std::ops::Range<char> == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&std::ops::Range<char>`\n   = help: the trait `PartialEq`\
    \ is implemented for `std::ops::Range<Idx>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpq6p8mu0a.rs:16:25\n   |\n16 |         result.push_str(&alphabet[index\
    \ + 2]);\n   |                         ^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ struct `std::ops::Range`\n   |\n   = note: expected reference `&str`\n     \
    \         found reference `&std::ops::Range<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq6p8mu0a.rs:17:25\n   |\n17 |         result.push_str(&alphabet[index\
    \ + 1]);\n   |                         ^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ struct `std::ops::Range`\n   |\n   = note: expected reference `&str`\n     \
    \         found reference `&std::ops::Range<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq6p8mu0a.rs:18:25\n   |\n18 |         result.push_str(&alphabet[index]);\n\
    \   |                         ^^^^^^^^^^^^^^^^ expected `str`, found struct `std::ops::Range`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&std::ops::Range<char>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        let index = alphabet.index(c);\n\
    \        result.push((index as char).to_string());\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpyz_74zfr.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyz_74zfr.rs:16:21\n   |\n16 |         result.push((index\
    \ as char).to_string());\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        let mut c = c.to_ascii_lowercase();\n\
    \        alphabet.rotate_left(2);\n        result.push_str(&alphabet.lookup(&c));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpk377xkm0.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push((alphabet.last() + alphabet.first()).to_string());\n\
    \        alphabet.pop();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `Option<&char>` to `Option<&char>`\n  --> /tmp/tmpbvvznu8d.rs:15:38\n\
    \   |\n15 |         result.push((alphabet.last() + alphabet.first()).to_string());\n\
    \   |                      --------------- ^ ---------------- Option<&char>\n\
    \   |                      |\n   |                      Option<&char>\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push((alphabet.iter().position(|x| x == c).unwrap()\
    \ + 2) % 26);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpp7eyf83d.rs:15:53\n\
    \   |\n15 |         result.push((alphabet.iter().position(|x| x == c).unwrap()\
    \ + 2) % 26);\n   |                                                     ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp7eyf83d.rs:15:21\n\
    \   |\n15 |         result.push((alphabet.iter().position(|x| x == c).unwrap()\
    \ + 2) % 26);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ let mut result = String::new();\n    for c in s.chars() {\n        let index\
    \ = alphabet.iter().position(|&x| x == c).unwrap();\n        result.push((alphabet[index]\
    \ + alphabet[index + 1]).to_string());\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpkqnelbe3.rs:15:38\n\
    \   |\n15 |         result.push((alphabet[index] + alphabet[index + 1]).to_string());\n\
    \   |                      --------------- ^ ------------------- char\n   |  \
    \                    |\n   |                      char\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpxkbvkvpu.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ let mut result = String::new();\n    for c in s.chars() {\n        let index\
    \ = alphabet.iter().position(|x| x == c).unwrap();\n        result.push_str(&alphabet[(index\
    \ * 2) as usize]);\n        result.push_str(&alphabet[(index * 2 + 1) as usize]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpz5yq4ru0.rs:14:52\n\
    \   |\n14 |         let index = alphabet.iter().position(|x| x == c).unwrap();\n\
    \   |                                                    ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpz5yq4ru0.rs:15:25\n   |\n15 |  \
    \       result.push_str(&alphabet[(index * 2) as usize]);\n   |              \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpz5yq4ru0.rs:16:25\n   |\n16 |\
    \         result.push_str(&alphabet[(index * 2 + 1) as usize]);\n   |        \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        let index = alphabet.iter().position(|x| *x == c).unwrap();\n\
    \        result.push_str(&alphabet[index]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyfhj1z9z.rs:16:25\n   |\n\
    16 |         result.push_str(&alphabet[index]);\n   |                        \
    \ ^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate(2);\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(alphabet[alphabet.index(c) + 1]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate` found for struct `Vec<char>` in\
    \ the current scope\n  --> /tmp/tmp4yozabhc.rs:12:14\n   |\n12 |     alphabet.rotate(2);\n\
    \   |              ^^^^^^ help: there is an associated function with a similar\
    \ name: `rotate_left`\n\nerror[E0599]: no method named `index` found for struct\
    \ `Vec<char>` in the current scope\n  --> /tmp/tmp4yozabhc.rs:15:39\n   |\n15\
    \ |         result.push(alphabet[alphabet.index(c) + 1]);\n   |              \
    \                         ^^^^^ method not found in `Vec<char>`\n   |\n   = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1\
    \  | use std::ops::Index;\n   |\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        let index = alphabet.iter().position(|&x| x == c).unwrap();\n\
    \        result.push((index as char).to_string());\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgu3lo6wv.rs:16:21\n   |\n\
    16 |         result.push((index as char).to_string());\n   |                 \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0604]:\
    \ only `u8` can be cast as `char`, not `usize`\n  --> /tmp/tmpgu3lo6wv.rs:16:21\n\
    \   |\n16 |         result.push((index as char).to_string());\n   |          \
    \           ^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32` instead\
    \ (via a `u32`)\n  --> /tmp/tmpgu3lo6wv.rs:16:21\n   |\n16 |         result.push((index\
    \ as char).to_string());\n   |                     ^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0604.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.sort_by_key(|&x| x.to_ascii_lowercase());\n\
    \    alphabet.rotate_left(2);\n    alphabet.sort_by_key(|&x| x.to_ascii_lowercase());\n\
    \    alphabet.iter().map(|&x| x.to_ascii_lowercase()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpx222zz0p.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate(2);\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(alphabet[alphabet.index(c) + 1]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate` found for struct `Vec<char>` in\
    \ the current scope\n  --> /tmp/tmpropk4q11.rs:12:14\n   |\n12 |     alphabet.rotate(2);\n\
    \   |              ^^^^^^ help: there is an associated function with a similar\
    \ name: `rotate_left`\n\nerror[E0599]: no method named `index` found for struct\
    \ `Vec<char>` in the current scope\n  --> /tmp/tmpropk4q11.rs:15:39\n   |\n15\
    \ |         result.push(alphabet[alphabet.index(c) + 1]);\n   |              \
    \                         ^^^^^ method not found in `Vec<char>`\n   |\n   = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1\
    \  | use std::ops::Index;\n   |\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last().unwrap());\n\
    \    let mut result = String::new();\n    for c in s.chars() {\n        result.push_str(alphabet.iter().map(|c|\
    \ c.to_string()).collect::<Vec<_>>().join(\"\"));\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpujx8rc46.rs:13:19\n   |\n\
    13 |     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found reference\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n           found reference `&std::ops::Range<char>`\n\
    \nerror[E0599]: the method `to_string` exists for reference `&std::ops::Range<char>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpujx8rc46.rs:16:51\n \
    \  |\n16 |           result.push_str(alphabet.iter().map(|c| c.to_string()).collect::<Vec<_>>().join(\"\
    \"));\n   |                                                     ^^^^^^^^^ method\
    \ cannot be called on `&std::ops::Range<char>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `std::ops::Range<char>:\
    \ std::fmt::Display`\n           which is required by `std::ops::Range<char>:\
    \ ToString`\n           `&std::ops::Range<char>: std::fmt::Display`\n        \
    \   which is required by `&std::ops::Range<char>: ToString`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpujx8rc46.rs:16:25\n   |\n16 |         result.push_str(alphabet.iter().map(|c|\
    \ c.to_string()).collect::<Vec<_>>().join(\"\"));\n   |                      \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\
    \                         |\n   |                         expected `&str`, found\
    \ struct `String`\n   |                         help: consider borrowing here:\
    \ `&alphabet.iter().map(|c| c.to_string()).collect::<Vec<_>>().join(\"\")`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        let mut c = c.to_ascii_lowercase();\n\
    \        let mut i = alphabet.find(c);\n        if i == Alphabet::NONE {\n   \
    \         i = alphabet.find(c.to_ascii_uppercase());\n        }\n        if i\
    \ == Alphabet::NONE {\n            i = alphabet.find(c.to_ascii_lowercase());\n\
    \        }\n        if i == Alphabet::NONE {\n            i = alphabet.find(c.to_ascii_uppercase());\n\
    \        }\n        result.append(alphabet.to_ascii_lowercase(i));\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp4s1rjlv9.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmp4s1rjlv9.rs:17:17\n\
    \   |\n17 |         if i == Alphabet::NONE {\n   |                 ^^^^^^^^ use\
    \ of undeclared type `Alphabet`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Alphabet`\n  --> /tmp/tmp4s1rjlv9.rs:20:17\n   |\n20 |         if i ==\
    \ Alphabet::NONE {\n   |                 ^^^^^^^^ use of undeclared type `Alphabet`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmp4s1rjlv9.rs:23:17\n\
    \   |\n23 |         if i == Alphabet::NONE {\n   |                 ^^^^^^^^ use\
    \ of undeclared type `Alphabet`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp4s1rjlv9.rs:26:16\n\
    \   |\n26 |         result.append(alphabet.to_ascii_lowercase(i));\n   |     \
    \           ^^^^^^ method not found in `String`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate_left(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        result.push_str(alphabet.iter().cloned().collect::<String>());\n\
    \        result.push(c);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `std::ops::Range<char>`\n    --> /tmp/tmpy4g4xesi.rs:15:50\n\
    \     |\n15   |         result.push_str(alphabet.iter().cloned().collect::<String>());\n\
    \     |                                                  ^^^^^^^ value of type\
    \ `String` cannot be built from `std::iter::Iterator<Item=std::ops::Range<char>>`\n\
    \     |\n     = help: the trait `FromIterator<std::ops::Range<char>>` is not implemented\
    \ for `String`\n     = help: the following other types implement trait `FromIterator<A>`:\n\
    \               <String as FromIterator<&'a char>>\n               <String as\
    \ FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy4g4xesi.rs:15:25\n\
    \   |\n15 |         result.push_str(alphabet.iter().cloned().collect::<String>());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \
    \  |                         |\n   |                         expected `&str`,\
    \ found struct `String`\n   |                         help: consider borrowing\
    \ here: `&alphabet.iter().cloned().collect::<String>()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ let mut alphabet2 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',\
    \ 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet3 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet4 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet5 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet6 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet7 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet8 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet9 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet10 = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut alphabet11 = vec!['A', 'B', 'C', 'D', 'E\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmptv6gms00.rs:22:1\n   |\n22 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmptv6gms00.rs:21:30\n   |\n10 | fn encrypt(s: String) -> String {\n  \
    \ |                                 - closing delimiter possibly meant for this\n\
    ...\n21 |     let mut alphabet11 = vec!['A', 'B', 'C', 'D', 'E\n   |         \
    \                     ^ unclosed delimiter\n22 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>();\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    \n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpztl0g8km.rs:12:19\n   |\n\
    12 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpztl0g8km.rs:13:19\n   |\n13 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpztl0g8km.rs:14:19\n   |\n14 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpztl0g8km.rs:15:19\n   |\n15 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpztl0g8km.rs:16:19\n   |\n16 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpztl0g8km.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpztl0g8km.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpztl0g8km.rs:19:19\n   |\n19 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note:"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    let mut result =\
    \ String::new();\n    for c in s.chars() {\n        result.push((alphabet.iter().position(|x|\
    \ *x == c).unwrap() + 2) % 26);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcwk30nif.rs:16:21\n   |\n\
    16 |         result.push((alphabet.iter().position(|x| *x == c).unwrap() + 2)\
    \ % 26);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.push('A');\n    alphabet.push('B');\n\
    \    alphabet.push('C');\n    alphabet.push('D');\n    alphabet.push('E');\n \
    \   alphabet.push('F');\n    alphabet.push('G');\n    alphabet.push('H');\n  \
    \  alphabet.push('I');\n    alphabet.push('J');\n    alphabet.push('K');\n   \
    \ alphabet.push('L');\n    alphabet.push('M');\n    alphabet.push('N');\n    alphabet.push('O');\n\
    \    alphabet.push('A');\n    alphabet.push('B');\n    alphabet.push('C');\n \
    \   alphabet.push('D');\n    alphabet.push('E');\n    alphabet.push('F');\n  \
    \  alphabet.push('G');\n    alphabet.push('H');\n    alphabet.push('I');\n   \
    \ alphabet.push('J');\n    alphabet.push('K');\n    alphabet.push('L');\n    alphabet.push('M');\n\
    \    alphabet.push('N');\n    alphabet.push('O');\n    alphabet.push('A');\n \
    \   alphabet.push('B');\n    alphabet.push('C');\n    alphabet.push('D');\n  \
    \  alphabet.push('E');\n    alphabet.push('F');\n    alphabet.push('G');\n   \
    \ alphabet.push('H');\n    alphabet.push('I');\n    alphabet.push('J');\n    alphabet.push('K');\n\
    \    alphabet.push('L');\n    alphabet.push('M');\n    alphabet.push('N');\n \
    \   alphabet.push('O');\n    alphabet.push('A');\n    alphabet.push('B');\n  \
    \  alphabet.push('C');\n    alphabet.push('D');\n    alphabet.push('E');\n   \
    \ alphabet.push('F');\n    alphabet.push('G');\n    alphabet.push('H');\n    alphabet.push('I');\n\
    \    alphabet.push('J');\n    alphabet.push('K');\n    alphabet.push('L');\n \
    \   alphabet.push('M');\n    alphabet.push('N');\n    alphabet.push('O');\n  \
    \  alphabet.push('A');\n    alphabet.push('B');\n    alphabet.push('C');\n   \
    \ alphabet.push('D');\n    alphabet.push('E');\n    alphabet.push('F');\n    alphabet.push('G');\n\
    \    alphabet.push('H');\n    alphabet.push('I');\n    alphabet.push('J');\n \
    \   alphabet.push('K');\n    \n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp41y3bklu.rs:12:19\n   |\n\
    12 |     alphabet.push('A');\n   |                   ^^^ expected struct `std::ops::Range`,\
    \ found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n   \
    \             found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp41y3bklu.rs:13:19\n\
    \   |\n13 |     alphabet.push('B');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp41y3bklu.rs:14:19\n\
    \   |\n14 |     alphabet.push('C');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp41y3bklu.rs:15:19\n\
    \   |\n15 |     alphabet.push('D');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp41y3bklu.rs:16:19\n\
    \   |\n16 |     alphabet.push('E');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp41y3bklu.rs:17:19\n\
    \   |\n17 |     alphabet.push('F');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp41y3bklu.rs:18:19\n\
    \   |\n18 |     alphabet.push('G');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp41y3bklu.rs:19:19\n\
    \   |\n19 |     alphabet.push('H');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `st"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpiuz3xu68.rs:66:18\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n66 |     alphabet.push(alphabet.clone\n\
    \   |                  ^ unclosed delimiter\n67 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiuz3xu68.rs:12:19\n\
    \   |\n12 |     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `std::ops::Range<_>`\n              found struct `Vec<std::ops::Range<_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiuz3xu68.rs:13:19\n   |\n13 |\
    \     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `std::ops::Range<_>`\n              found struct `Vec<std::ops::Range<_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiuz3xu68.rs:14:19\n   |\n14 |\
    \     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `std::ops::Range<_>`\n              found struct `Vec<std::ops::Range<_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiuz3xu68.rs:15:19\n   |\n15 |\
    \     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `std::ops::Range<_>`\n              found struct `Vec<std::ops::Range<_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiuz3xu68.rs:16:19\n   |\n16 |\
    \     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `std::ops::Range<_>`\n              found struct `Vec<std::ops::Range<_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiuz3xu68.rs:17:19\n   |\n17 |\
    \     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().map(|c| c.to_ascii_lowercase());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmp6dygxfmo.rs:12:14\n   |\n12 |     alphabet.push(alphabet.last());\n\
    \   |              ^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmp6dygxfmo.rs:11:38:\
    \ 11:64]>`\n\nerror[E0599]: no method named `push` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmp6dygxfmo.rs:13:14\n   |\n13 |     alphabet.push(alphabet.last());\n\
    \   |              ^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmp6dygxfmo.rs:11:38:\
    \ 11:64]>`\n\nerror[E0599]: no method named `push` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmp6dygxfmo.rs:14:14\n   |\n14 |     alphabet.push(alphabet.last());\n\
    \   |              ^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmp6dygxfmo.rs:11:38:\
    \ 11:64]>`\n\nerror[E0599]: no method named `push` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmp6dygxfmo.rs:15:14\n   |\n15 |     alphabet.push(alphabet.last());\n\
    \   |              ^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmp6dygxfmo.rs:11:38:\
    \ 11:64]>`\n\nerror[E0599]: no method named `push` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmp6dygxfmo.rs:16:14\n   |\n16 |     alphabet.push(alphabet.last());\n\
    \   |              ^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmp6dygxfmo.rs:11:38:\
    \ 11:64]>`\n\nerror[E0599]: no method named `push` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmp6dygxfmo.rs:17:14\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |              ^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmp6dygxfmo.rs:11:38:\
    \ 11:64]>`\n\nerror[E0599]: no method named `push` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmp6dygxfmo.rs:18:14\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |              ^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmp6dygxfmo.rs:11:38:\
    \ 11:64]>`\n\nerror[E0599]: no method named `push` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmp6dygxfmo.rs:19:14\n   |\n19 |     alphabet.push(alphabet.last());\n\
    \   |              ^^^^ method not found i"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(alphabet[alphabet.len() - alphabet.index(c)]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpty3m_ujr.rs:15:56\n   |\n15 |         result.push(alphabet[alphabet.len()\
    \ - alphabet.index(c)]);\n   |                                               \
    \         ^^^^^ method not found in `Vec<char>`\n   |\n   = help: items from traits\
    \ can only be used if the trait is in scope\nhelp: the following trait is implemented\
    \ but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.rotate_left(2);\n  \
    \  alphabet.iter().map(|c| c.to_string()).collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpsdpbvj0q.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<char>>();\n    alphabet.sort_unstable();\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphab\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphab` in this scope\n  --> /tmp/tmpgsc5brvh.rs:67:5\n\
    \   |\n67 |     alphab\n   |     ^^^^^^ help: a local variable with a similar\
    \ name exists: `alphabet`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgsc5brvh.rs:13:19\n\
    \   |\n13 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgsc5brvh.rs:14:19\n   |\n14 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgsc5brvh.rs:15:19\n   |\n15 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgsc5brvh.rs:16:19\n   |\n16 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgsc5brvh.rs:17:19\n   |\n17 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgsc5brvh.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgsc5brvh.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.sort_unstable();\n \
    \   alphabet.push(alphabet[0]);\n    alphabet.push(alphabet[1]);\n    alphabet.push(alphabet[2]);\n\
    \    alphabet.push(alphabet[3]);\n    alphabet.push(alphabet[4]);\n    alphabet.push(alphabet[5]);\n\
    \    alphabet.push(alphabet[6]);\n    alphabet.push(alphabet[7]);\n    alphabet.push(alphabet[8]);\n\
    \    alphabet.push(alphabet[9]);\n    alphabet.push(alphabet[10]);\n    alphabet.push(alphabet[11]);\n\
    \    alphabet.push(alphabet[12]);\n    alphabet.push(alphabet[13]);\n    alphabet.push(alphabet[14]);\n\
    \    alphabet.push(alphabet[15]);\n    alphabet.push(alphabet[16]);\n    alphabet.push(alphabet[17]);\n\
    \    alphabet.push(alphabet[18]);\n    alphabet.push(alphabet[19]);\n    alphabet.push(alphabet[20]);\n\
    \    alphabet.push(alphabet[21]);\n    alphabet.push(alphabet[22]);\n    alphabet.push(alphabet[23]);\n\
    \    alphabet.push(alphabet[24]);\n    alphabet.push(alphabet[25]);\n    alphabet.push(alphabet[26]);\n\
    \    alphabet.push(alphabet[27]);\n    alphabet.push(alphabet[28]);\n    alphabet.push(alphabet[29]);\n\
    \    alphabet.push(alphabet[30]);\n    alphabet.push(alphabet[31]);\n    alphabet.push(alphabet[32]);\n\
    \    alphabet.push(alphabet[33]);\n    alphabet.push(alphabet[34]);\n    alphabet.push(alphabet[35]);\n\
    \    alphabet.push(alphabet[36]);\n    alphabet.push(alphabet[37]);\n    alphabet.push(alphabet[38]);\n\
    \    alphabet.push(alphabet[39]);\n    alphabet.push(alphabet[40]);\n    alphabet.push(alphabet[41]);\n\
    \    alphabet.push(alphabet[42]);\n    alphabet.push(alphabet[43]);\n    alphabet.push(alphabet[44]);\n\
    \    alphabet.push(alphabet[45]);\n    alphabet.push(alphabet[46]);\n    alphabet.push(alphabet[47]);\n\
    \    alphabet.push(alphabet[48]);\n    alphabet.push(alphabet[49]);\n    alphabet.push(alphabet[50]);\n\
    \    alphabet.push(alphabet[51]);\n    alphabet.push(alphabet[52]);\n    alphabet.push(alphabet[53]);\n\
    \    alphabet.push(alphabet[54]);\n    alphabet.push(alphabet[55\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpmwsyncip.rs:68:27\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n68 |     alphabet.push(alphabet[55\n\
    \   |                           ^ unclosed delimiter\n69 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmwsyncip.rs:68:5\n\
    \   |\n10 |   fn encrypt(s: String) -> String {\n   |                        \
    \    ------ expected `String` because of return type\n...\n68 | /     alphabet.push(alphabet[55\n\
    69 | | }\n   | |_^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(alphabet[alphabet.index(c) + alphabet.len()\
    \ - alphabet.index(c) % alphabet.len()]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpowdk0fwt.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)\
    \ + alphabet.len() - alphabet.index(c) % alphabet.len()]);\n   |             \
    \                          ^^^^^ method not found in `Vec<char>`\n   |\n   = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1\
    \  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found\
    \ for struct `Vec<char>` in the current scope\n  --> /tmp/tmpowdk0fwt.rs:15:76\n\
    \   |\n15 |         result.push(alphabet[alphabet.index(c) + alphabet.len() -\
    \ alphabet.index(c) % alphabet.len()]);\n   |                                \
    \                                            ^^^^^ method not found in `Vec<char>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmplj4ad_gm.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        let index = alphabet.iter().position(|&x| x == c).unwrap();\n\
    \        result.push((alphabet[index + 1] + alphabet[index]).to_string());\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmp6lano6k3.rs:16:42\n\
    \   |\n16 |         result.push((alphabet[index + 1] + alphabet[index]).to_string());\n\
    \   |                      ------------------- ^ --------------- char\n   |  \
    \                    |\n   |                      char\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.iter().cloned().map(|c| c.to_string()).collect::<Vec<_>>().join(\"\
    \")\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `std::ops::Range<char>` doesn't implement `std::fmt::Display`\n\
    \  --> /tmp/tmp1ueq_aox.rs:14:40\n   |\n14 |       alphabet.iter().cloned().map(|c|\
    \ c.to_string()).collect::<Vec<_>>().join(\"\")\n   |                        \
    \                  ^^^^^^^^^ `std::ops::Range<char>` cannot be formatted with\
    \ the default formatter\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `std::ops::Range<char>: std::fmt::Display`\n        \
    \   which is required by `std::ops::Range<char>: ToString`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 't', 's', 'r', 'q', 'p', 'o', 'n',\
    \ 'm', 'l', 'k', 'j', 'h', 'i', 'a'];\n    alphabet.rotate_left(2);\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(alphabet[alphabet.index(c)]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpouhty2ca.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)]);\n\
    \   |                                       ^^^^^ method not found in `Vec<char>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate_left(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        let index = alphabet.iter().position(|x|\
    \ x == c).unwrap();\n        result.push_str(&alphabet[index]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&std::ops::Range<char>` with `char`\n  -->\
    \ /tmp/tmpylcz0r_q.rs:15:52\n   |\n15 |         let index = alphabet.iter().position(|x|\
    \ x == c).unwrap();\n   |                                                    ^^\
    \ no implementation for `&std::ops::Range<char> == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&std::ops::Range<char>`\n  \
    \ = help: the trait `PartialEq` is implemented for `std::ops::Range<Idx>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpylcz0r_q.rs:16:25\n   |\n16 |  \
    \       result.push_str(&alphabet[index]);\n   |                         ^^^^^^^^^^^^^^^^\
    \ expected `str`, found struct `std::ops::Range`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&std::ops::Range<char>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(*alphabet[alphabet.index(c) + 1]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpq230nlyq.rs:15:40\n   |\n15 |         result.push(*alphabet[alphabet.index(c)\
    \ + 1]);\n   |                                        ^^^^^ method not found in\
    \ `Vec<char>`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        let index = alphabet.iter().position(|&x| x == c).unwrap();\n\
    \        result.push(c);\n        result.push(alphabet[index + 1]);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpz0r0vbut.rs:15:59\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.swap_remove(alphabet.iter().cloned().skip(alphabet.len()/2));\n\
    \    let mut result = String::new();\n    for c in s.chars() {\n        let index\
    \ = alphabet.iter().position(|&x| x == c).unwrap();\n        result.push((alphabet[index].to_string()\
    \ + alphabet[index+1].to_string()).to_string());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp570kgxh3.rs:12:26\n   |\n\
    12 |     alphabet.swap_remove(alphabet.iter().cloned().skip(alphabet.len()/2));\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found struct `Skip`\n   |\n   = note: expected type `usize`\n\
    \            found struct `Skip<Cloned<std::slice::Iter<'_, std::ops::Range<char>>>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp570kgxh3.rs:15:56\n   |\n15 |\
    \         let index = alphabet.iter().position(|&x| x == c).unwrap();\n   |  \
    \                                                      ^ expected struct `std::ops::Range`,\
    \ found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n   \
    \             found type `char`\n\nerror[E0599]: `std::ops::Range<char>` doesn't\
    \ implement `std::fmt::Display`\n  --> /tmp/tmp570kgxh3.rs:16:38\n   |\n16 | \
    \          result.push((alphabet[index].to_string() + alphabet[index+1].to_string()).to_string());\n\
    \   |                                        ^^^^^^^^^ `std::ops::Range<char>`\
    \ cannot be formatted with the default formatter\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `std::ops::Range<char>: std::fmt::Display`\n\
    \           which is required by `std::ops::Range<char>: ToString`\n\nerror[E0599]:\
    \ `std::ops::Range<char>` doesn't implement `std::fmt::Display`\n  --> /tmp/tmp570kgxh3.rs:16:70\n\
    \   |\n16 |           result.push((alphabet[index].to_string() + alphabet[index+1].to_string()).to_string());\n\
    \   |                                                                        ^^^^^^^^^\
    \ `std::ops::Range<char>` cannot be formatted with the default formatter\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `std::ops::Range<char>:\
    \ std::fmt::Display`\n           which is required by `std::ops::Range<char>:\
    \ ToString`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>();\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp9ai6qr19.rs:60:18\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n60 |     alphabet.push(alphabet.last().\n\
    \   |                  ^ unclosed delimiter\n61 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: unexpected token: `)`\n  --> /tmp/tmp9ai6qr19.rs:61:1\n\
    \   |\n61 | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ai6qr19.rs:12:19\n\
    \   |\n12 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n12 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ai6qr19.rs:13:19\n\
    \   |\n13 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n13 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ai6qr19.rs:14:19\n\
    \   |\n14 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n14 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ai6qr19.rs:15:19\n\
    \   |\n15 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n15 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ai6qr19.rs:16:19\n\
    \   |\n16 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n16 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: misma"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.iter().cloned().collect::<String>()\n        .into_iter()\n    \
    \    .map(|c| s.chars().nth(alphabet.iter().position(|c| c == c).unwrap()).unwrap())\n\
    \        .collect::<String>()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `std::ops::Range<char>`\n    --> /tmp/tmpepicra10.rs:14:30\n\
    \     |\n14   |     alphabet.iter().cloned().collect::<String>()\n     |     \
    \                         ^^^^^^^ value of type `String` cannot be built from\
    \ `std::iter::Iterator<Item=std::ops::Range<char>>`\n     |\n     = help: the\
    \ trait `FromIterator<std::ops::Range<char>>` is not implemented for `String`\n\
    \     = help: the following other types implement trait `FromIterator<A>`:\n \
    \              <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror[E0599]: the method `into_iter` exists for struct `String`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmpepicra10.rs:15:10\n    |\n15  |  \
    \         .into_iter()\n    |            ^^^^^^^^^\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `String: IntoIterator`\n            `&String: Iterator`\n\
    \            which is required by `&String: IntoIterator`\n            `&mut String:\
    \ Iterator`\n            which is required by `&mut String: IntoIterator`\n  \
    \          `str: Sized`\n            which is required by `str: IntoIterator`\n\
    \            `str: Iterator`\n            which is required by `str: IntoIterator`\n\
    \            `&str: Iterator`\n            which is required by `&str: IntoIterator`\n\
    \            `&mut str: Iterator`\n            which is required by `&mut str:\
    \ IntoIterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.push('A');\n    alphabet.push('B');\n\
    \    alphabet.push('C');\n    alphabet.push('D');\n    alphabet.push('E');\n \
    \   alphabet.push('F');\n    alphabet.push('G');\n    alphabet.push('H');\n  \
    \  alphabet.push('I');\n    alphabet.push('J');\n    alphabet.push('K');\n   \
    \ alphabet.push('L');\n    alphabet.push('M');\n    alphabet.push('N');\n    alphabet.push('O');\n\
    \    alphabet.push('A');\n    alphabet.push('B');\n    alphabet.push('C');\n \
    \   alphabet.push('D');\n    alphabet.push('E');\n    alphabet.push('F');\n  \
    \  alphabet.push('G');\n    alphabet.push('H');\n    alphabet.push('I');\n   \
    \ alphabet.push('J');\n    alphabet.push('K');\n    alphabet.push('L');\n    alphabet.push('M');\n\
    \    alphabet.push('N');\n    alphabet.push('O');\n    alphabet.push('A');\n \
    \   alphabet.push('B');\n    alphabet.push('C');\n    alphabet.push('D');\n  \
    \  alphabet.push('E');\n    alphabet.push('F');\n    alphabet.push('G');\n   \
    \ alphabet.push('H');\n    alphabet.push('I');\n    alphabet.push('J');\n    alphabet.push('K');\n\
    \    alphabet.push('L');\n    alphabet.push('M');\n    alphabet.push('N');\n \
    \   alphabet.push('O');\n    alphabet.push('A');\n    alphabet.push('B');\n  \
    \  alphabet.push('C');\n    alphabet.push('D');\n    alphabet.push('E');\n   \
    \ alphabet.push('F');\n    alphabet.push('G');\n    alphabet.push('H');\n    alphabet.push('I');\n\
    \    alphabet.push('J');\n    alphabet.push('K');\n    alphabet.push('L');\n \
    \   alphabet.push('M');\n    alphabet.push('N');\n    alphabet.push('O');\n  \
    \  alphabet.push('A');\n    alphabet.push('B');\n    alphabet.push('C');\n   \
    \ alphabet.push('D');\n    alphabet.push('E');\n    alphabet.push('F');\n    alphabet.push('G');\n\
    \    alphabet.push('H');\n    alphabet.push('I');\n    alphabet.push('J');\n \
    \   alphabet.push('K');\n    \n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjichj2r1.rs:12:19\n   |\n\
    12 |     alphabet.push('A');\n   |                   ^^^ expected struct `std::ops::Range`,\
    \ found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n   \
    \             found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjichj2r1.rs:13:19\n\
    \   |\n13 |     alphabet.push('B');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjichj2r1.rs:14:19\n\
    \   |\n14 |     alphabet.push('C');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjichj2r1.rs:15:19\n\
    \   |\n15 |     alphabet.push('D');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjichj2r1.rs:16:19\n\
    \   |\n16 |     alphabet.push('E');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjichj2r1.rs:17:19\n\
    \   |\n17 |     alphabet.push('F');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjichj2r1.rs:18:19\n\
    \   |\n18 |     alphabet.push('G');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjichj2r1.rs:19:19\n\
    \   |\n19 |     alphabet.push('H');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `st"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 'v', 'u', 't', 's', 'r', 'q', 'p',\
    \ 'o', 'n', 'm', 'l', 'k', 'j', 'h', 'f', 'e', 'd', 'c', 'b', 'a'];\n    alphabet.rotate_left(2);\n\
    \    let mut result = String::new();\n    for c in s.chars() {\n        result.push_str(&alphabet[alphabet.index(c)]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp111yuj9r.rs:15:44\n   |\n15 |         result.push_str(&alphabet[alphabet.index(c)]);\n\
    \   |                                            ^^^^^ method not found in `Vec<char>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n    let\
    \ mut result = String::new();\n    for c in s.chars() {\n        let index = alphabet.iter().position(|&x|\
    \ x == c).unwrap();\n        result.push_str(&alphabet[index]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_3x6y5iw.rs:15:56\n   |\n\
    15 |         let index = alphabet.iter().position(|&x| x == c).unwrap();\n   |\
    \                                                        ^ expected struct `std::ops::Range`,\
    \ found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n   \
    \             found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_3x6y5iw.rs:16:25\n\
    \   |\n16 |         result.push_str(&alphabet[index]);\n   |                 \
    \        ^^^^^^^^^^^^^^^^ expected `str`, found struct `std::ops::Range`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&std::ops::Range<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\
    \    alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c\
    \ in s.chars() {\n        let index = alphabet.iter().position(|x| x == c).unwrap();\n\
    \        result.push_str(&alphabet[index]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpk82l5w9w.rs:15:52\n\
    \   |\n15 |         let index = alphabet.iter().position(|x| x == c).unwrap();\n\
    \   |                                                    ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpk82l5w9w.rs:16:25\n   |\n16 |  \
    \       result.push_str(&alphabet[index]);\n   |                         ^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n    let\
    \ mut result = String::new();\n    for c in s.chars() {\n        result.push(alphabet[alphabet.index(c)]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<std::ops::Range<char>>`\
    \ in the current scope\n  --> /tmp/tmph8qjg9yn.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)]);\n\
    \   |                                       ^^^^^ method not found in `Vec<std::ops::Range<char>>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    \n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe395qx52.rs:12:19\n   |\n\
    12 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe395qx52.rs:13:19\n   |\n13 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe395qx52.rs:14:19\n   |\n14 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe395qx52.rs:15:19\n   |\n15 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe395qx52.rs:16:19\n   |\n16 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe395qx52.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe395qx52.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe395qx52.rs:19:19\n   |\n19 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note:"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<char>>();\n    alphabet.rotate_left(2);\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpel8lh0o7.rs:68:1\n   |\n68\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpel8lh0o7.rs:13:19\n\
    \   |\n13 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpel8lh0o7.rs:14:19\n   |\n14 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpel8lh0o7.rs:15:19\n   |\n15 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpel8lh0o7.rs:16:19\n   |\n16 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpel8lh0o7.rs:17:19\n   |\n17 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpel8lh0o7.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpel8lh0o7.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpel8lh0o7.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |       "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.sort_by_key(|&c| c.to_ascii_lowercase());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp9nq03v49.rs:67:1\n   |\n67\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9nq03v49.rs:13:19\n\
    \   |\n13 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9nq03v49.rs:14:19\n   |\n14 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9nq03v49.rs:15:19\n   |\n15 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9nq03v49.rs:16:19\n   |\n16 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9nq03v49.rs:17:19\n   |\n17 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9nq03v49.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9nq03v49.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9nq03v49.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |       "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(alphabet[alphabet.len() - alphabet.iter().rev().next().unwrap().cmp(&c).unwrap()]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmp0k3am0cq.rs:15:93\n   |\n15 |         result.push(alphabet[alphabet.len()\
    \ - alphabet.iter().rev().next().unwrap().cmp(&c).unwrap()]);\n   |          \
    \                                                                            \
    \       ^^^^^^ method not found in `std::cmp::Ordering`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push_str(alphabet.iter().cloned().map(|c| c.to_string()).collect::<Vec<_>>());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_pwg8yus.rs:15:25\n   |\n\
    15 |         result.push_str(alphabet.iter().cloned().map(|c| c.to_string()).collect::<Vec<_>>());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `Vec`\n   |\n   = note: expected reference `&str`\n\
    \                 found struct `Vec<String>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphcu25m4i.rs:10:26\n   |\n\
    10 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    let mut result =\
    \ String::new();\n    for c in s.chars() {\n        result.push(alphabet[alphabet.index(c)\
    \ + alphabet.len()]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpgnqs86ra.rs:16:39\n   |\n16 |         result.push(alphabet[alphabet.index(c)\
    \ + alphabet.len()]);\n   |                                       ^^^^^ method\
    \ not found in `Vec<char>`\n   |\n   = help: items from traits can only be used\
    \ if the trait is in scope\nhelp: the following trait is implemented but not in\
    \ scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate_left(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        result.push((alphabet.iter().find(|&x|\
    \ x == c).unwrap() + 2) % 26 + 'A');\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&std::ops::Range<char>` with `char`\n  -->\
    \ /tmp/tmpn0qxj_pn.rs:15:50\n   |\n15 |         result.push((alphabet.iter().find(|&x|\
    \ x == c).unwrap() + 2) % 26 + 'A');\n   |                                   \
    \               ^^ no implementation for `&std::ops::Range<char> == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `&std::ops::Range<char>`\n\
    \   = help: the trait `PartialEq` is implemented for `std::ops::Range<Idx>`\n\n\
    error[E0369]: cannot add `{integer}` to `&std::ops::Range<char>`\n  --> /tmp/tmpn0qxj_pn.rs:15:65\n\
    \   |\n15 |         result.push((alphabet.iter().find(|&x| x == c).unwrap() +\
    \ 2) % 26 + 'A');\n   |                      ------------------------------------------\
    \ ^ - {integer}\n   |                      |\n   |                      &std::ops::Range<char>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n    let\
    \ mut result = String::new();\n    for c in s.chars() {\n        result.push(alphabet[alphabet.index(c)]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<std::ops::Range<char>>`\
    \ in the current scope\n  --> /tmp/tmp5douq7l_.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)]);\n\
    \   |                                       ^^^^^ method not found in `Vec<std::ops::Range<char>>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(alphabet[alphabet.index(c) + alphabet.len()\
    \ - alphabet.index(c) % alphabet.len()]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpixl0kxmq.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)\
    \ + alphabet.len() - alphabet.index(c) % alphabet.len()]);\n   |             \
    \                          ^^^^^ method not found in `Vec<char>`\n   |\n   = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1\
    \  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found\
    \ for struct `Vec<char>` in the current scope\n  --> /tmp/tmpixl0kxmq.rs:15:76\n\
    \   |\n15 |         result.push(alphabet[alphabet.index(c) + alphabet.len() -\
    \ alphabet.index(c) % alphabet.len()]);\n   |                                \
    \                                            ^^^^^ method not found in `Vec<char>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        let index = alphabet.iter().position(|x| x == c).unwrap();\n\
    \        result.push_str(&alphabet[index]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpugeru3ql.rs:15:52\n\
    \   |\n15 |         let index = alphabet.iter().position(|x| x == c).unwrap();\n\
    \   |                                                    ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugeru3ql.rs:16:25\n   |\n16 |  \
    \       result.push_str(&alphabet[index]);\n   |                         ^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.rotate_left(2);\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpv87zrcpq.rs:68:1\n   |\n68\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv87zrcpq.rs:13:19\n\
    \   |\n13 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv87zrcpq.rs:14:19\n   |\n14 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv87zrcpq.rs:15:19\n   |\n15 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv87zrcpq.rs:16:19\n   |\n16 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv87zrcpq.rs:17:19\n   |\n17 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv87zrcpq.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv87zrcpq.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv87zrcpq.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |       "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.rotate_left(2);\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpi3w7pk1f.rs:68:1\n   |\n68\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi3w7pk1f.rs:13:19\n\
    \   |\n13 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi3w7pk1f.rs:14:19\n   |\n14 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpi3w7pk1f.rs:15:19\n   |\n15 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi3w7pk1f.rs:16:19\n   |\n16 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpi3w7pk1f.rs:17:19\n   |\n17 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi3w7pk1f.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpi3w7pk1f.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi3w7pk1f.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |       "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n    let\
    \ mut result = String::new();\n    for c in s.chars() {\n        result.push(alphabet.iter().find(|&x|\
    \ x == c).unwrap().unwrap());\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&std::ops::Range<char>` with `char`\n  -->\
    \ /tmp/tmpd7z4qid2.rs:15:49\n   |\n15 |         result.push(alphabet.iter().find(|&x|\
    \ x == c).unwrap().unwrap());\n   |                                          \
    \       ^^ no implementation for `&std::ops::Range<char> == char`\n   |\n   =\
    \ help: the trait `PartialEq<char>` is not implemented for `&std::ops::Range<char>`\n\
    \   = help: the trait `PartialEq` is implemented for `std::ops::Range<Idx>`\n\n\
    error[E0599]: no method named `unwrap` found for reference `&std::ops::Range<char>`\
    \ in the current scope\n  --> /tmp/tmpd7z4qid2.rs:15:64\n   |\n15 |         result.push(alphabet.iter().find(|&x|\
    \ x == c).unwrap().unwrap());\n   |                                          \
    \                      ^^^^^^ method not found in `&std::ops::Range<char>`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate_left(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        result.push_str(alphabet.iter().cloned().take(alphabet.len()).collect::<String>());\n\
    \        result.push_str(&c.to_string());\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `std::ops::Range<char>`\n    --> /tmp/tmpbz_o4ukl.rs:15:71\n\
    \     |\n15   |         result.push_str(alphabet.iter().cloned().take(alphabet.len()).collect::<String>());\n\
    \     |                                                                      \
    \ ^^^^^^^ value of type `String` cannot be built from `std::iter::Iterator<Item=std::ops::Range<char>>`\n\
    \     |\n     = help: the trait `FromIterator<std::ops::Range<char>>` is not implemented\
    \ for `String`\n     = help: the following other types implement trait `FromIterator<A>`:\n\
    \               <String as FromIterator<&'a char>>\n               <String as\
    \ FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbz_o4ukl.rs:15:25\n\
    \   |\n15 |         result.push_str(alphabet.iter().cloned().take(alphabet.len()).collect::<String>());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                         |\n   |                         expected `&str`,\
    \ found struct `String`\n   |                         help: consider borrowing\
    \ here: `&alphabet.iter().cloned().take(alphabet.len()).collect::<String>()`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.sort_by_key(|&x| x.to_ascii_lowercase());\n\
    \    alphabet.push(Alphabet::Z);\n    alphabet.push(Alphabet::A);\n    alphabet.push(Alphabet::B);\n\
    \    alphabet.push(Alphabet::C);\n    alphabet.push(Alphabet::D);\n    alphabet.push(Alphabet::E);\n\
    \    alphabet.push(Alphabet::F);\n    alphabet.push(Alphabet::G);\n    alphabet.push(Alphabet::H);\n\
    \    alphabet.push(Alphabet::I);\n    alphabet.push(Alphabet::J);\n    alphabet.push(Alphabet::K);\n\
    \    alphabet.push(Alphabet::L);\n    alphabet.push(Alphabet::M);\n    alphabet.push(Alphabet::N);\n\
    \    alphabet.push(Alphabet::O);\n    alphabet.push(Alphabet::P);\n    alphabet.push(Alphabet::Q);\n\
    \    alphabet.push(Alphabet::R);\n    alphabet.push(Alphabet::S);\n    alphabet.push(Alphabet::T);\n\
    \    alphabet.push(Alphabet::U);\n    alphabet.push(Alphabet::V);\n    alphabet.push(Alphabet::W);\n\
    \    alphabet.push(Alphabet::X);\n    alphabet.push(Alphabet::Y);\n    alphabet.push(Alphabet::Z);\n\
    \n    let mut result = String::new();\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        let mut j = 0;\n        while j < alphabet.len() {\n            let\
    \ mut k = alphabet.len() - 1;\n            while k >= 0 && alphabet[j].to_ascii_lowercase()\
    \ == alphabet[k].to_ascii_lowercase() {\n                k -= 1;\n           \
    \ }\n            if k == -1 {\n                result.push(*alphabet[j]);\n  \
    \              j += 1;\n            } else {\n                result.push(*alphabet[j].rotate_left(k));\n\
    \                j += 1;\n            }\n        }\n        i += 1;\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpgmyp1dqm.rs:13:19\n   |\n13 |     alphabet.push(Alphabet::Z);\n   |\
    \                   ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmpgmyp1dqm.rs:14:19\n\
    \   |\n14 |     alphabet.push(Alphabet::A);\n   |                   ^^^^^^^^ use\
    \ of undeclared type `Alphabet`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Alphabet`\n  --> /tmp/tmpgmyp1dqm.rs:15:19\n   |\n15 |     alphabet.push(Alphabet::B);\n\
    \   |                   ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmpgmyp1dqm.rs:16:19\n\
    \   |\n16 |     alphabet.push(Alphabet::C);\n   |                   ^^^^^^^^ use\
    \ of undeclared type `Alphabet`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Alphabet`\n  --> /tmp/tmpgmyp1dqm.rs:17:19\n   |\n17 |     alphabet.push(Alphabet::D);\n\
    \   |                   ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmpgmyp1dqm.rs:18:19\n\
    \   |\n18 |     alphabet.push(Alphabet::E);\n   |                   ^^^^^^^^ use\
    \ of undeclared type `Alphabet`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Alphabet`\n  --> /tmp/tmpgmyp1dqm.rs:19:19\n   |\n19 |     alphabet.push(Alphabet::F);\n\
    \   |                   ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmpgmyp1dqm.rs:20:19\n\
    \   |\n20 |     alphabet.push(Alphabet::G);\n   |                   ^^^^^^^^ use\
    \ of undeclared type `Alphabet`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Alphabet`\n  --> /tmp/tmpgmyp1dqm.rs:21:19\n   |\n21 |     alphabet.push(Alphabet::H);\n\
    \   |                   ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmpgmyp1dqm.rs:22:19\n\
    \   |\n22 |     alphabet.push(Alphabet::I);\n   |                   ^^^^^^^^ use"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(alphabet[alphabet.index(c) + 1]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpn1zsjuze.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)\
    \ + 1]);\n   |                                       ^^^^^ method not found in\
    \ `Vec<char>`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push_str(alphabet.iter().cloned().take(alphabet.len()).collect::<String>());\n\
    \        result.push(c);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzmu762rn.rs:15:25\n   |\n\
    15 |         result.push_str(alphabet.iter().cloned().take(alphabet.len()).collect::<String>());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                         |\n   |                         expected `&str`,\
    \ found struct `String`\n   |                         help: consider borrowing\
    \ here: `&alphabet.iter().cloned().take(alphabet.len()).collect::<String>()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate(2);\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push_str(alphabet.iter().map(|c| c.to_string()).collect::<Vec<_>>().join(\"\
    \"));\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate` found for struct `Vec<char>` in\
    \ the current scope\n  --> /tmp/tmp03p0yopo.rs:12:14\n   |\n12 |     alphabet.rotate(2);\n\
    \   |              ^^^^^^ help: there is an associated function with a similar\
    \ name: `rotate_left`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp03p0yopo.rs:15:25\n\
    \   |\n15 |         result.push_str(alphabet.iter().map(|c| c.to_string()).collect::<Vec<_>>().join(\"\
    \"));\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                         |\n   |                         expected `&str`,\
    \ found struct `String`\n   |                         help: consider borrowing\
    \ here: `&alphabet.iter().map(|c| c.to_string()).collect::<Vec<_>>().join(\"\"\
    )`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzogsyxs0.rs:10:26\n   |\n\
    10 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(alphabet[alphabet.index(c) + alphabet.len()\
    \ - alphabet.index(c) - 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpx6__05z3.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)\
    \ + alphabet.len() - alphabet.index(c) - 1]);\n   |                          \
    \             ^^^^^ method not found in `Vec<char>`\n   |\n   = help: items from\
    \ traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use\
    \ std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct\
    \ `Vec<char>` in the current scope\n  --> /tmp/tmpx6__05z3.rs:15:76\n   |\n15\
    \ |         result.push(alphabet[alphabet.index(c) + alphabet.len() - alphabet.index(c)\
    \ - 1]);\n   |                                                               \
    \             ^^^^^ method not found in `Vec<char>`\n   |\n   = help: items from\
    \ traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use\
    \ std::ops::Index;\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpd4jjb2qj.rs:78:25\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n78 |     alphabet.rotate_left(\n\
    \   |                         ^ unclosed delimiter\n79 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n    --> /tmp/tmpd4jjb2qj.rs:78:14\n     |\n78   |     alphabet.rotate_left(\n\
    \     |              ^^^^^^^^^^^- supplied 0 arguments\n     |              |\n\
    \     |              expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd4jjb2qj.rs:78:5\n   |\n\
    10 |   fn encrypt(s: String) -> String {\n   |                            ------\
    \ expected `String` because of return type\n...\n78 | /     alphabet.rotate_left(\n\
    79 | | }\n   | |_^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpwhm6f61n.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 'v', 't', 's', 'r', 'q', 'p', 'o',\
    \ 'n', 'm', 'l', 'k', 'j', 'h', 'i', 'a'];\n    alphabet.rotate_left(2);\n   \
    \ let mut result = String::new();\n    for c in s.chars() {\n        result.push(alphabet[alphabet.index(c)\
    \ + 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp_92fqgfj.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)\
    \ + 1]);\n   |                                       ^^^^^ method not found in\
    \ `Vec<char>`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.sort_unstable();\n \
    \   alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpi2znur38.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n    let\
    \ mut result = String::new();\n    for c in s.chars() {\n        result.push((alphabet.iter().find(|&x|\
    \ x == c).unwrap() + 2) as char);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&std::ops::Range<char>` with `char`\n  -->\
    \ /tmp/tmp40qlv0ib.rs:15:50\n   |\n15 |         result.push((alphabet.iter().find(|&x|\
    \ x == c).unwrap() + 2) as char);\n   |                                      \
    \            ^^ no implementation for `&std::ops::Range<char> == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&std::ops::Range<char>`\n\
    \   = help: the trait `PartialEq` is implemented for `std::ops::Range<Idx>`\n\n\
    error[E0369]: cannot add `{integer}` to `&std::ops::Range<char>`\n  --> /tmp/tmp40qlv0ib.rs:15:65\n\
    \   |\n15 |         result.push((alphabet.iter().find(|&x| x == c).unwrap() +\
    \ 2) as char);\n   |                      ------------------------------------------\
    \ ^ - {integer}\n   |                      |\n   |                      &std::ops::Range<char>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate(2);\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push((alphabet.iter().find(|&x| x == c).unwrap() + 2) % 26);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate` found for struct `Vec<char>` in\
    \ the current scope\n  --> /tmp/tmps1mghyls.rs:12:14\n   |\n12 |     alphabet.rotate(2);\n\
    \   |              ^^^^^^ help: there is an associated function with a similar\
    \ name: `rotate_left`\n\nerror[E0277]: can't compare `&char` with `char`\n  -->\
    \ /tmp/tmps1mghyls.rs:15:50\n   |\n15 |         result.push((alphabet.iter().find(|&x|\
    \ x == c).unwrap() + 2) % 26);\n   |                                         \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0369]: cannot add `{integer}` to `&char`\n\
    \  --> /tmp/tmps1mghyls.rs:15:65\n   |\n15 |         result.push((alphabet.iter().find(|&x|\
    \ x == c).unwrap() + 2) % 26);\n   |                      ------------------------------------------\
    \ ^ - {integer}\n   |                      |\n   |                      &char\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmptqwg_9ap.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.sort_by_key(|&x| x.chars().count());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    let mut result = String::new();\n    for c in s.chars() {\n        let mut\
    \ i = 0;\n        for &a in alphabet {\n            if i == 0 {\n            \
    \    result.push(a);\n            }\n            if c.chars().any(|&b| a == b)\
    \ {\n                i += 2;\n            } else {\n                i += 1;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for struct `std::ops::Range`\
    \ in the current scope\n  --> /tmp/tmpdpoq3ej4.rs:12:33\n   |\n12 |     alphabet.sort_by_key(|&x|\
    \ x.chars().count());\n   |                                 ^^^^^ method not found\
    \ in `std::ops::Range<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdpoq3ej4.rs:13:19\n\
    \   |\n13 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found reference\n\
    \   |\n   = note: expected struct `std::ops::Range<char>`\n           found reference\
    \ `&std::ops::Range<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdpoq3ej4.rs:14:19\n\
    \   |\n14 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::ops::Range`, found reference\n\
    \   |\n   = note: expected struct `std::ops::Range<char>`\n           found reference\
    \ `&std::ops::Range<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdpoq3ej4.rs:18:13\n\
    \   |\n18 |         for &a in alphabet {\n   |             ^^    -------- this\
    \ expression has type `Option<std::ops::Range<char>>`\n   |             |\n  \
    \ |             expected struct `std::ops::Range`, found reference\n   |     \
    \        help: you can probably remove the explicit borrow: `a`\n   |\n   = note:\
    \ expected struct `std::ops::Range<char>`\n           found reference `&_`\n\n\
    error[E0599]: no method named `chars` found for type `char` in the current scope\n\
    \  --> /tmp/tmpdpoq3ej4.rs:22:18\n   |\n22 |             if c.chars().any(|&b|\
    \ a == b) {\n   |                  ^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ let mut new_alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut i = 0;\n    for c in s.chars() {\n        new_alphabet[i] = alphabet[alphabet.len()\
    \ - c - 1];\n        i += 1;\n    }\n    new_alphabet.push('A');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n    new_alphabet.push('Z');\n\
    \    new_alphabet.push('Z');\n    new_alphabet.push('\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp122xqz1x.rs:72:23\n\
    \   |\n72 |     new_alphabet.push('\n   |                       ^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 'v', 't', 's', 'r', 'q', 'p', 'o',\
    \ 'n', 'm', 'l', 'k', 'j', 'i', 'h', 'g', 'f', 'e', 'd', 'c', 'b', 'a'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push_str(&alphabet[alphabet.index(c) + alphabet.len()]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp9ao0h0b7.rs:15:44\n   |\n15 |         result.push_str(&alphabet[alphabet.index(c)\
    \ + alphabet.len()]);\n   |                                            ^^^^^ method\
    \ not found in `Vec<char>`\n   |\n   = help: items from traits can only be used\
    \ if the trait is in scope\nhelp: the following trait is implemented but not in\
    \ scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push((alphabet.iter().find(|x| x == c).unwrap()\
    \ + 2) % 26);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&&char` with `char`\n  --> /tmp/tmpogacwyu6.rs:15:49\n\
    \   |\n15 |         result.push((alphabet.iter().find(|x| x == c).unwrap() + 2)\
    \ % 26);\n   |                                                 ^^ no implementation\
    \ for `&&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0369]: cannot add `{integer}` to `&char`\n  --> /tmp/tmpogacwyu6.rs:15:64\n\
    \   |\n15 |         result.push((alphabet.iter().find(|x| x == c).unwrap() + 2)\
    \ % 26);\n   |                      -----------------------------------------\
    \ ^ - {integer}\n   |                      |\n   |                      &char\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.rotate_left(2);\n  \
    \  alphabet.iter().cloned().collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpxaqt9o1f.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `swap` on type `Vec<char>`\n\
    \  --> /tmp/tmprdh1ghqk.rs:53:14\n   |\n53 |     alphabet.swap\n   |         \
    \     ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n\
    \   |\n53 |     alphabet.swap(_, _)\n   |                  ++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut result = String::new();\n    let mut i = 0;\n    for c in s.chars()\
    \ {\n        let mut j = alphabet.len() - 1;\n        while j >= 0 {\n       \
    \     if alphabet[j] >= c {\n                j -= 2;\n            } else {\n \
    \               break;\n            }\n        }\n        i += j;\n        result.append(alphabet[i]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpk5917388.rs:24:16\n   |\n24 |         result.append(alphabet[i]);\n\
    \   |                ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x',\
    \ 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z',\
    \ 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y',\
    \ 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v',\
    \ 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w',\
    \ 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y',\
    \ 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x',\
    \ 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u',\
    \ 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u',\
    \ 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x',\
    \ 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z',\
    \ 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y',\
    \ 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v',\
    \ 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w',\
    \ 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y',\
    \ 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x',\
    \ 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u',\
    \ 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u',\
    \ 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x',\
    \ 'w', 'u', 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', 'z',\
    \ 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x', '\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmps4cvhjtw.rs:11:1649\n\
    \   |\n11 | ... 'v', 'u', 'y', 'x', 'z', 'y', 'x', 'w', 'u', 'v', 'u', 'y', 'x',\
    \ '\n   |                                                                    \
    \  ^\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n    alphabet.iter().for_each(|c|\
    \ {\n        let index = alphabet.iter().position(|x| x == c);\n        alphabet[index]\
    \ = alphabet[index].to_uppercase();\n    });\n    alphabet.iter().for_each(|c|\
    \ {\n        let index = alphabet.iter().position(|x| x == c);\n        alphabet[index]\
    \ = alphabet[index].to_lowercase();\n    });\n    alphabet.iter().for_each(|c|\
    \ {\n        let index = alphabet.iter().position(|x| x == c);\n        alphabet[index]\
    \ = c.to_string();\n    });\n    let mut result = String::new();\n    s.chars().for_each(|c|\
    \ {\n        let index = alphabet.iter().position(|x| x == c);\n        result.append(&alphabet[index]);\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[std::ops::Range<char>]` cannot be indexed by `Option<usize>`\n\
    \  --> /tmp/tmp24febn8a.rs:15:9\n   |\n15 |         alphabet[index] = alphabet[index].to_uppercase();\n\
    \   |         ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[std::ops::Range<char>]>` is not implemented\
    \ for `Option<usize>`\n   = note: required because of the requirements on the\
    \ impl of `Index<Option<usize>>` for `Vec<std::ops::Range<char>>`\n\nerror[E0277]:\
    \ the type `[std::ops::Range<char>]` cannot be indexed by `Option<usize>`\n  -->\
    \ /tmp/tmp24febn8a.rs:15:27\n   |\n15 |         alphabet[index] = alphabet[index].to_uppercase();\n\
    \   |                           ^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[std::ops::Range<char>]>`\
    \ is not implemented for `Option<usize>`\n   = note: required because of the requirements\
    \ on the impl of `Index<Option<usize>>` for `Vec<std::ops::Range<char>>`\n\nerror[E0277]:\
    \ the type `[std::ops::Range<char>]` cannot be indexed by `Option<usize>`\n  -->\
    \ /tmp/tmp24febn8a.rs:19:9\n   |\n19 |         alphabet[index] = alphabet[index].to_lowercase();\n\
    \   |         ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[std::ops::Range<char>]>` is not implemented\
    \ for `Option<usize>`\n   = note: required because of the requirements on the\
    \ impl of `Index<Option<usize>>` for `Vec<std::ops::Range<char>>`\n\nerror[E0277]:\
    \ the type `[std::ops::Range<char>]` cannot be indexed by `Option<usize>`\n  -->\
    \ /tmp/tmp24febn8a.rs:19:27\n   |\n19 |         alphabet[index] = alphabet[index].to_lowercase();\n\
    \   |                           ^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[std::ops::Range<char>]>`\
    \ is not implemented for `Option<usize>`\n   = note: required because of the requirements\
    \ on the impl of `Index<Option<usize>>` for `Vec<std::ops::Range<char>>`\n\nerror[E0599]:\
    \ the method `to_string` exist"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ let mut new_alphabet = alphabet.clone();\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.len() - 1);\n    new_alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    new_alphabet.swap_remove(alphabet.\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `)`\n  --> /tmp/tmpw4ie09n9.rs:51:1\n   |\n51\
    \ | }\n   | ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpw4ie09n9.rs:50:29\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n50 |     new_alphabet.swap_remove(alphabet.\n\
    \   |                             ^ unclosed delimiter\n51 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw4ie09n9.rs:50:30\n\
    \   |\n50 |     new_alphabet.swap_remove(alphabet.\n   |                     \
    \         ^^^^^^^^ expected `usize`, found struct `Vec`\n   |\n   = note: expected\
    \ type `usize`\n            found struct `Vec<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw4ie09n9.rs:50:5\n   |\n10 |   fn encrypt(s: String) ->\
    \ String {\n   |                            ------ expected `String` because of\
    \ return type\n...\n50 | /     new_alphabet.swap_remove(alphabet.\n51 | | }\n\
    \   | | ^- help: try using a conversion method: `.to_string()`\n   | |_|\n   |\
    \   expected struct `String`, found `char`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 't', 's', 'r', 'q', 'p', 'o', 'n',\
    \ 'm', 'l', 'k', 'j', 'h', 'i', 'a'];\n    alphabet.rotate_left(2);\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push((alphabet.last()\
    \ + (alphabet.len() - alphabet.iter().rev().next().unwrap().unwrap())).to_string());\n\
    \        result.push(c);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for reference `&char` in the\
    \ current scope\n  --> /tmp/tmpgk_fy623.rs:15:96\n   |\n15 |         result.push((alphabet.last()\
    \ + (alphabet.len() - alphabet.iter().rev().next().unwrap().unwrap())).to_string());\n\
    \   |                                                                        \
    \                        ^^^^^^ method not found in `&char`\n\nerror[E0369]: cannot\
    \ add `usize` to `Option<&char>`\n  --> /tmp/tmpgk_fy623.rs:15:38\n   |\n15 |\
    \         result.push((alphabet.last() + (alphabet.len() - alphabet.iter().rev().next().unwrap().unwrap())).to_string());\n\
    \   |                      --------------- ^ -----------------------------------------------------------------\
    \ usize\n   |                      |\n   |                      Option<&char>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 't', 's', 'r', 'q', 'p', 'o', 'n',\
    \ 'm', 'l', 'k', 'j', 'h', 'i', 'a'];\n    alphabet.rotate_left(2);\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(alphabet[alphabet.index(c)]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpjztuz6aa.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)]);\n\
    \   |                                       ^^^^^ method not found in `Vec<char>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `swap` on type `Vec<char>`\n\
    \  --> /tmp/tmp62xsjk32.rs:53:14\n   |\n53 |     alphabet.swap\n   |         \
    \     ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n\
    \   |\n53 |     alphabet.swap(_, _)\n   |                  ++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate(2);\n    let mut result = String::new();\n\
    \    for c in s.chars() {\n        result.push((alphabet.iter().find(|&x| x ==\
    \ c).unwrap() + 2) % 26);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate` found for struct `Vec<std::ops::Range<char>>`\
    \ in the current scope\n  --> /tmp/tmpw_0ua0p6.rs:12:14\n   |\n12 |     alphabet.rotate(2);\n\
    \   |              ^^^^^^ help: there is an associated function with a similar\
    \ name: `rotate_left`\n\nerror[E0277]: can't compare `&std::ops::Range<char>`\
    \ with `char`\n  --> /tmp/tmpw_0ua0p6.rs:15:50\n   |\n15 |         result.push((alphabet.iter().find(|&x|\
    \ x == c).unwrap() + 2) % 26);\n   |                                         \
    \         ^^ no implementation for `&std::ops::Range<char> == char`\n   |\n  \
    \ = help: the trait `PartialEq<char>` is not implemented for `&std::ops::Range<char>`\n\
    \   = help: the trait `PartialEq` is implemented for `std::ops::Range<Idx>`\n\n\
    error[E0369]: cannot add `{integer}` to `&std::ops::Range<char>`\n  --> /tmp/tmpw_0ua0p6.rs:15:65\n\
    \   |\n15 |         result.push((alphabet.iter().find(|&x| x == c).unwrap() +\
    \ 2) % 26);\n   |                      ------------------------------------------\
    \ ^ - {integer}\n   |                      |\n   |                      &std::ops::Range<char>\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(alphabet[alphabet.index(c) + alphabet.len()\
    \ - alphabet.index(c) - 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpz4hn2iii.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)\
    \ + alphabet.len() - alphabet.index(c) - 1]);\n   |                          \
    \             ^^^^^ method not found in `Vec<char>`\n   |\n   = help: items from\
    \ traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use\
    \ std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct\
    \ `Vec<char>` in the current scope\n  --> /tmp/tmpz4hn2iii.rs:15:76\n   |\n15\
    \ |         result.push(alphabet[alphabet.index(c) + alphabet.len() - alphabet.index(c)\
    \ - 1]);\n   |                                                               \
    \             ^^^^^ method not found in `Vec<char>`\n   |\n   = help: items from\
    \ traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use\
    \ std::ops::Index;\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate();\n    let mut cipher = String::new();\n\
    \    for c in s.chars() {\n        cipher.push((alphabet.index(c) + alphabet.index(c.next())).to_string());\n\
    \    }\n    cipher\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpbq0i80xx.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0599]:\
    \ no method named `next` found for type `char` in the current scope\n  --> /tmp/tmpbq0i80xx.rs:15:59\n\
    \   |\n15 |         cipher.push((alphabet.index(c) + alphabet.index(c.next())).to_string());\n\
    \   |                                                           ^^^^ method not\
    \ found in `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0433, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(alphabet[alphabet.index(c) + 1]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpr59kcf4j.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)\
    \ + 1]);\n   |                                       ^^^^^ method not found in\
    \ `Vec<char>`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpixonhg_r.rs:43:21\n   |\n\
    43 |     let mut alphabet\n   |                     ^ help: add `;` here\n44 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpixonhg_r.rs:10:26\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmphx40xdwk.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(alphabet[alphabet.index(c) + 1]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp03110riq.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)\
    \ + 1]);\n   |                                       ^^^^^ method not found in\
    \ `Vec<char>`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        result.push(alphabet.index(c));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmplp2wyr7d.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.rotate_left(2);\n  \
    \  alphabet.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp_rw4rm32.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmprhbrhg7s.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ let mut result = String::new();\n    let mut i = 0;\n    for c in s.chars()\
    \ {\n        let mut j = alphabet.len() - 1;\n        while j > i {\n        \
    \    alphabet.swap(i, j);\n            i += 2;\n            j -= 2;\n        }\n\
    \        result += alphabet[alphabet.len() - alphabet.iter().position(|&x| x ==\
    \ c).unwrap()];\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzvzxj6jz.rs:21:19\n   |\n\
    21 |         result += alphabet[alphabet.len() - alphabet.iter().position(|&x|\
    \ x == c).unwrap()];\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    let mut s = String::from(s);\n\
    \    for c in s.chars() {\n        alphabet.rotate_left(2);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n        alphabet.rotate_left(1);\n\
    \        alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpormbrv55.rs:96:3\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - unclosed delimiter\n...\n14 |     for c in s.chars() {\n   |       \
    \                 - this delimiter might not be properly closed...\n...\n84 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n96 |\
    \ }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpormbrv55.rs:84:1\n\
    \   |\n84 | }\n   | ^\n\nerror[E0433]: failed to resolve: use of undeclared type\
    \ `Alphabet`\n  --> /tmp/tmpormbrv55.rs:11:24\n   |\n11 |     let mut alphabet\
    \ = Alphabet::new();\n   |                        ^^^^^^^^ use of undeclared type\
    \ `Alphabet`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpormbrv55.rs:10:26\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.rotate_left(2);\n  \
    \  alphabet.iter().map(|c| c.to_string()).collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpuzsdjs2d.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        let index = alphabet.iter().position(|&x| x == c).unwrap();\n\
    \        result.push((alphabet.len() - index) as char);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `usize`\n  --> /tmp/tmpiyldavwm.rs:16:21\n\
    \   |\n16 |         result.push((alphabet.len() - index) as char);\n   |     \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try\
    \ `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmpiyldavwm.rs:16:21\n  \
    \ |\n16 |         result.push((alphabet.len() - index) as char);\n   |       \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0604`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n    let\
    \ mut result = String::new();\n    for c in s.chars() {\n        let index = alphabet.iter().position(|x|\
    \ *x == c).unwrap();\n        result.push_str(&alphabet[index..alphabet.iter().position(|x|\
    \ *x == c).unwrap()+2]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp525nf4vu.rs:15:56\n   |\n\
    15 |         let index = alphabet.iter().position(|x| *x == c).unwrap();\n   |\
    \                                                        ^ expected struct `std::ops::Range`,\
    \ found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n   \
    \             found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp525nf4vu.rs:16:77\n\
    \   |\n16 |         result.push_str(&alphabet[index..alphabet.iter().position(|x|\
    \ *x == c).unwrap()+2]);\n   |                                               \
    \                              ^ expected struct `std::ops::Range`, found `char`\n\
    \   |\n   = note: expected struct `std::ops::Range<char>`\n                found\
    \ type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp525nf4vu.rs:16:25\n\
    \   |\n16 |         result.push_str(&alphabet[index..alphabet.iter().position(|x|\
    \ *x == c).unwrap()+2]);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found slice\n   |\n   = note: expected reference `&str`\n  \
    \            found reference `&[std::ops::Range<char>]`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        let index = alphabet.iter().position(|x| *x == c).unwrap();\n\
    \        result.push_str(&alphabet[index]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1a6c8jo3.rs:16:25\n   |\n\
    16 |         result.push_str(&alphabet[index]);\n   |                        \
    \ ^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(alphabet[alphabet.index(c) + alphabet.len()]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpn7eyisgf.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)\
    \ + alphabet.len()]);\n   |                                       ^^^^^ method\
    \ not found in `Vec<char>`\n   |\n   = help: items from traits can only be used\
    \ if the trait is in scope\nhelp: the following trait is implemented but not in\
    \ scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 'v', 'u', 't', 's', 'r', 'q', 'p',\
    \ 'o', 'n', 'm', 'l', 'k', 'j', 'h', 'e', 'g', 'f', 'd', 'c', 'b', 'a'];\n   \
    \ alphabet.swap_remove(alphabet.iter().cloned().skip(alphabet.len()/2));\n   \
    \ let mut result = String::new();\n    for c in s.chars() {\n        let index\
    \ = alphabet.iter().position(|&x| x == c).unwrap();\n        result.push_str(&alphabet[index\
    \ + alphabet.len()/2]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9qfwv7qa.rs:12:26\n   |\n\
    12 |     alphabet.swap_remove(alphabet.iter().cloned().skip(alphabet.len()/2));\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found struct `Skip`\n   |\n   = note: expected type `usize`\n\
    \            found struct `Skip<Cloned<std::slice::Iter<'_, char>>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9qfwv7qa.rs:16:25\n   |\n16 |         result.push_str(&alphabet[index\
    \ + alphabet.len()/2]);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `swap` on type `Vec<char>`\n\
    \  --> /tmp/tmpaikj81ls.rs:53:14\n   |\n53 |     alphabet.swap\n   |         \
    \     ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n\
    \   |\n53 |     alphabet.swap(_, _)\n   |                  ++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    \n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpec2go_wt.rs:12:19\n   |\n\
    12 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpec2go_wt.rs:13:19\n   |\n13 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpec2go_wt.rs:14:19\n   |\n14 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpec2go_wt.rs:15:19\n   |\n15 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpec2go_wt.rs:16:19\n   |\n16 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpec2go_wt.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpec2go_wt.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpec2go_wt.rs:19:19\n   |\n19 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note:"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push((alphabet.iter().find(|&x| x == c).unwrap()\
    \ + 2) % 26);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpx_oh0yn5.rs:15:50\n\
    \   |\n15 |         result.push((alphabet.iter().find(|&x| x == c).unwrap() +\
    \ 2) % 26);\n   |                                                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0369]: cannot add `{integer}` to `&char`\n  --> /tmp/tmpx_oh0yn5.rs:15:65\n\
    \   |\n15 |         result.push((alphabet.iter().find(|&x| x == c).unwrap() +\
    \ 2) % 26);\n   |                      ------------------------------------------\
    \ ^ - {integer}\n   |                      |\n   |                      &char\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        let mut c = c.to_ascii_lowercase();\n\
    \        c = alphabet.rotate_right(c);\n        result.push(c);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp47dvjsgc.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp38zo5ns0.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n    let\
    \ mut result = String::new();\n    for c in s.chars() {\n        let index = alphabet.iter().position(|&x|\
    \ x == c).unwrap();\n        result.push_str(&alphabet[index]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpot41v25g.rs:15:56\n   |\n\
    15 |         let index = alphabet.iter().position(|&x| x == c).unwrap();\n   |\
    \                                                        ^ expected struct `std::ops::Range`,\
    \ found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n   \
    \             found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpot41v25g.rs:16:25\n\
    \   |\n16 |         result.push_str(&alphabet[index]);\n   |                 \
    \        ^^^^^^^^^^^^^^^^ expected `str`, found struct `std::ops::Range`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&std::ops::Range<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.sort_by_key(|&x| x.to_ascii_lowercase());\n\
    \    alphabet.push(alphabet[0]);\n    alphabet.push(alphabet[1]);\n    alphabet.push(alphabet[2]);\n\
    \    alphabet.push(alphabet[3]);\n    alphabet.push(alphabet[4]);\n    alphabet.push(alphabet[5]);\n\
    \    alphabet.push(alphabet[6]);\n    alphabet.push(alphabet[7]);\n    alphabet.push(alphabet[8]);\n\
    \    alphabet.push(alphabet[9]);\n    alphabet.push(alphabet[10]);\n    alphabet.push(alphabet[11]);\n\
    \    alphabet.push(alphabet[12]);\n    alphabet.push(alphabet[13]);\n    alphabet.push(alphabet[14]);\n\
    \    alphabet.push(alphabet[15]);\n    alphabet.push(alphabet[16]);\n    alphabet.push(alphabet[17]);\n\
    \    alphabet.push(alphabet[18]);\n    alphabet.push(alphabet[19]);\n    alphabet.push(alphabet[20]);\n\
    \    alphabet.push(alphabet[21]);\n    alphabet.push(alphabet[22]);\n    alphabet.push(alphabet[23]);\n\
    \    alphabet.push(alphabet[24]);\n    alphabet.push(alphabet[25]);\n    alphabet.push(alphabet[26]);\n\
    \    alphabet.push(alphabet[27]);\n    alphabet.push(alphabet[28]);\n    alphabet.push(alphabet[29]);\n\
    \    alphabet.push(alphabet[30]);\n    alphabet.push(alphabet[31]);\n    alphabet.push(alphabet[32]);\n\
    \    alphabet.push(alphabet[33]);\n    alphabet.push(alphabet[34]);\n    alphabet.push(alphabet[35]);\n\
    \    alphabet.push(alphabet[36]);\n    alphabet.push(alphabet[37]);\n    alphabet.push(alphabet[38]);\n\
    \    alphabet.push(alphabet[39]);\n    alphabet.push(alphabet[40]);\n    alphabet.push(alphabet[41]);\n\
    \    alphabet.push(alphabet[42]);\n    alphabet.push(alphabet[43]);\n    alphabet.push(alphabet[44]);\n\
    \    alphabet.push(alphabet[45]);\n    alphabet.push(alphabet[46]);\n    alphabet.push(alphabet[47]);\n\
    \    alphabet.push(alphabet[48]);\n    alphabet.push(alphabet[49]);\n    alphabet.push(alphabet[50]);\n\
    \    alphabet.push(alphabet[51]);\n    alphabet.push(alphabet[52]);\n    alphabet.push(alphabet[53]);\n\
    \    alphabet.push(alphabet[54]);\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeof00obr.rs:10:26\n   |\n\
    10 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 'v', 'u', 't', 's', 'r', 'q', 'p',\
    \ 'o', 'n', 'm', 'l', 'k', 'j', 'h', 'e', 'g', 'f', 'i', 'j', 'k', 'h', 'j', 'h',\
    \ 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k',\
    \ 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j',\
    \ 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h',\
    \ 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k',\
    \ 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j',\
    \ 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h',\
    \ 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k',\
    \ 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j',\
    \ 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h',\
    \ 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k',\
    \ 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j',\
    \ 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h',\
    \ 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k',\
    \ 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j', 'h', 'k', 'j',\
    \ 'h', 'k', 'j', 'h', 'k', 'j\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmplrw_gonu.rs:12:1\n   |\n12 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmplrw_gonu.rs:11:28\n   |\n10 | fn encrypt(s: String) -> String {\n  \
    \ |                                 - closing delimiter possibly meant for this\n\
    11 |     let mut alphabet = vec!['z', 'y', 'x', 'w', 'u', 'v', 'u', 't', 's',\
    \ 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'h', 'e', 'g', 'f',...\n   |  \
    \                          ^ unclosed delimiter\n12 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp0e_elh44.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ let mut result = String::new();\n    for c in s.chars() {\n        let mut index\
    \ = alphabet.iter().position(|&x| x == c).unwrap();\n        let mut new_index\
    \ = index;\n        new_index += 2;\n        alphabet[new_index] = alphabet[index];\n\
    \        alphabet[index] = c;\n        result.push_str(&alphabet);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ds68d8e.rs:19:25\n   |\n\
    19 |         result.push_str(&alphabet);\n   |                         ^^^^^^^^^\
    \ expected `str`, found struct `Vec`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&Vec<char>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate(2);\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(alphabet[alphabet.index(c) + 1]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate` found for struct `Vec<char>` in\
    \ the current scope\n  --> /tmp/tmpic0kfwhf.rs:12:14\n   |\n12 |     alphabet.rotate(2);\n\
    \   |              ^^^^^^ help: there is an associated function with a similar\
    \ name: `rotate_left`\n\nerror[E0599]: no method named `index` found for struct\
    \ `Vec<char>` in the current scope\n  --> /tmp/tmpic0kfwhf.rs:15:39\n   |\n15\
    \ |         result.push(alphabet[alphabet.index(c) + 1]);\n   |              \
    \                         ^^^^^ method not found in `Vec<char>`\n   |\n   = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1\
    \  | use std::ops::Index;\n   |\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate_left(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        result.push(alphabet[alphabet.index(c)]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<std::ops::Range<char>>`\
    \ in the current scope\n  --> /tmp/tmp8uq6o93e.rs:15:39\n   |\n15 |         result.push(alphabet[alphabet.index(c)]);\n\
    \   |                                       ^^^^^ method not found in `Vec<std::ops::Range<char>>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    let mut result = String::new();\n\
    \    for c in s.chars() {\n        let index = alphabet.iter().position(|&x| x\
    \ == c).unwrap();\n        result.push_str(&alphabet[index + 2]);\n        result.push_str(&alphabet[index\
    \ + 1]);\n        result.push_str(&alphabet[index]);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt7t6ry4s.rs:14:56\n   |\n\
    14 |         let index = alphabet.iter().position(|&x| x == c).unwrap();\n   |\
    \                                                        ^ expected struct `std::ops::Range`,\
    \ found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n   \
    \             found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt7t6ry4s.rs:15:25\n\
    \   |\n15 |         result.push_str(&alphabet[index + 2]);\n   |             \
    \            ^^^^^^^^^^^^^^^^^^^^ expected `str`, found struct `std::ops::Range`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&std::ops::Range<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpt7t6ry4s.rs:16:25\n   |\n16 |\
    \         result.push_str(&alphabet[index + 1]);\n   |                       \
    \  ^^^^^^^^^^^^^^^^^^^^ expected `str`, found struct `std::ops::Range`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&std::ops::Range<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpt7t6ry4s.rs:17:25\n   |\n17 |\
    \         result.push_str(&alphabet[index]);\n   |                         ^^^^^^^^^^^^^^^^\
    \ expected `str`, found struct `std::ops::Range`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&std::ops::Range<char>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        let mut c = c.to_ascii_lowercase();\n\
    \        alphabet.rotate_left(1);\n        result.push(c);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmprf7rw901.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.sort_unstable();\n \
    \   alphabet.rotate_right(alphabet.len() - 1);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `alphabet` as immutable because it is also\
    \ borrowed as mutable\n  --> /tmp/tmp684whyg1.rs:13:27\n   |\n13 |     alphabet.rotate_right(alphabet.len()\
    \ - 1);\n   |     ----------------------^^^^^^^^^^^^^^-----\n   |     |      \
    \  |            |\n   |     |        |            immutable borrow occurs here\n\
    \   |     |        mutable borrow later used by call\n   |     mutable borrow\
    \ occurs here\n   |\nhelp: try adding a local storing this argument...\n  -->\
    \ /tmp/tmp684whyg1.rs:13:27\n   |\n13 |     alphabet.rotate_right(alphabet.len()\
    \ - 1);\n   |                           ^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmp684whyg1.rs:13:5\n  \
    \ |\n13 |     alphabet.rotate_right(alphabet.len() - 1);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<char>>();\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<char>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<char>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<char>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<char>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<char>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<char>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<char>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<char>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<char>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<char>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<char>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<char>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<char>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<char>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<char>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp289n2myl.rs:43:21\n   |\n\
    43 |     let mut alphabet\n   |                     ^ help: add `;` here\n44 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp289n2myl.rs:10:26\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.rotate_left(2);\n  \
    \  alphabet.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8833ovis.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        result.push(alphabet[alphabet.index(c)\
    \ + 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate` found for struct `Vec<std::ops::Range<char>>`\
    \ in the current scope\n  --> /tmp/tmp021yhxz4.rs:12:14\n   |\n12 |     alphabet.rotate(2);\n\
    \   |              ^^^^^^ help: there is an associated function with a similar\
    \ name: `rotate_left`\n\nerror[E0599]: no method named `index` found for struct\
    \ `Vec<std::ops::Range<char>>` in the current scope\n  --> /tmp/tmp021yhxz4.rs:15:39\n\
    \   |\n15 |         result.push(alphabet[alphabet.index(c) + 1]);\n   |      \
    \                                 ^^^^^ method not found in `Vec<std::ops::Range<char>>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 't', 's', 'r', 'q', 'p', 'o', 'n',\
    \ 'm', 'l', 'k', 'j', 'h', 'i', 'a'];\n    alphabet.rotate_left(2);\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let index = alphabet.iter().position(|&x|\
    \ x == c).unwrap();\n        result.push((alphabet.len() - index) as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `usize`\n  --> /tmp/tmpjqusysg6.rs:16:21\n\
    \   |\n16 |         result.push((alphabet.len() - index) as char);\n   |     \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try\
    \ `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmpjqusysg6.rs:16:21\n  \
    \ |\n16 |         result.push((alphabet.len() - index) as char);\n   |       \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0604`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.rotate_left(2);\n  \
    \  alphabet.iter().cloned().collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp_vosg26t.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n    let mut cipher\
    \ = String::new();\n    cipher.push_str(s);\n    for c in cipher.chars() {\n \
    \       cipher.push(c);\n        alphabet.rotate_left(2);\n    }\n    cipher\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpmm3tks85.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmm3tks85.rs:14:21\n   |\n14 |     cipher.push_str(s);\n\
    \   |                     ^\n   |                     |\n   |                \
    \     expected `&str`, found struct `String`\n   |                     help: consider\
    \ borrowing here: `&s`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    \n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfmlyan2g.rs:12:19\n   |\n\
    12 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfmlyan2g.rs:13:19\n   |\n13 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfmlyan2g.rs:14:19\n   |\n14 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfmlyan2g.rs:15:19\n   |\n15 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfmlyan2g.rs:16:19\n   |\n16 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfmlyan2g.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfmlyan2g.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfmlyan2g.rs:19:19\n   |\n19 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note:"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.iter().for_each(|c| {\n        let index = alphabet.iter().position(|x|\
    \ x == c);\n        alphabet[index] = alphabet[index + 1];\n        alphabet[index\
    \ + 1] = c;\n    });\n    let mut result = String::new();\n    s.chars().for_each(|c|\
    \ {\n        let index = alphabet.iter().position(|x| x == c);\n        result.push(alphabet[index]);\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[std::ops::Range<char>]` cannot be indexed by `Option<usize>`\n\
    \  --> /tmp/tmp3ipgfcp3.rs:16:9\n   |\n16 |         alphabet[index] = alphabet[index\
    \ + 1];\n   |         ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[std::ops::Range<char>]>`\
    \ is not implemented for `Option<usize>`\n   = note: required because of the requirements\
    \ on the impl of `Index<Option<usize>>` for `Vec<std::ops::Range<char>>`\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp3ipgfcp3.rs:16:42\n\
    \   |\n16 |         alphabet[index] = alphabet[index + 1];\n   |             \
    \                       ----- ^ - {integer}\n   |                            \
    \        |\n   |                                    Option<usize>\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp3ipgfcp3.rs:17:24\n\
    \   |\n17 |         alphabet[index + 1] = c;\n   |                  ----- ^ -\
    \ {integer}\n   |                  |\n   |                  Option<usize>\n\n\
    error[E0277]: can't compare `&std::ops::Range<char>` with `char`\n  --> /tmp/tmp3ipgfcp3.rs:21:52\n\
    \   |\n21 |         let index = alphabet.iter().position(|x| x == c);\n   |  \
    \                                                  ^^ no implementation for `&std::ops::Range<char>\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&std::ops::Range<char>`\n   = help: the trait `PartialEq` is implemented for\
    \ `std::ops::Range<Idx>`\n\nerror[E0277]: the type `[std::ops::Range<char>]` cannot\
    \ be indexed by `Option<usize>`\n  --> /tmp/tmp3ipgfcp3.rs:22:21\n   |\n22 | \
    \        result.push(alphabet[index]);\n   |                     ^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[std::ops::Range<char>]>` is not implemented for `Option<usize>`\n\
    \   = note: required because of the requirements on the impl of `Index<Option<usize>>`\
    \ for `Vec<std::ops::Range<char>>`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0369.\nFor"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<char>>();\n    alphabet.rotate_left(2);\n\
    \    alphabet.iter().map(|c| c.to_string()).collect::<Vec<_>>()\n        .iter()\n\
    \        .map(|c| alphabet.iter().find(|c| c == c).unwrap().to_string())\n   \
    \     .collect::<Vec<_>>()\n        .iter()\n        .map(|c| c.to_string() +\
    \ c.to_string())\n        .collect::<Vec<_>>()\n        .iter()\n        .map(|c|\
    \ c.to_string() + c.to_string())\n        .collect::<Vec<_>>()\n        .iter()\n\
    \        .map(|c| c.to_string() + c.to_string())\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| c.to_string() + c.to_string())\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| c.to_string() + c.to_string())\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| c.to_string() + c.to_string())\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| c.to_string() + c.to_string())\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| c.to_string() + c.to_string())\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| c.to_string() + c.to_string())\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| c.to_string() + c.to_string())\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| c.to_string() + c.to_string())\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| c.to_string() + c.to_string())\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| c.to_string() + c.to_string())\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| c.to_string() + c.to_string())\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| c.to_string() + c.to_string())\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| c.to_string() + c.to_string())\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| c.to_string() + c.to_string())\n        .collect\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpspccq_xp.rs:18:34\n   |\n\
    18 |         .map(|c| c.to_string() + c.to_string())\n   |                   \
    \               ^^^^^^^^^^^^^\n   |                                  |\n   | \
    \                                 expected `&str`, found struct `String`\n   |\
    \                                  help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpspccq_xp.rs:21:34\n   |\n21 |\
    \         .map(|c| c.to_string() + c.to_string())\n   |                      \
    \            ^^^^^^^^^^^^^\n   |                                  |\n   |    \
    \                              expected `&str`, found struct `String`\n   |  \
    \                                help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpspccq_xp.rs:24:34\n   |\n24 |\
    \         .map(|c| c.to_string() + c.to_string())\n   |                      \
    \            ^^^^^^^^^^^^^\n   |                                  |\n   |    \
    \                              expected `&str`, found struct `String`\n   |  \
    \                                help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpspccq_xp.rs:27:34\n   |\n27 |\
    \         .map(|c| c.to_string() + c.to_string())\n   |                      \
    \            ^^^^^^^^^^^^^\n   |                                  |\n   |    \
    \                              expected `&str`, found struct `String`\n   |  \
    \                                help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpspccq_xp.rs:30:34\n   |\n30 |\
    \         .map(|c| c.to_string() + c.to_string())\n   |                      \
    \            ^^^^^^^^^^^^^\n   |                                  |\n   |    \
    \                              expected `&str`, found struct `String`\n   |  \
    \                                help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpspccq_xp.rs:33:34\n   |\n33 |\
    \         .map(|c| c.to_string() + c.to_string())\n   |                      \
    \            ^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprmi4wu9j.rs:10:26\n   |\n\
    10 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r', 'q', 'p', 'o',\
    \ 'n', 'm', 'l', 'k', 'j', 'h', 'i', 'a'];\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    let mut result = String::new();\n    for c in s.chars() {\n     \
    \   let mut i = alphabet.iter().position(|&x| x == c).unwrap();\n        result.push_str(&alphabet[(i\
    \ + 2) % alphabet.len()]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpob3l7_2p.rs:16:25\n   |\n\
    16 |         result.push_str(&alphabet[(i + 2) % alphabet.len()]);\n   |     \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.sort_by_key(|&x| x.chars().count());\n\
    \    let mut result = String::new();\n    for c in s.chars() {\n        let idx\
    \ = alphabet.iter().position(|&x| x == c).unwrap();\n        result.push_str(&alphabet[idx\
    \ % alphabet.len()]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for struct `std::ops::Range`\
    \ in the current scope\n  --> /tmp/tmprn87woii.rs:12:33\n   |\n12 |     alphabet.sort_by_key(|&x|\
    \ x.chars().count());\n   |                                 ^^^^^ method not found\
    \ in `std::ops::Range<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprn87woii.rs:15:54\n\
    \   |\n15 |         let idx = alphabet.iter().position(|&x| x == c).unwrap();\n\
    \   |                                                      ^ expected struct `std::ops::Range`,\
    \ found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n   \
    \             found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprn87woii.rs:16:25\n\
    \   |\n16 |         result.push_str(&alphabet[idx % alphabet.len()]);\n   |  \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ struct `std::ops::Range`\n   |\n   = note: expected reference `&str`\n     \
    \         found reference `&std::ops::Range<char>`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'u', 'v', 't', 's', 'r', 'q', 'p', 'o',\
    \ 'n', 'm', 'l', 'k', 'j', 'h', 'i', 'a'];\n    alphabet.rotate_left(2);\n   \
    \ let mut result = String::new();\n    for c in s.chars() {\n        result.push((alphabet.iter().find(|&x|\
    \ x == c).unwrap() + 2) % 26);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpndpfvwx_.rs:15:50\n\
    \   |\n15 |         result.push((alphabet.iter().find(|&x| x == c).unwrap() +\
    \ 2) % 26);\n   |                                                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0369]: cannot add `{integer}` to `&char`\n  --> /tmp/tmpndpfvwx_.rs:15:65\n\
    \   |\n15 |         result.push((alphabet.iter().find(|&x| x == c).unwrap() +\
    \ 2) % 26);\n   |                      ------------------------------------------\
    \ ^ - {integer}\n   |                      |\n   |                      &char\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    \n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_u0zlemc.rs:12:19\n   |\n\
    12 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_u0zlemc.rs:13:19\n   |\n13 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_u0zlemc.rs:14:19\n   |\n14 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_u0zlemc.rs:15:19\n   |\n15 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_u0zlemc.rs:16:19\n   |\n16 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_u0zlemc.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_u0zlemc.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_u0zlemc.rs:19:19\n   |\n19 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note:"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(alphabet[alphabet.len() - alphabet.iter().rev().find(|&x|\
    \ x == c).unwrap() - 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmogiykpc.rs:15:81\n\
    \   |\n15 |         result.push(alphabet[alphabet.len() - alphabet.iter().rev().find(|&x|\
    \ x == c).unwrap() - 1]);\n   |                                              \
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: cannot\
    \ subtract `&char` from `usize`\n  --> /tmp/tmpmogiykpc.rs:15:45\n   |\n15 | \
    \        result.push(alphabet[alphabet.len() - alphabet.iter().rev().find(|&x|\
    \ x == c).unwrap() - 1]);\n   |                                             ^\
    \ no implementation for `usize - &char`\n   |\n   = help: the trait `Sub<&char>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().collect::<Vec<_>>();\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    \n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw450_k47.rs:12:19\n   |\n\
    12 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw450_k47.rs:13:19\n   |\n13 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw450_k47.rs:14:19\n   |\n14 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw450_k47.rs:15:19\n   |\n15 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw450_k47.rs:16:19\n   |\n16 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw450_k47.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw450_k47.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw450_k47.rs:19:19\n   |\n19 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note:"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate_left(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push_str(alphabet.iter().cloned().take(alphabet.len()\
    \ - 1).collect::<String>());\n        result.push_str(&c.to_string());\n     \
    \   result.push_str(alphabet.iter().cloned().skip(alphabet.len() - 1).collect::<String>());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdns0b6s_.rs:15:25\n   |\n\
    15 |         result.push_str(alphabet.iter().cloned().take(alphabet.len() - 1).collect::<String>());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                         |\n   |                         expected `&str`,\
    \ found struct `String`\n   |                         help: consider borrowing\
    \ here: `&alphabet.iter().cloned().take(alphabet.len() - 1).collect::<String>()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdns0b6s_.rs:17:25\n   |\n17 |\
    \         result.push_str(alphabet.iter().cloned().skip(alphabet.len() - 1).collect::<String>());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                         |\n   |                         expected `&str`,\
    \ found struct `String`\n   |                         help: consider borrowing\
    \ here: `&alphabet.iter().cloned().skip(alphabet.len() - 1).collect::<String>()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
