name: HumanEval_21_rescale_to_unit
language: rust
results:
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let new_n = ((n - min) / (max - min)) as f64;\n\
    \        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp4h2unxgq.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n        if n > max_val {\n            max_val = n;\n        }\n    }\n  \
    \  let mut new_numbers = Vec::new();\n    for n in numbers {\n        let mut\
    \ new_n = n;\n        if n == min_val {\n            new_n = 0;\n        }\n \
    \       if n == max_val {\n            new_n = 1;\n        }\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiur95kcl.rs:20:21\n   |\n\
    18 |         let mut new_n = n;\n   |                         - expected due to\
    \ this value\n19 |         if n == min_val {\n20 |             new_n = 0;\n  \
    \ |                     ^\n   |                     |\n   |                  \
    \   expected `f64`, found integer\n   |                     help: use a float\
    \ literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiur95kcl.rs:23:21\n\
    \   |\n18 |         let mut new_n = n;\n   |                         - expected\
    \ due to this value\n...\n23 |             new_n = 1;\n   |                  \
    \   ^\n   |                     |\n   |                     expected `f64`, found\
    \ integer\n   |                     help: use a float literal: `1.0`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpl9yy9l0p.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpl9yy9l0p.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    for n in numbers {\n        n -= min;\n        n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmprgrlv_6l.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmprgrlv_6l.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmprgrlv_6l.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmprgrlv_6l.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmprgrlv_6l.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmprgrlv_6l.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    new_numbers.extend_from_slice(&[min]);\n    new_numbers.extend_from_slice(&[max]);\n\
    \    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2.0, 49.9]`,\n right: `[0.0, 1.0]`', /tmp/tmpqprcx4qm.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n        if n > max_val {\n            max_val = n;\n        }\n    }\n  \
    \  let mut new_numbers = Vec::new();\n    for n in numbers {\n        let new_n\
    \ = ((n - min_val) / (max_val - min_val)) * 2.0 + 0.5;\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpz0iraykl.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpi_t88not.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi_t88not.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_number = numbers[0];\n    let mut max_number = numbers[0];\n\
    \    for n in numbers {\n        if n < min_number {\n            min_number =\
    \ n;\n        }\n        if n > max_number {\n            max_number = n;\n  \
    \      }\n    }\n    let mut scale = (max_number - min_number).recip();\n    for\
    \ n in numbers {\n        *n /= scale;\n    }\n    numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp_dmjv9qn.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min).div(scale));\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `div` found for type `f64` in the current\
    \ scope\n   --> /tmp/tmpe9nliz98.rs:19:36\n    |\n19  |         new_numbers.push((n\
    \ - min).div(scale));\n    |                                    ^^^ method not\
    \ found in `f64`\n    |\n    = help: items from traits can only be used if the\
    \ trait is in scope\nhelp: the following trait is implemented but not in scope;\
    \ perhaps add a `use` for it:\n    |\n1   | use std::ops::Div;\n    |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    numbers.iter().for_each(|n| {\n        *n = *n * scale;\n    });\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmptr91w6cf.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n = *n * scale;\n   |         ^^^^^^^^^^^^^^^\
    \ `n` is a `&` reference, so the data it refers to cannot be written\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmptr91w6cf.rs:16:9\n   |\n\
    16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n   |  \
    \       |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmptr91w6cf.rs:17:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n    = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0382, E0594.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    let mut result = Vec::new();\n    for n in numbers {\n        result.push(n\
    \ * scale);\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpxrca6g_w.rs:16:9\n\
    \   |\n16 |     let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpxrca6g_w.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        new_numbers.push((n - min) / (max - min));\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp2nskd9jm.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    numbers.iter().for_each(|n| {\n        *n /= scale;\n    });\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmpani9l3up.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n /= scale;\n   |         ^^^^^^^^^^^ `n`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpani9l3up.rs:16:9\n   |\n16 |    \
    \ let mut scale = (max - min).recip();\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpani9l3up.rs:17:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n    = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0382, E0594.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n        if n > max_val {\n            max_val = n;\n        }\n    }\n  \
    \  let mut scale = (max_val - min_val).recip();\n    for n in numbers {\n    \
    \    *n -= min_val * scale;\n        scale *= 1.0;\n    }\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpwjgwfz7t.rs:18:9\n\
    \   |\n18 |         *n -= min_val * scale;\n   |         ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n        if n > max_val {\n            max_val = n;\n        }\n    }\n  \
    \  let mut new_numbers = Vec::new();\n    for n in numbers {\n        let mut\
    \ new_n = n;\n        if new_n < min_val {\n            new_n -= min_val;\n  \
    \      }\n        if new_n > max_val {\n            new_n -= max_val;\n      \
    \  }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp3o0sphcq.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut scale = max_value - min_value;\n    for n in numbers {\n \
    \       *n -= min_value;\n        *n *= scale;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp0yuas_m7.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmp0yuas_m7.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n        if n > max_val {\n            max_val = n;\n        }\n    }\n  \
    \  let mut scale = (max_val - min_val).recip();\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        new_numbers.push((n - min_val).map(|x| x * scale).unwrap_or(0.0))\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `f64` is not an iterator\n  --> /tmp/tmpj7b3euez.rs:19:40\n\
    \   |\n19 |         new_numbers.push((n - min_val).map(|x| x * scale).unwrap_or(0.0))\n\
    \   |                                        ^^^ `f64` is not an iterator\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `f64:\
    \ Iterator`\n           which is required by `&mut f64: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    let mut new_numbers = Vec::new();\n    for &n in numbers {\n    \
    \    new_numbers.push((n - min) / scale);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn66pqzm1.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn66pqzm1.rs:18:9\n   |\n18 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_number = numbers.iter().min().unwrap();\n    let mut max_number\
    \ = numbers.iter().max().unwrap();\n    let mut rescaled_numbers = Vec::new();\n\
    \    for number in numbers {\n        let rescaled_number = number / max_number\
    \ - min_number / min_number;\n        rescaled_numbers.push(rescaled_number);\n\
    \        min_number = number;\n        max_number = number;\n    }\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpobfkhp4n.rs:6:41\n\
    \     |\n6    |     let mut min_number = numbers.iter().min().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpobfkhp4n.rs:7:41\n\
    \     |\n7    |     let mut max_number = numbers.iter().max().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpobfkhp4n.rs:12:22\n   |\n6  |\
    \     let mut min_number = numbers.iter().min().unwrap();\n   |              \
    \            ----------------------------- expected due to this value\n...\n12\
    \ |         min_number = number;\n   |                      ^^^^^^\n   |     \
    \                 |\n   |                      expected `&f64`, found `f64`\n\
    \   |                      help: consider borrowing here: `&number`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpobfkhp4n.rs:13:22\n   |\n7  |     let mut max_number\
    \ = numbers.iter().max().unwrap();\n   |                          -----------------------------\
    \ expected due to this value\n...\n13 |         max_number = number;\n   |   \
    \                   ^^^^^^\n   |                      |\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut result = Vec::new();\n    for &n in numbers {\n        result.push((n\
    \ - min) * scale);\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpr4l1rmty.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr4l1rmty.rs:18:9\n   |\n18 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| n = n * scale);\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5jfkjrmr.rs:17:37\n   |\n\
    17 |     numbers.iter().for_each(|n| n = n * scale);\n   |                   \
    \           -      ^^^^^^^^^\n   |                              |      |\n   |\
    \                              |      expected `&f64`, found `f64`\n   |     \
    \                         |      help: consider borrowing here: `&(n * scale)`\n\
    \   |                              expected due to this parameter type\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n        if n > max_val {\n            max_val = n;\n        }\n    }\n  \
    \  let mut new_numbers = Vec::new();\n    for n in numbers {\n        let mut\
    \ new_n = n;\n        if new_n < min_val {\n            new_n -= min_val;\n  \
    \      }\n        if new_n > max_val {\n            new_n -= max_val;\n      \
    \  }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmps708cc9z.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpta8novh1.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0f64;\n   \
    \ for &n in numbers {\n        *n /= max - min;\n        *n *= scale;\n      \
    \  scale *= 1.0f64;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8ofb4ofo.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8ofb4ofo.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = max - min;\n\
    \    scale = scale / 2.0 + 1.0;\n    let mut result = Vec::new();\n    for n in\
    \ numbers {\n        result.push((n - min) * scale);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpsyj0gm9t.rs:19:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| {\n        *n /= scale;\n    });\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmpacgk4m4e.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n /= scale;\n   |         ^^^^^^^^^^^ `n`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpacgk4m4e.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |         |\n \
    \  |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpacgk4m4e.rs:17:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n    = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0382, E0594.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpusb86lhh.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpusb86lhh.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = max - min;\n\
    \    let mut new_numbers = Vec::new();\n    for &n in numbers {\n        new_numbers.push((n\
    \ - min) / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdpd0tnn6.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdpd0tnn6.rs:18:9\n   |\n18 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut new_min = min - 1.0 *\
    \ min / max;\n    let mut new_max = max - 1.0 * max / min;\n    for n in numbers\
    \ {\n        if n < new_min {\n            new_min = n;\n        }\n        if\
    \ n > new_max {\n            new_max = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        new_numbers.push((n - new_min)\
    \ / (new_max - new_min));\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpl3d5h88l.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0382]: use of moved value: `numbers`\n  -->\
    \ /tmp/tmpl3d5h88l.rs:27:14\n   |\n5  | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n   |                    ------- move occurs because `numbers`\
    \ has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n18 |  \
    \   for n in numbers {\n   |              ------- `numbers` moved due to this\
    \ implicit call to `.into_iter()`\n...\n27 |     for n in numbers {\n   |    \
    \          ^^^^^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n\
    \   |\n18 |     for n in &numbers {\n   |              +\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let mut new_n = n;\n        if new_n < min {\n\
    \            new_n -= min;\n        }\n        if new_n > max {\n            new_n\
    \ -= max;\n        }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpv7_gt5f7.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    let mut rescaled: Vec<f64> = Vec::new();\n    for n in numbers {\n      \
    \  rescaled.push(n * scale);\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpmla2cvmm.rs:16:9\n\
    \   |\n16 |     let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpmla2cvmm.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    new_numbers.extend_from_slice(&[min]);\n    new_numbers.extend_from_slice(&[max]);\n\
    \    new_numbers.extend_from_slice(&numbers[1..]);\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpvfqrowgs.rs:19:36\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     new_numbers.extend_from_slice(&numbers[1..]);\n    |          \
    \                          ^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `numbers`\n\
    help: consider iterating over a slice of the `Vec<f64>`'s content to avoid moving\
    \ into the `for` loop\n    |\n8   |     for n in &numbers {\n    |           \
    \   +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    for &n in numbers {\n        *n -= min;\n        *n *= scale;\n \
    \   }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphyygi1xi.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphyygi1xi.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| {\n        *n /= scale;\n    });\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmpdyvco3sc.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n /= scale;\n   |         ^^^^^^^^^^^ `n`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpdyvco3sc.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |         |\n \
    \  |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpdyvco3sc.rs:17:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n    = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0382, E0594.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n        if n > max_val {\n            max_val = n;\n        }\n    }\n  \
    \  let mut scale = max_val - min_val;\n    for n in numbers {\n        n -= min_val;\n\
    \        n *= scale;\n        n += min_val;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmp4jculfyv.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmp4jculfyv.rs:20:9\n   |\n20 |         n +=\
    \ min_val;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on\
    \ by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmp4jculfyv.rs:16:9\n   |\n\
    16 |     let mut scale = max_val - min_val;\n   |         ----^^^^^\n   |    \
    \     |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp4jculfyv.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmp4jculfyv.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min_val;\n\
    \   |         ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmp4jculfyv.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_number = numbers[0];\n    let mut max_number = numbers[0];\n\
    \    for number in numbers {\n        if number < min_number {\n            min_number\
    \ = number;\n        }\n        if number > max_number {\n            max_number\
    \ = number;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for\
    \ number in numbers {\n        let new_number = (number - min_number) / (max_number\
    \ - min_number);\n        new_numbers.push(new_number);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpz9pxgrew.rs:17:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n17  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n8   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = max - min;\n\
    \    numbers.iter().for_each(|n| {\n        *n -= min;\n        *n /= scale;\n\
    \    });\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwc5kt2bs.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpkkpmizaw.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpkkpmizaw.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0f64;\n   \
    \ for n in numbers {\n        scale *= n - min;\n    }\n    numbers.iter().map(|n|\
    \ n * scale).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpx55ctogc.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0382]: borrow of moved value: `numbers`\n\
    \  --> /tmp/tmpx55ctogc.rs:20:5\n   |\n5  | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n   |                    ------- move occurs because `numbers`\
    \ has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n17 |  \
    \   for n in numbers {\n   |              ------- `numbers` moved due to this\
    \ implicit call to `.into_iter()`\n...\n20 |     numbers.iter().map(|n| n * scale).collect()\n\
    \   |     ^^^^^^^^^^^^^^ value borrowed here after move\n   |\n   = note: borrow\
    \ occurs due to deref coercion to `[f64]`\nhelp: consider iterating over a slice\
    \ of the `Vec<f64>`'s content to avoid moving into the `for` loop\n   |\n17 |\
    \     for n in &numbers {\n   |              +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    for n in numbers {\n        n -= min;\n        n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmp5ur686ls.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmp5ur686ls.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp5ur686ls.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp5ur686ls.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmp5ur686ls.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmp5ur686ls.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut scale = (max_value - min_value).recip();\n    for n in numbers\
    \ {\n        *n -= min_value;\n        *n *= scale;\n    }\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmparabjy0u.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmparabjy0u.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n      \
    \  let new_value = ((n - min_value) / (max_value - min_value)).ceil() as f64;\n\
    \        new_numbers.push(new_value);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpimr2e4rt.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    for n in numbers {\n        n -= min;\n        n *= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmpr6xmmbrh.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmpr6xmmbrh.rs:19:9\n   |\n19 |         n *=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpr6xmmbrh.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpr6xmmbrh.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmpr6xmmbrh.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmpr6xmmbrh.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n        if n > max_val {\n            max_val = n;\n        }\n    }\n  \
    \  let mut scale = max_val - min_val;\n    for n in numbers {\n        *n -= min_val;\n\
    \        *n *= scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpszf9r41z.rs:18:9\n\
    \   |\n18 |         *n -= min_val;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmpszf9r41z.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = max - min;\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) / scale + min);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmple0rb0dm.rs:16:9\n\
    \   |\n16 |     let mut scale = max - min;\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmple0rb0dm.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp9n8s1lxz.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp9n8s1lxz.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    for n in numbers {\n        *n /= scale;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpaiycoyfz.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n      \
    \  let mut new_n = n;\n        if new_n < min_value {\n            new_n -= min_value;\n\
    \        }\n        if new_n > max_value {\n            new_n -= max_value;\n\
    \        }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn\
    \ main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpbrf5bj4c.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0f64;\n   \
    \ for n in numbers {\n        scale *= n - min;\n    }\n    numbers.iter().map(|n|\
    \ n * scale).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmps63s_88a.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0382]: borrow of moved value: `numbers`\n\
    \  --> /tmp/tmps63s_88a.rs:20:5\n   |\n5  | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n   |                    ------- move occurs because `numbers`\
    \ has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n17 |  \
    \   for n in numbers {\n   |              ------- `numbers` moved due to this\
    \ implicit call to `.into_iter()`\n...\n20 |     numbers.iter().map(|n| n * scale).collect()\n\
    \   |     ^^^^^^^^^^^^^^ value borrowed here after move\n   |\n   = note: borrow\
    \ occurs due to deref coercion to `[f64]`\nhelp: consider iterating over a slice\
    \ of the `Vec<f64>`'s content to avoid moving into the `for` loop\n   |\n17 |\
    \     for n in &numbers {\n   |              +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    let mut result = Vec::new();\n    for n in numbers {\n        result.push(n\
    \ * scale);\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpx3lcncrp.rs:16:9\n\
    \   |\n16 |     let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpx3lcncrp.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = max - min;\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpleuj5vbm.rs:16:9\n\
    \   |\n16 |     let mut scale = max - min;\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpleuj5vbm.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0f64 / max\
    \ - min;\n    for n in numbers {\n        *n -= min;\n        *n *= scale;\n \
    \   }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmppy4u7sq9.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmppy4u7sq9.rs:19:9\n   |\n19 |         *n *= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n      \
    \  let new_value = ((n - min_value) / (max_value - min_value)) * 2.0 + 0.5;\n\
    \        new_numbers.push(new_value);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmps1c8g_9d.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 / (max -\
    \ min);\n    for n in numbers {\n        *n -= min;\n        *n *= scale;\n  \
    \  }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpoo44njxt.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmpoo44njxt.rs:19:9\n   |\n19 |         *n *= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| n = n * scale);\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplbwwf8yu.rs:17:37\n   |\n\
    17 |     numbers.iter().for_each(|n| n = n * scale);\n   |                   \
    \           -      ^^^^^^^^^\n   |                              |      |\n   |\
    \                              |      expected `&f64`, found `f64`\n   |     \
    \                         |      help: consider borrowing here: `&(n * scale)`\n\
    \   |                              expected due to this parameter type\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    for n in numbers {\n        n -= min;\n        n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmpp2o0rp6k.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmpp2o0rp6k.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpp2o0rp6k.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpp2o0rp6k.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmpp2o0rp6k.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmpp2o0rp6k.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    for n in numbers {\n        *n /= scale;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmplesyp113.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpu0mwyrvr.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpu0mwyrvr.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n        if n > max_val {\n            max_val = n;\n        }\n    }\n  \
    \  let mut scale = max_val - min_val;\n    for n in numbers {\n        *n -= min_val;\n\
    \        *n *= scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpfrc_13ga.rs:18:9\n\
    \   |\n18 |         *n -= min_val;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmpfrc_13ga.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_number = numbers[0];\n    let mut max_number = numbers[0];\n\
    \    for number in numbers {\n        if number < min_number {\n            min_number\
    \ = number;\n        }\n        if number > max_number {\n            max_number\
    \ = number;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for\
    \ number in numbers {\n        let new_number = (number - min_number) / (max_number\
    \ - min_number);\n        new_numbers.push(new_number);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpj9kr2spq.rs:17:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n17  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n8   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpxpxusxpd.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpxpxusxpd.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = max - min;\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpefxc3ok4.rs:16:9\n\
    \   |\n16 |     let mut scale = max - min;\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpefxc3ok4.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpagrcvvsu.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpagrcvvsu.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for &n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4g8wylbs.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4g8wylbs.rs:18:9\n   |\n18 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n        if n > max_val {\n            max_val = n;\n        }\n    }\n  \
    \  let mut scale = (max_val - min_val).recip();\n    for n in numbers {\n    \
    \    *n -= min_val;\n        *n *= scale;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpcb7h4q93.rs:18:9\n\
    \   |\n18 |         *n -= min_val;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmpcb7h4q93.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n      \
    \  let new_n = ((n - min_value) / (max_value - min_value)) * 1.0;\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp6ckl3ghn.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min).div(scale));\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `div` found for type `f64` in the current\
    \ scope\n   --> /tmp/tmp61y46bdp.rs:19:36\n    |\n19  |         new_numbers.push((n\
    \ - min).div(scale));\n    |                                    ^^^ method not\
    \ found in `f64`\n    |\n    = help: items from traits can only be used if the\
    \ trait is in scope\nhelp: the following trait is implemented but not in scope;\
    \ perhaps add a `use` for it:\n    |\n1   | use std::ops::Div;\n    |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 / (max -\
    \ min);\n    for n in numbers {\n        *n -= min;\n        *n *= scale;\n  \
    \  }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp39wv99sh.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmp39wv99sh.rs:19:9\n   |\n19 |         *n *= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 / (max -\
    \ min);\n    for n in numbers {\n        *n -= min;\n        *n *= scale;\n  \
    \  }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp3njwbfne.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmp3njwbfne.rs:19:9\n   |\n19 |         *n *= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let mut new_n = n;\n        if new_n < min {\n\
    \            new_n -= min;\n        }\n        if new_n > max {\n            new_n\
    \ -= max;\n        }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmplab8jpz8.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for number in numbers {\n        if number < min_value {\n            min_value\
    \ = number;\n        }\n        if number > max_value {\n            max_value\
    \ = number;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for\
    \ number in numbers {\n        new_numbers.push(number - min_value) / (max_value\
    \ - min_value);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot divide `()` by `f64`\n  --> /tmp/tmpm294_cxt.rs:18:46\n\
    \   |\n18 |         new_numbers.push(number - min_value) / (max_value - min_value);\n\
    \   |         ------------------------------------ ^ ----------------------- f64\n\
    \   |         |\n   |         ()\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    for n in numbers {\n        n -= min;\n        n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmpklitcwro.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmpklitcwro.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpklitcwro.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpklitcwro.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmpklitcwro.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmpklitcwro.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| {\n        *n /= scale;\n    });\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmp4cd1wiwz.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n /= scale;\n   |         ^^^^^^^^^^^ `n`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp4cd1wiwz.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |         |\n \
    \  |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmp4cd1wiwz.rs:17:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n    = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0382, E0594.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n     \
    \   new_numbers.push((n - min) / scale);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp0_7q8rj1.rs:16:9\n\
    \   |\n16 |     let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n \
    \  |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0_7q8rj1.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n        if n > max_val {\n            max_val = n;\n        }\n    }\n  \
    \  let mut new_numbers = Vec::new();\n    for n in numbers {\n        let new_n\
    \ = ((n - min_val) / (max_val - min_val)).floor() as f64;\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpig8823bx.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for &n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut scale = (max_value - min_value).recip();\n    for &n in numbers\
    \ {\n        *n -= min_value;\n        *n *= scale;\n    }\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqe6gnql5.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqe6gnql5.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| {\n        *n /= scale;\n    });\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmpl5qa1zsz.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n /= scale;\n   |         ^^^^^^^^^^^ `n`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpl5qa1zsz.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |         |\n \
    \  |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpl5qa1zsz.rs:17:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n    = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0382, E0594.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut new_numbers = Vec::new();\n    new_numbers.extend_from_slice(&[min_value]);\n\
    \    new_numbers.extend_from_slice(&[max_value]);\n    new_numbers.extend_from_slice(&numbers[1..]);\n\
    \    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmp9bue07st.rs:19:36\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     new_numbers.extend_from_slice(&numbers[1..]);\n    |          \
    \                          ^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `numbers`\n\
    help: consider iterating over a slice of the `Vec<f64>`'s content to avoid moving\
    \ into the `for` loop\n    |\n8   |     for n in &numbers {\n    |           \
    \   +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = max - min;\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) / scale + 0.5);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpyvtpqg_1.rs:16:9\n\
    \   |\n16 |     let mut scale = max - min;\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpyvtpqg_1.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    numbers.iter().for_each(|n| {\n        n -= min;\n        n /= scale;\n\
    \    });\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `-=` cannot be applied to type\
    \ `&f64`\n  --> /tmp/tmp7lt8jtee.rs:18:9\n   |\n18 |         n -= min;\n   | \
    \        -^^^^^^^\n   |         |\n   |         cannot use `-=` on type `&f64`\n\
    \   |\nhelp: `-=` can be used on `f64`, you can dereference `n`\n   |\n18 |  \
    \       *n -= min;\n   |         +\n\nerror[E0368]: binary assignment operation\
    \ `/=` cannot be applied to type `&f64`\n  --> /tmp/tmp7lt8jtee.rs:19:9\n   |\n\
    19 |         n /= scale;\n   |         -^^^^^^^^^\n   |         |\n   |      \
    \   cannot use `/=` on type `&f64`\n   |\nhelp: `/=` can be used on `f64`, you\
    \ can dereference `n`\n   |\n19 |         *n /= scale;\n   |         +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 / (max -\
    \ min);\n    for &n in numbers {\n        *n -= min;\n        *n *= scale;\n \
    \   }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnvls5pt_.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnvls5pt_.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n        if n > max_val {\n            max_val = n;\n        }\n    }\n  \
    \  let mut scale = (max_val - min_val).recip();\n    for n in numbers {\n    \
    \    *n -= min_val;\n        *n *= scale;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp7o8xkcch.rs:18:9\n\
    \   |\n18 |         *n -= min_val;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmp7o8xkcch.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 / (max -\
    \ min);\n    numbers.iter().for_each(|n| n = n * scale);\n    numbers\n}\n\nfn\
    \ main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4n2mbxso.rs:17:37\n   |\n\
    17 |     numbers.iter().for_each(|n| n = n * scale);\n   |                   \
    \           -      ^^^^^^^^^\n   |                              |      |\n   |\
    \                              |      expected `&f64`, found `f64`\n   |     \
    \                         |      help: consider borrowing here: `&(n * scale)`\n\
    \   |                              expected due to this parameter type\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    let mut result = Vec::new();\n    for n in numbers {\n        result.push(n\
    \ * scale);\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpb63uxo5p.rs:16:9\n\
    \   |\n16 |     let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpb63uxo5p.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n        if n > max_val {\n            max_val = n;\n        }\n    }\n  \
    \  let mut scale = (max_val - min_val).recip();\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        new_numbers.push((n - min_val) * scale);\n  \
    \  }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp84yqve05.rs:16:9\n\
    \   |\n16 |     let mut scale = (max_val - min_val).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp84yqve05.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpn8dfq4wz.rs:16:9\n\
    \   |\n16 |     let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpn8dfq4wz.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    for n in numbers {\n        n -= min;\n        n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmp4rirdvs9.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmp4rirdvs9.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp4rirdvs9.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp4rirdvs9.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmp4rirdvs9.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmp4rirdvs9.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut scale = (max_value - min_value).recip();\n    for n in numbers\
    \ {\n        *n -= min_value;\n        *n *= scale;\n    }\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpgdkkas8p.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmpgdkkas8p.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| {\n        *n /= scale;\n    });\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmpoboagbpv.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n /= scale;\n   |         ^^^^^^^^^^^ `n`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpoboagbpv.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |         |\n \
    \  |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpoboagbpv.rs:17:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n    = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0382, E0594.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    for n in numbers {\n        *n /= scale;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpk6_1jkyt.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpwgpgpjy8.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpwgpgpjy8.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp5k3l8jlx.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp5k3l8jlx.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    for &n in numbers {\n        *n -= min;\n        *n /= scale;\n    }\n  \
    \  numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7jjrgh61.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7jjrgh61.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let new_n = ((n - min) / (max - min)) as f64;\n\
    \        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp61qse446.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n        if n > max_val {\n            max_val = n;\n        }\n    }\n  \
    \  let mut scale = (max_val - min_val).recip();\n    for n in numbers {\n    \
    \    *n -= min_val * scale;\n        scale *= 1.0;\n    }\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp8pe331qr.rs:18:9\n\
    \   |\n18 |         *n -= min_val * scale;\n   |         ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut scale = (max_value - min_value).recip();\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        new_numbers.push((n - min_value)\
    \ / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp_b4g9awh.rs:16:9\n\
    \   |\n16 |     let mut scale = (max_value - min_value).recip();\n   |       \
    \  ----^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n   =\
    \ note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: use of moved value:\
    \ `numbers`\n   --> /tmp/tmp_b4g9awh.rs:18:14\n    |\n5   | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n    |                    ------- move occurs because\
    \ `numbers` has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n\
    8   |     for n in numbers {\n    |              ------- `numbers` moved due to\
    \ this implicit call to `.into_iter()`\n...\n18  |     for n in numbers {\n  \
    \  |              ^^^^^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `numbers`\nhelp: consider\
    \ iterating over a slice of the `Vec<f64>`'s content to avoid moving into the\
    \ `for` loop\n    |\n8   |     for n in &numbers {\n    |              +\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    numbers.iter().for_each(|n| {\n        *n /= scale;\n    });\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmpmlrmruuo.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n /= scale;\n   |         ^^^^^^^^^^^ `n`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpmlrmruuo.rs:16:9\n   |\n16 |    \
    \ let mut scale = (max - min).recip();\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpmlrmruuo.rs:17:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n    = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0382, E0594.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 / (max -\
    \ min);\n    for &n in numbers {\n        *n = *n * scale;\n    }\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzykfnbcs.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzykfnbcs.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpon_aztc9.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpon_aztc9.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut scale = max_value - min_value;\n    for n in numbers {\n \
    \       *n -= min_value;\n        *n /= scale;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpwa7j96eu.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmpwa7j96eu.rs:19:9\n   |\n19 |         *n\
    \ /= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut scale = (max_value - min_value).recip();\n    for n in numbers\
    \ {\n        *n -= min_value;\n        *n *= scale;\n    }\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpakni689l.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmpakni689l.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut scale = (max_value - min_value).recip();\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        new_numbers.push((n - min_value)\
    \ / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpphl657rt.rs:16:9\n\
    \   |\n16 |     let mut scale = (max_value - min_value).recip();\n   |       \
    \  ----^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n   =\
    \ note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: use of moved value:\
    \ `numbers`\n   --> /tmp/tmpphl657rt.rs:18:14\n    |\n5   | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n    |                    ------- move occurs because\
    \ `numbers` has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n\
    8   |     for n in numbers {\n    |              ------- `numbers` moved due to\
    \ this implicit call to `.into_iter()`\n...\n18  |     for n in numbers {\n  \
    \  |              ^^^^^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `numbers`\nhelp: consider\
    \ iterating over a slice of the `Vec<f64>`'s content to avoid moving into the\
    \ `for` loop\n    |\n8   |     for n in &numbers {\n    |              +\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for &n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqz3651fn.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqz3651fn.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0f64 / max\
    \ - min;\n    numbers.iter().for_each(|n| n = n * scale);\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpswh37cy6.rs:17:37\n   |\n\
    17 |     numbers.iter().for_each(|n| n = n * scale);\n   |                   \
    \           -      ^^^^^^^^^\n   |                              |      |\n   |\
    \                              |      expected `&f64`, found `f64`\n   |     \
    \                         |      help: consider borrowing here: `&(n * scale)`\n\
    \   |                              expected due to this parameter type\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let mut new_n = n;\n        if new_n < min {\n\
    \            new_n -= min;\n        }\n        if new_n > max {\n            new_n\
    \ -= max;\n        }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmphziqfd50.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min) / (2.0 * std::f64::consts::PI);\n    numbers.iter().for_each(|n| {\n  \
    \      *n -= min;\n        *n *= scale;\n    });\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmpdd4k_ahv.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n -= min;\n   |         ^^^^^^^^^ `n` is\
    \ a `&` reference, so the data it refers to cannot be written\n\nerror[E0594]:\
    \ cannot assign to `*n`, which is behind a `&` reference\n  --> /tmp/tmpdd4k_ahv.rs:19:9\n\
    \   |\n17 |     numbers.iter().for_each(|n| {\n   |                          \
    \    - help: consider changing this to be a mutable reference: `&mut f64`\n18\
    \ |         *n -= min;\n19 |         *n *= scale;\n   |         ^^^^^^^^^^^ `n`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpdd4k_ahv.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min) / (2.0 * std::f64::consts::PI);\n   |    \
    \     ----^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `numbers`\n   --> /tmp/tmpdd4k_ahv.rs:17:5\n    |\n5   | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n    |                    ------- move occurs because\
    \ `numbers` has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n\
    8   |     for n in numbers {\n    |              ------- `numbers` moved due to\
    \ this implicit call to `.into_iter()`\n...\n17  |     numbers.iter().for_each(|n|\
    \ {\n    |     ^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `numbers`\n   \
    \ = note: borrow occurs due to deref coercion to `[f64]`\nhelp: consider iterating\
    \ over a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n\
    \    |\n8   |     for n in &numbers {\n    |              +\n\nerror: aborting\
    \ due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0382, E0594.\nFor more information about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0f64 / max\
    \ - min;\n    for n in numbers {\n        *n -= min;\n        *n *= scale;\n \
    \   }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpf64pjfts.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmpf64pjfts.rs:19:9\n   |\n19 |         *n *= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut result = Vec::new();\n    for n in numbers {\n        result.push((n\
    \ - min) * scale);\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpekylqz17.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpekylqz17.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    let mut result = Vec::new();\n    for n in numbers {\n        result.push(n\
    \ * scale);\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpfz3xnkvd.rs:16:9\n\
    \   |\n16 |     let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpfz3xnkvd.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut result = Vec::new();\n    for n in numbers {\n        result.push((n\
    \ - min).mul(scale));\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `mul` found for type `f64` in the current\
    \ scope\n   --> /tmp/tmp01zdt7jb.rs:19:31\n    |\n19  |         result.push((n\
    \ - min).mul(scale));\n    |                               ^^^ method not found\
    \ in `f64`\n    |\n    = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n    |\n1   | use std::ops::Mul;\n    |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpur2c2r37.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpur2c2r37.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut scale = (max_value - min_value).recip();\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        new_numbers.push((n - min_value)\
    \ / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpuyo7z1i0.rs:16:9\n\
    \   |\n16 |     let mut scale = (max_value - min_value).recip();\n   |       \
    \  ----^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n   =\
    \ note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: use of moved value:\
    \ `numbers`\n   --> /tmp/tmpuyo7z1i0.rs:18:14\n    |\n5   | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n    |                    ------- move occurs because\
    \ `numbers` has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n\
    8   |     for n in numbers {\n    |              ------- `numbers` moved due to\
    \ this implicit call to `.into_iter()`\n...\n18  |     for n in numbers {\n  \
    \  |              ^^^^^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `numbers`\nhelp: consider\
    \ iterating over a slice of the `Vec<f64>`'s content to avoid moving into the\
    \ `for` loop\n    |\n8   |     for n in &numbers {\n    |              +\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min) / (2.0 * std::f64::consts::PI);\n    numbers.iter().for_each(|n| {\n  \
    \      *n -= min;\n        *n = *n * scale;\n    });\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmp3_f5okin.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n -= min;\n   |         ^^^^^^^^^ `n` is\
    \ a `&` reference, so the data it refers to cannot be written\n\nerror[E0594]:\
    \ cannot assign to `*n`, which is behind a `&` reference\n  --> /tmp/tmp3_f5okin.rs:19:9\n\
    \   |\n17 |     numbers.iter().for_each(|n| {\n   |                          \
    \    - help: consider changing this to be a mutable reference: `&mut f64`\n18\
    \ |         *n -= min;\n19 |         *n = *n * scale;\n   |         ^^^^^^^^^^^^^^^\
    \ `n` is a `&` reference, so the data it refers to cannot be written\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmp3_f5okin.rs:16:9\n   |\n\
    16 |     let mut scale = 1.0 * (max - min) / (2.0 * std::f64::consts::PI);\n \
    \  |         ----^^^^^\n   |         |\n   |         help: remove this `mut`\n\
    \   |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow\
    \ of moved value: `numbers`\n   --> /tmp/tmp3_f5okin.rs:17:5\n    |\n5   | fn\
    \ rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |                    -------\
    \ move occurs because `numbers` has type `Vec<f64>`, which does not implement\
    \ the `Copy` trait\n...\n8   |     for n in numbers {\n    |              -------\
    \ `numbers` moved due to this implicit call to `.into_iter()`\n...\n17  |    \
    \ numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\n    = note: borrow occurs due to deref coercion to `[f64]`\n\
    help: consider iterating over a slice of the `Vec<f64>`'s content to avoid moving\
    \ into the `for` loop\n    |\n8   |     for n in &numbers {\n    |           \
    \   +\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors\
    \ have detailed explanations: E0382, E0594.\nFor more information about an error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_number = numbers[0];\n    let mut max_number = numbers[0];\n\
    \    for n in numbers {\n        if n < min_number {\n            min_number =\
    \ n;\n        }\n        if n > max_number {\n            max_number = n;\n  \
    \      }\n    }\n    let mut new_numbers = Vec::new();\n    new_numbers.extend_from_slice(&[min_number]);\n\
    \    new_numbers.extend_from_slice(&[max_number]);\n    new_numbers.extend_from_slice(&numbers[1..]);\n\
    \    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpxsrnxwcb.rs:19:36\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     new_numbers.extend_from_slice(&numbers[1..]);\n    |          \
    \                          ^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `numbers`\n\
    help: consider iterating over a slice of the `Vec<f64>`'s content to avoid moving\
    \ into the `for` loop\n    |\n8   |     for n in &numbers {\n    |           \
    \   +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut result = Vec::new();\n    for n in numbers {\n        result.push((n\
    \ - min) * scale);\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpwu5am5v5.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpwu5am5v5.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| {\n        *n = *n / scale;\n    });\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmpp4g_713n.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n = *n / scale;\n   |         ^^^^^^^^^^^^^^^\
    \ `n` is a `&` reference, so the data it refers to cannot be written\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmpp4g_713n.rs:16:9\n   |\n\
    16 |     let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |      \
    \   |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpp4g_713n.rs:17:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n    = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0382, E0594.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let mut new_n = n;\n        if new_n < min {\n\
    \            new_n -= min;\n        }\n        if new_n > max {\n            new_n\
    \ -= max;\n        }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmphgveqsbo.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n     \
    \   new_numbers.push((n - min) / scale);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp54oopr41.rs:16:9\n\
    \   |\n16 |     let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n \
    \  |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp54oopr41.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> =\
    \ Vec::new();\n    for n in numbers {\n        rescaled.push((n - min) / (max\
    \ - min));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpuob1l8rk.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let mut new_n = n;\n        if new_n < min {\n\
    \            new_n -= min;\n        }\n        if new_n > max {\n            new_n\
    \ -= max;\n        }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp4gmve0rf.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> =\
    \ Vec::new();\n    for n in numbers {\n        rescaled.push((n - min) / (max\
    \ - min));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp82715w6c.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    for n in numbers {\n        *n /= scale;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpxx8lh_ii.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let mut new_n = n;\n        if new_n < min {\n\
    \            new_n -= min;\n        }\n        if new_n > max {\n            new_n\
    \ -= max;\n        }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpedr89284.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for number in numbers {\n        if number < min_value {\n            min_value\
    \ = number;\n        }\n        if number > max_value {\n            max_value\
    \ = number;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for\
    \ number in numbers {\n        let new_number = (number - min_value) / (max_value\
    \ - min_value) as f64;\n        new_numbers.push(new_number);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp1ggbwxvl.rs:17:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n17  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n8   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| n *= scale);\n    numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `*=` cannot be applied to type\
    \ `&f64`\n  --> /tmp/tmpgjoibq4b.rs:17:33\n   |\n17 |     numbers.iter().for_each(|n|\
    \ n *= scale);\n   |                                 -^^^^^^^^^\n   |        \
    \                         |\n   |                                 cannot use `*=`\
    \ on type `&f64`\n   |\nhelp: `*=` can be used on `f64`, you can dereference `n`\n\
    \   |\n17 |     numbers.iter().for_each(|n| *n *= scale);\n   |              \
    \                   +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut rescaled = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpwtym0jhf.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let mut new_n = n;\n        if new_n < min {\n\
    \            new_n -= min as f64;\n        }\n        if new_n > max {\n     \
    \       new_n -= max as f64;\n        }\n        new_numbers.push(new_n);\n  \
    \  }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpcsjgckwb.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for &n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut scale = (max_value - min_value).recip();\n    for &n in numbers\
    \ {\n        *n -= min_value;\n        *n *= scale;\n    }\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptf7lo3a2.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptf7lo3a2.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_number = numbers.iter().min().unwrap();\n    let mut max_number\
    \ = numbers.iter().max().unwrap();\n    let mut new_numbers = Vec::new();\n  \
    \  new_numbers.extend_from_slice(&numbers);\n    new_numbers.sort_unstable_by_key(|x|\
    \ x.partial_cmp(&min_number).unwrap());\n    new_numbers.sort_unstable_by_key(|x|\
    \ x.partial_cmp(&max_number).unwrap());\n    new_numbers.iter_mut().for_each(|x|\
    \ {\n        *x = *x / max_number as f64;\n    });\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpfj2zoz19.rs:6:41\n\
    \     |\n6    |     let mut min_number = numbers.iter().min().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpfj2zoz19.rs:7:41\n\
    \     |\n7    |     let mut max_number = numbers.iter().max().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0606]: casting `&f64` as `f64` is invalid\n  --> /tmp/tmpfj2zoz19.rs:13:19\n\
    \   |\n13 |         *x = *x / max_number as f64;\n   |                   ----------^^^^^^^\n\
    \   |                   |\n   |                   cannot cast `&f64` as `f64`\n\
    \   |                   help: dereference the expression: `*max_number`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0606.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min) / (2.0 * std::f64::consts::PI);\n    numbers.iter().for_each(|n| {\n  \
    \      n -= min;\n        n /= scale;\n    });\n    numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpaigpbz_b.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0368]:\
    \ binary assignment operation `-=` cannot be applied to type `&f64`\n  --> /tmp/tmpaigpbz_b.rs:18:9\n\
    \   |\n18 |         n -= min;\n   |         -^^^^^^^\n   |         |\n   |   \
    \      cannot use `-=` on type `&f64`\n   |\nhelp: `-=` can be used on `f64`,\
    \ you can dereference `n`\n   |\n18 |         *n -= min;\n   |         +\n\nerror[E0368]:\
    \ binary assignment operation `/=` cannot be applied to type `&f64`\n  --> /tmp/tmpaigpbz_b.rs:19:9\n\
    \   |\n19 |         n /= scale;\n   |         -^^^^^^^^^\n   |         |\n   |\
    \         cannot use `/=` on type `&f64`\n   |\nhelp: `/=` can be used on `f64`,\
    \ you can dereference `n`\n   |\n19 |         *n /= scale;\n   |         +\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp_zicxwi4.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp_zicxwi4.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| n = n * scale);\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcegkyao0.rs:17:37\n   |\n\
    17 |     numbers.iter().for_each(|n| n = n * scale);\n   |                   \
    \           -      ^^^^^^^^^\n   |                              |      |\n   |\
    \                              |      expected `&f64`, found `f64`\n   |     \
    \                         |      help: consider borrowing here: `&(n * scale)`\n\
    \   |                              expected due to this parameter type\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut scale = (max_value - min_value).recip();\n    for n in numbers\
    \ {\n        *n -= min_value;\n        *n *= scale;\n    }\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpsp5z5ot2.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmpsp5z5ot2.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 / (max -\
    \ min);\n    for n in numbers {\n        *n -= min;\n        *n *= scale;\n  \
    \  }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpbfcpg1aa.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmpbfcpg1aa.rs:19:9\n   |\n19 |         *n *= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    for n in numbers {\n        *n /= scale;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpu44b2mi2.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    numbers.iter().for_each(|n| {\n        n -= min;\n        n /= scale;\n\
    \    });\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `-=` cannot be applied to type\
    \ `&f64`\n  --> /tmp/tmp8s_0mza9.rs:18:9\n   |\n18 |         n -= min;\n   | \
    \        -^^^^^^^\n   |         |\n   |         cannot use `-=` on type `&f64`\n\
    \   |\nhelp: `-=` can be used on `f64`, you can dereference `n`\n   |\n18 |  \
    \       *n -= min;\n   |         +\n\nerror[E0368]: binary assignment operation\
    \ `/=` cannot be applied to type `&f64`\n  --> /tmp/tmp8s_0mza9.rs:19:9\n   |\n\
    19 |         n /= scale;\n   |         -^^^^^^^^^\n   |         |\n   |      \
    \   cannot use `/=` on type `&f64`\n   |\nhelp: `/=` can be used on `f64`, you\
    \ can dereference `n`\n   |\n19 |         *n /= scale;\n   |         +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for &n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzqgl3hzm.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzqgl3hzm.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    for n in numbers {\n        n -= min;\n        n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmp9rzx_f3w.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmp9rzx_f3w.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp9rzx_f3w.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp9rzx_f3w.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmp9rzx_f3w.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmp9rzx_f3w.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_number = numbers[0];\n    let mut max_number = numbers[0];\n\
    \    for number in numbers {\n        if number < min_number {\n            min_number\
    \ = number;\n        }\n        if number > max_number {\n            max_number\
    \ = number;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for\
    \ number in numbers {\n        let new_number = (number - min_number) / (max_number\
    \ - min_number);\n        new_numbers.push(new_number);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpa_ubuc9w.rs:17:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n17  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n8   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0f64;\n   \
    \ for n in numbers {\n        scale *= (n - min) / (max - min);\n    }\n    numbers.iter().map(|n|\
    \ n * scale).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpgo9g3m31.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0382]: borrow of moved value: `numbers`\n\
    \  --> /tmp/tmpgo9g3m31.rs:20:5\n   |\n5  | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n   |                    ------- move occurs because `numbers`\
    \ has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n17 |  \
    \   for n in numbers {\n   |              ------- `numbers` moved due to this\
    \ implicit call to `.into_iter()`\n...\n20 |     numbers.iter().map(|n| n * scale).collect()\n\
    \   |     ^^^^^^^^^^^^^^ value borrowed here after move\n   |\n   = note: borrow\
    \ occurs due to deref coercion to `[f64]`\nhelp: consider iterating over a slice\
    \ of the `Vec<f64>`'s content to avoid moving into the `for` loop\n   |\n17 |\
    \     for n in &numbers {\n   |              +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for &n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpabtklx89.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpabtklx89.rs:18:9\n   |\n18 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n      \
    \  let new_n = ((n - min_value) / (max_value - min_value)) * 2.0 - 1.0;\n    \
    \    new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpz19fqz2k.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for &n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut new_numbers = Vec::new();\n    for &n in numbers {\n     \
    \   let new_value = ((n - min_value) / (max_value - min_value)) * 2.0 + 0.5;\n\
    \        new_numbers.push(new_value);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmzasudy8.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmzasudy8.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    for n in numbers {\n        *n -= min;\n        *n *= scale;\n    }\n   \
    \ numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpdtz2laoa.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmpdtz2laoa.rs:19:9\n   |\n19 |         *n *= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min) / (1.0 * numbers.len());\n    for n in numbers {\n        n -= min;\n \
    \       n /= scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot multiply `{float}` by `usize`\n  --> /tmp/tmpp6voj13l.rs:16:46\n\
    \   |\n16 |     let mut scale = 1.0 * (max - min) / (1.0 * numbers.len());\n \
    \  |                                              ^ no implementation for `{float}\
    \ * usize`\n   |\n   = help: the trait `Mul<usize>` is not implemented for `{float}`\n\
    \   = help: the following other types implement trait `Mul<Rhs>`:\n          \
    \   <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a\
    \ i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32\
    \ as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n        if n > max_val {\n            max_val = n;\n        }\n    }\n  \
    \  let mut new_numbers = Vec::new();\n    new_numbers.extend_from_slice(&[min_val]);\n\
    \    new_numbers.extend_from_slice(&[max_val]);\n    new_numbers.extend_from_slice(&numbers[1..]);\n\
    \    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpdc66erl2.rs:19:36\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     new_numbers.extend_from_slice(&numbers[1..]);\n    |          \
    \                          ^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `numbers`\n\
    help: consider iterating over a slice of the `Vec<f64>`'s content to avoid moving\
    \ into the `for` loop\n    |\n8   |     for n in &numbers {\n    |           \
    \   +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = max - min;\n\
    \    if scale == 0.0 {\n        return vec![];\n    }\n    let mut result = vec![];\n\
    \    for &n in numbers {\n        let mut n = n - min;\n        let mut n2 = n\
    \ * n;\n        let mut n3 = n * n * n;\n        let mut n4 = n * n * n * n;\n\
    \        let mut n5 = n * n * n * n * n;\n        let mut n6 = n * n * n * n *\
    \ n * n;\n        let mut n7 = n * n * n * n * n * n * n;\n        let mut n8\
    \ = n * n * n * n * n * n * n * n;\n        let mut n9 = n * n * n * n * n * n\
    \ * n * n * n;\n        let mut n10 = n * n * n * n * n * n * n * n * n * n;\n\
    \        let mut n11 = n * n * n * n * n * n * n * n * n * n * n;\n        let\
    \ mut n12 = n * n * n * n * n * n * n * n * n * n * n * n;\n        let mut n13\
    \ = n * n * n * n * n * n * n * n * n * n * n * n * n;\n        let mut n14 =\
    \ n * n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n        let mut\
    \ n15 = n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n \
    \       let mut n16 = n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n;\n        let mut n17 = n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n;\n        let mut n18 = n * n * n * n *\
    \ n * n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n        let mut\
    \ n19 = n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n;\n        let mut n20 = n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n * n * n * n * n * n * n;\n        let mut n21 = n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n     \
    \   let mut n22 = n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n * n;\n        let mut n23 = n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n;\n        let mut \n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpl2d99uja.rs:55:3\n\
    \   |\n5  | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n   |        \
    \                                           - unclosed delimiter\n...\n21 |  \
    \   for &n in numbers {\n   |                       - this delimiter might not\
    \ be properly closed...\n...\n46 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n55 | }\n   |   ^\n\nerror: expected identifier,\
    \ found `}`\n  --> /tmp/tmpl2d99uja.rs:46:1\n   |\n46 | }\n   | ^ expected identifier\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpl2d99uja.rs:8:9\n  |\n8 |     for\
    \ &n in numbers {\n  |         ^^    ------- this expression has type `Option<f64>`\n\
    \  |         |\n  |         expected `f64`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `n`\n  |\n  = note:   expected\
    \ type `f64`\n          found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl2d99uja.rs:21:9\n   |\n21 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpl2d99uja.rs:5:42\n\
    \  |\n5 | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n  |    ---------------\
    \                       ^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<f64>`\n          found unit type `()`\n\n\
    error: aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0f64;\n   \
    \ for &n in numbers {\n        *n /= max - min;\n        *n *= scale;\n      \
    \  scale *= 1.0f64;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbgpmid1g.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbgpmid1g.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut scale = (max_value - min_value).recip();\n    for n in numbers\
    \ {\n        *n -= min_value;\n        *n *= scale;\n    }\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpimjxo85a.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmpimjxo85a.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min) / (1.0 * numbers.len());\n    numbers.iter().for_each(|n| {\n        n\
    \ -= min;\n        n /= scale;\n    });\n    numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot multiply `{float}` by `usize`\n  --> /tmp/tmpc6kzf23t.rs:16:46\n\
    \   |\n16 |     let mut scale = 1.0 * (max - min) / (1.0 * numbers.len());\n \
    \  |                                              ^ no implementation for `{float}\
    \ * usize`\n   |\n   = help: the trait `Mul<usize>` is not implemented for `{float}`\n\
    \   = help: the following other types implement trait `Mul<Rhs>`:\n          \
    \   <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a\
    \ i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32\
    \ as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0368]:\
    \ binary assignment operation `-=` cannot be applied to type `&f64`\n  --> /tmp/tmpc6kzf23t.rs:18:9\n\
    \   |\n18 |         n -= min;\n   |         -^^^^^^^\n   |         |\n   |   \
    \      cannot use `-=` on type `&f64`\n   |\nhelp: `-=` can be used on `f64`,\
    \ you can dereference `n`\n   |\n18 |         *n -= min;\n   |         +\n\nerror[E0368]:\
    \ binary assignment operation `/=` cannot be applied to type `&f64`\n  --> /tmp/tmpc6kzf23t.rs:19:9\n\
    \   |\n19 |         n /= scale;\n   |         -^^^^^^^^^\n   |         |\n   |\
    \         cannot use `/=` on type `&f64`\n   |\nhelp: `/=` can be used on `f64`,\
    \ you can dereference `n`\n   |\n19 |         *n /= scale;\n   |         +\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0368.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 / (max -\
    \ min);\n    for n in numbers {\n        *n -= min;\n        *n *= scale;\n  \
    \  }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp7a6fha9r.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmp7a6fha9r.rs:19:9\n   |\n19 |         *n *= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n \
    \       rescaled_numbers.push((n - min_value) / (max_value - min_value));\n  \
    \  }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpnj7d79qj.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    for n in numbers {\n        n -= min;\n        n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmpciyx9xqh.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmpciyx9xqh.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpciyx9xqh.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpciyx9xqh.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmpciyx9xqh.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmpciyx9xqh.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> =\
    \ Vec::new();\n    for n in numbers {\n        rescaled.push((n - min) / (max\
    \ - min));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp8hnxd496.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    for n in numbers {\n        *n /= scale;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpoedhme85.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0f64 / max\
    \ - min;\n    numbers.iter().for_each(|n| {\n        *n = *n * scale;\n    });\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmp0_zam_p2.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n = *n * scale;\n   |         ^^^^^^^^^^^^^^^\
    \ `n` is a `&` reference, so the data it refers to cannot be written\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmp0_zam_p2.rs:16:9\n   |\n\
    16 |     let mut scale = 1.0f64 / max - min;\n   |         ----^^^^^\n   |   \
    \      |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmp0_zam_p2.rs:17:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n    = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0382, E0594.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpab8xtgow.rs:16:9\n\
    \   |\n16 |     let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpab8xtgow.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut result = Vec::new();\n    for &n in numbers {\n        result.push((n\
    \ - min) * scale);\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4owfdcrf.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4owfdcrf.rs:18:9\n   |\n18 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = max - min;\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp8nth5gjx.rs:16:9\n\
    \   |\n16 |     let mut scale = max - min;\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp8nth5gjx.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n        if n > max_val {\n            max_val = n;\n        }\n    }\n  \
    \  let mut new_numbers = Vec::new();\n    for n in numbers {\n        let mut\
    \ new_n = n;\n        if new_n < min_val {\n            new_n -= min_val;\n  \
    \      }\n        if new_n > max_val {\n            new_n -= max_val;\n      \
    \  }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpedb3coms.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut scale = (max_value - min_value).recip();\n    for n in numbers\
    \ {\n        *n -= min_value;\n        *n *= scale;\n    }\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpkry8r4jy.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmpkry8r4jy.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    for n in numbers {\n        n -= min;\n        n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmp52ju04x4.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmp52ju04x4.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp52ju04x4.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp52ju04x4.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmp52ju04x4.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmp52ju04x4.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    for n in numbers {\n        n -= min;\n        n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmpnorvl54d.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmpnorvl54d.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpnorvl54d.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpnorvl54d.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmpnorvl54d.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmpnorvl54d.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n \
    \       rescaled_numbers.push((n - min_value) / (max_value - min_value));\n  \
    \  }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp7nvaw2nu.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut result = Vec::new();\n    for &n in numbers {\n        result.push((n\
    \ - min).mul(scale));\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpynhw0u5f.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpynhw0u5f.rs:18:9\n   |\n18 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpxyz8d2om.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpxyz8d2om.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| {\n        *n /= scale;\n    });\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmp6c897cov.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n /= scale;\n   |         ^^^^^^^^^^^ `n`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp6c897cov.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |         |\n \
    \  |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmp6c897cov.rs:17:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n    = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0382, E0594.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 / (max -\
    \ min);\n    for n in numbers {\n        *n -= min;\n        *n *= scale;\n  \
    \  }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpocg0eb9_.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmpocg0eb9_.rs:19:9\n   |\n19 |         *n *= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n      \
    \  let new_value = ((n - min_value) / (max_value - min_value)).floor();\n    \
    \    new_numbers.push(new_value);\n    }\n    new_numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmprq1orlco.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| {\n        *n /= scale;\n    });\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmpyje4tdzg.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n /= scale;\n   |         ^^^^^^^^^^^ `n`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpyje4tdzg.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |         |\n \
    \  |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpyje4tdzg.rs:17:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n    = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0382, E0594.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = max - min;\n\
    \    scale = scale / 2.0 + 1.0;\n    numbers.iter().map(|n| n * scale).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmp2nso2tj3.rs:18:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     numbers.iter().map(|n| n * scale).collect()\n    |     ^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `numbers`\n    = note: borrow occurs due to\
    \ deref coercion to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = max - min;\n\
    \    let mut new_numbers = Vec::new();\n    for &n in numbers {\n        new_numbers.push((n\
    \ - min) / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp6tdusrd2.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6tdusrd2.rs:18:9\n   |\n18 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        new_numbers.push((n - min) / (max - min));\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpww9pxxn7.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_number = numbers[0];\n    let mut max_number = numbers[0];\n\
    \    for number in numbers {\n        if number < min_number {\n            min_number\
    \ = number;\n        }\n        if number > max_number {\n            max_number\
    \ = number;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for\
    \ number in numbers {\n        let new_number = (number - min_number) / (max_number\
    \ - min_number);\n        new_numbers.push(new_number);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpevnn0tse.rs:17:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n17  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n8   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_number = numbers.iter().min().unwrap();\n    let mut max_number\
    \ = numbers.iter().max().unwrap();\n    min_number = min_number / max_number;\n\
    \    max_number = max_number / min_number;\n    numbers.iter().map(|x| x * max_number).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp5fvo698a.rs:6:41\n\
    \     |\n6    |     let mut min_number = numbers.iter().min().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp5fvo698a.rs:7:41\n\
    \     |\n7    |     let mut max_number = numbers.iter().max().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp5fvo698a.rs:8:18\n  |\n6 |    \
    \ let mut min_number = numbers.iter().min().unwrap();\n  |                   \
    \       ----------------------------- expected due to this value\n7 |     let\
    \ mut max_number = numbers.iter().max().unwrap();\n8 |     min_number = min_number\
    \ / max_number;\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^\n  |           \
    \       |\n  |                  expected `&f64`, found `f64`\n  |            \
    \      help: consider borrowing here: `&(min_number / max_number)`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5fvo698a.rs:9:18\n  |\n7 |     let mut max_number\
    \ = numbers.iter().max().unwrap();\n  |                          -----------------------------\
    \ expected due to this value\n8 |     min_number = min_num"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp9s980xjg.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp9s980xjg.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    for n in numbers {\n        n -= min;\n        n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmpl7_n1inx.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmpl7_n1inx.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpl7_n1inx.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpl7_n1inx.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmpl7_n1inx.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmpl7_n1inx.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = max - min;\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) / scale + min);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp64ddna_w.rs:16:9\n\
    \   |\n16 |     let mut scale = max - min;\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp64ddna_w.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut result = Vec::new();\n    for n in numbers {\n        result.push((n\
    \ - min) * scale);\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpsk0vfkf0.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpsk0vfkf0.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = max - min;\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp4z75h51k.rs:16:9\n\
    \   |\n16 |     let mut scale = max - min;\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp4z75h51k.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpqhk0p_tm.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpqhk0p_tm.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    let mut result = Vec::new();\n    for n in numbers {\n        result.push(n\
    \ * scale);\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp743bo6nz.rs:16:9\n\
    \   |\n16 |     let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp743bo6nz.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpbgf6nsb0.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpbgf6nsb0.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 / (max -\
    \ min);\n    for n in numbers {\n        *n -= min;\n        *n *= scale;\n  \
    \  }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpxpxgj1rl.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmpxpxgj1rl.rs:19:9\n   |\n19 |         *n *= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut scale = max_value - min_value;\n    numbers.iter().for_each(|n|\
    \ {\n        *n -= min_value;\n        *n /= scale;\n    });\n    numbers\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmpr_g_iukh.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n -= min_value;\n   |         ^^^^^^^^^^^^^^^\
    \ `n` is a `&` reference, so the data it refers to cannot be written\n\nerror[E0594]:\
    \ cannot assign to `*n`, which is behind a `&` reference\n  --> /tmp/tmpr_g_iukh.rs:19:9\n\
    \   |\n17 |     numbers.iter().for_each(|n| {\n   |                          \
    \    - help: consider changing this to be a mutable reference: `&mut f64`\n18\
    \ |         *n -= min_value;\n19 |         *n /= scale;\n   |         ^^^^^^^^^^^\
    \ `n` is a `&` reference, so the data it refers to cannot be written\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmpr_g_iukh.rs:16:9\n   |\n\
    16 |     let mut scale = max_value - min_value;\n   |         ----^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpr_g_iukh.rs:17:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n    = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0382, E0594.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    for n in numbers {\n        *n /= scale;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpii4sbtyl.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpoa_ta8sz.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpoa_ta8sz.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut scale = (max_value - min_value).recip();\n    for n in numbers\
    \ {\n        *n -= min_value;\n        *n *= scale;\n    }\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpae9mubfk.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmpae9mubfk.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| {\n        *n /= scale;\n    });\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmpm48xncis.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n /= scale;\n   |         ^^^^^^^^^^^ `n`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpm48xncis.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |         |\n \
    \  |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpm48xncis.rs:17:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n    = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0382, E0594.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    for n in numbers {\n        n -= min;\n        n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmpgtj52nco.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmpgtj52nco.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpgtj52nco.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpgtj52nco.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmpgtj52nco.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmpgtj52nco.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    for n in numbers {\n        *n /= scale;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp7chr545u.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    for n in numbers {\n        n -= min;\n        n *= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmp1btyntvj.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmp1btyntvj.rs:19:9\n   |\n19 |         n *=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp1btyntvj.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp1btyntvj.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmp1btyntvj.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmp1btyntvj.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpl097o2nz.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpl097o2nz.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    for n in numbers {\n        n -= min;\n        n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmpx49ouqpn.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmpx49ouqpn.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpx49ouqpn.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpx49ouqpn.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmpx49ouqpn.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmpx49ouqpn.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 / (max -\
    \ min);\n    for n in numbers {\n        *n = *n * scale;\n    }\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp4jepyosj.rs:18:9\n\
    \   |\n18 |         *n = *n * scale;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmp4jepyosj.rs:18:14\n   |\n18 |        \
    \ *n = *n * scale;\n   |              ^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = (max - min).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for &n in numbers {\n        new_numbers.push((n\
    \ - min) * scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpp1rdf1rv.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp1rdf1rv.rs:18:9\n   |\n18 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| n = n * scale);\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj4nyp0bn.rs:17:37\n   |\n\
    17 |     numbers.iter().for_each(|n| n = n * scale);\n   |                   \
    \           -      ^^^^^^^^^\n   |                              |      |\n   |\
    \                              |      expected `&f64`, found `f64`\n   |     \
    \                         |      help: consider borrowing here: `&(n * scale)`\n\
    \   |                              expected due to this parameter type\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n      \
    \  let mut new_n = n;\n        if n < min_value {\n            new_n -= min_value;\n\
    \        }\n        if n > max_value {\n            new_n -= max_value;\n    \
    \    }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp9ya4qexj.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0f64 / max\
    \ - min;\n    numbers.iter().for_each(|n| n = n * scale);\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgpzcph98.rs:17:37\n   |\n\
    17 |     numbers.iter().for_each(|n| n = n * scale);\n   |                   \
    \           -      ^^^^^^^^^\n   |                              |      |\n   |\
    \                              |      expected `&f64`, found `f64`\n   |     \
    \                         |      help: consider borrowing here: `&(n * scale)`\n\
    \   |                              expected due to this parameter type\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max -\
    \ min);\n    for n in numbers {\n        n -= min;\n        n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmpvyc1z9qk.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmpvyc1z9qk.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpvyc1z9qk.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpvyc1z9qk.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmpvyc1z9qk.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmpvyc1z9qk.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  exit_code: 1
  status: SyntaxError
