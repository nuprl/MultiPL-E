name: HumanEval_78_hex_key
language: rust
results:
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_counter = vec![];\n    let mut prime_digits_counter2\
    \ = vec![];\n    let mut prime_digits_counter3 = vec![];\n    let mut prime_digits_counter4\
    \ = vec![];\n    let mut prime_digits_counter5 = vec![];\n    let mut prime_digits_counter6\
    \ = vec![];\n    let mut prime_digits_counter7 = vec![];\n    let mut prime_digits_counter8\
    \ = vec![];\n    let mut prime_digits_counter9 = vec![];\n    let mut prime_digits_counter10\
    \ = vec![];\n    let mut prime_digits_counter11 = vec![];\n    let mut prime_digits_counter12\
    \ = vec![];\n    let mut prime_digits_counter13 = vec![];\n    let mut prime_digits_counter14\
    \ = vec![];\n    let mut prime_digits_counter15 = vec![];\n    let mut prime_digits_counter16\
    \ = vec![];\n    let mut prime_digits_counter17 = vec![];\n    let mut prime_digits_counter18\
    \ = vec![];\n    let mut prime_digits_counter19 = vec![];\n    let mut prime_digits_counter20\
    \ = vec![];\n    let mut prime_digits_counter21 = vec![];\n    let mut prime_digits_counter22\
    \ = vec![];\n    let mut prime_digits_counter23 = vec![];\n    let mut prime_digits_counter24\
    \ = vec![];\n    let mut prime_digits_counter25 = vec![];\n    let mut prime_digits_counter26\
    \ = vec![];\n    let mut prime_digits_counter27 = vec![];\n    let mut prime_digits_counter28\
    \ = vec![];\n    let mut prime_digits_counter29 = vec![];\n    let mut prime_digits_counter30\
    \ = vec![];\n    let mut prime_digits_counter31 = vec![];\n    let mut prime_digits_counter32\
    \ = vec![];\n    let mut prime_digits_counter33 = vec![];\n    let mut prime_digits_counter34\
    \ = vec![];\n    let mut prime_digits_counter35 = vec![];\n    let mut prime_digits_counter36\
    \ = vec![];\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpewtqhr8i.rs:56:11\n   |\n\
    56 |     let mu\n   |           ^ help: add `;` here\n57 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpewtqhr8i.rs:17:28\n \
    \  |\n17 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19];\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set_size = prime_digits_set.len();\n    let mut prime_digits_set_iter\
    \ = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let\
    \ mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter\
    \ = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let\
    \ mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter\
    \ = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let\
    \ mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter\
    \ = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let\
    \ mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter\
    \ = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let\
    \ mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter\
    \ = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp8kmsy0rx.rs:45:1\n   |\n45\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp8kmsy0rx.rs:44:61\n\
    \   |\n44 |     let mut prime_digits_set_iter = prime_digits_set.iter().\n   |\
    \                                                             ^ help: add `;`\
    \ here\n45 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmp8kmsy0rx.rs:20:32\n   |\n20 |  \
    \   let mut prime_digits_set = HashSet::new();\n   |                         \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8kmsy0rx.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count_max\
    \ = vec![];\n    let mut prime_digits_count_min = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_value\
    \ = vec![];\n    let mut prime_digits_count_min_value = vec![];\n    let mut prime_digits_count_max_value_max\
    \ = vec![];\n    let mut prime_digits_count_min_value_max = vec![];\n    let mut\
    \ prime_digits_count_max_value_min = vec![];\n    let mut prime_digits_count_min_value_min\
    \ = vec![];\n    let mut prime_digits_count_max_value_min_index = vec![];\n  \
    \  let mut prime_digits_count_min_value_min_index = vec![];\n    let mut prime_digits_count_max_value_min_value\
    \ = vec![];\n    let mut prime_digits_count_min_value_min_value = vec![];\n  \
    \  let mut prime_digits_count_max_value_min_value_max = vec![];\n    let mut prime_digits_count_min_value_min_value_max\
    \ = vec![];\n    let mut prime_digits_count_max_value_min_value_min = vec![];\n\
    \    let mut prime_digits_count_min_value_min_value_min = vec![];\n    let mut\
    \ prime_digits_count_max_value_min_value_min_index = vec![];\n    let mut prime_digits_count_min_value_min_value_min_index\
    \ = vec![];\n    let mut prime_digits_count_max_value_min_value_min_value = vec![];\n\
    \    let mut prime_digits_count_min_value_min_value_min = vec![];\n    let mut\
    \ prime_digits_count_max_value_min_value_min_index = vec![];\n    let mut prime_digits_count_min_value_min_value_min_index\
    \ = vec![];\n    let mut prime_digits_count_max_value_min_value_min_value = vec![];\n\
    \    let mut prime_digits_count_min_value_min_value_min_index = vec![];\n    let\
    \ mut prime_digits_count_max_value_min_value_min_value = vec![];\n    let mut\
    \ prime_digits_count_min_value_min_value_min_index = vec![];\n    let mut prime_digits_count_max_value_min_value_min_value\
    \ = vec![];\n    let mut prime_digits_count_min_value_min_\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2wx56rol.rs:50:46\n   |\n\
    50 |     let mut prime_digits_count_min_value_min_\n   |                     \
    \                         ^ help: add `;` here\n51 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2wx56rol.rs:17:28\n   |\n17 |\
    \ fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3vc2_0sf.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3vc2_0sf.rs:17:28\n \
    \  |\n17 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count_max\
    \ = vec![];\n    let mut prime_digits_count_max_index = vec![];\n    let mut prime_digits_count_min\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_value\
    \ = vec![];\n    let mut prime_digits_count_min_value = vec![];\n    let mut prime_digits_count_max_value_max\
    \ = vec![];\n    let mut prime_digits_count_min_value_max = vec![];\n    let mut\
    \ prime_digits_count_max_value_min = vec![];\n    let mut prime_digits_count_min_value_min\
    \ = vec![];\n    let mut prime_digits_count_max_value_min_index = vec![];\n  \
    \  let mut prime_digits_count_min_value_min_index = vec![];\n    let mut prime_digits_count_max_value_min_value\
    \ = vec![];\n    let mut prime_digits_count_min_value_min_value = vec![];\n  \
    \  let mut prime_digits_count_max_value_min_value_max = vec![];\n    let mut prime_digits_count_min_value_min_value_max\
    \ = vec![];\n    let mut prime_digits_count_max_value_min_value_min = vec![];\n\
    \    let mut prime_digits_count_min_value_min_value_min = vec![];\n    let mut\
    \ prime_digits_count_max_value_min_value_min_index = vec![];\n    let mut prime_digits_count_min_value_min_value_min_index\
    \ = vec![];\n    let mut prime_digits_count_max_value_min_value_min_value = vec![];\n\
    \    let mut prime_digits_count_min_value_min_value_min = vec![];\n    let mut\
    \ prime_digits_count_max_value_min_value_min_index = vec![];\n    let mut prime_digits_count_min_value_min_value_min_index\
    \ = vec![];\n    let mut prime_digits_count_max_value_min_value_min_value = vec![];\n\
    \    let mut prime_digits_count_min_value_min_value_min_index = vec![];\n    let\
    \ mut prime_digits_count_max_value_min_value_min_value = vec![];\n    let mut\
    \ prime_digits_count_min_value_min_value_min_index = vec![];\n    let mut prime_digits_count_max_value_min_value_min_value\
    \ = vec![];\n    let mut prime_digits_count_min_value_min_\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp18y21px9.rs:50:46\n   |\n\
    50 |     let mut prime_digits_count_min_value_min_\n   |                     \
    \                         ^ help: add `;` here\n51 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp18y21px9.rs:17:28\n   |\n17 |\
    \ fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_vec();\n    let mut cnt: usize\
    \ = 0;\n    let mut prime: usize = 2;\n    let mut prime_found = false;\n    let\
    \ mut prime_found2 = false;\n    let mut prime_found3 = false;\n    let mut prime_found4\
    \ = false;\n    let mut prime_found5 = false;\n    let mut prime_found6 = false;\n\
    \    let mut prime_found7 = false;\n    let mut prime_found8 = false;\n    let\
    \ mut prime_found9 = false;\n    let mut prime_found10 = false;\n    let mut prime_found11\
    \ = false;\n    let mut prime_found12 = false;\n    let mut prime_found13 = false;\n\
    \    let mut prime_found14 = false;\n    let mut prime_found15 = false;\n    let\
    \ mut prime_found16 = false;\n    let mut prime_found17 = false;\n    let mut\
    \ prime_found18 = false;\n    let mut prime_found19 = false;\n    let mut prime_found20\
    \ = false;\n    let mut prime_found21 = false;\n    let mut prime_found22 = false;\n\
    \    let mut prime_found23 = false;\n    let mut prime_found24 = false;\n    let\
    \ mut prime_found25 = false;\n    let mut prime_found26 = false;\n    let mut\
    \ prime_found27 = false;\n    let mut prime_found28 = false;\n    let mut prime_found29\
    \ = false;\n    let mut prime_found30 = false;\n    let mut prime_found31 = false;\n\
    \    let mut prime_found32 = false;\n    let mut prime_found33 = false;\n    let\
    \ mut prime_found34 = false;\n    let mut prime_found35 = false;\n    let mut\
    \ prime_found36 = false;\n    let mut prime_found37 = false;\n    let mut prime_found38\
    \ = false;\n    let mut prime_found39 = false;\n    let mut prime_found40 = false;\n\
    \    let mut prime_found41 = false;\n    let mut prime_found42 = false;\n    let\
    \ mut prime_found43 = false;\n    let mut prime_found44 = false;\n    let mut\
    \ prime_found45 = false;\n    let mut prime_found46 = false;\n    let mut prime_found47\
    \ = false;\n    let mut prime_found48 = false;\n    let mut prime_found49 = false;\n\
    \    let mut prime_found50 = false;\n    let mut prime_found51 = false;\n    let\
    \ mut prime_found52 = false;\n    let mut prime\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2ko_9cu1.rs:73:18\n   |\n\
    73 |     let mut prime\n   |                  ^ help: add `;` here\n74 | }\n \
    \  | - unexpected token\n\nerror[E0599]: no method named `to_vec` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp2ko_9cu1.rs:18:32\n   |\n18 | \
    \    let mut num: Vec<u8> = num.to_vec();\n   |                              \
    \  ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2ko_9cu1.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize {\n \
    \  |    -------                 ^^^^^ expected `isize`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_vec();\n    let mut prime: isize\
    \ = 0;\n    let mut prime_counter: isize = 0;\n    let mut prime_counter2: isize\
    \ = 0;\n    let mut prime_counter3: isize = 0;\n    let mut prime_counter4: isize\
    \ = 0;\n    let mut prime_counter5: isize = 0;\n    let mut prime_counter6: isize\
    \ = 0;\n    let mut prime_counter7: isize = 0;\n    let mut prime_counter8: isize\
    \ = 0;\n    let mut prime_counter9: isize = 0;\n    let mut prime_counter10: isize\
    \ = 0;\n    let mut prime_counter11: isize = 0;\n    let mut prime_counter12:\
    \ isize = 0;\n    let mut prime_counter13: isize = 0;\n    let mut prime_counter14:\
    \ isize = 0;\n    let mut prime_counter15: isize = 0;\n    let mut prime_counter16:\
    \ isize = 0;\n    let mut prime_counter17: isize = 0;\n    let mut prime_counter18:\
    \ isize = 0;\n    let mut prime_counter19: isize = 0;\n    let mut prime_counter20:\
    \ isize = 0;\n    let mut prime_counter21: isize = 0;\n    let mut prime_counter22:\
    \ isize = 0;\n    let mut prime_counter23: isize = 0;\n    let mut prime_counter24:\
    \ isize = 0;\n    let mut prime_counter25: isize = 0;\n    let mut prime_counter26:\
    \ isize = 0;\n    let mut prime_counter27: isize = 0;\n    let mut prime_counter28:\
    \ isize = 0;\n    let mut prime_counter29: isize = 0;\n    let mut prime_counter30:\
    \ isize = 0;\n    let mut prime_counter31: isize = 0;\n    let mut prime_counter32:\
    \ isize = 0;\n    let mut prime_counter33: isize = 0;\n    let mut prime_counter34:\
    \ isize = 0;\n    let mut prime_counter35: isize = 0;\n    let mut prime_counter36:\
    \ isize = 0;\n    let mut prime_counter37: isize = 0;\n    let mut prime_counter38:\
    \ isize = 0;\n    let mut prime_counter39: isize = 0;\n    let mut prime_counter40:\
    \ isize = 0;\n    let mut prime_counter41: isize = 0;\n    let \n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpknb6neb7.rs:62:1\n  \
    \ |\n62 | }\n   | ^ expected pattern\n\nerror[E0599]: no method named `to_vec`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpknb6neb7.rs:18:32\n\
    \   |\n18 |     let mut num: Vec<u8> = num.to_vec();\n   |                   \
    \             ^^^^^^ method not found in `String`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut digits = num.chars().collect::<Vec<_>>();\n\
    \    let mut prime_digits = vec![false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp0w7puf29.rs:20:32\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n20 |     let mut prime_digits\
    \ = vec![false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, ...\n   |                               \
    \ ^ unclosed delimiter\n21 | }\n   | ^ mismatched closing delimiter\n\nerror:\
    \ expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmp0w7puf29.rs:21:1\n\
    \   |\n21 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\n\
    error: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut prime_counter = 0;\n    let\
    \ mut prime_counter2 = 0;\n    let mut prime_counter3 = 0;\n    let mut prime_counter4\
    \ = 0;\n    let mut prime_counter5 = 0;\n    let mut prime_counter6 = 0;\n   \
    \ let mut prime_counter7 = 0;\n    let mut prime_counter8 = 0;\n    let mut prime_counter9\
    \ = 0;\n    let mut prime_counter10 = 0;\n    let mut prime_counter11 = 0;\n \
    \   let mut prime_counter12 = 0;\n    let mut prime_counter13 = 0;\n    let mut\
    \ prime_counter14 = 0;\n    let mut prime_counter15 = 0;\n    let mut prime_counter16\
    \ = 0;\n    let mut prime_counter17 = 0;\n    let mut prime_counter18 = 0;\n \
    \   let mut prime_counter19 = 0;\n    let mut prime_counter20 = 0;\n    let mut\
    \ prime_counter21 = 0;\n    let mut prime_counter22 = 0;\n    let mut prime_counter23\
    \ = 0;\n    let mut prime_counter24 = 0;\n    let mut prime_counter25 = 0;\n \
    \   let mut prime_counter26 = 0;\n    let mut prime_counter27 = 0;\n    let mut\
    \ prime_counter28 = 0;\n    let mut prime_counter29 = 0;\n    let mut prime_counter30\
    \ = 0;\n    let mut prime_counter31 = 0;\n    let mut prime_counter32 = 0;\n \
    \   let mut prime_counter33 = 0;\n    let mut prime_counter34 = 0;\n    let mut\
    \ prime_counter35 = 0;\n    let mut prime_counter36 = 0;\n    let mut prime_counter37\
    \ = 0;\n    let mut prime_counter38 = 0;\n    let mut prime_counter39 = 0;\n \
    \   let mut prime_counter40 = 0;\n    let mut prime_counter41 = 0;\n    let mut\
    \ prime_counter42 = 0;\n    let mut prime_counter43 = 0;\n    let mut prime_counter44\
    \ = 0;\n    let mut prime_counter45 = 0;\n    let mut prime_counter46 = 0;\n \
    \   let mut prime_counter47 = 0;\n    let mut prime_counter48 = 0;\n    let mut\
    \ prime_counter49 = 0;\n    let mut prime_counter50 = 0;\n    let mut prime_counter51\
    \ = 0;\n    let mut prime_counter52 = 0;\n    let mut prime_counter53 = 0;\n \
    \   let mut prime_counter54 = 0;\n    let mut prime_counter55 = 0;\n    let mut\
    \ prime_counter56 = 0;\n    let mut prime_counter57\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp145tul73.rs:75:28\n   |\n\
    75 |     let mut prime_counter57\n   |                            ^ help: add\
    \ `;` here\n76 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp145tul73.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count_max\
    \ = vec![];\n    let mut prime_digits_count_min = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuccno7vo.rs:55:32\n   |\n\
    55 |     let mut prime_digits_count_\n   |                                ^ help:\
    \ add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpuccno7vo.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime.len();\n    let mut prime_len\
    \ = prime.\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpglmy2jqk.rs:61:1\n   |\n61\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpglmy2jqk.rs:60:31\n\
    \   |\n60 |     let mut prime_len = prime.\n   |                             \
    \  ^ help: add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmpglmy2jqk.rs:18:55\n     |\n18   |     let mut num: Vec<u8> =\
    \ num.to_lowercase().chars().collect();\n     |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpglmy2jqk.rs:17:28\n   |\n17 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut digit_count = 1;\n   \
    \ let mut digit = num.chars().nth(1).unwrap();\n    while digit != char::from_u32(digit\
    \ as u32).unwrap() {\n        digit_count += 1;\n        digit += 1;\n    }\n\
    \    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count\
    \ += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n\
    \    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count\
    \ += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n\
    \    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count\
    \ += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n\
    \    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count\
    \ += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n\
    \    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count\
    \ += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n\
    \    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count\
    \ += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n\
    \    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count\
    \ += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n\
    \    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count\
    \ += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n\
    \    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count\
    \ += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n\
    \    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count\
    \ += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n\
    \    digit_count += 1;\n    digit_count += 1;\n    digit_count += 1;\n    digit_count\
    \ += 1;\n    digit_count += 1;\n    digit_count += 1;\n\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `char`\n  --> /tmp/tmp31wty5te.rs:23:9\n   |\n23 |         digit += 1;\n   |\
    \         -----^^^^^\n   |         |\n   |         cannot use `+=` on type `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp31wty5te.rs:17:28\n   |\n17 |\
    \ fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17, 19];\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpgrnn5lr3.rs:55:1\n   |\n55\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpgrnn5lr3.rs:54:45\n\
    \   |\n54 |     let mut prime_digits_len = prime_digits.\n   |               \
    \                              ^ help: add `;` here\n55 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgrnn5lr3.rs:17:28\n \
    \  |\n17 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut digits = num.chars().collect::<Vec<_>>();\n\
    \    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut primes_set\
    \ = primes.iter().cloned().collect::<HashSet<_>>();\n    let mut primes_set_size\
    \ = primes_set.len();\n    let mut primes_set_iter = primes_set.iter().cloned().collect::<Iterator<_>>();\n\
    \    let mut primes_set_iter_next = primes_set_iter.next();\n    while primes_set_iter_next.unwrap().is_some()\
    \ {\n        primes_set_iter_next = primes_set_iter.next();\n    }\n    let mut\
    \ primes_set_iter_next_prime = primes_set_iter.next();\n    while primes_set_iter_next_prime.unwrap().is_some()\
    \ {\n        primes_set_iter_next_prime = primes_set_iter.next();\n    }\n   \
    \ let mut primes_set_iter_next_prime_prime = primes_set_iter.next();\n    while\
    \ primes_set_iter_next_prime_prime.unwrap().is_some() {\n        primes_set_iter_next_prime_prime\
    \ = primes_set_iter.next();\n    }\n    let mut primes_set_iter_next_prime_prime_prime\
    \ = primes_set_iter.next();\n    while primes_set_iter_next_prime_prime_prime.unwrap().is_some()\
    \ {\n        primes_set_iter_next_prime_prime_prime = primes_set_iter.next();\n\
    \    }\n    let mut primes_set_iter_next_prime_prime_prime_prime = primes_set_iter.next();\n\
    \    while primes_set_iter_next_prime_prime_prime_prime.unwrap().is_some() {\n\
    \        primes_set_iter_next_prime_prime_prime_prime = primes_set_iter.next();\n\
    \    }\n    let mut primes_set_iter_next_prime_prime_prime_prime_prime = primes_set_iter.next();\n\
    \    while primes_set_iter_next_prime_prime_prime_prime_prime.unwrap().is_some()\
    \ {\n        primes_set_iter_next_prime_prime_prime_prime_prime = primes_set_iter.next();\n\
    \    }\n    let mut primes_set_iter_next_prime_prime_prime_prime_prime_prime =\
    \ primes_set_iter.next();\n    while primes_set_iter_next_prime_prime_prime_prime_prime_prime.unwrap().is_some()\
    \ {\n        primes_set_iter_next_prime_prime_prime_prime_prime_prime = primes_set_iter.next();\n\
    \    }\n    let mut primes_set_iter_next_prime\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx0meqw9d.rs:52:39\n   |\n\
    52 |     let mut primes_set_iter_next_prime\n   |                            \
    \           ^ help: add `;` here\n53 | }\n   | - unexpected token\n\nerror[E0412]:\
    \ cannot find type `HashSet` in this scope\n  --> /tmp/tmpx0meqw9d.rs:21:59\n\
    \   |\n21 |     let mut primes_set = primes.iter().cloned().collect::<HashSet<_>>();\n\
    \   |                                                           ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx0meqw9d.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_digits = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_count = prime_digits.len();\n  \
    \  let mut prime_digits_index = 0;\n    let mut prime_digits_index_count = 0;\n\
    \    let mut prime_digits_index_max = 0;\n    let mut prime_digits_index_min =\
    \ 0;\n    let mut prime_digits_index_max_prime = 0;\n    let mut prime_digits_index_min_prime\
    \ = 0;\n    let mut prime_digits_index_max_prime_prime = 0;\n    let mut prime_digits_index_min_prime_prime\
    \ = 0;\n    let mut prime_digits_index_max_prime_prime_prime = 0;\n    let mut\
    \ prime_digits_index_min_prime_prime_prime = 0;\n    let mut prime_digits_index_max_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_digits_index_min_prime_prime_prime_prime = 0;\n    let\
    \ mut prime_digits_index_max_prime_prime_prime_prime_prime = 0;\n    let mut prime_digits_index_min_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_digits_index_max_prime_prime_prime_prime_prime = 0;\n\
    \    let mut prime_digits_index_min_prime_prime_prime_prime_prime = 0;\n    let\
    \ mut prime_digits_index_max_prime_prime_prime_prime_prime = 0;\n    let mut prime_digits_index_min_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_digits_index_max_prime_prime_prime_prime_prime = 0;\n\
    \    let mut prime_digits_index_min_prime_prime_prime_prime_prime_prime = 0;\n\
    \    let mut prime_digits_index_max_prime_prime_prime_prime_prime_prime = 0;\n\
    \    let mut prime_digits_index_min_prime_prime_prime_prime_prime_prime = 0;\n\
    \    let mut prime_digits_index_max_prime_prime_prime_prime_prime_prime = 0;\n\
    \    let mut prime_digits_index_min_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_digits_index_max_\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphyoowjp5.rs:46:36\n   |\n\
    46 |     let mut prime_digits_index_max_\n   |                               \
    \     ^ help: add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmphyoowjp5.rs:20:32\n\
    \   |\n20 |     let mut prime_digits_set = HashSet::new();\n   |             \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmphyoowjp5.rs:18:55\n     |\n18   |     let mut num:\
    \ Vec<u8> = num.to_lowercase().chars().collect();\n     |                    \
    \                                   ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphyoowjp5.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjwoo0c4u.rs:55:18\n   |\n\
    55 |     let mut prime\n   |                  ^ help: add `;` here\n56 | }\n \
    \  | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmpjwoo0c4u.rs:20:32\n   |\n20 |     let mut prime_digits_set\
    \ = HashSet::new();\n   |                                ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpjwoo0c4u.rs:21:32\n   |\n21 |     let mut prime_digits_set = HashSet::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpjwoo0c4u.rs:22:32\n   |\n22 |     let mut prime_digits_set = HashSet::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpjwoo0c4u.rs:23:32\n   |\n23 |     let mut prime_digits_set = HashSet::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpjwoo0c4u.rs:24:32\n   |\n24 |     let mut prime_digits_set = HashSet::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpjwoo0c4u.rs:25:32\n   |\n25 |     let mut prime_digits_set = HashSet::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E043"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut prime_counter = 0;\n    let\
    \ mut prime_digits = vec![];\n    let mut prime_digits_counter = 0;\n    let mut\
    \ prime_digits_counter2 = 0;\n    let mut prime_digits_counter3 = 0;\n    let\
    \ mut prime_digits_counter4 = 0;\n    let mut prime_digits_counter5 = 0;\n   \
    \ let mut prime_digits_counter6 = 0;\n    let mut prime_digits_counter7 = 0;\n\
    \    let mut prime_digits_counter8 = 0;\n    let mut prime_digits_counter9 = 0;\n\
    \    let mut prime_digits_counter10 = 0;\n    let mut prime_digits_counter11 =\
    \ 0;\n    let mut prime_digits_counter12 = 0;\n    let mut prime_digits_counter13\
    \ = 0;\n    let mut prime_digits_counter14 = 0;\n    let mut prime_digits_counter15\
    \ = 0;\n    let mut prime_digits_counter16 = 0;\n    let mut prime_digits_counter17\
    \ = 0;\n    let mut prime_digits_counter18 = 0;\n    let mut prime_digits_counter19\
    \ = 0;\n    let mut prime_digits_counter20 = 0;\n    let mut prime_digits_counter21\
    \ = 0;\n    let mut prime_digits_counter22 = 0;\n    let mut prime_digits_counter23\
    \ = 0;\n    let mut prime_digits_counter24 = 0;\n    let mut prime_digits_counter25\
    \ = 0;\n    let mut prime_digits_counter26 = 0;\n    let mut prime_digits_counter27\
    \ = 0;\n    let mut prime_digits_counter28 = 0;\n    let mut prime_digits_counter29\
    \ = 0;\n    let mut prime_digits_counter30 = 0;\n    let mut prime_digits_counter31\
    \ = 0;\n    let mut prime_digits_counter32 = 0;\n    let mut prime_digits_counter33\
    \ = 0;\n    let mut prime_digits_counter34 = 0;\n    let mut prime_digits_counter35\
    \ = 0;\n    let mut prime_digits_counter36 = 0;\n    let mut prime_digits_counter37\
    \ = 0;\n    let mut prime_digits_counter38 = 0;\n    let mut prime_digits_counter39\
    \ = 0;\n    let mut prime_digits_counter40 = 0;\n    let mut prime_digits_counter41\
    \ = 0;\n    let mut prime_digits_counter42 = 0;\n    let mut prime_digits_counter43\
    \ = 0;\n    let mut prime_digits_counter44 = 0;\n    let mut prime_digits_counter\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8gts4aev.rs:65:33\n   |\n\
    65 |     let mut prime_digits_counter\n   |                                 ^\
    \ help: add `;` here\n66 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8gts4aev.rs:17:28\n   |\n17 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut digits = num.to_string().chars().collect::<Vec<_>>();\n\
    \    digits.sort_unstable();\n    for digit in digits {\n        if digit == 'A'\
    \ || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit ==\
    \ 'F' {\n            counter += 1;\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpse1xqpge.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: isize = 0;\n    let mut digits: Vec<isize> = num.to_chars().collect();\n\
    \    let mut prime: isize = 2;\n    let mut prime_found = false;\n    let mut\
    \ prime_found2 = false;\n    let mut prime_found3 = false;\n    let mut prime_found4\
    \ = false;\n    let mut prime_found5 = false;\n    let mut prime_found6 = false;\n\
    \    let mut prime_found7 = false;\n    let mut prime_found8 = false;\n    let\
    \ mut prime_found9 = false;\n    let mut prime_found10 = false;\n    let mut prime_found11\
    \ = false;\n    let mut prime_found12 = false;\n    let mut prime_found13 = false;\n\
    \    let mut prime_found14 = false;\n    let mut prime_found15 = false;\n    let\
    \ mut prime_found16 = false;\n    let mut prime_found17 = false;\n    let mut\
    \ prime_found18 = false;\n    let mut prime_found19 = false;\n    let mut prime_found20\
    \ = false;\n    let mut prime_found21 = false;\n    let mut prime_found22 = false;\n\
    \    let mut prime_found23 = false;\n    let mut prime_found24 = false;\n    let\
    \ mut prime_found25 = false;\n    let mut prime_found26 = false;\n    let mut\
    \ prime_found27 = false;\n    let mut prime_found28 = false;\n    let mut prime_found29\
    \ = false;\n    let mut prime_found30 = false;\n    let mut prime_found31 = false;\n\
    \    let mut prime_found32 = false;\n    let mut prime_found33 = false;\n    let\
    \ mut prime_found34 = false;\n    let mut prime_found35 = false;\n    let mut\
    \ prime_found36 = false;\n    let mut prime_found37 = false;\n    let mut prime_found38\
    \ = false;\n    let mut prime_found39 = false;\n    let mut prime_found40 = false;\n\
    \    let mut prime_found41 = false;\n    let mut prime_found42 = false;\n    let\
    \ mut prime_found43 = false;\n    let mut prime_found44 = false;\n    let mut\
    \ prime_found45 = false;\n    let mut prime_found46 = false;\n    let mut prime_found47\
    \ = false;\n    let mut prime_found48 = false;\n    let mut prime_found49 = false;\n\
    \    let mut prime_found50 = false;\n    let mut prime_found51 = false;\n    let\
    \ mut prime_found52 = false;\n    let \n}\n\nfn main() {\n    let candidate =\
    \ hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp1gg7z39r.rs:74:1\n  \
    \ |\n74 | }\n   | ^ expected pattern\n\nerror[E0599]: no method named `to_chars`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmp1gg7z39r.rs:19:38\n\
    \   |\n19 |     let mut digits: Vec<isize> = num.to_chars().collect();\n   | \
    \                                     ^^^^^^^^ method not found in `isize`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157,\
    \ 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241,\
    \ 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347,\
    \ 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439,\
    \ 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547,\
    \ 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,\
    \ 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751,\
    \ 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,\
    \ 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,\
    \ 983, 991, 997];\n    let mut num_digits = num.chars().map(|c| c.to_digit(16).unwrap()).collect::<Vec<_>>();\n\
    \    let mut num_digits_iter = num_digits.iter();\n    let mut num_digits_iter\
    \ = num_digits.iter();\n    let mut num_digits_iter = num_digits.iter();\n   \
    \ let mut num_digits_iter = num_digits.iter();\n    let mut num_digits_iter =\
    \ num_digits.iter();\n    let mut num_digits_iter = num_digits.iter();\n    let\
    \ mut num_digits_iter = num_digits.iter();\n    let mut num_digits_iter = num_digits.iter();\n\
    \    let mut num_digits_iter = num_digits.iter();\n    let mut num_digits_iter\
    \ = num_digits.iter();\n    let mut num_digits_iter = num_digits.iter();\n   \
    \ let mut num_digits_iter = num_digits.iter();\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpntbp59ca.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut digits = num.chars().collect::<Vec<_>>();\n\
    \    let mut prime_digits = vec![false; 16];\n    let mut prime_digits_count =\
    \ vec![0; 16];\n    let mut prime_digits_count_index = 0;\n    let mut prime_digits_count_index2\
    \ = 0;\n    let mut prime_digits_count_index3 = 0;\n    let mut prime_digits_count_index4\
    \ = 0;\n    let mut prime_digits_count_index5 = 0;\n    let mut prime_digits_count_index6\
    \ = 0;\n    let mut prime_digits_count_index7 = 0;\n    let mut prime_digits_count_index8\
    \ = 0;\n    let mut prime_digits_count_index9 = 0;\n    let mut prime_digits_count_index10\
    \ = 0;\n    let mut prime_digits_count_index11 = 0;\n    let mut prime_digits_count_index12\
    \ = 0;\n    let mut prime_digits_count_index13 = 0;\n    let mut prime_digits_count_index14\
    \ = 0;\n    let mut prime_digits_count_index15 = 0;\n    let mut prime_digits_count_index16\
    \ = 0;\n    let mut prime_digits_count_index17 = 0;\n    let mut prime_digits_count_index18\
    \ = 0;\n    let mut prime_digits_count_index19 = 0;\n    let mut prime_digits_count_index20\
    \ = 0;\n    let mut prime_digits_count_index21 = 0;\n    let mut prime_digits_count_index22\
    \ = 0;\n    let mut prime_digits_count_index23 = 0;\n    let mut prime_digits_count_index24\
    \ = 0;\n    let mut prime_digits_count_index25 = 0;\n    let mut prime_digits_count_index26\
    \ = 0;\n    let mut prime_digits_count_index27 = 0;\n    let mut prime_digits_count_index28\
    \ = 0;\n    let mut prime_digits_count_index29 = 0;\n    let mut prime_digits_count_index30\
    \ = 0;\n    let mut prime_digits_count_index31 = 0;\n    let mut prime_digits_count_index32\
    \ = 0;\n    let mut prime_digits_count_index33 = 0;\n    let mut prime_digits_count_index34\
    \ = 0;\n    let mut prime_digits_count_index35 = 0;\n    let mut prime_digits_count_index36\
    \ = 0;\n    let mut prime_digits_count_index37 = 0;\n    let mut prime_digits_count_index38\
    \ = 0;\n    let mut prime_digits_count_index\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoxsdg8ix.rs:60:37\n   |\n\
    60 |     let mut prime_digits_count_index\n   |                              \
    \       ^ help: add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoxsdg8ix.rs:17:28\n   |\n17 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: isize = 0;\n    let mut num_digits: isize = 0;\n\
    \    let mut num_primes: isize = 0;\n    let mut num_primes_digits: isize = 0;\n\
    \    let mut num_primes_digits_2: isize = 0;\n    let mut num_primes_digits_3:\
    \ isize = 0;\n    let mut num_primes_digits_4: isize = 0;\n    let mut num_primes_digits_5:\
    \ isize = 0;\n    let mut num_primes_digits_6: isize = 0;\n    let mut num_primes_digits_7:\
    \ isize = 0;\n    let mut num_primes_digits_8: isize = 0;\n    let mut num_primes_digits_9:\
    \ isize = 0;\n    let mut num_primes_digits_10: isize = 0;\n    let mut num_primes_digits_11:\
    \ isize = 0;\n    let mut num_primes_digits_12: isize = 0;\n    let mut num_primes_digits_13:\
    \ isize = 0;\n    let mut num_primes_digits_14: isize = 0;\n    let mut num_primes_digits_15:\
    \ isize = 0;\n    let mut num_primes_digits_16: isize = 0;\n    let mut num_primes_digits_17:\
    \ isize = 0;\n    let mut num_primes_digits_18: isize = 0;\n    let mut num_primes_digits_19:\
    \ isize = 0;\n    let mut num_primes_digits_20: isize = 0;\n    let mut num_primes_digits_21:\
    \ isize = 0;\n    let mut num_primes_digits_22: isize = 0;\n    let mut num_primes_digits_23:\
    \ isize = 0;\n    let mut num_primes_digits_24: isize = 0;\n    let mut num_primes_digits_25:\
    \ isize = 0;\n    let mut num_primes_digits_26: isize = 0;\n    let mut num_primes_digits_27:\
    \ isize = 0;\n    let mut num_primes_digits_28: isize = 0;\n    let mut num_primes_digits_29:\
    \ isize = 0;\n    let mut num_primes_digits_30: isize = 0;\n    let mut num_primes_digits_31:\
    \ isize = 0;\n    let mut num_primes_digits_32: isize = 0;\n    let mut num_primes_digits_33:\
    \ isize = 0;\n    let mut num_primes_digits_34: isize = 0;\n    let mut num_primes_digits_35:\
    \ isize = 0;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjg3tnygs.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: isize = 0;\n    let mut num_digits: isize = 0;\n\
    \    let mut num_prime: isize = 0;\n    let mut num_prime_digits: isize = 0;\n\
    \    let mut num_prime_digits_2: isize = 0;\n    let mut num_prime_digits_3: isize\
    \ = 0;\n    let mut num_prime_digits_4: isize = 0;\n    let mut num_prime_digits_5:\
    \ isize = 0;\n    let mut num_prime_digits_6: isize = 0;\n    let mut num_prime_digits_7:\
    \ isize = 0;\n    let mut num_prime_digits_8: isize = 0;\n    let mut num_prime_digits_9:\
    \ isize = 0;\n    let mut num_prime_digits_10: isize = 0;\n    let mut num_prime_digits_11:\
    \ isize = 0;\n    let mut num_prime_digits_12: isize = 0;\n    let mut num_prime_digits_13:\
    \ isize = 0;\n    let mut num_prime_digits_14: isize = 0;\n    let mut num_prime_digits_15:\
    \ isize = 0;\n    let mut num_prime_digits_16: isize = 0;\n    let mut num_prime_digits_17:\
    \ isize = 0;\n    let mut num_prime_digits_18: isize = 0;\n    let mut num_prime_digits_19:\
    \ isize = 0;\n    let mut num_prime_digits_20: isize = 0;\n    let mut num_prime_digits_21:\
    \ isize = 0;\n    let mut num_prime_digits_22: isize = 0;\n    let mut num_prime_digits_23:\
    \ isize = 0;\n    let mut num_prime_digits_24: isize = 0;\n    let mut num_prime_digits_25:\
    \ isize = 0;\n    let mut num_prime_digits_26: isize = 0;\n    let mut num_prime_digits_27:\
    \ isize = 0;\n    let mut num_prime_digits_28: isize = 0;\n    let mut num_prime_digits_29:\
    \ isize = 0;\n    let mut num_prime_digits_30: isize = 0;\n    let mut num_prime_digits_31:\
    \ isize = 0;\n    let mut num_prime_digits_32: isize = 0;\n    let mut num_prime_digits_33:\
    \ isize = 0;\n    let mut num_prime_digits_34: isize = 0;\n    let mut num_prime_digits_35:\
    \ isize = 0;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptnaqquth.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len\n}\n\nfn main() {\n    let candidate =\
    \ hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp70ia16u3.rs:62:39\n   |\n\
    62 |     let mut prime_digits_len = num.len\n   |                            \
    \           ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0615]:\
    \ attempted to take value of method `len` on type `String`\n  --> /tmp/tmp70ia16u3.rs:62:36\n\
    \   |\n62 |     let mut prime_digits_len = num.len\n   |                     \
    \               ^^^ method, not a field\n   |\nhelp: use parentheses to call the\
    \ method\n   |\n62 |     let mut prime_digits_len = num.len()\n   |          \
    \                             ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp70ia16u3.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0615.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: isize = 0;\n    let mut num_str: String = num.to_string();\n\
    \    let mut num_str: Vec<String> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<String> = num_str.chars().collect();\n    let mut num_str: Vec<String> =\
    \ num_str.chars().collect();\n    let mut num_str: Vec<String> = num_str.chars().collect();\n\
    \    let mut num_str: Vec<String> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<String> = num_str.chars().collect();\n    let mut num_str: Vec<String> =\
    \ num_str.chars().collect();\n    let mut num_str: Vec<String> = num_str.chars().collect();\n\
    \    let mut num_str: Vec<String> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<String> = num_str.chars().collect();\n    let mut num_str: Vec<String> =\
    \ num_str.chars().collect();\n    let mut num_str: Vec<String> = num_str.chars().collect();\n\
    \    let mut num_str: Vec<String> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<String> = num_str.chars().collect();\n    let mut num_str: Vec<String> =\
    \ num_str.chars().collect();\n    let mut num_str: Vec<String> = num_str.chars().collect();\n\
    \    let mut num_str: Vec<String> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<String> = num_str.chars().collect();\n    let mut num_str: Vec<String> =\
    \ num_str.chars().collect();\n    let mut num_str: Vec<String> = num_str.chars().collect();\n\
    \    let mut num_str: Vec<String> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<String> = num_str.chars().collect();\n    let mut num_str: Vec<String> =\
    \ num_str.chars().collect();\n    let mut num_str: Vec<String> = num_str.chars().collect();\n\
    \    let mut num_str: Vec<String> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<String> = num_str.chars().collect();\n    let mut num_str: Vec<String> =\
    \ num_str.chars().collect();\n    let mut num_str\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpc0n462ml.rs:47:20\n   |\n\
    47 |     let mut num_str\n   |                    ^ help: add `;` here\n48 | }\n\
    \   | - unexpected token\n\nerror[E0599]: no method named `chars` found for struct\
    \ `Vec<String>` in the current scope\n  --> /tmp/tmpc0n462ml.rs:21:44\n   |\n\
    21 |     let mut num_str: Vec<String> = num_str.chars().collect();\n   |     \
    \                                       ^^^^^ method not found in `Vec<String>`\n\
    \nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpc0n462ml.rs:20:52\n     |\n20\
    \   |     let mut num_str: Vec<String> = num_str.chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `chars` found for struct\
    \ `Vec<String>` in the current scope\n  --> /tmp/tmpc0n462ml.rs:22:44\n   |\n\
    22 |     let mut num_str: Vec<String> = num_str.chars().collect();\n   |     \
    \                                       ^^^^^ method not found in `Vec<String>`\n\
    \nerror[E0599]: no method named `chars` found for struct `Vec<String>` in the\
    \ current scope\n  --> /tmp/tmpc0n462ml.rs:23:44\n   |\n23 |     let mut num_str:\
    \ Vec<String> = num_str.chars().collect();\n   |                             \
    \               ^^^^^ method not found in `Vec<String>`\n\nerror[E0599]: no method\
    \ named `chars` found for struct `Vec<String>` in the current scope\n  --> /tmp/tmpc0n462ml.rs:24:44\n\
    \   |\n24 |     let mut num_str: Vec<String> = num_str.chars().collect();\n  \
    \ |                                            ^^^^^ method not found in `Vec<String>`\n\
    \nerror[E0599]: no method named `chars` found for struct `Vec<String>` in the\
    \ current scope\n  --> /tmp/tmpc0n462ml.rs:25:44\n   |\n25 |     let mut num_str:\
    \ Vec<String> = num_str.chars().co"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: isize = 0;\n    let mut num_str: String = num.to_string();\n\
    \    let mut num_str: Vec<&str> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.to_vec();\n    let mut num_str: Vec<&str> = num_str.to_owned();\n\
    \    let mut num_str: Vec<&str> = num_str.to_owned();\n    let mut num_str: Vec<&str>\
    \ = num_str.to_owned();\n    let mut num_str: Vec<&str> = num_str.to_owned();\n\
    \    let mut num_str: Vec<&str> = num_str.to_owned();\n    let mut num_str: Vec<&str>\
    \ = num_str.to_owned();\n    let mut num_str: Vec<&str> = num_str.to_owned();\n\
    \    let mut num_str: Vec<&str> = num_str.to_owned();\n    let mut num_str: Vec<&str>\
    \ = num_str.to_owned();\n    let mut num_str: Vec<&str> = num_str.to_owned();\n\
    \    let mut num_str: Vec<&str> = num_str.to_owned();\n    let mut num_str: Vec<&str>\
    \ = num_str.to_owned();\n    let mut num_str: Vec<&str> = num_str.to_owned();\n\
    \    let mut num_str: Vec<&str> = num_str.to_owned();\n    let mut num_str: Vec<&str>\
    \ = num_str.to_owned();\n    let mut num_str: Vec<&str> = num_str.to_owned();\n\
    \    let mut num_str: Vec<&str> = num_str.to_owned();\n    let mut num_str: Vec<&str>\
    \ = num_str.to_owned();\n    let mut num_str: Vec<&str> = num_str.to_owned();\n\
    \    let mut num_str: Vec<&str> = num_str.to_owned();\n    let mut num_str: Vec<&str>\
    \ = num_str.to_owned();\n    let mut num_str: Vec<&str> = num_str.to_owned();\n\
    \    let mut num_str: Vec<&str> = num_str.to_owned();\n    let mut num_str: Vec<&str>\
    \ = num_str.to_owned\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnx5kcslt.rs:45:50\n   |\n\
    45 |     let mut num_str: Vec<&str> = num_str.to_owned\n   |                 \
    \                                 ^ help: add `;` here\n46 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpnx5kcslt.rs:20:50\n     |\n20\
    \   |     let mut num_str: Vec<&str> = num_str.chars().collect();\n     |    \
    \                                              ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0615]: attempted to take value of method `to_owned`\
    \ on type `Vec<&str>`\n  --> /tmp/tmpnx5kcslt.rs:45:42\n   |\n45 |     let mut\
    \ num_str: Vec<&str> = num_str.to_owned\n   |                                \
    \          ^^^^^^^^ method, not a field\n   |\nhelp: use parentheses to call the\
    \ method\n   |\n45 |     let mut num_str: Vec<&str> = num_str.to_owned()\n   |\
    \                                                  ++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnx5kcslt.rs:17:28\n   |\n17 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0615.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut nums = num.to_chars().collect::<Vec<_>>();\n    let\
    \ mut prime_count = 0;\n    let mut prime_digits = vec![2, 3];\n    let mut prime_digits_count\
    \ = vec![2, 3];\n    let mut prime_digits_count_2 = vec![2, 3];\n    let mut prime_digits_count_3\
    \ = vec![2, 3];\n    let mut prime_digits_count_4 = vec![2, 3];\n    let mut prime_digits_count_5\
    \ = vec![2, 3];\n    let mut prime_digits_count_6 = vec![2, 3];\n    let mut prime_digits_count_7\
    \ = vec![2, 3];\n    let mut prime_digits_count_8 = vec![2, 3];\n    let mut prime_digits_count_9\
    \ = vec![2, 3];\n    let mut prime_digits_count_10 = vec![2, 3];\n    let mut\
    \ prime_digits_count_11 = vec![2, 3];\n    let mut prime_digits_count_12 = vec![2,\
    \ 3];\n    let mut prime_digits_count_13 = vec![2, 3];\n    let mut prime_digits_count_14\
    \ = vec![2, 3];\n    let mut prime_digits_count_15 = vec![2, 3];\n    let mut\
    \ prime_digits_count_16 = vec![2, 3];\n    let mut prime_digits_count_17 = vec![2,\
    \ 3];\n    let mut prime_digits_count_18 = vec![2, 3];\n    let mut prime_digits_count_19\
    \ = vec![2, 3];\n    let mut prime_digits_count_20 = vec![2, 3];\n    let mut\
    \ prime_digits_count_21 = vec![2, 3];\n    let mut prime_digits_count_22 = vec![2,\
    \ 3];\n    let mut prime_digits_count_23 = vec![2, 3];\n    let mut prime_digits_count_24\
    \ = vec![2, 3];\n    let mut prime_digits_count_25 = vec![2, 3];\n    let mut\
    \ prime_digits_count_26 = vec![2, 3];\n    let mut prime_digits_count_27 = vec![2,\
    \ 3];\n    let mut prime_digits_count_28 = vec![2, 3];\n    let mut prime_digits_count_29\
    \ = vec![2, 3];\n    let mut prime_digits_count_30 = vec![2, 3];\n    let mut\
    \ prime_digits_count_\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7kv0w1p1.rs:51:32\n   |\n\
    51 |     let mut prime_digits_count_\n   |                                ^ help:\
    \ add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0599]: no method named\
    \ `to_chars` found for struct `String` in the current scope\n  --> /tmp/tmp7kv0w1p1.rs:18:24\n\
    \   |\n18 |     let mut nums = num.to_chars().collect::<Vec<_>>();\n   |     \
    \                   ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `chars`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7kv0w1p1.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut digits = num.chars().map(|c|\
    \ c as char).collect::<Vec<_>>();\n    let mut primes = vec![false; 10];\n   \
    \ let mut primes_counter = vec![0; 10];\n    let mut primes_counter2 = vec![0;\
    \ 10];\n    let mut primes_counter3 = vec![0; 10];\n    let mut primes_counter4\
    \ = vec![0; 10];\n    let mut primes_counter5 = vec![0; 10];\n    let mut primes_counter6\
    \ = vec![0; 10];\n    let mut primes_counter7 = vec![0; 10];\n    let mut primes_counter8\
    \ = vec![0; 10];\n    let mut primes_counter9 = vec![0; 10];\n    let mut primes_counter10\
    \ = vec![0; 10];\n    let mut primes_counter11 = vec![0; 10];\n    let mut primes_counter12\
    \ = vec![0; 10];\n    let mut primes_counter13 = vec![0; 10];\n    let mut primes_counter14\
    \ = vec![0; 10];\n    let mut primes_counter15 = vec![0; 10];\n    let mut primes_counter16\
    \ = vec![0; 10];\n    let mut primes_counter17 = vec![0; 10];\n    let mut primes_counter18\
    \ = vec![0; 10];\n    let mut primes_counter19 = vec![0; 10];\n    let mut primes_counter20\
    \ = vec![0; 10];\n    let mut primes_counter21 = vec![0; 10];\n    let mut primes_counter22\
    \ = vec![0; 10];\n    let mut primes_counter23 = vec![0; 10];\n    let mut primes_counter24\
    \ = vec![0; 10];\n    let mut primes_counter25 = vec![0; 10];\n    let mut primes_counter26\
    \ = vec![0; 10];\n    let mut primes_counter27 = vec![0; 10];\n    let mut primes_counter28\
    \ = vec![0; 10];\n    let mut primes_counter29 = vec![0; 10];\n    let mut primes_counter30\
    \ = vec![0; 10];\n    let mut primes_counter31 = vec![0; 10];\n    let mut primes_counter32\
    \ = vec![0; 10];\n    let mut primes_counter33 = vec![0; 10];\n    let mut primes_counter34\
    \ = vec![0; 10];\n    let mut primes_\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp128xuqbz.rs:55:20\n   |\n\
    55 |     let mut primes_\n   |                    ^ help: add `;` here\n56 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp128xuqbz.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num_digits = num.len();\n    let mut prime_count = 0;\n\
    \    let mut prime_digits = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n\n}\n\nfn main() {\n    let candidate = hex_key;\n  \
    \  assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfu54erye.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut num_digits = num.len();\n\
    \    let mut num_digits_squared = num_digits * num_digits;\n    let mut num_digits_cubed\
    \ = num_digits_squared * num_digits_squared;\n    let mut num_digits_cubed_squared\
    \ = num_digits_cubed * num_digits_cubed;\n    let mut num_digits_cubed_cubed_squared\
    \ = num_digits_cubed_squared * num_digits_cubed_squared;\n    let mut num_digits_cubed_cubed_cubed_squared\
    \ = num_digits_cubed_cubed_squared * num_digits_cubed_cubed_squared;\n    let\
    \ mut num_digits_cubed_cubed_cubed_cubed_squared = num_digits_cubed_cubed_cubed_squared\
    \ * num_digits_cubed_cubed_cubed_squared;\n    let mut num_digits_cubed_cubed_cubed_cubed_cubed_squared\
    \ = num_digits_cubed_cubed_cubed_cubed_squared * num_digits_cubed_cubed_cubed_cubed_squared;\n\
    \    let mut num_digits_cubed_cubed_cubed_cubed_cubed_cubed_squared = num_digits_cubed_cubed_cubed_cubed_cubed_squared\
    \ * num_digits_cubed_cubed_cubed_cubed_cubed_squared;\n    let mut num_digits_cubed_cubed_cubed_cubed_cubed_cubed_squared\
    \ = num_digits_cubed_cubed_cubed_cubed_cubed_cubed_squared * num_digits_cubed_cubed_cubed_cubed_cubed_squared;\n\
    \    let mut num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_squared = num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_squared\
    \ * num_digits_cubed_cubed_cubed_cubed_cubed_cubed_squared;\n    let mut num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_squared\
    \ = num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_squared * num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_squared;\n\
    \    let mut num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_squared\
    \ = num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1qu1tsli.rs:31:153\n   |\n\
    31 |     let mut num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_squared\
    \ = num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_\n   |  \
    \                                                                            \
    \                                                                           ^\
    \ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_squared` in\
    \ this scope\n  --> /tmp/tmp1qu1tsli.rs:29:76\n   |\n29 | ..._cubed_cubed_cubed_squared\
    \ = num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_squared * num_digits_cubed_cubed_cubed_cubed_cubed_c...\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `num_digits_cubed_cubed_cubed_cubed_cubed_cubed_squared`\n\
    \nerror[E0425]: cannot find value `num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_squared`\
    \ in this scope\n  --> /tmp/tmp1qu1tsli.rs:30:82\n   |\n30 | ...ubed_cubed_cubed_squared\
    \ = num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_squared * num_digits_cubed_cubed_cubed_cubed_cub...\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_squared`\n\
    \nerror[E0425]: cannot find value `num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_`\
    \ in this scope\n  --> /tmp/tmp1qu1tsli.rs:31:88\n   |\n31 | ...ubed_cubed_cubed_squared\
    \ = num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_\n   |  \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `num_digits_cubed_cubed_cubed_cubed_cubed_cubed_cubed_cubed_squared`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1qu1tsli.rs:17:28\n   |\n17 |\
    \ fn hex_key(num: String) -> isize {\n   |    -------"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len\n}\n\nfn main() {\n    let candidate =\
    \ hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8viti3of.rs:62:39\n   |\n\
    62 |     let mut prime_digits_len = num.len\n   |                            \
    \           ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0615]:\
    \ attempted to take value of method `len` on type `String`\n  --> /tmp/tmp8viti3of.rs:62:36\n\
    \   |\n62 |     let mut prime_digits_len = num.len\n   |                     \
    \               ^^^ method, not a field\n   |\nhelp: use parentheses to call the\
    \ method\n   |\n62 |     let mut prime_digits_len = num.len()\n   |          \
    \                             ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8viti3of.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0615.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4ermy_s9.rs:55:18\n   |\n\
    55 |     let mut prime\n   |                  ^ help: add `;` here\n56 | }\n \
    \  | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmp4ermy_s9.rs:20:32\n   |\n20 |     let mut prime_digits_set\
    \ = HashSet::new();\n   |                                ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp4ermy_s9.rs:21:32\n   |\n21 |     let mut prime_digits_set = HashSet::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp4ermy_s9.rs:22:32\n   |\n22 |     let mut prime_digits_set = HashSet::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp4ermy_s9.rs:23:32\n   |\n23 |     let mut prime_digits_set = HashSet::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp4ermy_s9.rs:24:32\n   |\n24 |     let mut prime_digits_set = HashSet::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp4ermy_s9.rs:25:32\n   |\n25 |     let mut prime_digits_set = HashSet::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E043"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut digits = num.chars().collect::<Vec<_>>();\n\
    \    let mut prime_digits = vec![false; 10];\n    let mut prime_digits_count =\
    \ vec![0; 10];\n    let mut prime_digits_index = vec![0; 10];\n    let mut prime_digits_index_count\
    \ = vec![0; 10];\n    let mut prime_digits_index_index = 0;\n    let mut prime_digits_index_index_count\
    \ = 0;\n    let mut prime_digits_index_index_index = 0;\n    let mut prime_digits_index_index_index_count\
    \ = 0;\n    let mut prime_digits_index_index_index_index = 0;\n    let mut prime_digits_index_index_index_index_count\
    \ = 0;\n    let mut prime_digits_index_index_index_index_index = 0;\n    let mut\
    \ prime_digits_index_index_index_index_count = 0;\n    let mut prime_digits_index_index_index_index_index\
    \ = 0;\n    let mut prime_digits_index_index_index_index_index_count = 0;\n  \
    \  let mut prime_digits_index_index_index_index_index_index = 0;\n    let mut\
    \ prime_digits_index_index_index_index_index_count = 0;\n    let mut prime_digits_index_index_index_index_index_index\
    \ = 0;\n    let mut prime_digits_index_index_index_index_index_index_count = 0;\n\
    \    let mut prime_digits_index_index_index_index_index_index_index = 0;\n   \
    \ let mut prime_digits_index_index_index_index_index_index_count = 0;\n    let\
    \ mut prime_digits_index_index_index_index_index_index_index = 0;\n    let mut\
    \ prime_digits_index_index_index_index_index_index_index_count = 0;\n    let mut\
    \ prime_digits_index_index_index_index_index_index_index_index = 0;\n    let mut\
    \ prime_digits_index_index_index_index_index_index_index_count = 0;\n    let mut\
    \ prime_digits_index_index_index_index_index_index_index_index = 0;\n    let mut\
    \ prime_digits_index_index_index_index_index_index_index_index_count = 0;\n  \
    \  let mut prime_digits_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut prime_digits_index_index_index_index_index_index_index_index_index_count\
    \ = 0;\n    let mut prime_digits_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut prime_digits_index_index_index_index_index_index_index_index_index_count\
    \ = 0;\n    let mut prime_digits_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut prime_digits_index_index_index_index_index_index_index_index_index_index_count\
    \ = 0;\n    let mut prime\n}\n\nfn main() {\n    let candidate = hex_key;\n  \
    \  assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3yvhdul1.rs:52:18\n   |\n\
    52 |     let mut prime\n   |                  ^ help: add `;` here\n53 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3yvhdul1.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3];\n    let mut prime_counter: usize =\
    \ 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3: usize\
    \ = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5: usize\
    \ = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7: usize\
    \ = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9: usize\
    \ = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: usize = 0;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpap_gy1xy.rs:60:11\n   |\n\
    60 |     let mu\n   |           ^ help: add `;` here\n61 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpap_gy1xy.rs:18:55\n     |\n18\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpap_gy1xy.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_vec();\n    let mut prime_count\
    \ = 0;\n    let mut prime_digit = 0;\n    let mut prime_digit_count = 0;\n   \
    \ let mut prime_digit_index = 0;\n    let mut prime_digit_index2 = 0;\n    let\
    \ mut prime_digit_index3 = 0;\n    let mut prime_digit_index4 = 0;\n    let mut\
    \ prime_digit_index5 = 0;\n    let mut prime_digit_index6 = 0;\n    let mut prime_digit_index7\
    \ = 0;\n    let mut prime_digit_index8 = 0;\n    let mut prime_digit_index9 =\
    \ 0;\n    let mut prime_digit_index10 = 0;\n    let mut prime_digit_index11 =\
    \ 0;\n    let mut prime_digit_index12 = 0;\n    let mut prime_digit_index13 =\
    \ 0;\n    let mut prime_digit_index14 = 0;\n    let mut prime_digit_index15 =\
    \ 0;\n    let mut prime_digit_index16 = 0;\n    let mut prime_digit_index17 =\
    \ 0;\n    let mut prime_digit_index18 = 0;\n    let mut prime_digit_index19 =\
    \ 0;\n    let mut prime_digit_index20 = 0;\n    let mut prime_digit_index21 =\
    \ 0;\n    let mut prime_digit_index22 = 0;\n    let mut prime_digit_index23 =\
    \ 0;\n    let mut prime_digit_index24 = 0;\n    let mut prime_digit_index25 =\
    \ 0;\n    let mut prime_digit_index26 = 0;\n    let mut prime_digit_index27 =\
    \ 0;\n    let mut prime_digit_index28 = 0;\n    let mut prime_digit_index29 =\
    \ 0;\n    let mut prime_digit_index30 = 0;\n    let mut prime_digit_index31 =\
    \ 0;\n    let mut prime_digit_index32 = 0;\n    let mut prime_digit_index33 =\
    \ 0;\n    let mut prime_digit_index34 = 0;\n    let mut prime_digit_index35 =\
    \ 0;\n    let mut prime_digit_index36 = 0;\n    let mut prime_digit_index37 =\
    \ 0;\n    let mut prime_digit_index38 = 0;\n    let mut prime_digit_index39 =\
    \ 0;\n    let mut prime_digit_index40 = 0;\n    let mut prime_digit_index41 =\
    \ 0;\n    let mut prime_digit_index42 = 0;\n    let mut prime_digit_index43 =\
    \ 0;\n    let mut prime_digit_index44 = 0;\n    let mut prime_digit_index45 =\
    \ 0;\n    let mut prime_digit_index46 = 0;\n    let mut prime_digit_index47 =\
    \ 0;\n    let mut prime_digit_index48 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_vec` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp6tdt2vzs.rs:18:32\n   |\n18 |     let mut num:\
    \ Vec<u8> = num.to_vec();\n   |                                ^^^^^^ method not\
    \ found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6tdt2vzs.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpml_ejxqc.rs:54:1\n  \
    \ |\n54 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmpml_ejxqc.rs:20:32\n   |\n20 |     let\
    \ mut prime_digits_set = HashSet::new();\n   |                               \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpml_ejxqc.rs:21:32\n   |\n21\
    \ |     let mut prime_digits_set = HashSet::new();\n   |                     \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpml_ejxqc.rs:22:32\n\
    \   |\n22 |     let mut prime_digits_set = HashSet::new();\n   |             \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpml_ejxqc.rs:23:32\n\
    \   |\n23 |     let mut prime_digits_set = HashSet::new();\n   |             \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpml_ejxqc.rs:24:32\n\
    \   |\n24 |     let mut prime_digits_set = HashSet::new();\n   |             \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpml_ejxqc.rs:25:32\n\
    \   |\n25 |     let mut prime_digits_set = HashSet::new();\n   |             \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17];\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv0pxdu05.rs:54:48\n   |\n\
    54 |     let mut prime_digits_len = prime_digits.len\n   |                   \
    \                             ^ help: add `;` here\n55 | }\n   | - unexpected\
    \ token\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpv0pxdu05.rs:54:45\n\
    \   |\n54 |     let mut prime_digits_len = prime_digits.len\n   |            \
    \                                 ^^^ private field\n   |\nhelp: a method `len`\
    \ also exists, call it with parentheses\n   |\n54 |     let mut prime_digits_len\
    \ = prime_digits.len()\n   |                                                ++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv0pxdu05.rs:17:28\n   |\n17 |\
    \ fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0616.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: isize = 0;\n    let mut digits: Vec<isize> = num.to_chars().collect();\n\
    \    for digit in digits {\n        if digit == 'A' || digit == 'B' || digit ==\
    \ 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n            num = num\
    \ * 16 + digit as isize;\n        } else {\n            num = num * 10 + digit\
    \ as isize;\n        }\n    }\n    return num;\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_chars` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpo5sd9hiw.rs:19:38\n   |\n19 |     let mut digits:\
    \ Vec<isize> = num.to_chars().collect();\n   |                               \
    \       ^^^^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo5sd9hiw.rs:21:21\n   |\n21 |         if digit == 'A' || digit\
    \ == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n \
    \  |                     ^^^ expected `isize`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo5sd9hiw.rs:21:37\n   |\n21 |         if digit == 'A' ||\
    \ digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F'\
    \ {\n   |                                     ^^^ expected `isize`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo5sd9hiw.rs:21:53\n   |\n21 |\
    \         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit\
    \ == 'E' || digit == 'F' {\n   |                                             \
    \        ^^^ expected `isize`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo5sd9hiw.rs:21:69\n   |\n21 |         if digit == 'A' || digit\
    \ == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n \
    \  |                                                                     ^^^ expected\
    \ `isize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo5sd9hiw.rs:21:85\n\
    \   |\n21 |         if digit == 'A' || digit == 'B' || digit == 'C' || digit ==\
    \ 'D' || digit == 'E' || digit == 'F' {\n   |                                \
    \                                                     ^^^ expected `isize`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo5sd9hiw.rs:21:101\n\
    \   |\n21 |         if digit == 'A' || digit == 'B' || digit == 'C' || digit ==\
    \ 'D' || digit == 'E' || digit == 'F' {\n   |                                \
    \                                                                     ^^^ expected\
    \ `isize`, found `char`\n\nerror: aborting due to 7 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor m"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: isize = num.len();\n    let mut prime: isize =\
    \ 0;\n    let mut prime_found = false;\n    let mut prime_found2 = false;\n  \
    \  let mut prime_found3 = false;\n    let mut prime_found4 = false;\n    let mut\
    \ prime_found5 = false;\n    let mut prime_found6 = false;\n    let mut prime_found7\
    \ = false;\n    let mut prime_found8 = false;\n    let mut prime_found9 = false;\n\
    \    let mut prime_found10 = false;\n    let mut prime_found11 = false;\n    let\
    \ mut prime_found12 = false;\n    let mut prime_found13 = false;\n    let mut\
    \ prime_found14 = false;\n    let mut prime_found15 = false;\n    let mut prime_found16\
    \ = false;\n    let mut prime_found17 = false;\n    let mut prime_found18 = false;\n\
    \    let mut prime_found19 = false;\n    let mut prime_found20 = false;\n    let\
    \ mut prime_found21 = false;\n    let mut prime_found22 = false;\n    let mut\
    \ prime_found23 = false;\n    let mut prime_found24 = false;\n    let mut prime_found25\
    \ = false;\n    let mut prime_found26 = false;\n    let mut prime_found27 = false;\n\
    \    let mut prime_found28 = false;\n    let mut prime_found29 = false;\n    let\
    \ mut prime_found30 = false;\n    let mut prime_found31 = false;\n    let mut\
    \ prime_found32 = false;\n    let mut prime_found33 = false;\n    let mut prime_found34\
    \ = false;\n    let mut prime_found35 = false;\n    let mut prime_found36 = false;\n\
    \    let mut prime_found37 = false;\n    let mut prime_found38 = false;\n    let\
    \ mut prime_found39 = false;\n    let mut prime_found40 = false;\n    let mut\
    \ prime_found41 = false;\n    let mut prime_found42 = false;\n    let mut prime_found43\
    \ = false;\n    let mut prime_found44 = false;\n    let mut prime_found45 = false;\n\
    \    let mut prime_found46 = false;\n    let mut prime_found47 = false;\n    let\
    \ mut prime_found48 = false;\n    let mut prime_found49 = false;\n    let mut\
    \ prime_found50 = false;\n    let mut prime_found51 = false;\n    let mut prime_found52\
    \ = false;\n    let mut prime_found53 = false;\n    let mut prime_found\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwas7dg5z.rs:73:24\n   |\n\
    73 |     let mut prime_found\n   |                        ^ help: add `;` here\n\
    74 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwas7dg5z.rs:18:26\n\
    \   |\n18 |     let mut num: isize = num.len();\n   |                  ----- \
    \  ^^^^^^^^^ expected `isize`, found `usize`\n   |                  |\n   |  \
    \                expected due to this\n   |\nhelp: you can convert a `usize` to\
    \ an `isize` and panic if the converted value doesn't fit\n   |\n18 |     let\
    \ mut num: isize = num.len().try_into().unwrap();\n   |                      \
    \             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwas7dg5z.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count_max\
    \ = vec![];\n    let mut prime_digits_count_min = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_index2\
    \ = vec![];\n    let mut prime_digits_count_min_index2 = vec![];\n    let mut\
    \ prime_digits_count_max_index3 = vec![];\n    let mut prime_digits_count_min_index3\
    \ = vec![];\n    let mut prime_digits_count_max_index4 = vec![];\n    let mut\
    \ prime_digits_count_min_index4 = vec![];\n    let mut prime_digits_count_max_index5\
    \ = vec![];\n    let mut prime_digits_count_min_index5 = vec![];\n    let mut\
    \ prime_digits_count_max_index6 = vec![];\n    let mut prime_digits_count_min_index6\
    \ = vec![];\n    let mut prime_digits_count_max_index7 = vec![];\n    let mut\
    \ prime_digits_count_min_index7 = vec![];\n    let mut prime_digits_count_max_index8\
    \ = vec![];\n    let mut prime_digits_count_min_index8 = vec![];\n    let mut\
    \ prime_digits_count_max_index9 = vec![];\n    let mut prime_digits_count_min_index9\
    \ = vec![];\n    let mut prime_digits_count_max_index10 = vec![];\n    let mut\
    \ prime_digits_count_min_index10 = vec![];\n    let mut prime_digits_count_max_index11\
    \ = vec![];\n    let mut prime_digits_count_min_index11 = vec![];\n    let mut\
    \ prime_digits_count_max_index12 = vec![];\n    let mut prime_digits_count_min_index12\
    \ = vec![];\n    let mut prime_digits_count_max_index13 = vec![];\n    let mut\
    \ prime_digits_count_min_index13 = vec![];\n    let mut prime_digits_count_max_index14\
    \ = vec![];\n    let mut prime_digits_count_min_index14 = vec![];\n    let mut\
    \ prime_digits_count_max_index15 = vec![];\n    let mut prime_digits_count_min_index15\
    \ = vec![];\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpewq4p5d1.rs:53:11\n   |\n\
    53 |     let mu\n   |           ^ help: add `;` here\n54 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpewq4p5d1.rs:17:28\n \
    \  |\n17 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut\
    \ primes = vec![];\n    let mut primes_count = vec![];\n    let mut primes_count_index\
    \ = vec![];\n    let mut primes_count_index_max = vec![];\n    let mut primes_count_index_max_index\
    \ = vec![];\n    let mut primes_count_index_max_value = vec![];\n    let mut primes_count_index_max_value_index\
    \ = vec![];\n    let mut primes_count_index_max_value_max = vec![];\n    let mut\
    \ primes_count_index_max_value_max_index = vec![];\n    let mut primes_count_index_max_value_max_value\
    \ = vec![];\n    let mut primes_count_index_max_value_max_value_index = vec![];\n\
    \    let mut primes_count_index_max_value_max_value_max = vec![];\n    let mut\
    \ primes_count_index_max_value_max_value_max_index = vec![];\n    let mut primes_count_index_max_value_max_value_max_value\
    \ = vec![];\n    let mut primes_count_index_max_value_max_value_max_value_index\
    \ = vec![];\n    let mut primes_count_index_max_value_max_value_max_value_max\
    \ = vec![];\n    let mut primes_count_index_max_value_max_value_max_value_max_index\
    \ = vec![];\n    let mut primes_count_index_max_value_max_value_max_value_max_value\
    \ = vec![];\n    let mut primes_count_index_max_value_max_value_max_value_max_value_index\
    \ = vec![];\n    let mut primes_count_index_max_value_max_value_max_value_max_value_max\
    \ = vec![];\n    let mut primes_count_index_max_value_max_value_max_value_max_value_max_index\
    \ = vec![];\n    let mut primes_count_index_max_value_max_value_max_value_max_value_max_value\
    \ = vec![];\n    let mut primes_count_index_max_value_max_value_max_value_max_value_max_value_index\
    \ = vec![];\n    let mut primes_count_index_max_value_max_value_max_value_max_value_max_value_max\
    \ = vec![];\n    let mut primes_count_index_max_value_max_value_max_value_max_value_max_value_max_index\
    \ = vec![];\n    let mut primes_count_index_max_value_max_value_max_value_max_value_max_value_max_value\
    \ = vec![];\n    let mut primes_count_index_max_value_max_value_max_value_max_value_max_value_max_value_index\
    \ = vec![];\n    let mut primes_count_index_max_value_max_value_max_value_max_value_max_value_max_value_max\
    \ = vec![];\n    let mut primes_count_index_max_value_\n}\n\nfn main() {\n   \
    \ let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp45dmfdd1.rs:47:42\n   |\n\
    47 |     let mut primes_count_index_max_value_\n   |                         \
    \                 ^ help: add `;` here\n48 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp45dmfdd1.rs:17:28\n   |\n17 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_len = num.len\n}\n\nfn main() {\n    let candidate =\
    \ hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpappriwsa.rs:62:39\n   |\n\
    62 |     let mut prime_digits_len = num.len\n   |                            \
    \           ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0615]:\
    \ attempted to take value of method `len` on type `String`\n  --> /tmp/tmpappriwsa.rs:62:36\n\
    \   |\n62 |     let mut prime_digits_len = num.len\n   |                     \
    \               ^^^ method, not a field\n   |\nhelp: use parentheses to call the\
    \ method\n   |\n62 |     let mut prime_digits_len = num.len()\n   |          \
    \                             ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpappriwsa.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0615.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut prime_counter = 0;\n    let\
    \ mut prime_digits = vec![];\n    let mut prime_digits_counter = 0;\n    let mut\
    \ prime_digits_counter2 = 0;\n    let mut prime_digits_counter3 = 0;\n    let\
    \ mut prime_digits_counter4 = 0;\n    let mut prime_digits_counter5 = 0;\n   \
    \ let mut prime_digits_counter6 = 0;\n    let mut prime_digits_counter7 = 0;\n\
    \    let mut prime_digits_counter8 = 0;\n    let mut prime_digits_counter9 = 0;\n\
    \    let mut prime_digits_counter10 = 0;\n    let mut prime_digits_counter11 =\
    \ 0;\n    let mut prime_digits_counter12 = 0;\n    let mut prime_digits_counter13\
    \ = 0;\n    let mut prime_digits_counter14 = 0;\n    let mut prime_digits_counter15\
    \ = 0;\n    let mut prime_digits_counter16 = 0;\n    let mut prime_digits_counter17\
    \ = 0;\n    let mut prime_digits_counter18 = 0;\n    let mut prime_digits_counter19\
    \ = 0;\n    let mut prime_digits_counter20 = 0;\n    let mut prime_digits_counter21\
    \ = 0;\n    let mut prime_digits_counter22 = 0;\n    let mut prime_digits_counter23\
    \ = 0;\n    let mut prime_digits_counter24 = 0;\n    let mut prime_digits_counter25\
    \ = 0;\n    let mut prime_digits_counter26 = 0;\n    let mut prime_digits_counter27\
    \ = 0;\n    let mut prime_digits_counter28 = 0;\n    let mut prime_digits_counter29\
    \ = 0;\n    let mut prime_digits_counter30 = 0;\n    let mut prime_digits_counter31\
    \ = 0;\n    let mut prime_digits_counter32 = 0;\n    let mut prime_digits_counter33\
    \ = 0;\n    let mut prime_digits_counter34 = 0;\n    let mut prime_digits_counter35\
    \ = 0;\n    let mut prime_digits_counter36 = 0;\n    let mut prime_digits_counter37\
    \ = 0;\n    let mut prime_digits_counter38 = 0;\n    let mut prime_digits_counter39\
    \ = 0;\n    let mut prime_digits_counter40 = 0;\n    let mut prime_digits_counter41\
    \ = 0;\n    let mut prime_digits_counter42 = 0;\n    let mut prime_digits_counter43\
    \ = 0;\n    let mut prime_digits_counter44 = 0;\n    let mut prime_digits_counter\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpc854fbms.rs:65:33\n   |\n\
    65 |     let mut prime_digits_counter\n   |                                 ^\
    \ help: add `;` here\n66 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc854fbms.rs:17:28\n   |\n17 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut nums = num.to_chars().collect::<Vec<_>>();\n    let\
    \ mut primes = vec![false; 26];\n    let mut primes_counter = 0;\n    let mut\
    \ primes_counter2 = 0;\n    let mut primes_counter3 = 0;\n    let mut primes_counter4\
    \ = 0;\n    let mut primes_counter5 = 0;\n    let mut primes_counter6 = 0;\n \
    \   let mut primes_counter7 = 0;\n    let mut primes_counter8 = 0;\n    let mut\
    \ primes_counter9 = 0;\n    let mut primes_counter10 = 0;\n    let mut primes_counter11\
    \ = 0;\n    let mut primes_counter12 = 0;\n    let mut primes_counter13 = 0;\n\
    \    let mut primes_counter14 = 0;\n    let mut primes_counter15 = 0;\n    let\
    \ mut primes_counter16 = 0;\n    let mut primes_counter17 = 0;\n    let mut primes_counter18\
    \ = 0;\n    let mut primes_counter19 = 0;\n    let mut primes_counter20 = 0;\n\
    \    let mut primes_counter21 = 0;\n    let mut primes_counter22 = 0;\n    let\
    \ mut primes_counter23 = 0;\n    let mut primes_counter24 = 0;\n    let mut primes_counter25\
    \ = 0;\n    let mut primes_counter26 = 0;\n    let mut primes_counter27 = 0;\n\
    \    let mut primes_counter28 = 0;\n    let mut primes_counter29 = 0;\n    let\
    \ mut primes_counter30 = 0;\n    let mut primes_counter31 = 0;\n    let mut primes_counter32\
    \ = 0;\n    let mut primes_counter33 = 0;\n    let mut primes_counter34 = 0;\n\
    \    let mut primes_counter35 = 0;\n    let mut primes_counter36 = 0;\n    let\
    \ mut primes_counter37 = 0;\n    let mut primes_counter38 = 0;\n    let mut primes_counter39\
    \ = 0;\n    let mut primes_counter40 = 0;\n    let mut primes_counter41 = 0;\n\
    \    let mut primes_counter42 = 0;\n    let mut primes_counter43 = 0;\n    let\
    \ mut primes_counter44 = 0;\n    let mut primes_counter45 = 0;\n    let mut primes_counter46\
    \ = 0;\n    let mut primes_counter47 = 0;\n    let mut primes_counter48 = 0;\n\
    \    let mut primes_counter49 = 0;\n    let mut primes_counter50 = 0;\n    let\
    \ mut primes_counter51 = 0;\n    let mut primes_counter52 = 0;\n    let mut primes_counter53\
    \ = 0;\n    let mut primes_counter54 = 0;\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwcvy1zfe.rs:74:11\n   |\n\
    74 |     let mu\n   |           ^ help: add `;` here\n75 | }\n   | - unexpected\
    \ token\n\nerror[E0599]: no method named `to_chars` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpwcvy1zfe.rs:18:24\n   |\n18 |     let mut\
    \ nums = num.to_chars().collect::<Vec<_>>();\n   |                        ^^^^^^^^\
    \ help: there is an associated function with a similar name: `chars`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwcvy1zfe.rs:17:28\n   |\n17 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num_digits = num.chars().count();\n    let mut prime_count\
    \ = 0;\n    let mut prime_digits = vec![];\n    let mut prime_digit = vec![];\n\
    \    let mut prime_digit_count = 1;\n    let mut prime_digit_index = 0;\n    let\
    \ mut prime_digit_value = 1;\n    let mut prime_digit_index2 = 0;\n    let mut\
    \ prime_digit_value2 = 1;\n    let mut prime_digit_index3 = 0;\n    let mut prime_digit_value3\
    \ = 1;\n    let mut prime_digit_index4 = 0;\n    let mut prime_digit_value4 =\
    \ 1;\n    let mut prime_digit_index5 = 0;\n    let mut prime_digit_value5 = 1;\n\
    \    let mut prime_digit_index6 = 0;\n    let mut prime_digit_value6 = 1;\n  \
    \  let mut prime_digit_index7 = 0;\n    let mut prime_digit_value7 = 1;\n    let\
    \ mut prime_digit_index8 = 0;\n    let mut prime_digit_value8 = 1;\n    let mut\
    \ prime_digit_index9 = 0;\n    let mut prime_digit_value9 = 1;\n    let mut prime_digit_index10\
    \ = 0;\n    let mut prime_digit_value10 = 1;\n    let mut prime_digit_index11\
    \ = 0;\n    let mut prime_digit_value11 = 1;\n    let mut prime_digit_index12\
    \ = 0;\n    let mut prime_digit_value12 = 1;\n    let mut prime_digit_index13\
    \ = 0;\n    let mut prime_digit_value13 = 1;\n    let mut prime_digit_index14\
    \ = 0;\n    let mut prime_digit_value14 = 1;\n    let mut prime_digit_index15\
    \ = 0;\n    let mut prime_digit_value15 = 1;\n    let mut prime_digit_index16\
    \ = 0;\n    let mut prime_digit_value16 = 1;\n    let mut prime_digit_index17\
    \ = 0;\n    let mut prime_digit_value17 = 1;\n    let mut prime_digit_index18\
    \ = 0;\n    let mut prime_digit_value18 = 1;\n    let mut prime_digit_index19\
    \ = 0;\n    let mut prime_digit_value19 = 1;\n    let mut prime_digit_index20\
    \ = 0;\n    let mut prime_digit_value20 = 1;\n    let mut prime_digit_index21\
    \ = 0;\n    let mut prime_digit_value21 = 1;\n    let mut prime_digit_index22\
    \ = 0;\n    let mut prime_digit_value22 = 1;\n    let mut prime_digit_index23\
    \ = 0;\n    let mut prime_digit_value23 = 1;\n    let mut prime_digit_index24\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphoe6rwwe.rs:69:32\n   |\n\
    69 |     let mut prime_digit_index24\n   |                                ^ help:\
    \ add `;` here\n70 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphoe6rwwe.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_vec();\n    let mut prime_digits\
    \ = vec![false; 9];\n    let mut prime_digits_counter = 0;\n    let mut prime_digits_counter2\
    \ = 0;\n    let mut prime_digits_counter3 = 0;\n    let mut prime_digits_counter4\
    \ = 0;\n    let mut prime_digits_counter5 = 0;\n    let mut prime_digits_counter6\
    \ = 0;\n    let mut prime_digits_counter7 = 0;\n    let mut prime_digits_counter8\
    \ = 0;\n    let mut prime_digits_counter9 = 0;\n    let mut prime_digits_counter10\
    \ = 0;\n    let mut prime_digits_counter11 = 0;\n    let mut prime_digits_counter12\
    \ = 0;\n    let mut prime_digits_counter13 = 0;\n    let mut prime_digits_counter14\
    \ = 0;\n    let mut prime_digits_counter15 = 0;\n    let mut prime_digits_counter16\
    \ = 0;\n    let mut prime_digits_counter17 = 0;\n    let mut prime_digits_counter18\
    \ = 0;\n    let mut prime_digits_counter19 = 0;\n    let mut prime_digits_counter20\
    \ = 0;\n    let mut prime_digits_counter21 = 0;\n    let mut prime_digits_counter22\
    \ = 0;\n    let mut prime_digits_counter23 = 0;\n    let mut prime_digits_counter24\
    \ = 0;\n    let mut prime_digits_counter25 = 0;\n    let mut prime_digits_counter26\
    \ = 0;\n    let mut prime_digits_counter27 = 0;\n    let mut prime_digits_counter28\
    \ = 0;\n    let mut prime_digits_counter29 = 0;\n    let mut prime_digits_counter30\
    \ = 0;\n    let mut prime_digits_counter31 = 0;\n    let mut prime_digits_counter32\
    \ = 0;\n    let mut prime_digits_counter33 = 0;\n    let mut prime_digits_counter34\
    \ = 0;\n    let mut prime_digits_counter35 = 0;\n    let mut prime_digits_counter36\
    \ = 0;\n    let mut prime_digits_counter37 = 0;\n    let mut prime_digits_counter38\
    \ = 0;\n    let mut prime_digits_counter39 = 0;\n    let mut prime_digits_counter40\
    \ = 0;\n    let mut prime_digits_counter41 = 0;\n    let mut prime_digits_counter42\
    \ = 0;\n    let mut prime_digits_counter43 = 0;\n    let mut prime_digits_counter44\
    \ = 0;\n    let mut prime\n}\n\nfn main() {\n    let candidate = hex_key;\n  \
    \  assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd3ps8iez.rs:64:18\n   |\n\
    64 |     let mut prime\n   |                  ^ help: add `;` here\n65 | }\n \
    \  | - unexpected token\n\nerror[E0599]: no method named `to_vec` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpd3ps8iez.rs:18:32\n   |\n18 | \
    \    let mut num: Vec<u8> = num.to_vec();\n   |                              \
    \  ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpd3ps8iez.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize {\n \
    \  |    -------                 ^^^^^ expected `isize`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_sum: isize = 0;\n\
    \    let mut prime_digit_sum2: isize = 0;\n    let mut prime_digit_sum3: isize\
    \ = 0;\n    let mut prime_digit_sum4: isize = 0;\n    let mut prime_digit_sum5:\
    \ isize = 0;\n    let mut prime_digit_sum6: isize = 0;\n    let mut prime_digit_sum7:\
    \ isize = 0;\n    let mut prime_digit_sum8: isize = 0;\n    let mut prime_digit_sum9:\
    \ isize = 0;\n    let mut prime_digit_sum10: isize = 0;\n    let mut prime_digit_sum11:\
    \ isize = 0;\n    let mut prime_digit_sum12: isize = 0;\n    let mut prime_digit_sum13:\
    \ isize = 0;\n    let mut prime_digit_sum14: isize = 0;\n    let mut prime_digit_sum15:\
    \ isize = 0;\n    let mut prime_digit_sum16: isize = 0;\n    let mut prime_digit_sum17:\
    \ isize = 0;\n    let mut prime_digit_sum18: isize = 0;\n    let mut prime_digit_sum19:\
    \ isize = 0;\n    let mut prime_digit_sum20: isize = 0;\n    let mut prime_digit_sum21:\
    \ isize = 0;\n    let mut prime_digit_sum22: isize = 0;\n    let mut prime_digit_sum23:\
    \ isize = 0;\n    let mut prime_digit_sum24: isize = 0;\n    let mut prime_digit_sum25:\
    \ isize = 0;\n    let mut prime_digit_sum26: isize = 0;\n    let mut prime_digit_sum27:\
    \ isize = 0;\n    let mut prime_digit_sum28: isize = 0;\n    let mut prime_digit_sum29:\
    \ isize = 0;\n    let mut prime_digit_sum30: isize = 0;\n    let mut prime_digit_sum31:\
    \ isize = 0;\n    let mut prime_digit_sum32: isize = 0;\n    let mut prime_digit_sum33:\
    \ isize = 0;\n    let mut prime_digit_sum34: isize = 0;\n    let mut prime_digit_sum35:\
    \ isize = 0;\n    let mut prime_digit_sum36: isize = 0;\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprewqc054.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmprewqc054.rs:18:55\n     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_sum: isize = 0;\n\
    \    let mut prime_digit_sum2: isize = 0;\n    let mut prime_digit_sum3: isize\
    \ = 0;\n    let mut prime_digit_sum4: isize = 0;\n    let mut prime_digit_sum5:\
    \ isize = 0;\n    let mut prime_digit_sum6: isize = 0;\n    let mut prime_digit_sum7:\
    \ isize = 0;\n    let mut prime_digit_sum8: isize = 0;\n    let mut prime_digit_sum9:\
    \ isize = 0;\n    let mut prime_digit_sum10: isize = 0;\n    let mut prime_digit_sum11:\
    \ isize = 0;\n    let mut prime_digit_sum12: isize = 0;\n    let mut prime_digit_sum13:\
    \ isize = 0;\n    let mut prime_digit_sum14: isize = 0;\n    let mut prime_digit_sum15:\
    \ isize = 0;\n    let mut prime_digit_sum16: isize = 0;\n    let mut prime_digit_sum17:\
    \ isize = 0;\n    let mut prime_digit_sum18: isize = 0;\n    let mut prime_digit_sum19:\
    \ isize = 0;\n    let mut prime_digit_sum20: isize = 0;\n    let mut prime_digit_sum21:\
    \ isize = 0;\n    let mut prime_digit_sum22: isize = 0;\n    let mut prime_digit_sum23:\
    \ isize = 0;\n    let mut prime_digit_sum24: isize = 0;\n    let mut prime_digit_sum25:\
    \ isize = 0;\n    let mut prime_digit_sum26: isize = 0;\n    let mut prime_digit_sum27:\
    \ isize = 0;\n    let mut prime_digit_sum28: isize = 0;\n    let mut prime_digit_sum29:\
    \ isize = 0;\n    let mut prime_digit_sum30: isize = 0;\n    let mut prime_digit_sum31:\
    \ isize = 0;\n    let mut prime_digit_sum32: isize = 0;\n    let mut prime_digit_sum33:\
    \ isize = 0;\n    let mut prime_digit_sum34: isize = 0;\n    let mut prime_digit_sum35:\
    \ isize = 0;\n    let mut prime_digit_sum36: isize = 0;\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3y2_d_d9.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmp3y2_d_d9.rs:18:55\n     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 5, 7, 11, 13, 17];\n    let mut num_digits = num.chars().count();\n    let\
    \ mut num_digits_prime = 0;\n    let mut num_digits_not_prime = 0;\n    while\
    \ num_digits > 0 {\n        let mut num_digits_prime_next = 0;\n        let mut\
    \ num_digits_not_prime_next = 0;\n        for d in prime_digits {\n          \
    \  if num_digits % d == 0 {\n                num_digits_prime_next += 1;\n   \
    \         }\n        }\n        for d in prime_digits {\n            if num_digits\
    \ % d != 0 {\n                num_digits_not_prime_next += 1;\n            }\n\
    \        }\n        if num_digits_prime_next == num_digits_prime {\n         \
    \   prime_count += 1;\n        }\n        if num_digits_not_prime_next == num_digits_not_prime\
    \ {\n            prime_count += 1;\n        }\n        num_digits -= 1;\n    \
    \    num_digits_prime -= 1;\n        num_digits_not_prime -= 1;\n    }\n    prime_count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmphwgldz3g.rs:19:9\n\
    \   |\n19 |     let mut prime_digits = vec![2, 3, 5, 7, 11, 13, 17];\n   |   \
    \      ----^^^^^^^^^^^^\n   |         |\n   |         help: remove this `mut`\n\
    \   |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: use of\
    \ moved value: `prime_digits`\n   --> /tmp/tmphwgldz3g.rs:26:18\n    |\n19  |\
    \     let mut prime_digits = vec![2, 3, 5, 7, 11, 13, 17];\n    |         ----------------\
    \ move occurs because `prime_digits` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n26  |         for d in prime_digits {\n    |        \
    \          ^^^^^^^^^^^^ value used here after move\n...\n31  |         for d in\
    \ prime_digits {\n    |                  ------------ `prime_digits` moved due\
    \ to this implicit call to `.into_iter()`, in previous iteration of loop\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `prime_digits`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n31  |         for d in &prime_digits {\n    |  \
    \                +\n\nerror[E0382]: use of moved value: `prime_digits`\n  -->\
    \ /tmp/tmphwgldz3g.rs:31:18\n   |\n19 |     let mut prime_digits = vec![2, 3,\
    \ 5, 7, 11, 13, 17];\n   |         ---------------- move occurs because `prime_digits`\
    \ has type `Vec<usize>`, which does not implement the `Copy` trait\n...\n26 |\
    \         for d in prime_digits {\n   |                  ------------ `prime_digits`\
    \ moved due to this implicit call to `.into_iter()`\n...\n31 |         for d in\
    \ prime_digits {\n   |                  ^^^^^^^^^^^^ value used here after move\n\
    \   |\nhelp: consider iterating over a slice of the `Vec<usize>`'s content to\
    \ avoid moving into the `for` loop\n   |\n26 |         for d in &prime_digits\
    \ {\n   |                  +\n\nerror: aborting due to 2 previous errors; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut digit_count = 1;\n   \
    \ let mut digits = num.chars().collect::<Vec<_>>();\n    let mut primes = vec![false;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let mut primes_count = vec![0;\
    \ 10];\n    let mut primes_count = vec![0; 10];\n    let \n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp4d9tmbnz.rs:62:1\n  \
    \ |\n62 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut prime_counter = 0;\n    let\
    \ mut prime_digits = vec![2, 3, 4, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut digits = num.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.length;\n    let mut digits_counter = 0;\n  \
    \  let mut prime_digits_len = prime_digits.length;\n    let mut prime_digits_counter\
    \ = 0;\n    let mut prime_digits_counter2 = 0;\n    let mut prime_digits_counter3\
    \ = 0;\n    let mut prime_digits_counter4 = 0;\n    let mut prime_digits_counter5\
    \ = 0;\n    let mut prime_digits_counter6 = 0;\n    let mut prime_digits_counter7\
    \ = 0;\n    let mut prime_digits_counter8 = 0;\n    let mut prime_digits_counter9\
    \ = 0;\n    let mut prime_digits_counter10 = 0;\n    let mut prime_digits_counter11\
    \ = 0;\n    let mut prime_digits_counter12 = 0;\n    let mut prime_digits_counter13\
    \ = 0;\n    let mut prime_digits_counter14 = 0;\n    let mut prime_digits_counter15\
    \ = 0;\n    let mut prime_digits_counter16 = 0;\n    let mut prime_digits_counter17\
    \ = 0;\n    let mut prime_digits_counter18 = 0;\n    let mut prime_digits_counter19\
    \ = 0;\n    let mut prime_digits_counter20 = 0;\n    let mut prime_digits_counter21\
    \ = 0;\n    let mut prime_digits_counter22 = 0;\n    let mut prime_digits_counter23\
    \ = 0;\n    let mut prime_digits_counter24 = 0;\n    let mut prime_digits_counter25\
    \ = 0;\n    let mut prime_digits_counter26 = 0;\n    let mut prime_digits_counter27\
    \ = 0;\n    let mut prime_digits_counter28 = 0;\n    let mut prime_digits_counter29\
    \ = 0;\n    let mut prime_digits_counter30 = 0;\n    let mut prime_digits_counter31\
    \ = 0;\n    let mut prime_digits_counter32 = 0;\n    let mut prime_digits_counter33\
    \ = 0;\n    let mut prime_digits_counter34 = 0;\n    let mut prime_digits_counter35\
    \ = 0;\n    let mut prime_digits_counter36 = 0;\n    let mut prime_digits_counter37\
    \ = 0;\n    let mut prime_\n}\n\nfn main() {\n    let candidate = hex_key;\n \
    \   assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2_vobk2x.rs:62:19\n   |\n\
    62 |     let mut prime_\n   |                   ^ help: add `;` here\n63 | }\n\
    \   | - unexpected token\n\nerror[E0609]: no field `length` on type `Vec<char>`\n\
    \  --> /tmp/tmp2_vobk2x.rs:22:33\n   |\n22 |     let mut digits_len = digits.length;\n\
    \   |                                 ^^^^^^ unknown field\n\nerror[E0609]: no\
    \ field `length` on type `Vec<{integer}>`\n  --> /tmp/tmp2_vobk2x.rs:24:45\n \
    \  |\n24 |     let mut prime_digits_len = prime_digits.length;\n   |         \
    \                                    ^^^^^^ unknown field\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2_vobk2x.rs:17:28\n   |\n17 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0609.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpc2ec2gup.rs:57:31\n   |\n\
    57 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n58 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpc2ec2gup.rs:57:30\n   |\n57 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpc2ec2gup.rs:18:55\n\
    \     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc2ec2gup.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digit = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count_len = vec![];\n    let mut prime_digit_count_len_max\
    \ = vec![];\n    let mut prime_digit_count_len_max_len = vec![];\n    let mut\
    \ prime_digit_count_len_max_len_max = vec![];\n    let mut prime_digit_count_len_max_len_max_max\
    \ = vec![];\n    let mut prime_digit_count_len_max_len_max_max_max = vec![];\n\
    \    let mut prime_digit_count_len_max_len_max_max_max_max = vec![];\n    let\
    \ mut prime_digit_count_len_max_len_max_max_max_max = vec![];\n    let mut prime_digit_count_len_max_len_max_max_max_max_max\
    \ = vec![];\n    let mut prime_digit_count_len_max_len_max_max_max_max_max = vec![];\n\
    \    let mut prime_digit_count_len_max_len_max_max_max_max_max = vec![];\n   \
    \ let mut prime_digit_count_len_max_len_max_max_max_max_max_max = vec![];\n  \
    \  let mut prime_digit_count_len_max_len_max_max_max_max_max_max = vec![];\n \
    \   let mut prime_digit_count_len_max_len_max_max_max_max_max_max = vec![];\n\
    \    let mut prime_digit_count_len_max_len_max_max_max_max_max_max = vec![];\n\
    \    let mut prime_digit_count_len_max_len_max_max_max_max_max_max = vec![];\n\
    \    let mut prime_digit_count_len_max_len_max_max_max_max_max_max = vec![];\n\
    \    let mut prime_digit_count_len_max_len_max_max_max_max_max_max = vec![];\n\
    \    let mut prime_digit_count_len_max_len_max_max_max_max_max_max_max = vec![];\n\
    \    let mut prime_digit_count_len_max_len_max_max_max_max_max_max_max = vec![];\n\
    \    let mut prime_digit_count_len_max_len_max_max_max_max_max_max_max = vec![];\n\
    \    let mut prime_digit_count_len_max_len_max_max_max_max_max_max_max = vec![];\n\
    \    let mut prime_digit_count_len_max_len_max_max_max_max_max_max_max = vec![];\n\
    \    let mut prime_digit_count_len_max_len_max_max_max_max_max_max_max = vec![];\n\
    \    let mut prime_digit_count_len_max_len_max_max_max_max_max_max_max = vec![];\n\
    \    let mut prime_\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpum_6nt67.rs:47:19\n   |\n\
    47 |     let mut prime_\n   |                   ^ help: add `;` here\n48 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpum_6nt67.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num_digits = num.chars().filter(|c| c >= '0' && c <=\
    \ '9').count();\n    let mut num_primes = 1;\n    while num_digits > 0 {\n   \
    \     let mut num_primes_digits = 1;\n        while num_primes_digits < num_digits\
    \ {\n            let mut num_primes_digits_pow = 1;\n            while num_primes_digits_pow\
    \ < num_primes_digits {\n                if num_primes_digits_pow % 2 == 0 {\n\
    \                    num_primes_digits_pow += 1;\n                }\n        \
    \        else {\n                    num_primes_digits_pow += 2;\n           \
    \     }\n            }\n            num_primes_digits += num_primes_digits_pow;\n\
    \        }\n        num_primes += num_primes_digits;\n        num_digits -= num_primes_digits;\n\
    \    }\n    num_primes\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp62wvq0i6.rs:18:54\n   |\n\
    18 |     let mut num_digits = num.chars().filter(|c| c >= '0' && c <= '9').count();\n\
    \   |                                                      ^^^\n   |         \
    \                                             |\n   |                        \
    \                              expected `&char`, found `char`\n   |          \
    \                                            help: consider borrowing here: `&'0'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp62wvq0i6.rs:18:66\n   |\n18 |\
    \     let mut num_digits = num.chars().filter(|c| c >= '0' && c <= '9').count();\n\
    \   |                                                                  ^^^\n \
    \  |                                                                  |\n   |\
    \                                                                  expected `&char`,\
    \ found `char`\n   |                                                         \
    \         help: consider borrowing here: `&'9'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp62wvq0i6.rs:37:5\n   |\n17 | fn hex_key(num: String) -> isize {\n\
    \   |                            ----- expected `isize` because of return type\n\
    ...\n37 |     num_primes\n   |     ^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n37 |     num_primes.try_into().unwrap()\n   |     \
    \          ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut num_digits = num.len();\n\
    \    let mut num_digits_prime = 0;\n    let mut num_digits_not_prime = 0;\n  \
    \  let mut num_digits_not_prime_prime = 0;\n    let mut num_digits_not_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime = 0;\n\
    \    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime = 0;\n \
    \   let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n\
    \    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv6oss8x4.rs:39:76\n   |\n\
    39 |     let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_\n\
    \   |                                                                        \
    \    ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv6oss8x4.rs:17:28\n   |\n17 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![];\n    let mut prime_counter: usize = 0;\n\
    \    let mut prime_counter2: usize = 0;\n    let mut prime_counter3: usize = 0;\n\
    \    let mut prime_counter4: usize = 0;\n    let mut prime_counter5: usize = 0;\n\
    \    let mut prime_counter6: usize = 0;\n    let mut prime_counter7: usize = 0;\n\
    \    let mut prime_counter8: usize = 0;\n    let mut prime_counter9: usize = 0;\n\
    \    let mut prime_counter10: usize = 0;\n    let mut prime_counter11: usize =\
    \ 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13: usize\
    \ = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: usize = 0;\n    let mut prime\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr76v3mg8.rs:60:18\n   |\n\
    60 |     let mut prime\n   |                  ^ help: add `;` here\n61 | }\n \
    \  | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmpr76v3mg8.rs:18:55\n\
    \     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr76v3mg8.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<usize> = num.to_vec();\n    let mut prime_count:\
    \ isize = 0;\n    let mut prime_digit: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ usize = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpudcy3ne6.rs:64:11\n   |\n\
    64 |     let mu\n   |           ^ help: add `;` here\n65 | }\n   | - unexpected\
    \ token\n\nerror[E0599]: no method named `to_vec` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpudcy3ne6.rs:18:35\n   |\n18 |     let mut num:\
    \ Vec<usize> = num.to_vec();\n   |                                   ^^^^^^ method\
    \ not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpudcy3ne6.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: isize = num.len();\n    let mut prime: isize =\
    \ 0;\n    let mut prime_found = false;\n    let mut prime_found2 = false;\n  \
    \  let mut prime_found3 = false;\n    let mut prime_found4 = false;\n    let mut\
    \ prime_found5 = false;\n    let mut prime_found6 = false;\n    let mut prime_found7\
    \ = false;\n    let mut prime_found8 = false;\n    let mut prime_found9 = false;\n\
    \    let mut prime_found10 = false;\n    let mut prime_found11 = false;\n    let\
    \ mut prime_found12 = false;\n    let mut prime_found13 = false;\n    let mut\
    \ prime_found14 = false;\n    let mut prime_found15 = false;\n    let mut prime_found16\
    \ = false;\n    let mut prime_found17 = false;\n    let mut prime_found18 = false;\n\
    \    let mut prime_found19 = false;\n    let mut prime_found20 = false;\n    let\
    \ mut prime_found21 = false;\n    let mut prime_found22 = false;\n    let mut\
    \ prime_found23 = false;\n    let mut prime_found24 = false;\n    let mut prime_found25\
    \ = false;\n    let mut prime_found26 = false;\n    let mut prime_found27 = false;\n\
    \    let mut prime_found28 = false;\n    let mut prime_found29 = false;\n    let\
    \ mut prime_found30 = false;\n    let mut prime_found31 = false;\n    let mut\
    \ prime_found32 = false;\n    let mut prime_found33 = false;\n    let mut prime_found34\
    \ = false;\n    let mut prime_found35 = false;\n    let mut prime_found36 = false;\n\
    \    let mut prime_found37 = false;\n    let mut prime_found38 = false;\n    let\
    \ mut prime_found39 = false;\n    let mut prime_found40 = false;\n    let mut\
    \ prime_found41 = false;\n    let mut prime_found42 = false;\n    let mut prime_found43\
    \ = false;\n    let mut prime_found44 = false;\n    let mut prime_found45 = false;\n\
    \    let mut prime_found46 = false;\n    let mut prime_found47 = false;\n    let\
    \ mut prime_found48 = false;\n    let mut prime_found49 = false;\n    let mut\
    \ prime_found50 = false;\n    let mut prime_found51 = false;\n    let mut prime_found52\
    \ = false;\n    let mut prime_found53 = false;\n    let mut prime_found\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxizm8rsm.rs:73:24\n   |\n\
    73 |     let mut prime_found\n   |                        ^ help: add `;` here\n\
    74 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxizm8rsm.rs:18:26\n\
    \   |\n18 |     let mut num: isize = num.len();\n   |                  ----- \
    \  ^^^^^^^^^ expected `isize`, found `usize`\n   |                  |\n   |  \
    \                expected due to this\n   |\nhelp: you can convert a `usize` to\
    \ an `isize` and panic if the converted value doesn't fit\n   |\n18 |     let\
    \ mut num: isize = num.len().try_into().unwrap();\n   |                      \
    \             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxizm8rsm.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut digits = num.chars().collect::<Vec<_>>();\n  \
    \  let mut digits_len = digits.length;\n    let mut digits_index = 0;\n    let\
    \ mut prime_digits_index = 0;\n    let mut prime_digits_len = prime_digits.length;\n\
    \    let mut prime_digits_index = 0;\n    let mut prime_digits_index2 = 0;\n \
    \   let mut prime_digits_index3 = 0;\n    let mut prime_digits_index4 = 0;\n \
    \   let mut prime_digits_index5 = 0;\n    let mut prime_digits_index6 = 0;\n \
    \   let mut prime_digits_index7 = 0;\n    let mut prime_digits_index8 = 0;\n \
    \   let mut prime_digits_index9 = 0;\n    let mut prime_digits_index10 = 0;\n\
    \    let mut prime_digits_index11 = 0;\n    let mut prime_digits_index12 = 0;\n\
    \    let mut prime_digits_index13 = 0;\n    let mut prime_digits_index14 = 0;\n\
    \    let mut prime_digits_index15 = 0;\n    let mut prime_digits_index16 = 0;\n\
    \    let mut prime_digits_index17 = 0;\n    let mut prime_digits_index18 = 0;\n\
    \    let mut prime_digits_index19 = 0;\n    let mut prime_digits_index20 = 0;\n\
    \    let mut prime_digits_index21 = 0;\n    let mut prime_digits_index22 = 0;\n\
    \    let mut prime_digits_index23 = 0;\n    let mut prime_digits_index24 = 0;\n\
    \    let mut prime_digits_index25 = 0;\n    let mut prime_digits_index26 = 0;\n\
    \    let mut prime_digits_index27 = 0;\n    let mut prime_digits_index28 = 0;\n\
    \    let mut prime_digits_index29 = 0;\n    let mut prime_digits_index30 = 0;\n\
    \    let mut prime_digits_index31 = 0;\n    let mut prime_digits_index32 = 0;\n\
    \    let mut prime_digits_index33 = 0;\n    let mut prime_digits_index34 = 0;\n\
    \    let mut prime_digits_index35 = 0;\n    let mut prime_digits_index36 = 0;\n\
    \    let mut prime_digits_index37 = 0;\n    let mut prime\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9laazr2j.rs:62:18\n   |\n\
    62 |     let mut prime\n   |                  ^ help: add `;` here\n63 | }\n \
    \  | - unexpected token\n\nerror[E0609]: no field `length` on type `Vec<char>`\n\
    \  --> /tmp/tmp9laazr2j.rs:21:33\n   |\n21 |     let mut digits_len = digits.length;\n\
    \   |                                 ^^^^^^ unknown field\n\nerror[E0609]: no\
    \ field `length` on type `Vec<{integer}>`\n  --> /tmp/tmp9laazr2j.rs:24:45\n \
    \  |\n24 |     let mut prime_digits_len = prime_digits.length;\n   |         \
    \                                    ^^^^^^ unknown field\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9laazr2j.rs:17:28\n   |\n17 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0609.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num_digits = num.len();\n    let mut prime_count = 0;\n\
    \    let mut prime_digits = vec![];\n    let mut prime_digits_count = vec![];\n\
    \    let mut prime_digits_count_max = vec![];\n    let mut prime_digits_count_min\
    \ = vec![];\n    let mut prime_digits_count_max_min = vec![];\n    let mut prime_digits_count_min_max\
    \ = vec![];\n    let mut prime_digits_count_min_max_max = vec![];\n    let mut\
    \ prime_digits_count_min_max_max_max = vec![];\n    let mut prime_digits_count_min_max_max_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_max_max_max_max_max = vec![];\n\
    \    let mut prime_digits_count_min_max_max_max_max_max_max = vec![];\n    let\
    \ mut prime_digits_count_min_max_max_max_max_max_max_max = vec![];\n    let mut\
    \ prime_digits_count_min_max_max_max_max_max_max_max_max = vec![];\n    let mut\
    \ prime_digits_count_min_max_max_max_max_max_max_max_max_max = vec![];\n    let\
    \ mut prime_digits_count_min_max_max_max_max_max_max_max_max_max_max = vec![];\n\
    \    let mut prime_digits_count_min_max_max_max_max_max_max_max_max_max_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_max_max_max_max_max_max_max_max_max_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_max_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_max_max_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_max_max_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_max_max_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_max_\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdtrc8t2l.rs:44:40\n   |\n\
    44 |     let mut prime_digits_count_min_max_\n   |                           \
    \             ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdtrc8t2l.rs:17:28\n   |\n17 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: usize = 0;\n    let mut prime_digit_index: usize = 0;\n\
    \    let mut prime_digit_remainder: usize = 0;\n    let mut prime_digit_remainder_count:\
    \ usize = 0;\n    let mut prime_digit_remainder_index: usize = 0;\n    let mut\
    \ prime_digit_remainder_remainder: usize = 0;\n    let mut prime_digit_remainder_remainder_count:\
    \ usize = 0;\n    let mut prime_digit_remainder_remainder_index: usize = 0;\n\
    \    let mut prime_digit_remainder_remainder_remainder: usize = 0;\n    let mut\
    \ prime_digit_remainder_remainder_remainder_count: usize = 0;\n    let mut prime_digit_remainder_remainder_remainder_index:\
    \ usize = 0;\n    let mut prime_digit_remainder_remainder_remainder_remainder:\
    \ usize = 0;\n    let mut prime_digit_remainder_remainder_remainder_count: usize\
    \ = 0;\n    let mut prime_digit_remainder_remainder_remainder_index: usize = 0;\n\
    \    let mut prime_digit_remainder_remainder_remainder_remainder: usize = 0;\n\
    \    let mut prime_digit_remainder_remainder_remainder_count: usize = 0;\n   \
    \ let mut prime_digit_remainder_remainder_remainder_index: usize = 0;\n    let\
    \ mut prime_digit_remainder_remainder_remainder_remainder: usize = 0;\n    let\
    \ mut prime_digit_remainder_remainder_remainder_count: usize = 0;\n    let mut\
    \ prime_digit_remainder_remainder_remainder_index: usize = 0;\n    let mut prime_digit_remainder_remainder_remainder_remainder:\
    \ usize = 0;\n    let mut prime_digit_remainder_remainder_remainder_count: usize\
    \ = 0;\n    let mut prime_digit_remainder_remainder_remainder_index: usize = 0;\n\
    \    let mut prime_digit_remainder_remainder_remainder_remainder: usize = 0;\n\
    \    let mut prime_digit_remainder_remainder_remainder_count: usize = 0;\n   \
    \ let mut prime_digit_remainder_remainder_remainder_index: usize = 0;\n    let\
    \ mut prime_digit_remainder_remainder_remainder_remainder: usize = 0;\n    let\
    \ mut prime_digit_remainder_remainder_remainder_count: usize = 0;\n    let mut\
    \ prime_digit_remainder_remainder_remainder_index: usize\n}\n\nfn main() {\n \
    \   let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp455fmf80.rs:49:67\n   |\n\
    49 |     let mut prime_digit_remainder_remainder_remainder_index: usize\n   |\
    \                                                                   ^ help: add\
    \ `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp455fmf80.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmp455fmf80.rs:18:55\n     |\n18   | \
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |    \
    \                                                   ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_digits = vec![false; 26];\n    let mut prime_counter = 0;\n\
    \    let mut prime_digits_counter = 0;\n    let mut prime_digits_counter2 = 0;\n\
    \    let mut prime_digits_counter3 = 0;\n    let mut prime_digits_counter4 = 0;\n\
    \    let mut prime_digits_counter5 = 0;\n    let mut prime_digits_counter6 = 0;\n\
    \    let mut prime_digits_counter7 = 0;\n    let mut prime_digits_counter8 = 0;\n\
    \    let mut prime_digits_counter9 = 0;\n    let mut prime_digits_counter10 =\
    \ 0;\n    let mut prime_digits_counter11 = 0;\n    let mut prime_digits_counter12\
    \ = 0;\n    let mut prime_digits_counter13 = 0;\n    let mut prime_digits_counter14\
    \ = 0;\n    let mut prime_digits_counter15 = 0;\n    let mut prime_digits_counter16\
    \ = 0;\n    let mut prime_digits_counter17 = 0;\n    let mut prime_digits_counter18\
    \ = 0;\n    let mut prime_digits_counter19 = 0;\n    let mut prime_digits_counter20\
    \ = 0;\n    let mut prime_digits_counter21 = 0;\n    let mut prime_digits_counter22\
    \ = 0;\n    let mut prime_digits_counter23 = 0;\n    let mut prime_digits_counter24\
    \ = 0;\n    let mut prime_digits_counter25 = 0;\n    let mut prime_digits_counter26\
    \ = 0;\n    let mut prime_digits_counter27 = 0;\n    let mut prime_digits_counter28\
    \ = 0;\n    let mut prime_digits_counter29 = 0;\n    let mut prime_digits_counter30\
    \ = 0;\n    let mut prime_digits_counter31 = 0;\n    let mut prime_digits_counter32\
    \ = 0;\n    let mut prime_digits_counter33 = 0;\n    let mut prime_digits_counter34\
    \ = 0;\n    let mut prime_digits_counter35 = 0;\n    let mut prime_digits_counter36\
    \ = 0;\n    let mut prime_digits_counter37 = 0;\n    let mut prime_digits_counter38\
    \ = 0;\n    let mut prime_digits_counter39 = 0;\n    let mut prime_digits_counter40\
    \ = 0;\n    let mut prime_digits_counter41 = 0;\n    let mut prime_digits_counter42\
    \ = 0;\n    let mut prime_digits_counter43 = 0;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp2u2c4aw0.rs:65:1\n\
    \   |\n65 | }\n   | ^ expected identifier\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmp2u2c4aw0.rs:18:55\n\
    \     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: isize = 0;\n    let mut digits: Vec<&str> = num.to_string().chars().collect();\n\
    \    let mut prime: Vec<&str> = vec![];\n    let mut prime_digits: Vec<&str> =\
    \ vec![];\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count_max:\
    \ usize = 0;\n    let mut prime_digit_count_min: usize = 0;\n    let mut prime_digit_count_min2:\
    \ usize = 0;\n    let mut prime_digit_count_min3: usize = 0;\n    let mut prime_digit_count_min4:\
    \ usize = 0;\n    let mut prime_digit_count_min5: usize = 0;\n    let mut prime_digit_count_min6:\
    \ usize = 0;\n    let mut prime_digit_count_min7: usize = 0;\n    let mut prime_digit_count_min8:\
    \ usize = 0;\n    let mut prime_digit_count_min9: usize = 0;\n    let mut prime_digit_count_min10:\
    \ usize = 0;\n    let mut prime_digit_count_min11: usize = 0;\n    let mut prime_digit_count_min12:\
    \ usize = 0;\n    let mut prime_digit_count_min13: usize = 0;\n    let mut prime_digit_count_min14:\
    \ usize = 0;\n    let mut prime_digit_count_min15: usize = 0;\n    let mut prime_digit_count_min16:\
    \ usize = 0;\n    let mut prime_digit_count_min17: usize = 0;\n    let mut prime_digit_count_min18:\
    \ usize = 0;\n    let mut prime_digit_count_min19: usize = 0;\n    let mut prime_digit_count_min20:\
    \ usize = 0;\n    let mut prime_digit_count_min21: usize = 0;\n    let mut prime_digit_count_min22:\
    \ usize = 0;\n    let mut prime_digit_count_min23: usize = 0;\n    let mut prime_digit_count_min24:\
    \ usize = 0;\n    let mut prime_digit_count_min25: usize = 0;\n    let mut prime_digit_count_min26:\
    \ usize = 0;\n    let mut prime_digit_count_min27: usize = 0;\n    let mut prime_digit_count_min28:\
    \ usize = 0;\n    let mut prime_digit_count_min29: usize = 0;\n    let mut prime_digit_count_min30:\
    \ usize = 0;\n    let mut prime_digit_count_min31: usize\n}\n\nfn main() {\n \
    \   let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpogew1b03.rs:54:43\n   |\n\
    54 |     let mut prime_digit_count_min31: usize\n   |                        \
    \                   ^ help: add `;` here\n55 | }\n   | - unexpected token\n\n\
    error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmpogew1b03.rs:19:57\n     |\n19   | \
    \    let mut digits: Vec<&str> = num.to_string().chars().collect();\n     |  \
    \                                                       ^^^^^^^ value of type\
    \ `Vec<&str>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpogew1b03.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num_digits = num.chars().count();\n    let mut num_primes\
    \ = 0;\n    let mut num_primes_found = 0;\n    let mut num_primes_found2 = 0;\n\
    \    let mut num_primes_found3 = 0;\n    let mut num_primes_found4 = 0;\n    let\
    \ mut num_primes_found5 = 0;\n    let mut num_primes_found6 = 0;\n    let mut\
    \ num_primes_found7 = 0;\n    let mut num_primes_found8 = 0;\n    let mut num_primes_found9\
    \ = 0;\n    let mut num_primes_found10 = 0;\n    let mut num_primes_found11 =\
    \ 0;\n    let mut num_primes_found12 = 0;\n    let mut num_primes_found13 = 0;\n\
    \    let mut num_primes_found14 = 0;\n    let mut num_primes_found15 = 0;\n  \
    \  let mut num_primes_found16 = 0;\n    let mut num_primes_found17 = 0;\n    let\
    \ mut num_primes_found18 = 0;\n    let mut num_primes_found19 = 0;\n    let mut\
    \ num_primes_found20 = 0;\n    let mut num_primes_found21 = 0;\n    let mut num_primes_found22\
    \ = 0;\n    let mut num_primes_found23 = 0;\n    let mut num_primes_found24 =\
    \ 0;\n    let mut num_primes_found25 = 0;\n    let mut num_primes_found26 = 0;\n\
    \    let mut num_primes_found27 = 0;\n    let mut num_primes_found28 = 0;\n  \
    \  let mut num_primes_found29 = 0;\n    let mut num_primes_found30 = 0;\n    let\
    \ mut num_primes_found31 = 0;\n    let mut num_primes_found32 = 0;\n    let mut\
    \ num_primes_found33 = 0;\n    let mut num_primes_found34 = 0;\n    let mut num_primes_found35\
    \ = 0;\n    let mut num_primes_found36 = 0;\n    let mut num_primes_found37 =\
    \ 0;\n    let mut num_primes_found38 = 0;\n    let mut num_primes_found39 = 0;\n\
    \    let mut num_primes_found40 = 0;\n    let mut num_primes_found41 = 0;\n  \
    \  let mut num_primes_found42 = 0;\n    let mut num_primes_found43 = 0;\n    let\
    \ mut num_primes_found44 = 0;\n    let mut num_primes_found45 = 0;\n    let mut\
    \ num_primes_found46 = 0;\n    let mut num_primes_found47 = 0;\n    let mut num_primes_found48\
    \ = 0;\n    let mut num_primes_found49 = 0;\n    let mut num_primes_found\n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppkk_skhh.rs:69:29\n   |\n\
    69 |     let mut num_primes_found\n   |                             ^ help: add\
    \ `;` here\n70 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppkk_skhh.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digits: Vec<u8> = vec![];\n    let mut prime_digits_count: isize =\
    \ 0;\n    let mut prime_digits_sum: isize = 0;\n    let mut prime_digits_sum2:\
    \ isize = 0;\n    let mut prime_digits_sum3: isize = 0;\n    let mut prime_digits_sum4:\
    \ isize = 0;\n    let mut prime_digits_sum5: isize = 0;\n    let mut prime_digits_sum6:\
    \ isize = 0;\n    let mut prime_digits_sum7: isize = 0;\n    let mut prime_digits_sum8:\
    \ isize = 0;\n    let mut prime_digits_sum9: isize = 0;\n    let mut prime_digits_sum10:\
    \ isize = 0;\n    let mut prime_digits_sum11: isize = 0;\n    let mut prime_digits_sum12:\
    \ isize = 0;\n    let mut prime_digits_sum13: isize = 0;\n    let mut prime_digits_sum14:\
    \ isize = 0;\n    let mut prime_digits_sum15: isize = 0;\n    let mut prime_digits_sum16:\
    \ isize = 0;\n    let mut prime_digits_sum17: isize = 0;\n    let mut prime_digits_sum18:\
    \ isize = 0;\n    let mut prime_digits_sum19: isize = 0;\n    let mut prime_digits_sum20:\
    \ isize = 0;\n    let mut prime_digits_sum21: isize = 0;\n    let mut prime_digits_sum22:\
    \ isize = 0;\n    let mut prime_digits_sum23: isize = 0;\n    let mut prime_digits_sum24:\
    \ isize = 0;\n    let mut prime_digits_sum25: isize = 0;\n    let mut prime_digits_sum26:\
    \ isize = 0;\n    let mut prime_digits_sum27: isize = 0;\n    let mut prime_digits_sum28:\
    \ isize = 0;\n    let mut prime_digits_sum29: isize = 0;\n    let mut prime_digits_sum30:\
    \ isize = 0;\n    let mut prime_digits_sum31: isize = 0;\n    let mut prime_digits_sum32:\
    \ isize = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptxxt1wy3.rs:55:11\n   |\n\
    55 |     let mu\n   |           ^ help: add `;` here\n56 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmptxxt1wy3.rs:18:55\n     |\n18\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptxxt1wy3.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set_size\
    \ = prime_digits_set.len();\n    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp833yhzeg.rs:39:18\n   |\n\
    39 |     let mut prime\n   |                  ^ help: add `;` here\n40 | }\n \
    \  | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmp833yhzeg.rs:20:32\n   |\n20 |     let mut prime_digits_set\
    \ = HashSet::new();\n   |                                ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp833yhzeg.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17];\n    let mut digits = num.chars().collect::<Vec<_>>();\n\
    \    let mut digits_iter = digits.iter();\n    let mut digits_len = digits_iter.len();\n\
    \    let mut digit_count = 1;\n    let mut digit_iter = digits_iter.clone();\n\
    \    let mut digit_len = digit_iter.len();\n    let mut digit_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17];\n    let mut digit_digits_iter = digit_digits.iter();\n\
    \    let mut digit_digits_len = digit_digits_iter.len();\n    let mut digit_digits_count\
    \ = digit_digits_iter.len();\n    let mut digit_digits_iter = digit_digits_iter.clone();\n\
    \    let mut digit_digits_len = digit_digits_iter.len();\n    let mut digit_digits_count\
    \ = digit_digits_iter.len();\n    let mut digit_digits_iter = digit_digits_iter.clone();\n\
    \    let mut digit_digits_len = digit_digits_iter.len();\n    let mut digit_digits_count\
    \ = digit_digits_iter.len();\n    let mut digit_digits_iter = digit_digits_iter.clone();\n\
    \    let mut digit_digits_len = digit_digits_iter.len();\n    let mut digit_digits_count\
    \ = digit_digits_iter.len();\n    let mut digit_digits_iter = digit_digits_iter.clone();\n\
    \    let mut digit_digits_len = digit_digits_iter.len();\n    let mut digit_digits_count\
    \ = digit_digits_iter.len();\n    let mut digit_digits_iter = digit_digits_iter.clone();\n\
    \    let mut digit_digits_len = digit_digits_iter.len();\n    let mut digit_digits_count\
    \ = digit_digits_iter.len();\n    let mut digit_digits_iter = digit_digits_iter.clone();\n\
    \    let mut digit_digits_len = digit_digits_iter.len();\n    let mut digit_digits_count\
    \ = digit_digits_iter.len();\n    let mut digit_digits_iter = digit_digits_iter.clone();\n\
    \    let mut digit_digits_len = digit_digits_iter.len();\n    let mut digit_digits_count\
    \ = digit_digits_iter.len();\n    let mut digit_digits_iter = digit_digits_iter.clone();\n\
    \    let mut digit_digits_len = digit_digits_iter.len();\n    let mut digit_digits_count\
    \ = digit_digits_iter.len();\n    let mut digit_digits_iter = digit_digits_iter.clone();\n\
    \    let mut digit_digits_len = digit_digits_iter.len();\n    let mut digit_digits_count\
    \ = digit_digits_iter.\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp39jl5fnv.rs:57:1\n   |\n57\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp39jl5fnv.rs:56:52\n\
    \   |\n56 |     let mut digit_digits_count = digit_digits_iter.\n   |        \
    \                                            ^ help: add `;` here\n57 | }\n  \
    \ | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp39jl5fnv.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digit = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n    let mut prime_digit_count = vec![];\n\
    \    let mut prime_digit_count = vec![];\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplu6fg13w.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<usize> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime: usize = 2;\n    let mut\
    \ prime_found = false;\n    let mut digit: usize = 0;\n    let mut digit_found\
    \ = false;\n    let mut digit_prime: usize = 0;\n    let mut digit_prime_found\
    \ = false;\n    let mut digit_prime_prime: usize = 0;\n    let mut digit_prime_prime_found\
    \ = false;\n    let mut digit_prime_prime_prime: usize = 0;\n    let mut digit_prime_prime_prime_found\
    \ = false;\n    let mut digit_prime_prime_prime_prime: usize = 0;\n    let mut\
    \ digit_prime_prime_prime_prime_found = false;\n    let mut digit_prime_prime_prime_prime_prime:\
    \ usize = 0;\n    let mut digit_prime_prime_prime_prime_prime_found = false;\n\
    \    let mut digit_prime_prime_prime_prime_prime_found = false;\n    let mut digit_prime_prime_prime_prime_prime_prime_found\
    \ = false;\n    let mut digit_prime_prime_prime_prime_prime_prime_found = false;\n\
    \    let mut digit_prime_prime_prime_prime_prime_prime_prime_found = false;\n\
    \    let mut digit_prime_prime_prime_prime_prime_prime_prime_found = false;\n\
    \    let mut digit_prime_prime_prime_prime_prime_prime_prime_found = false;\n\
    \    let mut digit_prime_prime_prime_prime_prime_prime_prime_found = false;\n\
    \    let mut digit_prime_prime_prime_prime_prime_prime_prime_prime_found = false;\n\
    \    let mut digit_prime_prime_prime_prime_prime_prime_prime_prime_found = false;\n\
    \    let mut digit_prime_prime_prime_prime_prime_prime_prime_prime_found = false;\n\
    \    let mut digit_prime_prime_prime_prime_prime_prime_prime_prime_prime_found\
    \ = false;\n    let mut digit_prime_prime_prime_prime_prime_prime_prime_prime_prime_found\
    \ = false;\n    let mut digit_prime_prime_prime_prime_prime_prime_prime_prime_prime_found\
    \ = false;\n    let mut digit_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_found\
    \ = false;\n    let mut digit_\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_5mnum4g.rs:48:19\n   |\n\
    48 |     let mut digit_\n   |                   ^ help: add `;` here\n49 | }\n\
    \   | - unexpected token\n\nerror[E0277]: a value of type `Vec<usize>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmp_5mnum4g.rs:18:58\n\
    \     |\n18   |     let mut num: Vec<usize> = num.to_lowercase().chars().collect();\n\
    \     |                                                          ^^^^^^^ value\
    \ of type `Vec<usize>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<usize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_5mnum4g.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_numbers = vec![2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut\
    \ num_digits = num.len();\n    let mut num_primes = 0;\n    let mut num_primes_found\
    \ = 0;\n    let mut num_primes_found2 = 0;\n    let mut num_primes_found3 = 0;\n\
    \    let mut num_primes_found4 = 0;\n    let mut num_primes_found5 = 0;\n    let\
    \ mut num_primes_found6 = 0;\n    let mut num_primes_found7 = 0;\n    let mut\
    \ num_primes_found8 = 0;\n    let mut num_primes_found9 = 0;\n    let mut num_primes_found10\
    \ = 0;\n    let mut num_primes_found11 = 0;\n    let mut num_primes_found12 =\
    \ 0;\n    let mut num_primes_found13 = 0;\n    let mut num_primes_found14 = 0;\n\
    \    let mut num_primes_found15 = 0;\n    let mut num_primes_found16 = 0;\n  \
    \  let mut num_primes_found17 = 0;\n    let mut num_primes_found18 = 0;\n    let\
    \ mut num_primes_found19 = 0;\n    let mut num_primes_found20 = 0;\n    let mut\
    \ num_primes_found21 = 0;\n    let mut num_primes_found22 = 0;\n    let mut num_primes_found23\
    \ = 0;\n    let mut num_primes_found24 = 0;\n    let mut num_primes_found25 =\
    \ 0;\n    let mut num_primes_found26 = 0;\n    let mut num_primes_found27 = 0;\n\
    \    let mut num_primes_found28 = 0;\n    let mut num_primes_found29 = 0;\n  \
    \  let mut num_primes_found30 = 0;\n    let mut num_primes_found31 = 0;\n    let\
    \ mut num_primes_found32 = 0;\n    let mut num_primes_found33 = 0;\n    let mut\
    \ num_primes_found34 = 0;\n    let mut num_primes_found35 = 0;\n    let mut num_primes_found36\
    \ = 0;\n    let mut num_primes_found37 = 0;\n    let mut num_primes_found38 =\
    \ 0;\n    let mut num_primes_found39 = 0;\n    let mut num_primes_found40 = 0;\n\
    \    let mut num_primes_found41 = 0;\n    let mut num_primes_found42 = 0;\n  \
    \  let mut num_primes_found43 = 0;\n    let mut num_primes_found44 = 0;\n    let\
    \ mut num_primes_found45 = 0;\n    let mut num_primes_found\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnk6z41l2.rs:66:29\n   |\n\
    66 |     let mut num_primes_found\n   |                             ^ help: add\
    \ `;` here\n67 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnk6z41l2.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut num_digits = num.len();\n    let mut num_digits_prime = 0;\n    let\
    \ mut num_digits_not_prime = 0;\n    while num_digits > 0 {\n        let mut num_digits_prime_digits\
    \ = 0;\n        let mut num_digits_not_prime_digits = 0;\n        while num_digits\
    \ > 0 {\n            let digit = num[num_digits - 1];\n            if digit ==\
    \ 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit\
    \ == 'F' {\n                break;\n            }\n            if digit == '0'\
    \ {\n                break;\n            }\n            num_digits_prime_digits\
    \ += 1;\n            num_digits -= 1;\n        }\n        while num_digits > 0\
    \ {\n            let digit = num[num_digits - 1];\n            if digit == '0'\
    \ {\n                break;\n            }\n            num_digits_not_prime_digits\
    \ += 1;\n            num_digits -= 1;\n        }\n        if num_digits_prime_digits\
    \ == num_digits_not_prime_digits {\n            prime_count += 1;\n          \
    \  prime_digits.extend_from_slice(&digit);\n            num_digits_prime -= 1;\n\
    \            num_digits_not_prime -= 1;\n        }\n    }\n    prime_count\n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `digit` in this scope\n  --> /tmp/tmpiypz9gtb.rs:47:45\n\
    \   |\n47 |             prime_digits.extend_from_slice(&digit);\n   |        \
    \                                     ^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpiypz9gtb.rs:27:25\n\
    \   |\n27 |             let digit = num[num_digits - 1];\n   |               \
    \          ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpiypz9gtb.rs:38:25\n\
    \   |\n38 |             let digit = num[num_digits - 1];\n   |               \
    \          ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut digits = num.chars().collect::<Vec<_>>();\n    let mut digits_len\
    \ = digits.length;\n    let mut digits_index = 0;\n    let mut digits_len = digits.length;\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.length;\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.length;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = digits.length;\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.length;\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.length;\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.length;\n    let mut digits_index = 0;\n    let mut\
    \ digits_len = digits.length;\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.length;\n    let mut digits_index = 0;\n    let mut digits_len = digits.length;\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.length;\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.length;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = digits.length;\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.length;\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.length;\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.length;\n    let mut digits_index = 0;\n    let mut\
    \ digits_len = digits.length;\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.length;\n    let mut digits_index = 0;\n    let mut digits_len = digits.length;\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.length;\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.length;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = digits.length;\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.length;\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.length;\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.length;\n    let mut digits_index = 0;\n    let mut\
    \ digits_len = digits.length;\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.length;\n    let mut digits_index = 0;\n    let \n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpgcq7zhlp.rs:78:1\n  \
    \ |\n78 | }\n   | ^ expected pattern\n\nerror[E0609]: no field `length` on type\
    \ `Vec<char>`\n  --> /tmp/tmpgcq7zhlp.rs:21:33\n   |\n21 |     let mut digits_len\
    \ = digits.length;\n   |                                 ^^^^^^ unknown field\n\
    \nerror[E0609]: no field `length` on type `Vec<char>`\n  --> /tmp/tmpgcq7zhlp.rs:23:33\n\
    \   |\n23 |     let mut digits_len = digits.length;\n   |                    \
    \             ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type\
    \ `Vec<char>`\n  --> /tmp/tmpgcq7zhlp.rs:25:33\n   |\n25 |     let mut digits_len\
    \ = digits.length;\n   |                                 ^^^^^^ unknown field\n\
    \nerror[E0609]: no field `length` on type `Vec<char>`\n  --> /tmp/tmpgcq7zhlp.rs:27:33\n\
    \   |\n27 |     let mut digits_len = digits.length;\n   |                    \
    \             ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type\
    \ `Vec<char>`\n  --> /tmp/tmpgcq7zhlp.rs:29:33\n   |\n29 |     let mut digits_len\
    \ = digits.length;\n   |                                 ^^^^^^ unknown field\n\
    \nerror[E0609]: no field `length` on type `Vec<char>`\n  --> /tmp/tmpgcq7zhlp.rs:31:33\n\
    \   |\n31 |     let mut digits_len = digits.length;\n   |                    \
    \             ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type\
    \ `Vec<char>`\n  --> /tmp/tmpgcq7zhlp.rs:33:33\n   |\n33 |     let mut digits_len\
    \ = digits.length;\n   |                                 ^^^^^^ unknown field\n\
    \nerror[E0609]: no field `length` on type `Vec<char>`\n  --> /tmp/tmpgcq7zhlp.rs:35:33\n\
    \   |\n35 |     let mut digits_len = digits.length;\n   |                    \
    \             ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type\
    \ `Vec<char>`\n  --> /tmp/tmpgcq7zhlp.rs:37:33\n   |\n37 |     let mut digits_len\
    \ = digits.length;\n   |                                 ^^^^^^ unknown field\n\
    \nerror[E0609]: no field `length` on type `Vec<char>`\n  --> /tmp/tmpgcq7zhlp.rs:39:33\n\
    \   |\n39 |     let mut digits_len = digits.length;\n   |                    \
    \             ^^^^^^ unknown field\n\nerror[E0609]: n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime: isize = 2;\n    let mut\
    \ prime_found = false;\n    let mut digit_count: isize = 0;\n    let mut digit_found\
    \ = false;\n    while !digit_found {\n        digit_found = true;\n        for\
    \ &digit in num {\n            if digit == '0' {\n                digit_found\
    \ = false;\n                break;\n            }\n        }\n        if digit_found\
    \ {\n            digit_count++;\n        }\n    }\n    while !prime_found {\n\
    \        prime_found = true;\n        for &digit in num {\n            if digit\
    \ == '2' {\n                prime_found = false;\n                break;\n   \
    \         }\n        }\n        if prime_found {\n            prime_count++;\n\
    \        }\n    }\n    prime_count += digit_count - 1;\n    prime_count += 2;\n\
    \    prime_count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp7lh5tgcc.rs:33:24\n\
    \   |\n33 |             digit_count++;\n   |                        ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n33 |             { let\
    \ tmp = digit_count; digit_count += 1; tmp };\n   |             +++++++++++  \
    \          ~~~~~~~~~~~~~~~~~~~~~~~~~\n33 -             digit_count++;\n33 +  \
    \           digit_count += 1;\n   | \n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmp7lh5tgcc.rs:45:24\n   |\n45 |             prime_count++;\n   |\
    \                        ^^ not a valid postfix operator\n   |\nhelp: use `+=\
    \ 1` instead\n   |\n45 |             { let tmp = prime_count; prime_count += 1;\
    \ tmp };\n   |             +++++++++++            ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    45 -             prime_count++;\n45 +             prime_count += 1;\n   | \n\n\
    error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmp7lh5tgcc.rs:18:55\n     |\n18   | \
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |    \
    \                                                   ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7lh5tgcc.rs:26:13\n\
    \   |\n26 |         for &digit in num {\n   |             ^^^^^^    --- this expression\
    \ has type `Option<u8>`\n   |             |\n   |             expected `u8`, found\
    \ reference\n   |             help: you can probably remove the explicit borrow:\
    \ `digit`\n   |\n   = note:   expected type `u8`\n           found reference `&_`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7lh5tgcc.rs:38:13\n   |\n38 |\
    \         for &digit in num {\n   |             ^^^^^^    --- this expression\
    \ has type `Option<u8>`\n   |             |\n   |             expected `u8`, found\
    \ reference\n   |             help: you can probably"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_count: isize = 0;\n\
    \    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count: isize\
    \ = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8jx8rjpx.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmp8jx8rjpx.rs:18:55\n     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_index2 = 0;\n    let mut prime_digits_index3 = 0;\n\
    \    let mut prime_digits_index4 = 0;\n    let mut prime_digits_index5 = 0;\n\
    \    let mut prime_digits_index6 = 0;\n    let mut prime_digits_index7 = 0;\n\
    \    let mut prime_digits_index8 = 0;\n    let mut prime_digits_index9 = 0;\n\
    \    let mut prime_digits_index10 = 0;\n    let mut prime_digits_index11 = 0;\n\
    \    let mut prime_digits_index12 = 0;\n    let mut prime_digits_index13 = 0;\n\
    \    let mut prime_digits_index14 = 0;\n    let mut prime_digits_index15 = 0;\n\
    \    let mut prime_digits_index16 = 0;\n    let mut prime_digits_index17 = 0;\n\
    \    let mut prime_digits_index18 = 0;\n    let mut prime_digits_index19 = 0;\n\
    \    let mut prime_digits_index20 = 0;\n    let mut prime_digits_index21 = 0;\n\
    \    let mut prime_digits_index22 = 0;\n    let mut prime_digits_index23 = 0;\n\
    \    let mut prime_digits_index24 = 0;\n    let mut prime_digits_index25 = 0;\n\
    \    let mut prime_digits_index26 = 0;\n    let mut prime_digits_index27 = 0;\n\
    \    let mut prime_digits_index28 = 0;\n    let mut prime_digits_index29 = 0;\n\
    \    let mut prime_digits_index30 = 0;\n    let mut prime_digits_index31 = 0;\n\
    \    let mut prime_digits_index32 = 0;\n    let mut prime_digits_index33 = 0;\n\
    \    let mut prime_digits_index34 = 0;\n    let mut prime_digits_index35 = 0;\n\
    \    let mut prime_digits_index36 = 0;\n    let mut prime_digits_index37 = 0;\n\
    \    let mut prime_digits_index38 = 0;\n    let mut prime_digits_index39 = 0;\n\
    \    let mut prime_digits_index40 = 0;\n    let mut prime_digits_index41 = 0;\n\
    \    let mut prime_digits_index42 = 0;\n    let mut prime_digits_index43 = 0;\n\
    \    let mut prime_digits_index44 = 0;\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp95d8636j.rs:65:11\n   |\n\
    65 |     let mu\n   |           ^ help: add `;` here\n66 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp95d8636j.rs:17:28\n \
    \  |\n17 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: isize = num.chars().filter(|&c| c >= '0' && c <=\
    \ '9').count();\n    let mut prime: isize = 2;\n    while prime < num {\n    \
    \    if num % prime == 0 {\n            num -= prime;\n        } else {\n    \
    \        prime += 2;\n        }\n    }\n    num\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsuiv0mp5.rs:18:26\n   |\n\
    18 |     let mut num: isize = num.chars().filter(|&c| c >= '0' && c <= '9').count();\n\
    \   |                  -----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |                  |\n   |             \
    \     expected due to this\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |     let mut num: isize\
    \ = num.chars().filter(|&c| c >= '0' && c <= '9').count().try_into().unwrap();\n\
    \   |                                                                        \
    \       ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut digits = num.chars().map(|c|\
    \ c as char).collect::<Vec<_>>();\n    let mut primes = vec![false; 10];\n   \
    \ let mut primes_counter = 0;\n    let mut primes_digits = vec![false; 10];\n\
    \    let mut primes_digits_counter = 0;\n    let mut primes_digits_counter2 =\
    \ 0;\n    let mut primes_digits_counter3 = 0;\n    let mut primes_digits_counter4\
    \ = 0;\n    let mut primes_digits_counter5 = 0;\n    let mut primes_digits_counter6\
    \ = 0;\n    let mut primes_digits_counter7 = 0;\n    let mut primes_digits_counter8\
    \ = 0;\n    let mut primes_digits_counter9 = 0;\n    let mut primes_digits_counter10\
    \ = 0;\n    let mut primes_digits_counter11 = 0;\n    let mut primes_digits_counter12\
    \ = 0;\n    let mut primes_digits_counter13 = 0;\n    let mut primes_digits_counter14\
    \ = 0;\n    let mut primes_digits_counter15 = 0;\n    let mut primes_digits_counter16\
    \ = 0;\n    let mut primes_digits_counter17 = 0;\n    let mut primes_digits_counter18\
    \ = 0;\n    let mut primes_digits_counter19 = 0;\n    let mut primes_digits_counter20\
    \ = 0;\n    let mut primes_digits_counter21 = 0;\n    let mut primes_digits_counter22\
    \ = 0;\n    let mut primes_digits_counter23 = 0;\n    let mut primes_digits_counter24\
    \ = 0;\n    let mut primes_digits_counter25 = 0;\n    let mut primes_digits_counter26\
    \ = 0;\n    let mut primes_digits_counter27 = 0;\n    let mut primes_digits_counter28\
    \ = 0;\n    let mut primes_digits_counter29 = 0;\n    let mut primes_digits_counter30\
    \ = 0;\n    let mut primes_digits_counter31 = 0;\n    let mut primes_digits_counter32\
    \ = 0;\n    let mut primes_digits_counter33 = 0;\n    let mut primes_digits_counter34\
    \ = 0;\n    let mut primes_digits_counter35 = 0;\n    let mut primes_digits_counter36\
    \ = 0;\n    let mut primes_digits_counter37 = 0;\n    let mut primes_digits_counter38\
    \ = 0;\n    let mut primes_digits_counter39 = 0;\n    let mut primes_digits_counter40\
    \ = 0;\n    let mut primes_digits_counter41 = 0;\n    let \n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpajyde9yx.rs:65:1\n  \
    \ |\n65 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut\
    \ primes = vec![true; 26];\n    let mut primes_count = vec![0; 26];\n    let mut\
    \ primes_count_index = vec![0; 26];\n    let mut primes_count_index2 = vec![0;\
    \ 26];\n    let mut primes_count_index3 = vec![0; 26];\n    let mut primes_count_index4\
    \ = vec![0; 26];\n    let mut primes_count_index5 = vec![0; 26];\n    let mut\
    \ primes_count_index6 = vec![0; 26];\n    let mut primes_count_index7 = vec![0;\
    \ 26];\n    let mut primes_count_index8 = vec![0; 26];\n    let mut primes_count_index9\
    \ = vec![0; 26];\n    let mut primes_count_index10 = vec![0; 26];\n    let mut\
    \ primes_count_index11 = vec![0; 26];\n    let mut primes_count_index12 = vec![0;\
    \ 26];\n    let mut primes_count_index13 = vec![0; 26];\n    let mut primes_count_index14\
    \ = vec![0; 26];\n    let mut primes_count_index15 = vec![0; 26];\n    let mut\
    \ primes_count_index16 = vec![0; 26];\n    let mut primes_count_index17 = vec![0;\
    \ 26];\n    let mut primes_count_index18 = vec![0; 26];\n    let mut primes_count_index19\
    \ = vec![0; 26];\n    let mut primes_count_index20 = vec![0; 26];\n    let mut\
    \ primes_count_index21 = vec![0; 26];\n    let mut primes_count_index22 = vec![0;\
    \ 26];\n    let mut primes_count_index23 = vec![0; 26];\n    let mut primes_count_index24\
    \ = vec![0; 26];\n    let mut primes_count_index25 = vec![0; 26];\n    let mut\
    \ primes_count_index26 = vec![0; 26];\n    let mut primes_count_index27 = vec![0;\
    \ 26];\n    let mut primes_count_index28 = vec![0; 26];\n    let mut primes_count_index29\
    \ = vec![0; 26];\n    let mut primes_count_index30 = vec![0; 26];\n    let mut\
    \ primes_count_index31 = vec![0; 26];\n    let mut primes_count_index32 = vec![0;\
    \ 26];\n    let mut prime\n}\n\nfn main() {\n    let candidate = hex_key;\n  \
    \  assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3nqdcz7i.rs:53:18\n   |\n\
    53 |     let mut prime\n   |                  ^ help: add `;` here\n54 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3nqdcz7i.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_digits = vec![2, 3, 4, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut\
    \ prime_digits_len = prime_digits.len();\n    let mut prime_digits_count = prime_digits_len;\n\
    \    let mut prime_digits_count_2 = prime_digits_count_2;\n    let mut prime_digits_count_3\
    \ = prime_digits_count_3;\n    let mut prime_digits_count_4 = prime_digits_count_4;\n\
    \    let mut prime_digits_count_5 = prime_digits_count_5;\n    let mut prime_digits_count_6\
    \ = prime_digits_count_6;\n    let mut prime_digits_count_7 = prime_digits_count_7;\n\
    \    let mut prime_digits_count_8 = prime_digits_count_8;\n    let mut prime_digits_count_9\
    \ = prime_digits_count_9;\n    let mut prime_digits_count_10 = prime_digits_count_10;\n\
    \    let mut prime_digits_count_11 = prime_digits_count_11;\n    let mut prime_digits_count_12\
    \ = prime_digits_count_12;\n    let mut prime_digits_count_13 = prime_digits_count_13;\n\
    \    let mut prime_digits_count_14 = prime_digits_count_14;\n    let mut prime_digits_count_15\
    \ = prime_digits_count_15;\n    let mut prime_digits_count_16 = prime_digits_count_16;\n\
    \    let mut prime_digits_count_17 = prime_digits_count_17;\n    let mut prime_digits_count_18\
    \ = prime_digits_count_18;\n    let mut prime_digits_count_19 = prime_digits_count_19;\n\
    \    let mut prime_digits_count_20 = prime_digits_count_20;\n    let mut prime_digits_count_21\
    \ = prime_digits_count_21;\n    let mut prime_digits_count_22 = prime_digits_count_22;\n\
    \    let mut prime_digits_count_23 = prime_digits_count_23;\n    let mut prime_digits_count_24\
    \ = prime_digits_count_24;\n    let mut prime_digits_count_25 = prime_digits_count_25;\n\
    \    let mut prime_digits_count_26 = prime_digits_count_26;\n    let mut prime_digits_count_27\
    \ = prime_digits_count_27;\n    let \n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpse9ve13t.rs:48:1\n  \
    \ |\n48 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find value `prime_digits_count_2`\
    \ in this scope\n  --> /tmp/tmpse9ve13t.rs:21:36\n   |\n21 |     let mut prime_digits_count_2\
    \ = prime_digits_count_2;\n   |                                    ^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `prime_digits_count`\n\n\
    error[E0425]: cannot find value `prime_digits_count_3` in this scope\n  --> /tmp/tmpse9ve13t.rs:22:36\n\
    \   |\n22 |     let mut prime_digits_count_3 = prime_digits_count_3;\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `prime_digits_count_2`\n\nerror[E0425]: cannot find\
    \ value `prime_digits_count_4` in this scope\n  --> /tmp/tmpse9ve13t.rs:23:36\n\
    \   |\n23 |     let mut prime_digits_count_4 = prime_digits_count_4;\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `prime_digits_count_2`\n\nerror[E0425]: cannot find\
    \ value `prime_digits_count_5` in this scope\n  --> /tmp/tmpse9ve13t.rs:24:36\n\
    \   |\n24 |     let mut prime_digits_count_5 = prime_digits_count_5;\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `prime_digits_count_2`\n\nerror[E0425]: cannot find\
    \ value `prime_digits_count_6` in this scope\n  --> /tmp/tmpse9ve13t.rs:25:36\n\
    \   |\n25 |     let mut prime_digits_count_6 = prime_digits_count_6;\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `prime_digits_count_2`\n\nerror[E0425]: cannot find\
    \ value `prime_digits_count_7` in this scope\n  --> /tmp/tmpse9ve13t.rs:26:36\n\
    \   |\n26 |     let mut prime_digits_count_7 = prime_digits_count_7;\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `prime_digits_count_2`\n\nerror[E0425]: cannot find\
    \ value `prime_digits_count_8` in this scope\n  --> /tmp/tmpse9ve13t.rs:27:36\n\
    \   |\n27 |     let mut "
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157,\
    \ 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241,\
    \ 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347,\
    \ 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439,\
    \ 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547,\
    \ 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,\
    \ 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751,\
    \ 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,\
    \ 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,\
    \ 983, 991, 997];\n    let mut num_digits = num.chars().count();\n    let mut\
    \ num_digits_prime = num_digits;\n    let mut num_digits_prime_prime = 0;\n  \
    \  let mut num_digits_prime_prime_prime = 0;\n    let mut num_digits_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime = 0;\n    let mut\
    \ num_digits_prime_prime_prime_prime_prime_prime = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0et09rcv.rs:30:17\n   |\n\
    30 |     let mut num_\n   |                 ^ help: add `;` here\n31 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0et09rcv.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut digits = num.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut primes_set = primes.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_set.clone();\n\
    \    let mut primes_set = primes_set.clone();\n    let mut primes_set = primes_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8csfv4z4.rs:61:33\n   |\n\
    61 |     let mut primes_set = primes_\n   |                                 ^\
    \ help: add `;` here\n62 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `primes_` in this scope\n  --> /tmp/tmp8csfv4z4.rs:61:26\n   |\n\
    61 |     let mut primes_set = primes_\n   |                          ^^^^^^^ help:\
    \ a local variable with a similar name exists: `primes`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8csfv4z4.rs:17:28\n   |\n17 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num_digits = num.len();\n    let mut num_primes = 0;\n\
    \    let mut num_primes_found = 0;\n    let mut num_primes_found2 = 0;\n    let\
    \ mut num_primes_found3 = 0;\n    let mut num_primes_found4 = 0;\n    let mut\
    \ num_primes_found5 = 0;\n    let mut num_primes_found6 = 0;\n    let mut num_primes_found7\
    \ = 0;\n    let mut num_primes_found8 = 0;\n    let mut num_primes_found9 = 0;\n\
    \    let mut num_primes_found10 = 0;\n    let mut num_primes_found11 = 0;\n  \
    \  let mut num_primes_found12 = 0;\n    let mut num_primes_found13 = 0;\n    let\
    \ mut num_primes_found14 = 0;\n    let mut num_primes_found15 = 0;\n    let mut\
    \ num_primes_found16 = 0;\n    let mut num_primes_found17 = 0;\n    let mut num_primes_found18\
    \ = 0;\n    let mut num_primes_found19 = 0;\n    let mut num_primes_found20 =\
    \ 0;\n    let mut num_primes_found21 = 0;\n    let mut num_primes_found22 = 0;\n\
    \    let mut num_primes_found23 = 0;\n    let mut num_primes_found24 = 0;\n  \
    \  let mut num_primes_found25 = 0;\n    let mut num_primes_found26 = 0;\n    let\
    \ mut num_primes_found27 = 0;\n    let mut num_primes_found28 = 0;\n    let mut\
    \ num_primes_found29 = 0;\n    let mut num_primes_found30 = 0;\n    let mut num_primes_found31\
    \ = 0;\n    let mut num_primes_found32 = 0;\n    let mut num_primes_found33 =\
    \ 0;\n    let mut num_primes_found34 = 0;\n    let mut num_primes_found35 = 0;\n\
    \    let mut num_primes_found36 = 0;\n    let mut num_primes_found37 = 0;\n  \
    \  let mut num_primes_found38 = 0;\n    let mut num_primes_found39 = 0;\n    let\
    \ mut num_primes_found40 = 0;\n    let mut num_primes_found41 = 0;\n    let mut\
    \ num_primes_found42 = 0;\n    let mut num_primes_found43 = 0;\n    let mut num_primes_found44\
    \ = 0;\n    let mut num_primes_found45 = 0;\n    let mut num_primes_found46 =\
    \ 0;\n    let mut num_primes_found47 = 0;\n    let mut num_primes_found48 = 0;\n\
    \    let mut num_primes_found49 = 0;\n    let mut num_primes_found50 = 0;\n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvnj7cdyc.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = vec![false; 26];\n    let mut prime_digits\
    \ = vec![0; 26];\n    let mut prime_digit_counts = vec![0; 26];\n    let mut prime_digit_counts_index\
    \ = 0;\n    let mut prime_digit_counts_index2 = 0;\n    let mut prime_digit_counts_index3\
    \ = 0;\n    let mut prime_digit_counts_index4 = 0;\n    let mut prime_digit_counts_index5\
    \ = 0;\n    let mut prime_digit_counts_index6 = 0;\n    let mut prime_digit_counts_index7\
    \ = 0;\n    let mut prime_digit_counts_index8 = 0;\n    let mut prime_digit_counts_index9\
    \ = 0;\n    let mut prime_digit_counts_index10 = 0;\n    let mut prime_digit_counts_index11\
    \ = 0;\n    let mut prime_digit_counts_index12 = 0;\n    let mut prime_digit_counts_index13\
    \ = 0;\n    let mut prime_digit_counts_index14 = 0;\n    let mut prime_digit_counts_index15\
    \ = 0;\n    let mut prime_digit_counts_index16 = 0;\n    let mut prime_digit_counts_index17\
    \ = 0;\n    let mut prime_digit_counts_index18 = 0;\n    let mut prime_digit_counts_index19\
    \ = 0;\n    let mut prime_digit_counts_index20 = 0;\n    let mut prime_digit_counts_index21\
    \ = 0;\n    let mut prime_digit_counts_index22 = 0;\n    let mut prime_digit_counts_index23\
    \ = 0;\n    let mut prime_digit_counts_index24 = 0;\n    let mut prime_digit_counts_index25\
    \ = 0;\n    let mut prime_digit_counts_index26 = 0;\n    let mut prime_digit_counts_index27\
    \ = 0;\n    let mut prime_digit_counts_index28 = 0;\n    let mut prime_digit_counts_index29\
    \ = 0;\n    let mut prime_digit_counts_index30 = 0;\n    let mut prime_digit_counts_index31\
    \ = 0;\n    let mut prime_digit_counts_index32 = 0;\n    let mut prime_digit_counts_index33\
    \ = 0;\n    let mut prime_digit_counts_index34 = 0;\n    let mut prime_digit_counts_index35\
    \ = 0;\n    let mut prime_digit_counts_index36 = 0;\n    let mut prime_digit_counts_index37\
    \ = 0;\n    let mut prime_digit_counts_index38 = 0;\n    let mut prime_digit_counts_index39\
    \ = 0;\n    let mut prime_digit_counts_index\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjq4w95m8.rs:60:37\n   |\n\
    60 |     let mut prime_digit_counts_index\n   |                              \
    \       ^ help: add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjq4w95m8.rs:17:28\n   |\n17 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = vec![];\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count_max\
    \ = vec![];\n    let mut prime_digits_count_min = vec![];\n    let mut prime_digits_count_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_min = vec![];\n    let mut prime_digits_count_max_min_max\
    \ = vec![];\n    let mut prime_digits_count_min_min_max = vec![];\n    let mut\
    \ prime_digits_count_max_min_min_max = vec![];\n    let mut prime_digits_count_min_min_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_min_max_max = vec![];\n    let\
    \ mut prime_digits_count_min_min_max_max_max = vec![];\n    let mut prime_digits_count_min_min_max_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_min_max_max_max = vec![];\n  \
    \  let mut prime_digits_count_min_min_max_max_max_max = vec![];\n    let mut prime_digits_count_min_min_max_max_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_min_max_max_max_max = vec![];\n\
    \    let mut prime_digits_count_min_min_max_max_max_max = vec![];\n    let mut\
    \ prime_digits_count_min_min_max_max_max_max = vec![];\n    let mut prime_digits_count_min_min_max_max_max_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_min_max_max_max_max_max = vec![];\n\
    \    let mut prime_digits_count_min_min_max_max_max_max_max = vec![];\n    let\
    \ mut prime_digits_count_min_min_max_max_max_max_max = vec![];\n    let mut prime_digits_count_min_min_max_max_max_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_min_max_max_max_max_max = vec![];\n\
    \    let mut prime_digits_count_min_min_max_max_max_max_max = vec![];\n    let\
    \ mut prime_digits_count_min_min_max_max_max_max_max = vec![];\n    let mut prime_digits_count_min_min_max_max_max_max_max\
    \ = vec![];\n    let mut prime_digits_count_min_min_max_max_max_max_max = vec![];\n\
    \    let mut prime_digits_count_min_min_max_max_max_max_max = vec\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqeq6fb2a.rs:48:65\n   |\n\
    48 |     let mut prime_digits_count_min_min_max_max_max_max_max = vec\n   |  \
    \                                                               ^ help: add `;`\
    \ here\n49 | }\n   | - unexpected token\n\nerror[E0423]: expected value, found\
    \ macro `vec`\n  --> /tmp/tmpqeq6fb2a.rs:48:62\n   |\n48 |     let mut prime_digits_count_min_min_max_max_max_max_max\
    \ = vec\n   |                                                              ^^^\
    \ not a value\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqeq6fb2a.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0423.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count_max\
    \ = vec![];\n    let mut prime_digits_count_min = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkt0q0vrd.rs:55:32\n   |\n\
    55 |     let mut prime_digits_count_\n   |                                ^ help:\
    \ add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkt0q0vrd.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97];\n    let mut prime_digits_len = prime_digits.len();\n \
    \   let mut prime_digits_cap = prime_digits_len;\n    let mut prime_digits_cap_2\
    \ = prime_digits_cap * prime_digits_cap;\n    let mut prime_digits_cap_3 = prime_digits_cap_2\
    \ * prime_digits_cap;\n    let mut prime_digits_cap_4 = prime_digits_cap_3 * prime_digits_cap;\n\
    \    let mut prime_digits_cap_5 = prime_digits_cap_4 * prime_digits_cap;\n   \
    \ let mut prime_digits_cap_6 = prime_digits_cap_5 * prime_digits_cap;\n    let\
    \ mut prime_digits_cap_7 = prime_digits_cap_6 * prime_digits_cap;\n    let mut\
    \ prime_digits_cap_8 = prime_digits_cap_7 * prime_digits_cap;\n    let mut prime_digits_cap_9\
    \ = prime_digits_cap_8 * prime_digits_cap;\n    let mut prime_digits_cap_10 =\
    \ prime_digits_cap_9 * prime_digits_cap;\n    let mut prime_digits_cap_11 = prime_digits_cap_10\
    \ * prime_digits_cap;\n    let mut prime_digits_cap_12 = prime_digits_cap_11 *\
    \ prime_digits_cap;\n    let mut prime_digits_cap_13 = prime_digits_cap_12 * prime_digits_cap;\n\
    \    let mut prime_digits_cap_14 = prime_digits_cap_13 * prime_digits_cap;\n \
    \   let mut prime_digits_cap_15 = prime_digits_cap_14 * prime_digits_cap;\n  \
    \  let mut prime_digits_cap_16 = prime_digits_cap_15 * prime_digits_cap;\n   \
    \ let mut prime_digits_cap_17 = prime_digits_cap_16 * prime_digits_cap;\n    let\
    \ mut prime_digits_cap_18 = prime_digits_cap_17 * prime_digits_cap;\n    let mut\
    \ prime_digits_cap_19 = \n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpzyz1jplj.rs:40:1\n\
    \   |\n40 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut digits = num.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ digits_len = digits.length;\n    while digits_len > 0 {\n        let mut digit\
    \ = digits[digits_len - 1];\n        digits_len -= 1;\n        if digit == 'A'\
    \ || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit ==\
    \ 'F' {\n            prime_digits.push_back(digit);\n        }\n        if digit\
    \ == '0' {\n            prime_digits.push_back(digit);\n        }\n    }\n   \
    \ for digit in prime_digits {\n        prime_count += 1;\n    }\n    prime_count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `length` on type `Vec<char>`\n  --> /tmp/tmpb20h3yk1.rs:21:33\n\
    \   |\n21 |     let mut digits_len = digits.length;\n   |                    \
    \             ^^^^^^ unknown field\n\nerror[E0599]: no method named `push_back`\
    \ found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpb20h3yk1.rs:26:26\n\
    \   |\n26 |             prime_digits.push_back(digit);\n   |                 \
    \         ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named\
    \ `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpb20h3yk1.rs:29:26\n\
    \   |\n29 |             prime_digits.push_back(digit);\n   |                 \
    \         ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_vec();\n    let mut prime: Vec<u8>\
    \ = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97];\n    let mut prime_counter: usize = 0;\n    let mut\
    \ prime_counter2: usize = 0;\n    let mut prime_counter3: usize = 0;\n    let\
    \ mut prime_counter4: usize = 0;\n    let mut prime_counter5: usize = 0;\n   \
    \ let mut prime_counter6: usize = 0;\n    let mut prime_counter7: usize = 0;\n\
    \    let mut prime_counter8: usize = 0;\n    let mut prime_counter9: usize = 0;\n\
    \    let mut prime_counter10: usize = 0;\n    let mut prime_counter11: usize =\
    \ 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13: usize\
    \ = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let \n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpmhj2sbsz.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror[E0599]: no method named `to_vec`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpmhj2sbsz.rs:18:32\n\
    \   |\n18 |     let mut num: Vec<u8> = num.to_vec();\n   |                   \
    \             ^^^^^^ method not found in `String`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = vec![false; 10];\n    let mut prime_digits\
    \ = vec![0; 10];\n    let mut prime_digits_count = vec![0; 10];\n    let mut prime_digits_count_index\
    \ = 0;\n    let mut prime_digits_count_index2 = 0;\n    let mut prime_digits_count_index3\
    \ = 0;\n    let mut prime_digits_count_index4 = 0;\n    let mut prime_digits_count_index5\
    \ = 0;\n    let mut prime_digits_count_index6 = 0;\n    let mut prime_digits_count_index7\
    \ = 0;\n    let mut prime_digits_count_index8 = 0;\n    let mut prime_digits_count_index9\
    \ = 0;\n    let mut prime_digits_count_index10 = 0;\n    let mut prime_digits_count_index11\
    \ = 0;\n    let mut prime_digits_count_index12 = 0;\n    let mut prime_digits_count_index13\
    \ = 0;\n    let mut prime_digits_count_index14 = 0;\n    let mut prime_digits_count_index15\
    \ = 0;\n    let mut prime_digits_count_index16 = 0;\n    let mut prime_digits_count_index17\
    \ = 0;\n    let mut prime_digits_count_index18 = 0;\n    let mut prime_digits_count_index19\
    \ = 0;\n    let mut prime_digits_count_index20 = 0;\n    let mut prime_digits_count_index21\
    \ = 0;\n    let mut prime_digits_count_index22 = 0;\n    let mut prime_digits_count_index23\
    \ = 0;\n    let mut prime_digits_count_index24 = 0;\n    let mut prime_digits_count_index25\
    \ = 0;\n    let mut prime_digits_count_index26 = 0;\n    let mut prime_digits_count_index27\
    \ = 0;\n    let mut prime_digits_count_index28 = 0;\n    let mut prime_digits_count_index29\
    \ = 0;\n    let mut prime_digits_count_index30 = 0;\n    let mut prime_digits_count_index31\
    \ = 0;\n    let mut prime_digits_count_index32 = 0;\n    let mut prime_digits_count_index33\
    \ = 0;\n    let mut prime_digits_count_index34 = 0;\n    let mut prime_digits_count_index35\
    \ = 0;\n    let mut prime_digits_count_index36 = 0;\n    let mut prime_digits_count_index37\
    \ = 0;\n    let mut prime_digits_count_index38 = 0;\n    let mut prime_digits_count_index39\
    \ = 0;\n    let mut prime_digits_count_index\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpja5nta2y.rs:60:37\n   |\n\
    60 |     let mut prime_digits_count_index\n   |                              \
    \       ^ help: add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpja5nta2y.rs:17:28\n   |\n17 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num_digits = num.chars().count();\n    let mut prime_digits\
    \ = vec![];\n    let mut prime_digits_count = vec![];\n    let mut prime_digits_count_max\
    \ = vec![];\n    let mut prime_digits_count_min = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_value\
    \ = vec![];\n    let mut prime_digits_count_min_value = vec![];\n    let mut prime_digits_count_max_value_pos\
    \ = vec![];\n    let mut prime_digits_count_min_value_pos = vec![];\n    let mut\
    \ prime_digits_count_max_value_neg = vec![];\n    let mut prime_digits_count_min_value_neg\
    \ = vec![];\n    let mut prime_digits_count_max_value_pos_neg = vec![];\n    let\
    \ mut prime_digits_count_min_value_pos_neg = vec![];\n    let mut prime_digits_count_max_value_neg_pos\
    \ = vec![];\n    let mut prime_digits_count_min_value_neg_pos = vec![];\n    let\
    \ mut prime_digits_count_max_value_neg_neg = vec![];\n    let mut prime_digits_count_min_value_neg_neg\
    \ = vec![];\n    let mut prime_digits_count_max_value_pos_pos_neg = vec![];\n\
    \    let mut prime_digits_count_min_value_pos_pos_neg = vec![];\n    let mut prime_digits_count_max_value_neg_pos_neg\
    \ = vec![];\n    let mut prime_digits_count_min_value_neg_pos_neg = vec![];\n\
    \    let mut prime_digits_count_max_value_pos_neg_neg = vec![];\n    let mut prime_digits_count_min_value_pos_neg_neg\
    \ = vec![];\n    let mut prime_digits_count_max_value_neg_neg_pos = vec![];\n\
    \    let mut prime_digits_count_min_value_neg_neg_pos = vec![];\n    let mut prime_digits_count_max_value_neg_neg_neg\
    \ = vec![];\n    let mut prime_digits_count_min_value_neg_neg_neg = vec![];\n\
    \    let mut prime_digits_count_max_value_pos_pos_neg_neg = vec![];\n    let mut\
    \ prime_digits_count_min_value_pos_pos_neg_neg = vec![];\n    let mut prime_digits_count_max_value_neg_pos_neg_neg\
    \ = vec![];\n    let mut prime_digits_count_min_value_neg_pos_neg_neg = \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmprzlabz3c.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count_max\
    \ = vec![];\n    let mut prime_digits_count_min = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len_prime\
    \ = vec![];\n    let mut prime_digits_count_min_len_prime = vec![];\n    let mut\
    \ prime_digits_count_max_len_not_prime = vec![];\n    let mut prime_digits_count_min_len_not_prime\
    \ = vec![];\n    let mut prime_digits_count_max_len_not_prime_prime = vec![];\n\
    \    let mut prime_digits_count_min_len_not_prime_prime = vec![];\n    let mut\
    \ prime_digits_count_max_len_not_prime_not_prime = vec![];\n    let mut prime_digits_count_min_len_not_prime_not_prime\
    \ = vec![];\n    let mut prime_digits_count_max_len_not_prime_not_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_min_len_not_prime_not_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_max_len_not_prime_not_prime_not_prime\
    \ = vec![];\n    let mut prime_digits_count_min_len_not_prime_not_prime_not_prime\
    \ = vec![];\n    let mut prime_digits_count_max_len_not_prime_not_prime_not_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_min_len_not_prime_not_prime_not_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_max_len_not_prime_not_prime_not_prime_not_prime\
    \ = vec![];\n    let mut prime_digits_count_min_len_not_prime_not_prime_not_prime_not_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_max_len_not_prime_not_prime_not_prime_not_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_min_len_not_prime_not_prime_not_prime_not_prime_not_prime\
    \ = vec![];\n    let mut prime_digits_count_max_len_not_prime_not_prime_not_prime_not_prime_not_prime_prime\
    \ = vec![];\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphok1ybeh.rs:44:11\n   |\n\
    44 |     let mu\n   |           ^ help: add `;` here\n45 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphok1ybeh.rs:17:28\n \
    \  |\n17 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_sum: isize = 0;\n\
    \    let mut prime_digit_sum2: isize = 0;\n    let mut prime_digit_sum3: isize\
    \ = 0;\n    let mut prime_digit_sum4: isize = 0;\n    let mut prime_digit_sum5:\
    \ isize = 0;\n    let mut prime_digit_sum6: isize = 0;\n    let mut prime_digit_sum7:\
    \ isize = 0;\n    let mut prime_digit_sum8: isize = 0;\n    let mut prime_digit_sum9:\
    \ isize = 0;\n    let mut prime_digit_sum10: isize = 0;\n    let mut prime_digit_sum11:\
    \ isize = 0;\n    let mut prime_digit_sum12: isize = 0;\n    let mut prime_digit_sum13:\
    \ isize = 0;\n    let mut prime_digit_sum14: isize = 0;\n    let mut prime_digit_sum15:\
    \ isize = 0;\n    let mut prime_digit_sum16: isize = 0;\n    let mut prime_digit_sum17:\
    \ isize = 0;\n    let mut prime_digit_sum18: isize = 0;\n    let mut prime_digit_sum19:\
    \ isize = 0;\n    let mut prime_digit_sum20: isize = 0;\n    let mut prime_digit_sum21:\
    \ isize = 0;\n    let mut prime_digit_sum22: isize = 0;\n    let mut prime_digit_sum23:\
    \ isize = 0;\n    let mut prime_digit_sum24: isize = 0;\n    let mut prime_digit_sum25:\
    \ isize = 0;\n    let mut prime_digit_sum26: isize = 0;\n    let mut prime_digit_sum27:\
    \ isize = 0;\n    let mut prime_digit_sum28: isize = 0;\n    let mut prime_digit_sum29:\
    \ isize = 0;\n    let mut prime_digit_sum30: isize = 0;\n    let mut prime_digit_sum31:\
    \ isize = 0;\n    let mut prime_digit_sum32: isize = 0;\n    let mut prime_digit_sum33:\
    \ isize = 0;\n    let mut prime_digit_sum34: isize = 0;\n    let mut prime_digit_sum35:\
    \ isize = 0;\n    let mut prime_digit_sum36: isize = 0;\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq9vw6bb1.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmpq9vw6bb1.rs:18:55\n     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<usize> = num.to_vec();\n    let mut prime_count:\
    \ usize = 0;\n    let mut prime_digit: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprbxi1roe.rs:64:11\n   |\n\
    64 |     let mu\n   |           ^ help: add `;` here\n65 | }\n   | - unexpected\
    \ token\n\nerror[E0599]: no method named `to_vec` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmprbxi1roe.rs:18:35\n   |\n18 |     let mut num:\
    \ Vec<usize> = num.to_vec();\n   |                                   ^^^^^^ method\
    \ not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprbxi1roe.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut prime_digits_len = prime_digits.len();\n    let\
    \ mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp6e2jcck7.rs:54:1\n  \
    \ |\n54 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut digits = num.chars().map(|c|\
    \ match c {\n        'A'..='F' => c - 'A' + 1,\n        'a'..='f' => c - 'a' +\
    \ 1,\n        _ => 0,\n    });\n    let mut primes = vec![true; 16];\n    primes[0]\
    \ = false;\n    primes[1] = false;\n    primes[2] = false;\n    primes[3] = false;\n\
    \    primes[4] = false;\n    primes[5] = false;\n    primes[6] = false;\n    primes[7]\
    \ = false;\n    primes[8] = false;\n    primes[9] = false;\n    primes[10] = false;\n\
    \    primes[11] = false;\n    primes[12] = false;\n    primes[13] = false;\n \
    \   primes[14] = false;\n    primes[15] = false;\n    primes[16] = false;\n  \
    \  primes[17] = false;\n    primes[18] = false;\n    primes[19] = false;\n   \
    \ primes[20] = false;\n    primes[21] = false;\n    primes[22] = false;\n    primes[23]\
    \ = false;\n    primes[24] = false;\n    primes[25] = false;\n    primes[26] =\
    \ false;\n    primes[27] = false;\n    primes[28] = false;\n    primes[29] = false;\n\
    \    primes[30] = false;\n    primes[31] = false;\n    primes[32] = false;\n \
    \   primes[33] = false;\n    primes[34] = false;\n    primes[35] = false;\n  \
    \  primes[36] = false;\n    primes[37] = false;\n    primes[38] = false;\n   \
    \ primes[39] = false;\n    primes[40] = false;\n    primes[41] = false;\n    primes[42]\
    \ = false;\n    primes[43] = false;\n    primes[44] = false;\n    primes[45] =\
    \ false;\n    primes[46] = false;\n    primes[47] = false;\n    primes[48] = false;\n\
    \    primes[49] = false;\n    primes[50] = false;\n    primes[51] = false;\n \
    \   primes[52] = false;\n    primes[53] = false;\n    primes[54] = false;\n  \
    \  primes[55] = false;\n    primes[56] = false;\n    primes[57] = false;\n   \
    \ primes[58] = false;\n    primes[59] = false;\n    primes[60] = false;\n    primes[61]\
    \ = false;\n    primes[62] = false;\n    primes[63] = false;\n    primes[64\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpavyezgpt.rs:89:11\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n89 |     primes[64\n\
    \   |           ^ unclosed delimiter\n90 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpavyezgpt.rs:20:24\n\
    \   |\n20 |         'A'..='F' => c - 'A' + 1,\n   |                      - ^ ---\
    \ char\n   |                      |\n   |                      char\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmpavyezgpt.rs:21:24\n   |\n\
    21 |         'a'..='f' => c - 'a' + 1,\n   |                      - ^ --- char\n\
    \   |                      |\n   |                      char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpavyezgpt.rs:89:5\n   |\n17 |   fn hex_key(num:\
    \ String) -> isize {\n   |                              ----- expected `isize`\
    \ because of return type\n...\n89 | /     primes[64\n90 | | }\n   | |_^ expected\
    \ `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0369.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut\
    \ primes = vec![false; 26];\n    let mut primes_counter = 0;\n    let mut primes_counter2\
    \ = 0;\n    let mut primes_counter3 = 0;\n    let mut primes_counter4 = 0;\n \
    \   let mut primes_counter5 = 0;\n    let mut primes_counter6 = 0;\n    let mut\
    \ primes_counter7 = 0;\n    let mut primes_counter8 = 0;\n    let mut primes_counter9\
    \ = 0;\n    let mut primes_counter10 = 0;\n    let mut primes_counter11 = 0;\n\
    \    let mut primes_counter12 = 0;\n    let mut primes_counter13 = 0;\n    let\
    \ mut primes_counter14 = 0;\n    let mut primes_counter15 = 0;\n    let mut primes_counter16\
    \ = 0;\n    let mut primes_counter17 = 0;\n    let mut primes_counter18 = 0;\n\
    \    let mut primes_counter19 = 0;\n    let mut primes_counter20 = 0;\n    let\
    \ mut primes_counter21 = 0;\n    let mut primes_counter22 = 0;\n    let mut primes_counter23\
    \ = 0;\n    let mut primes_counter24 = 0;\n    let mut primes_counter25 = 0;\n\
    \    let mut primes_counter26 = 0;\n    let mut primes_counter27 = 0;\n    let\
    \ mut primes_counter28 = 0;\n    let mut primes_counter29 = 0;\n    let mut primes_counter30\
    \ = 0;\n    let mut primes_counter31 = 0;\n    let mut primes_counter32 = 0;\n\
    \    let mut primes_counter33 = 0;\n    let mut primes_counter34 = 0;\n    let\
    \ mut primes_counter35 = 0;\n    let mut primes_counter36 = 0;\n    let mut primes_counter37\
    \ = 0;\n    let mut primes_counter38 = 0;\n    let mut primes_counter39 = 0;\n\
    \    let mut primes_counter40 = 0;\n    let mut primes_counter41 = 0;\n    let\
    \ mut primes_counter42 = 0;\n    let mut primes_counter43 = 0;\n    let mut primes_counter44\
    \ = 0;\n    let mut primes_counter45 = 0;\n    let mut primes_counter46 = 0;\n\
    \    let mut primes_counter47 = 0;\n    let mut primes_counter48 = 0;\n    let\
    \ mut primes_counter49 = 0;\n    let mut primes_counter50 = 0;\n    let mut primes_counter51\
    \ = 0;\n    let mut primes_counter52 = 0;\n    let mut primes_counter53 = 0;\n\
    \    let mut primes_counter54 = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbkdwslue.rs:74:11\n   |\n\
    74 |     let mu\n   |           ^ help: add `;` here\n75 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbkdwslue.rs:17:28\n \
    \  |\n17 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97];\n    let mut digits = num.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.length;\n    let mut prime_digits_len = prime_digits.length;\n\
    \    let mut prime_digits_count = prime_digits_len;\n    let mut prime_digits_count_index\
    \ = 0;\n    let mut prime_digits_count_index2 = 0;\n    let mut prime_digits_count_index3\
    \ = 0;\n    let mut prime_digits_count_index4 = 0;\n    let mut prime_digits_count_index5\
    \ = 0;\n    let mut prime_digits_count_index6 = 0;\n    let mut prime_digits_count_index7\
    \ = 0;\n    let mut prime_digits_count_index8 = 0;\n    let mut prime_digits_count_index9\
    \ = 0;\n    let mut prime_digits_count_index10 = 0;\n    let mut prime_digits_count_index11\
    \ = 0;\n    let mut prime_digits_count_index12 = 0;\n    let mut prime_digits_count_index13\
    \ = 0;\n    let mut prime_digits_count_index14 = 0;\n    let mut prime_digits_count_index15\
    \ = 0;\n    let mut prime_digits_count_index16 = 0;\n    let mut prime_digits_count_index17\
    \ = 0;\n    let mut prime_digits_count_index18 = 0;\n    let mut prime_digits_count_index19\
    \ = 0;\n    let mut prime_digits_count_index20 = 0;\n    let mut prime_digits_count_index21\
    \ = 0;\n    let mut prime_digits_count_index22 = 0;\n    let mut prime_digits_count_index23\
    \ = 0;\n    let mut prime_digits_count_index24 = 0;\n    let mut prime_digits_count_index25\
    \ = 0;\n    let mut prime_digits_count_index26 = 0;\n    let mut prime_digits_count_index27\
    \ = 0;\n    let mut prime_digits_count_index28 = 0;\n    let mut prime_digits_count_index29\
    \ = 0;\n    let mut prime_digits_count_index30 = 0;\n    let mut prime_digits_count_index31\
    \ = 0;\n    let mut prime_digits_count_index32 = 0;\n    let mut prime_digits_count_index33\
    \ = 0;\n    let mut prime_digits_count_index34 = 0;\n    let mut prime_\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaz7ndi8_.rs:58:19\n   |\n\
    58 |     let mut prime_\n   |                   ^ help: add `;` here\n59 | }\n\
    \   | - unexpected token\n\nerror[E0609]: no field `length` on type `Vec<char>`\n\
    \  --> /tmp/tmpaz7ndi8_.rs:21:33\n   |\n21 |     let mut digits_len = digits.length;\n\
    \   |                                 ^^^^^^ unknown field\n\nerror[E0609]: no\
    \ field `length` on type `Vec<{integer}>`\n  --> /tmp/tmpaz7ndi8_.rs:22:45\n \
    \  |\n22 |     let mut prime_digits_len = prime_digits.length;\n   |         \
    \                                    ^^^^^^ unknown field\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpaz7ndi8_.rs:17:28\n   |\n17 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0609.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3];\n    let mut num_prime_2: Vec<u8>\
    \ = vec![2, 3, 5];\n    let mut num_prime_3: Vec<u8> = vec![2, 3, 5, 7];\n   \
    \ let mut num_prime_4: Vec<u8> = vec![2, 3, 5, 7, 11];\n    let mut num_prime_5:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13];\n    let mut num_prime_6: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17];\n    let mut num_prime_7: Vec<u8> = vec![2, 3, 5, 7, 11,\
    \ 13, 17, 19];\n    let mut num_prime_8: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23];\n    let mut num_prime_9: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29];\n    let mut num_prime_10: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29, 31];\n    let mut num_prime_11: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37];\n    let mut num_prime_12: Vec<u8> = vec![2, 3, 5, 7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41];\n    let mut num_prime_13: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 45];\n    let mut num_prime_14:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 45, 49];\n  \
    \  let mut num_prime_15: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 45, 49, 53];\n    let mut num_prime_16: Vec<u8> = vec![2, 3, 5, 7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, 45, 49, 53, 57];\n    let mut num_prime_17:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 45, 49, 53, 57,\
    \ 61];\n    let mut num_prime_18: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 45, 49, 53, 57, 61, 65];\n    let mut num_prime_19: Vec<u8>\
    \ = vec![2, 3, 5, 7, \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmphgwszb5c.rs:37:41\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n37 |     let mut num_prime_19:\
    \ Vec<u8> = vec![2, 3, 5, 7, \n   |                                         ^\
    \ unclosed delimiter\n38 | }\n   | ^ mismatched closing delimiter\n\nerror: expected\
    \ one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmphgwszb5c.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\n\
    error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmphgwszb5c.rs:18:55\n     |\n18   | \
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |    \
    \                                                   ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: isize = num.chars().filter(|c| c >= '0' && c <=\
    \ '9').count();\n    let mut prime: isize = 2;\n    let mut remainder: isize =\
    \ 0;\n    while prime < num {\n        remainder = num % prime;\n        if remainder\
    \ == 0 {\n            prime++;\n        }\n        num = num / prime;\n    }\n\
    \    prime\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpwi3elnuk.rs:24:18\n\
    \   |\n24 |             prime++;\n   |                  ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n24 |             { let tmp =\
    \ prime; prime += 1; tmp };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n\
    24 -             prime++;\n24 +             prime += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwi3elnuk.rs:18:54\n   |\n18 |     let mut num:\
    \ isize = num.chars().filter(|c| c >= '0' && c <= '9').count();\n   |        \
    \                                              ^^^\n   |                     \
    \                                 |\n   |                                    \
    \                  expected `&char`, found `char`\n   |                      \
    \                                help: consider borrowing here: `&'0'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwi3elnuk.rs:18:66\n   |\n18 |     let mut num:\
    \ isize = num.chars().filter(|c| c >= '0' && c <= '9').count();\n   |        \
    \                                                          ^^^\n   |         \
    \                                                         |\n   |            \
    \                                                      expected `&char`, found\
    \ `char`\n   |                                                               \
    \   help: consider borrowing here: `&'9'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwi3elnuk.rs:18:26\n   |\n18 |     let mut num: isize = num.chars().filter(|c|\
    \ c >= '0' && c <= '9').count();\n   |                  -----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |                  |\n   |             \
    \     expected due to this\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |     let mut num: isize\
    \ = num.chars().filter(|c| c >= '0' && c <= '9').count().try_into().unwrap();\n\
    \   |                                                                        \
    \      ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nFor\
    \ more information about"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut num_digits = num.len();\n\
    \    let mut num_digits_prime = 0;\n    let mut num_digits_not_prime = 0;\n  \
    \  let mut num_digits_not_prime_prime = 0;\n    let mut num_digits_not_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime = 0;\n    let mut num_digits_not_prime_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime = 0;\n    let mut num_digits_not_prime_prime_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime = 0;\n    let\
    \ mut num_digits_not_prime_prime_prime_prime_not_prime = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_not_prime = 0;\n\
    \    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime = 0;\n \
    \   let mut num_digits_not_prime_prime_prime_prime_prime_prime_not_prime = 0;\n\
    \    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime =\
    \ 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzan4elbw.rs:42:111\n   |\n\
    42 |     let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\n\
    \   |                                                                        \
    \                                       ^ help: add `;` here\n43 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzan4elbw.rs:17:28\n \
    \  |\n17 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set_size\
    \ = prime_digits_set.len();\n    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n\
    \    let mut prime_digits_set_iter_next = prime_digits_set_iter.next();\n    let\
    \ mut prime_digits_set_iter_next_next = prime_digits_set_iter_next.next();\n \
    \   let mut prime_digits_set_iter_next_next_next = prime_digits_set_iter_next_next.next();\n\
    \    let mut prime_digits_set_iter_next_next_next_next = prime_digits_set_iter_next_next_next.next();\n\
    \    let mut prime_digits_set_iter_next_next_next_next_next = prime_digits_set_iter_next_next_next_next.next();\n\
    \    let mut prime_digits_set_iter_next_next_next_next_next_next = prime_digits_set_iter_next_next_next_next_next.next();\n\
    \    let mut prime_digits_set_iter_next_next_next_next_next_next_next = prime_digits_set_iter_next_next_next_next_next_next.next();\n\
    \    let mut prime_digits_set_iter_next_next_next_next_next_next_next_next = prime_digits_set_iter_next_next_next_next_next_next_next.next();\n\
    \    let mut prime_digits_set_iter_next_next_next_next_next_next_next_next_next\
    \ = prime_digits_set_iter_next_next_next_next_next_next_next_next.next();\n  \
    \  let mut prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next\
    \ = prime_digits_set_iter_next_next_next_next_next_next_next_next_next.next();\n\
    \    let mut prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next_next\
    \ = prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next_next.next();\n\
    \    let mut prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next_next_next_next.next();\n\
    \    let mut prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next_next_next_next.next();\n\
    \    let mut prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next.next();\n\
    \    let mut \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp_2hh1l87.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected identifier\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmp_2hh1l87.rs:20:32\n   |\n20\
    \ |     let mut prime_digits_set = HashSet::new();\n   |                     \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot\
    \ find value `prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next_next`\
    \ in this scope\n  --> /tmp/tmp_2hh1l87.rs:33:92\n   |\n33 | ..._next_next_next_next\
    \ = prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next_next.next();\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next`\n\
    \nerror[E0425]: cannot find value `prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next_next_next_next`\
    \ in this scope\n  --> /tmp/tmp_2hh1l87.rs:34:97\n   |\n34 | ...t_next_next_next\
    \ = prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next_next_next_next.next();\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next_next`\n\
    \nerror[E0425]: cannot find value `prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next_next_next_next`\
    \ in this scope\n  --> /tmp/tmp_2hh1l87.rs:35:102\n   |\n35 | ...t_next_next_next\
    \ = prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next_next_next_next.next();\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `prime_digits_set_iter_next_next_next_next_next_next_next_next_next_next_next_next`\n\
    \nerror[E0425]: cannot find value"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_index: isize = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value_count:\
    \ isize = 0;\n    let mut prime_digit_value_is_prime: isize = 0;\n    let mut\
    \ prime_digit_value_is_prime_count: isize = 0;\n    let mut prime_digit_value_is_prime_digit:\
    \ u8 = 0;\n    let mut prime_digit_value_is_prime_digit_count: isize = 0;\n  \
    \  let mut prime_digit_value_is_prime_digit_index: isize = 0;\n    let mut prime_digit_value_is_prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value_is_prime_digit_value_count: isize = 0;\n\
    \    let mut prime_digit_value_is_prime_digit_value_is_prime: isize = 0;\n   \
    \ let mut prime_digit_value_is_prime_digit_value_is_prime_count: isize = 0;\n\
    \    let mut prime_digit_value_is_prime_digit_value_is_prime_digit: u8 = 0;\n\
    \    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_count: isize\
    \ = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value_count:\
    \ isize = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value_is_prime:\
    \ isize = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value_is_prime_count:\
    \ isize = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value_is_prime_digit:\
    \ u8 = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value_is_prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value_is_prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value_is_prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value_is_prime_digit_value_count:\
    \ isize = 0;\n\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3o2wl97a.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmp3o2wl97a.rs:18:55\n     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_index: isize = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value_index:\
    \ isize = 0;\n    let mut prime_digit_value_count: isize = 0;\n    let mut prime_digit_value_is_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_is_prime_index: isize = 0;\n    let mut\
    \ prime_digit_value_is_prime_count: isize = 0;\n    let mut prime_digit_value_is_prime_digit:\
    \ u8 = 0;\n    let mut prime_digit_value_is_prime_digit_index: isize = 0;\n  \
    \  let mut prime_digit_value_is_prime_digit_value: u8 = 0;\n    let mut prime_digit_value_is_prime_digit_value_index:\
    \ isize = 0;\n    let mut prime_digit_value_is_prime_digit_value_count: isize\
    \ = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime: u8 = 0;\n\
    \    let mut prime_digit_value_is_prime_digit_value_is_prime_index: isize = 0;\n\
    \    let mut prime_digit_value_is_prime_digit_value_is_prime_count: isize = 0;\n\
    \    let mut prime_digit_value_is_prime_digit_value_is_prime_digit: u8 = 0;\n\
    \    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_index: isize\
    \ = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value_index:\
    \ isize = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value_count:\
    \ isize = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value_is_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value_is_prime_index:\
    \ isize = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value_is_prime_count:\
    \ isize = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value_is_prime_digit:\
    \ u8 = 0;\n    let mut prime_digit_value_is_prime_digit_value_is_prime_digit_value_is_prime_digit_index:\
    \ isize = 0;\n    let mut prime\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzp1_p8_m.rs:47:18\n   |\n\
    47 |     let mut prime\n   |                  ^ help: add `;` here\n48 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzp1_p8_m.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmpzp1_p8_m.rs:18:55\n     |\n18   |     let mut num: Vec<u8> =\
    \ num.to_lowercase().chars().collect();\n     |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: isize = 0;\n    let mut num_str: String = num.to_string();\n\
    \    let mut num_str: Vec<String> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<String> = num_str.chars().collect();\n    let mut num_str: Vec<String> =\
    \ num_str.chars().collect();\n    let mut num_str: Vec<String> = num_str.chars().collect();\n\
    \    let mut num_str: Vec<String> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<String> = num_str.chars().collect();\n    let mut num_str: Vec<String> =\
    \ num_str.chars().collect();\n    let mut num_str: Vec<String> = num_str.chars().collect();\n\
    \    let mut num_str: Vec<String> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<String> = num_str.chars().collect();\n    let mut num_str: Vec<String> =\
    \ num_str.chars().collect();\n    let mut num_str: Vec<String> = num_str.chars().collect();\n\
    \    let mut num_str: Vec<String> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<String> = num_str.chars().collect();\n    let mut num_str: Vec<String> =\
    \ num_str.chars().collect();\n    let mut num_str: Vec<String> = num_str.chars().collect();\n\
    \    let mut num_str: Vec<String> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<String> = num_str.chars().collect();\n    let mut num_str: Vec<String> =\
    \ num_str.chars().collect();\n    let mut num_str: Vec<String> = num_str.chars().collect();\n\
    \    let mut num_str: Vec<String> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<String> = num_str.chars().collect();\n    let mut num_str: Vec<String> =\
    \ num_str.chars().collect();\n    let mut num_str: Vec<String> = num_str.chars().collect();\n\
    \    let mut num_str: Vec<String> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<String> = num_str.chars().collect();\n    let mut num_str: Vec<String> =\
    \ num_str.chars().collect();\n    let mut num_str\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg30y96f3.rs:47:20\n   |\n\
    47 |     let mut num_str\n   |                    ^ help: add `;` here\n48 | }\n\
    \   | - unexpected token\n\nerror[E0599]: no method named `chars` found for struct\
    \ `Vec<String>` in the current scope\n  --> /tmp/tmpg30y96f3.rs:21:44\n   |\n\
    21 |     let mut num_str: Vec<String> = num_str.chars().collect();\n   |     \
    \                                       ^^^^^ method not found in `Vec<String>`\n\
    \nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpg30y96f3.rs:20:52\n     |\n20\
    \   |     let mut num_str: Vec<String> = num_str.chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `chars` found for struct\
    \ `Vec<String>` in the current scope\n  --> /tmp/tmpg30y96f3.rs:22:44\n   |\n\
    22 |     let mut num_str: Vec<String> = num_str.chars().collect();\n   |     \
    \                                       ^^^^^ method not found in `Vec<String>`\n\
    \nerror[E0599]: no method named `chars` found for struct `Vec<String>` in the\
    \ current scope\n  --> /tmp/tmpg30y96f3.rs:23:44\n   |\n23 |     let mut num_str:\
    \ Vec<String> = num_str.chars().collect();\n   |                             \
    \               ^^^^^ method not found in `Vec<String>`\n\nerror[E0599]: no method\
    \ named `chars` found for struct `Vec<String>` in the current scope\n  --> /tmp/tmpg30y96f3.rs:24:44\n\
    \   |\n24 |     let mut num_str: Vec<String> = num_str.chars().collect();\n  \
    \ |                                            ^^^^^ method not found in `Vec<String>`\n\
    \nerror[E0599]: no method named `chars` found for struct `Vec<String>` in the\
    \ current scope\n  --> /tmp/tmpg30y96f3.rs:25:44\n   |\n25 |     let mut num_str:\
    \ Vec<String> = num_str.chars().co"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = vec![false; 26];\n    let mut prime_digits\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_digit_count\
    \ = vec![0; 26];\n    let mut prime_digit_count = vec![0; 26];\n    let mut prime_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4ora4i_7.rs:57:19\n   |\n\
    57 |     let mut prime_\n   |                   ^ help: add `;` here\n58 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4ora4i_7.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set_size\
    \ = prime_digits_set.len();\n    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let\
    \ mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter\
    \ = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let\
    \ mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter\
    \ = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let\
    \ mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter\
    \ = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let\
    \ mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter\
    \ = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let\
    \ mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter\
    \ = prime_digits_set.iter().cloned();\n    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n\
    \    let mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let\
    \ mut prime_digits_set_iter = prime_digits_set.iter().cloned();\n    let mut \n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp3gxnk83q.rs:46:1\n\
    \   |\n46 | }\n   | ^ expected identifier\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmp3gxnk83q.rs:20:32\n   |\n20\
    \ |     let mut prime_digits_set = HashSet::new();\n   |                     \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_sum: isize = 0;\n\
    \    let mut prime_digit_sum2: isize = 0;\n    let mut prime_digit_sum3: isize\
    \ = 0;\n    let mut prime_digit_sum4: isize = 0;\n    let mut prime_digit_sum5:\
    \ isize = 0;\n    let mut prime_digit_sum6: isize = 0;\n    let mut prime_digit_sum7:\
    \ isize = 0;\n    let mut prime_digit_sum8: isize = 0;\n    let mut prime_digit_sum9:\
    \ isize = 0;\n    let mut prime_digit_sum10: isize = 0;\n    let mut prime_digit_sum11:\
    \ isize = 0;\n    let mut prime_digit_sum12: isize = 0;\n    let mut prime_digit_sum13:\
    \ isize = 0;\n    let mut prime_digit_sum14: isize = 0;\n    let mut prime_digit_sum15:\
    \ isize = 0;\n    let mut prime_digit_sum16: isize = 0;\n    let mut prime_digit_sum17:\
    \ isize = 0;\n    let mut prime_digit_sum18: isize = 0;\n    let mut prime_digit_sum19:\
    \ isize = 0;\n    let mut prime_digit_sum20: isize = 0;\n    let mut prime_digit_sum21:\
    \ isize = 0;\n    let mut prime_digit_sum22: isize = 0;\n    let mut prime_digit_sum23:\
    \ isize = 0;\n    let mut prime_digit_sum24: isize = 0;\n    let mut prime_digit_sum25:\
    \ isize = 0;\n    let mut prime_digit_sum26: isize = 0;\n    let mut prime_digit_sum27:\
    \ isize = 0;\n    let mut prime_digit_sum28: isize = 0;\n    let mut prime_digit_sum29:\
    \ isize = 0;\n    let mut prime_digit_sum30: isize = 0;\n    let mut prime_digit_sum31:\
    \ isize = 0;\n    let mut prime_digit_sum32: isize = 0;\n    let mut prime_digit_sum33:\
    \ isize = 0;\n    let mut prime_digit_sum34: isize = 0;\n    let mut prime_digit_sum35:\
    \ isize = 0;\n    let mut prime_digit_sum36: isize = 0;\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp25jc67q_.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmp25jc67q_.rs:18:55\n     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut nums = num.to_chars().collect::<Vec<_>>();\n    let\
    \ mut primes = vec![];\n    let mut primes_count = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_min = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut \n}\n\nfn main() {\n    let candidate = hex_key;\n  \
    \  assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpj7frm2ac.rs:65:1\n\
    \   |\n65 | }\n   | ^ expected identifier\n\nerror[E0599]: no method named `to_chars`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpj7frm2ac.rs:18:24\n\
    \   |\n18 |     let mut nums = num.to_chars().collect::<Vec<_>>();\n   |     \
    \                   ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `chars`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_value = num.chars().nth(prime_digits_index).unwrap();\n\
    \    let mut prime_digits_value = prime_digits_value.to_digit(10);\n    while\
    \ prime_digits_index < prime_digits_len {\n        let mut prime_digits_value\
    \ = prime_digits_value.to_digit(10);\n        let mut prime_digits_value = prime_digits_value.to_digit(10);\n\
    \        while prime_digits_index < prime_digits_len {\n            let mut prime_digits_value\
    \ = prime_digits_value.to_digit(10);\n            if prime_digits_value == 2 {\n\
    \                prime_digits.push(2);\n                prime_digits_index +=\
    \ 1;\n            }\n            if prime_digits_value == 3 {\n              \
    \  prime_digits.push(3);\n                prime_digits_index += 1;\n         \
    \   }\n            if prime_digits_value == 5 {\n                prime_digits.push(5);\n\
    \                prime_digits_index += 1;\n            }\n            if prime_digits_value\
    \ == 7 {\n                prime_digits.push(7);\n                prime_digits_index\
    \ += 1;\n            }\n            if prime_digits_value == 11 {\n          \
    \      prime_digits.push(11);\n                prime_digits_index += 1;\n    \
    \        }\n            if prime_digits_value == 13 {\n                prime_digits.push(13);\n\
    \                prime_digits_index += 1;\n            }\n            if prime_digits_value\
    \ == 17 {\n                prime_digits.push(17);\n                prime_digits_index\
    \ += 1;\n            }\n            if prime_digits_value == 19 {\n          \
    \      prime_digits.push(19);\n                prime_digits_index += 1;\n    \
    \        }\n            if prime_digits_value == 29 {\n                prime_digits.push(29);\n\
    \                prime_digits_index += 1;\n            }\n            if prime_digits_value\
    \ == 37 {\n                prime_digits.push(37);\n                prime_digits_index\
    \ += 1;\n            }\n            if prime_digits_value == 41 {\n          \
    \      prime_digits.push(41);\n                prime_digits_index += 1;\n    \
    \        }\n            if prime_digits_value == 431 {\n                prime_digits.push(431);\n\
    \                prime_digits_index += 1;\n            }\n            if prime_digits_value\
    \ == 479 {\n                prime_digits.push(479);\n                prime_digit\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpyigq4uwr.rs:90:3\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - unclosed delimiter\n...\n24 |     while prime_digits_index < prime_digits_len\
    \ {\n   |                                                 - unclosed delimiter\n\
    ...\n27 |         while prime_digits_index < prime_digits_len {\n   |        \
    \                                             - unclosed delimiter\n...\n77 |\
    \             if prime_digits_value == 479 {\n   |                           \
    \               - this delimiter might not be properly closed...\n...\n80 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n90 | }\n\
    \   |   ^\n\nerror[E0425]: cannot find value `prime_digit` in this scope\n  -->\
    \ /tmp/tmpyigq4uwr.rs:79:17\n   |\n79 |                 prime_digit\n   |    \
    \             ^^^^^^^^^^^ help: a local variable with a similar name exists: `prime_digits`\n\
    \nerror[E0599]: no method named `to_digit` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpyigq4uwr.rs:25:57\n   |\n25 |         let mut prime_digits_value\
    \ = prime_digits_value.to_digit(10);\n   |                                   \
    \                      ^^^^^^^^ method not found in `Option<u32>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyigq4uwr.rs:24:5\n   |\n17 |   fn hex_key(num:\
    \ String) -> isize {\n   |                              ----- expected `isize`\
    \ because of return type\n...\n24 | /     while prime_digits_index < prime_digits_len\
    \ {\n25 | |         let mut prime_digits_value = prime_digits_value.to_digit(10);\n\
    26 | |         let mut prime_digits_value = prime_digits_value.to_digit(10);\n\
    27 | |         while prime_digits_index < prime_digits_len {\n...  |\n89 | | \
    \    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")),\
    \ 12);\n90 | | }\n   | |__^ expected `isize`, found `()`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n    let mut\
    \ num: Vec<u8> = num.to_lowercase().chars().collect();\n    let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n    let mut\
    \ num: Vec<u8> = num.to_lowercase().chars().collect();\n    let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n    let mut\
    \ num: Vec<u8> = num.to_lowercase().chars().collect();\n    let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n    let mut\
    \ num: Vec<u8> = num.to_lowercase().chars().collect();\n    let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n    let mut\
    \ num: Vec<u8> = num.to_lowercase().chars().collect();\n    let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n    let mut\
    \ num: Vec<u8> = num.to_lowercase().chars().collect();\n    let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n    let mut\
    \ num: Vec<u8> = num.to_lowercase().chars().collect();\n}\n\nfn main() {\n   \
    \ let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_lowercase` found for struct `Vec<u8>`\
    \ in the current scope\n  --> /tmp/tmpqpp94f2w.rs:19:32\n   |\n19 |     let mut\
    \ num: Vec<u8> = num.to_lowercase().chars().collect();\n   |                 \
    \               ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_ascii_lowercase`\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpqpp94f2w.rs:18:55\n\
    \     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `to_lowercase` found\
    \ for struct `Vec<u8>` in the current scope\n  --> /tmp/tmpqpp94f2w.rs:20:32\n\
    \   |\n20 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]: no method\
    \ named `to_lowercase` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmpqpp94f2w.rs:21:32\n   |\n21 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]: no method\
    \ named `to_lowercase` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmpqpp94f2w.rs:22:32\n   |\n22 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]: no method\
    \ named `to_lowercase` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmpqpp94f2w.rs:23:32\n   |\n23 |     let mut num: Vec<u8> = num.to_lowe"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut digit_count = 0;\n   \
    \ let mut digits = num.to_string().chars().collect::<Vec<_>>();\n    let mut primes\
    \ = vec![false; 26];\n    let mut primes_set = vec![false; 26];\n    let mut primes_set_index\
    \ = 0;\n    let mut primes_set_index2 = 0;\n    let mut primes_set_index3 = 0;\n\
    \    let mut primes_set_index4 = 0;\n    let mut primes_set_index5 = 0;\n    let\
    \ mut primes_set_index6 = 0;\n    let mut primes_set_index7 = 0;\n    let mut\
    \ primes_set_index8 = 0;\n    let mut primes_set_index9 = 0;\n    let mut primes_set_index10\
    \ = 0;\n    let mut primes_set_index11 = 0;\n    let mut primes_set_index12 =\
    \ 0;\n    let mut primes_set_index13 = 0;\n    let mut primes_set_index14 = 0;\n\
    \    let mut primes_set_index15 = 0;\n    let mut primes_set_index16 = 0;\n  \
    \  let mut primes_set_index17 = 0;\n    let mut primes_set_index18 = 0;\n    let\
    \ mut primes_set_index19 = 0;\n    let mut primes_set_index20 = 0;\n    let mut\
    \ primes_set_index21 = 0;\n    let mut primes_set_index22 = 0;\n    let mut primes_set_index23\
    \ = 0;\n    let mut primes_set_index24 = 0;\n    let mut primes_set_index25 =\
    \ 0;\n    let mut primes_set_index26 = 0;\n    let mut primes_set_index27 = 0;\n\
    \    let mut primes_set_index28 = 0;\n    let mut primes_set_index29 = 0;\n  \
    \  let mut primes_set_index30 = 0;\n    let mut primes_set_index31 = 0;\n    let\
    \ mut primes_set_index32 = 0;\n    let mut primes_set_index33 = 0;\n    let mut\
    \ primes_set_index34 = 0;\n    let mut primes_set_index35 = 0;\n    let mut primes_set_index36\
    \ = 0;\n    let mut primes_set_index37 = 0;\n    let mut primes_set_index38 =\
    \ 0;\n    let mut primes_set_index39 = 0;\n    let mut primes_set_index40 = 0;\n\
    \    let mut primes_set_index41 = 0;\n    let mut primes_set_index42 = 0;\n  \
    \  let mut primes_set_index43 = 0;\n    let mut primes_set_index44 = 0;\n    let\
    \ mut primes_set_index45 = 0;\n    let mut primes_set_index46 = 0;\n\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpegym8dg2.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut digits = num.chars().collect::<Vec<_>>();\n\
    \    digits.sort_unstable();\n    for i in 0..digits.len() {\n        let mut\
    \ digit = digits[i];\n        let mut is_prime = true;\n        for j in 0..digits.len()\
    \ {\n            if digit == digits[j] {\n                is_prime = false;\n\
    \                break;\n            }\n        }\n        if is_prime {\n   \
    \         counter += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n   \
    \ let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp31avoyfl.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut prime_counter = 0;\n    let\
    \ mut prime_counter2 = 0;\n    let mut prime_counter3 = 0;\n    let mut prime_counter4\
    \ = 0;\n    let mut prime_counter5 = 0;\n    let mut prime_counter6 = 0;\n   \
    \ let mut prime_counter7 = 0;\n    let mut prime_counter8 = 0;\n    let mut prime_counter9\
    \ = 0;\n    let mut prime_counter10 = 0;\n    let mut prime_counter11 = 0;\n \
    \   let mut prime_counter12 = 0;\n    let mut prime_counter13 = 0;\n    let mut\
    \ prime_counter14 = 0;\n    let mut prime_counter15 = 0;\n    let mut prime_counter16\
    \ = 0;\n    let mut prime_counter17 = 0;\n    let mut prime_counter18 = 0;\n \
    \   let mut prime_counter19 = 0;\n    let mut prime_counter20 = 0;\n    let mut\
    \ prime_counter21 = 0;\n    let mut prime_counter22 = 0;\n    let mut prime_counter23\
    \ = 0;\n    let mut prime_counter24 = 0;\n    let mut prime_counter25 = 0;\n \
    \   let mut prime_counter26 = 0;\n    let mut prime_counter27 = 0;\n    let mut\
    \ prime_counter28 = 0;\n    let mut prime_counter29 = 0;\n    let mut prime_counter30\
    \ = 0;\n    let mut prime_counter31 = 0;\n    let mut prime_counter32 = 0;\n \
    \   let mut prime_counter33 = 0;\n    let mut prime_counter34 = 0;\n    let mut\
    \ prime_counter35 = 0;\n    let mut prime_counter36 = 0;\n    let mut prime_counter37\
    \ = 0;\n    let mut prime_counter38 = 0;\n    let mut prime_counter39 = 0;\n \
    \   let mut prime_counter40 = 0;\n    let mut prime_counter41 = 0;\n    let mut\
    \ prime_counter42 = 0;\n    let mut prime_counter43 = 0;\n    let mut prime_counter44\
    \ = 0;\n    let mut prime_counter45 = 0;\n    let mut prime_counter46 = 0;\n \
    \   let mut prime_counter47 = 0;\n    let mut prime_counter48 = 0;\n    let mut\
    \ prime_counter49 = 0;\n    let mut prime_counter50 = 0;\n    let mut prime_counter51\
    \ = 0;\n    let mut prime_counter52 = 0;\n    let mut prime_counter53 = 0;\n \
    \   let mut prime_counter54 = 0;\n    let mut prime_counter55 = 0;\n    let mut\
    \ prime_counter56 = 0;\n    let mut prime_counter57\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpagb_s9mm.rs:75:28\n   |\n\
    75 |     let mut prime_counter57\n   |                            ^ help: add\
    \ `;` here\n76 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpagb_s9mm.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_index: isize = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let \n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpeccl1og6.rs:69:1\n  \
    \ |\n69 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpeccl1og6.rs:18:55\n\
    \     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count_max\
    \ = vec![];\n    let mut prime_digits_count_min = vec![];\n    let mut prime_digits_count_max_len\
    \ = vec![];\n    let mut prime_digits_count_min_len = vec![];\n    let mut prime_digits_count_max_len_prime\
    \ = vec![];\n    let mut prime_digits_count_min_len_prime = vec![];\n    let mut\
    \ prime_digits_count_max_len_prime_prime = vec![];\n    let mut prime_digits_count_min_len_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_max_len_prime_prime_prime = vec![];\n\
    \    let mut prime_digits_count_min_len_prime_prime_prime = vec![];\n    let mut\
    \ prime_digits_count_max_len_prime_prime_prime_prime = vec![];\n    let mut prime_digits_count_min_len_prime_prime_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_max_len_prime_prime_prime_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_min_len_prime_prime_prime_prime_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_max_len_prime_prime_prime_prime_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_min_len_prime_prime_prime_prime_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_max_len_prime_prime_prime_prime_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_min_len_prime_prime_prime_prime_prime_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_max_len_prime_prime_prime_prime_prime_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_min_len_prime_prime_prime_prime_prime_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_max_len_prime_prime_prime_prime_prime_prime_prime\
    \ = vec![];\n    let mut prime_digits_count_min_len_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = vec![];\n    let mut prime_digit\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqcrdw2i6.rs:43:24\n   |\n\
    43 |     let mut prime_digit\n   |                        ^ help: add `;` here\n\
    44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqcrdw2i6.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![0; 8];\n    let mut num_prime_prime: Vec<u8>\
    \ = vec![0; 8];\n    let mut num_prime_prime_prime: Vec<u8> = vec![0; 8];\n  \
    \  let mut num_prime_prime_prime_prime: Vec<u8> = vec![0; 8];\n    let mut num_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmvccmjji.rs:35:22\n   |\n\
    35 |     let mut num_prime\n   |                      ^ help: add `;` here\n36\
    \ | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpmvccmjji.rs:18:55\n\
    \     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmvccmjji.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut prime_counter = 0;\n    let\
    \ mut prime_counter2 = 0;\n    let mut prime_counter3 = 0;\n    let mut prime_counter4\
    \ = 0;\n    let mut prime_counter5 = 0;\n    let mut prime_counter6 = 0;\n   \
    \ let mut prime_counter7 = 0;\n    let mut prime_counter8 = 0;\n    let mut prime_counter9\
    \ = 0;\n    let mut prime_counter10 = 0;\n    let mut prime_counter11 = 0;\n \
    \   let mut prime_counter12 = 0;\n    let mut prime_counter13 = 0;\n    let mut\
    \ prime_counter14 = 0;\n    let mut prime_counter15 = 0;\n    let mut prime_counter16\
    \ = 0;\n    let mut prime_counter17 = 0;\n    let mut prime_counter18 = 0;\n \
    \   let mut prime_counter19 = 0;\n    let mut prime_counter20 = 0;\n    let mut\
    \ prime_counter21 = 0;\n    let mut prime_counter22 = 0;\n    let mut prime_counter23\
    \ = 0;\n    let mut prime_counter24 = 0;\n    let mut prime_counter25 = 0;\n \
    \   let mut prime_counter26 = 0;\n    let mut prime_counter27 = 0;\n    let mut\
    \ prime_counter28 = 0;\n    let mut prime_counter29 = 0;\n    let mut prime_counter30\
    \ = 0;\n    let mut prime_counter31 = 0;\n    let mut prime_counter32 = 0;\n \
    \   let mut prime_counter33 = 0;\n    let mut prime_counter34 = 0;\n    let mut\
    \ prime_counter35 = 0;\n    let mut prime_counter36 = 0;\n    let mut prime_counter37\
    \ = 0;\n    let mut prime_counter38 = 0;\n    let mut prime_counter39 = 0;\n \
    \   let mut prime_counter40 = 0;\n    let mut prime_counter41 = 0;\n    let mut\
    \ prime_counter42 = 0;\n    let mut prime_counter43 = 0;\n    let mut prime_counter44\
    \ = 0;\n    let mut prime_counter45 = 0;\n    let mut prime_counter46 = 0;\n \
    \   let mut prime_counter47 = 0;\n    let mut prime_counter48 = 0;\n    let mut\
    \ prime_counter49 = 0;\n    let mut prime_counter50 = 0;\n    let mut prime_counter51\
    \ = 0;\n    let mut prime_counter52 = 0;\n    let mut prime_counter53 = 0;\n \
    \   let mut prime_counter54 = 0;\n    let mut prime_counter55 = 0;\n    let mut\
    \ prime_counter56 = 0;\n    let mut prime_counter57\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmgw5cpc7.rs:75:28\n   |\n\
    75 |     let mut prime_counter57\n   |                            ^ help: add\
    \ `;` here\n76 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmgw5cpc7.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut num_digits = num.len();\n\
    \    let mut num_digits_prime = 0;\n    let mut num_digits_not_prime = 0;\n  \
    \  let mut num_digits_not_prime_prime = 0;\n    let mut num_digits_not_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_not_prime_prime = 0;\n    let mut num_digits_not_prime_not_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_not_prime_not_prime_prime = 0;\n    let\
    \ mut num_digits_not_prime_not_prime_not_prime_not_prime = 0;\n    let mut num_digits_not_prime_not_prime_not_prime_not_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_not_prime_not_prime_not_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_not_prime_not_prime_not_prime_not_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime\
    \ = 0;\n    let mut num_digits_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_not_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_not_prime_not_\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpacncegqx.rs:41:48\n   |\n\
    41 |     let mut num_digits_not_prime_not_prime_not_\n   |                   \
    \                             ^ help: add `;` here\n42 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpacncegqx.rs:17:28\n \
    \  |\n17 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut digits = num.chars().map(|c|\
    \ c.to_digit(16).unwrap());\n    while let Some(digit) = digits.next() {\n   \
    \     counter += digit as isize;\n    }\n    counter\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `21`,\n right: `1`', /tmp/tmpkrzfblyl.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_count: isize = 0;\n\
    \    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count: isize\
    \ = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplg5k90nb.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmplg5k90nb.rs:18:55\n     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut num_digits = num.len();\n    let mut num_digits_prime = 0;\n    let\
    \ mut num_digits_non_prime = 0;\n    let mut num_digits_non_prime_prime = 0;\n\
    \    let mut num_digits_non_prime_non_prime = 0;\n    let mut num_digits_non_prime_prime_prime\
    \ = 0;\n    let mut num_digits_non_prime_prime_non_prime = 0;\n    let mut num_digits_prime_prime\
    \ = 0;\n    let mut num_digits_prime_non_prime = 0;\n    let mut num_digits_prime_non_prime_prime\
    \ = 0;\n    let mut num_digits_prime_non_prime_non_prime = 0;\n    let mut num_digits_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_non_prime = 0;\n    let mut num_digits_prime_prime_non_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_non_prime_non_prime = 0;\n    let mut\
    \ num_digits_prime_prime_prime_prime = 0;\n    let mut num_digits_prime_prime_prime_non_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_non_prime_prime = 0;\n    let\
    \ mut num_digits_prime_prime_prime_non_prime_non_prime = 0;\n    let mut num_digits_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_non_prime = 0;\n    let\
    \ mut num_digits_prime_prime_prime_prime_non_prime_prime = 0;\n    let mut num_digits_prime_prime_prime_prime_non_prime_non_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime = 0;\n    let\
    \ mut num_digits_prime_prime_prime_prime_prime_non_prime = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_non_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_non_prime_non_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_non_prime_non_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_non_prime_non_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_non_prime_non_prime_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1h5svdyx.rs:49:74\n   |\n\
    49 |     let mut num_digits_prime_prime_prime_prime_prime_non_prime_non_prime_\n\
    \   |                                                                        \
    \  ^ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1h5svdyx.rs:17:28\n   |\n17 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_vec();\n    let mut prime_numbers:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_index = 0;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxs1q1pgs.rs:57:18\n   |\n\
    57 |     let mut prime\n   |                  ^ help: add `;` here\n58 | }\n \
    \  | - unexpected token\n\nerror[E0599]: no method named `to_vec` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpxs1q1pgs.rs:18:32\n   |\n18 | \
    \    let mut num: Vec<u8> = num.to_vec();\n   |                              \
    \  ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxs1q1pgs.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize {\n \
    \  |    -------                 ^^^^^ expected `isize`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut digits = num.chars().map(|c|\
    \ match c {\n        'A'..='F' => c - 'A' + 1,\n        'a'..='f' => c - 'a' +\
    \ 1,\n        _ => 0,\n    });\n    while digits.len() > 0 {\n        let mut\
    \ prime = true;\n        for d in digits {\n            if d % 2 == 0 {\n    \
    \            prime = false;\n                break;\n            }\n        }\n\
    \        if prime {\n            counter += 1;\n        }\n        digits.remove(0);\n\
    \    }\n    counter\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp2xixrgvn.rs:20:24\n\
    \   |\n20 |         'A'..='F' => c - 'A' + 1,\n   |                      - ^ ---\
    \ char\n   |                      |\n   |                      char\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmp2xixrgvn.rs:21:24\n   |\n\
    21 |         'a'..='f' => c - 'a' + 1,\n   |                      - ^ --- char\n\
    \   |                      |\n   |                      char\n\nerror[E0599]:\
    \ the method `len` exists for struct `Map<Chars<'_>, _>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmp2xixrgvn.rs:24:18\n   |\n24 |       while\
    \ digits.len() > 0 {\n   |                    ^^^ method cannot be called on `Map<Chars<'_>,\
    \ _>` due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `Chars<'_>: ExactSizeIterator`\n           which\
    \ is required by `Map<Chars<'_>, _>: ExactSizeIterator`\n\nerror[E0599]: no method\
    \ named `remove` found for struct `Map` in the current scope\n  --> /tmp/tmp2xixrgvn.rs:35:16\n\
    \   |\n35 |         digits.remove(0);\n   |                ^^^^^^ method not found\
    \ in `Map<Chars<'_>, _>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0369, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_counter = 0;\n    let mut prime_counter2 = 0;\n\
    \    let mut prime_counter3 = 0;\n    let mut prime_counter4 = 0;\n    let mut\
    \ prime_counter5 = 0;\n    let mut prime_counter6 = 0;\n    let mut prime_counter7\
    \ = 0;\n    let mut prime_counter8 = 0;\n    let mut prime_counter9 = 0;\n   \
    \ let mut prime_counter10 = 0;\n    let mut prime_counter11 = 0;\n    let mut\
    \ prime_counter12 = 0;\n    let mut prime_counter13 = 0;\n    let mut prime_counter14\
    \ = 0;\n    let mut prime_counter15 = 0;\n    let mut prime_counter16 = 0;\n \
    \   let mut prime_counter17 = 0;\n    let mut prime_counter18 = 0;\n    let mut\
    \ prime_counter19 = 0;\n    let mut prime_counter20 = 0;\n    let mut prime_counter21\
    \ = 0;\n    let mut prime_counter22 = 0;\n    let mut prime_counter23 = 0;\n \
    \   let mut prime_counter24 = 0;\n    let mut prime_counter25 = 0;\n    let mut\
    \ prime_counter26 = 0;\n    let mut prime_counter27 = 0;\n    let mut prime_counter28\
    \ = 0;\n    let mut prime_counter29 = 0;\n    let mut prime_counter30 = 0;\n \
    \   let mut prime_counter31 = 0;\n    let mut prime_counter32 = 0;\n    let mut\
    \ prime_counter33 = 0;\n    let mut prime_counter34 = 0;\n    let mut prime_counter35\
    \ = 0;\n    let mut prime_counter36 = 0;\n    let mut prime_counter37 = 0;\n \
    \   let mut prime_counter38 = 0;\n    let mut prime_counter39 = 0;\n    let mut\
    \ prime_counter40 = 0;\n    let mut prime_counter41 = 0;\n    let mut prime_counter42\
    \ = 0;\n    let mut prime_counter43 = 0;\n    let mut prime_counter44 = 0;\n \
    \   let mut prime_counter45 = 0;\n    let mut prime_counter46 = 0;\n    let mut\
    \ prime_counter47 = 0;\n    let mut prime_counter48 = 0;\n    let mut prime_counter49\
    \ = 0;\n    let mut prime_counter50 = 0;\n    let mut prime_counter51 = 0;\n \
    \   let mut prime_counter52 = 0;\n    let mut prime_counter53 = 0;\n    let mut\
    \ prime_counter54 = 0;\n    let mut prime_counter55 = 0;\n    let mut prime_counter56\
    \ = 0;\n    let mut prime_counter57 = 0;\n    let mut prime\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpm4rwsq6r.rs:75:18\n   |\n\
    75 |     let mut prime\n   |                  ^ help: add `;` here\n76 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm4rwsq6r.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: usize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digits: Vec<u8> = vec![];\n    let mut prime_digits_count: usize =\
    \ 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvcd9c53e.rs:63:19\n   |\n\
    63 |     let mut prime_\n   |                   ^ help: add `;` here\n64 | }\n\
    \   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be\
    \ built from an iterator over elements of type `char`\n    --> /tmp/tmpvcd9c53e.rs:18:55\n\
    \     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvcd9c53e.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut digits = num.chars().map(|c|\
    \ c.to_digit(16).unwrap()).collect::<Vec<_>>();\n    let mut primes = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut primes_set = primes.clone();\n    let mut primes_count\
    \ = primes.len();\n    let mut primes_index = 0;\n    let mut primes_index_count\
    \ = 0;\n    let mut primes_index_max = primes.len();\n    let mut primes_index_min\
    \ = primes.len();\n    let mut primes_index_max_prime = 0;\n    let mut primes_index_min_prime\
    \ = 0;\n    let mut primes_index_max_prime_prime = 0;\n    let mut primes_index_min_prime_prime\
    \ = 0;\n    let mut primes_index_max_prime_prime_prime = 0;\n    let mut primes_index_min_prime_prime_prime\
    \ = 0;\n    let mut primes_index_max_prime_prime_prime_prime = 0;\n    let mut\
    \ primes_index_min_prime_prime_prime_prime = 0;\n    let mut primes_index_max_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut primes_index_min_prime_prime_prime_prime_prime = 0;\n    let\
    \ mut primes_index_max_prime_prime_prime_prime_prime_prime = 0;\n    let mut primes_index_min_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut primes_index_max_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut primes_index_min_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut primes_index_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut primes_index_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut primes_index_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut primes_index_min_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut primes_index_max_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut primes_index_min_prime_prime_prime_prime_prime_prime_prime_prime_prime\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaw4njha2.rs:46:83\n   |\n\
    46 |     let mut primes_index_min_prime_prime_prime_prime_prime_prime_prime_prime_prime\n\
    \   |                                                                        \
    \           ^ help: add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaw4njha2.rs:17:28\n   |\n17 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: isize = num.len();\n    let mut prime: isize =\
    \ 0;\n    let mut prime_counter: isize = 0;\n    let mut prime_counter2: isize\
    \ = 0;\n    let mut prime_counter3: isize = 0;\n    let mut prime_counter4: isize\
    \ = 0;\n    let mut prime_counter5: isize = 0;\n    let mut prime_counter6: isize\
    \ = 0;\n    let mut prime_counter7: isize = 0;\n    let mut prime_counter8: isize\
    \ = 0;\n    let mut prime_counter9: isize = 0;\n    let mut prime_counter10: isize\
    \ = 0;\n    let mut prime_counter11: isize = 0;\n    let mut prime_counter12:\
    \ isize = 0;\n    let mut prime_counter13: isize = 0;\n    let mut prime_counter14:\
    \ isize = 0;\n    let mut prime_counter15: isize = 0;\n    let mut prime_counter16:\
    \ isize = 0;\n    let mut prime_counter17: isize = 0;\n    let mut prime_counter18:\
    \ isize = 0;\n    let mut prime_counter19: isize = 0;\n    let mut prime_counter20:\
    \ isize = 0;\n    let mut prime_counter21: isize = 0;\n    let mut prime_counter22:\
    \ isize = 0;\n    let mut prime_counter23: isize = 0;\n    let mut prime_counter24:\
    \ isize = 0;\n    let mut prime_counter25: isize = 0;\n    let mut prime_counter26:\
    \ isize = 0;\n    let mut prime_counter27: isize = 0;\n    let mut prime_counter28:\
    \ isize = 0;\n    let mut prime_counter29: isize = 0;\n    let mut prime_counter30:\
    \ isize = 0;\n    let mut prime_counter31: isize = 0;\n    let mut prime_counter32:\
    \ isize = 0;\n    let mut prime_counter33: isize = 0;\n    let mut prime_counter34:\
    \ isize = 0;\n    let mut prime_counter35: isize = 0;\n    let mut prime_counter36:\
    \ isize = 0;\n    let mut prime_counter37: isize = 0;\n    let mut prime_counter38:\
    \ isize = 0;\n    let mut prime_counter39: isize = 0;\n    let mut prime_counter40:\
    \ isize = 0;\n    let mut prime_counter41: isize = 0;\n    let mut prime\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6orm5x4c.rs:61:18\n   |\n\
    61 |     let mut prime\n   |                  ^ help: add `;` here\n62 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6orm5x4c.rs:18:26\n\
    \   |\n18 |     let mut num: isize = num.len();\n   |                  ----- \
    \  ^^^^^^^^^ expected `isize`, found `usize`\n   |                  |\n   |  \
    \                expected due to this\n   |\nhelp: you can convert a `usize` to\
    \ an `isize` and panic if the converted value doesn't fit\n   |\n18 |     let\
    \ mut num: isize = num.len().try_into().unwrap();\n   |                      \
    \             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6orm5x4c.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_vec();\n    let mut prime: Vec<u8>\
    \ = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97];\n    let mut counter: usize = 0;\n    let mut digit:\
    \ u8 = 0;\n    let mut prime_counter: usize = 0;\n    let mut prime_digit: u8\
    \ = 0;\n    let mut prime_prime_counter: usize = 0;\n    let mut prime_prime_digit:\
    \ u8 = 0;\n    let mut prime_prime_prime_counter: usize = 0;\n    let mut prime_prime_prime_digit:\
    \ u8 = 0;\n    let mut prime_prime_prime_prime_counter: usize = 0;\n    let mut\
    \ prime_prime_prime_prime_digit: u8 = 0;\n    let mut prime_prime_prime_prime_prime_counter:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_digit: u8 = 0;\n    let\
    \ mut prime_prime_prime_prime_prime_prime_counter: usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_digit:\
    \ u8 = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_counter: usize\
    \ = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_counter: usize =\
    \ 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_counter: usize\
    \ = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_counter: usize\
    \ = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_counter:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_counter:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_counter:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_counter:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_counter:\
    \ usize = 0;\n    let mut prime_prime_prime\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph48ov26q.rs:43:30\n   |\n\
    43 |     let mut prime_prime_prime\n   |                              ^ help:\
    \ add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0599]: no method named\
    \ `to_vec` found for struct `String` in the current scope\n  --> /tmp/tmph48ov26q.rs:18:32\n\
    \   |\n18 |     let mut num: Vec<u8> = num.to_vec();\n   |                   \
    \             ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph48ov26q.rs:17:28\n   |\n17 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<usize> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: usize = 2;\n  \
    \  let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count: usize\
    \ = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb679tkni.rs:63:37\n   |\n\
    63 |     let mut prime_digit_count: usize\n   |                              \
    \       ^ help: add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb679tkni.rs:17:28\n   |\n17 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror[E0277]: a value of type `Vec<usize>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpb679tkni.rs:18:58\n\
    \     |\n18   |     let mut num: Vec<usize> = num.to_lowercase().chars().collect();\n\
    \     |                                                          ^^^^^^^ value\
    \ of type `Vec<usize>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<usize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: isize = 0;\n    let mut num_digits = num.len();\n\
    \    let mut prime_digits = 2;\n    let mut prime_digits_counter = 0;\n    let\
    \ mut prime_digits_counter_2 = 0;\n    let mut prime_digits_counter_3 = 0;\n \
    \   let mut prime_digits_counter_4 = 0;\n    let mut prime_digits_counter_5 =\
    \ 0;\n    let mut prime_digits_counter_6 = 0;\n    let mut prime_digits_counter_7\
    \ = 0;\n    let mut prime_digits_counter_8 = 0;\n    let mut prime_digits_counter_9\
    \ = 0;\n    let mut prime_digits_counter_10 = 0;\n    let mut prime_digits_counter_11\
    \ = 0;\n    let mut prime_digits_counter_12 = 0;\n    let mut prime_digits_counter_13\
    \ = 0;\n    let mut prime_digits_counter_14 = 0;\n    let mut prime_digits_counter_15\
    \ = 0;\n    let mut prime_digits_counter_16 = 0;\n    let mut prime_digits_counter_17\
    \ = 0;\n    let mut prime_digits_counter_18 = 0;\n    let mut prime_digits_counter_19\
    \ = 0;\n    let mut prime_digits_counter_20 = 0;\n    let mut prime_digits_counter_21\
    \ = 0;\n    let mut prime_digits_counter_22 = 0;\n    let mut prime_digits_counter_23\
    \ = 0;\n    let mut prime_digits_counter_24 = 0;\n    let mut prime_digits_counter_25\
    \ = 0;\n    let mut prime_digits_counter_26 = 0;\n    let mut prime_digits_counter_27\
    \ = 0;\n    let mut prime_digits_counter_28 = 0;\n    let mut prime_digits_counter_29\
    \ = 0;\n    let mut prime_digits_counter_30 = 0;\n    let mut prime_digits_counter_31\
    \ = 0;\n    let mut prime_digits_counter_32 = 0;\n    let mut prime_digits_counter_33\
    \ = 0;\n    let mut prime_digits_counter_34 = 0;\n    let mut prime_digits_counter_35\
    \ = 0;\n    let mut prime_digits_counter_36 = 0;\n    let mut prime_digits_counter_37\
    \ = 0;\n    let mut prime_digits_counter_38 = 0;\n    let mut prime_digits_counter_39\
    \ = 0;\n    let mut prime_digits_counter_40 = 0;\n    let mut prime_digits_counter_41\
    \ = 1;\n    let mut prime_digits_counter_42 = 0;\n    let mut prime_digits_counter_43\
    \ = 0;\n    let mut prime_digits_counter_44 = 0;\n    let mu\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwzo2efn4.rs:65:11\n   |\n\
    65 |     let mu\n   |           ^ help: add `;` here\n66 | }\n   | - unexpected\
    \ token\n\nerror[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpwzo2efn4.rs:19:30\n   |\n19 |     let mut num_digits =\
    \ num.len();\n   |                              ^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwzo2efn4.rs:17:28\n   |\n17 |\
    \ fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17];\n    let mut prime_digit_counts = vec![0, 0, 0, 0];\n\
    \    let mut prime_digit_counts_len = prime_digit_counts.len();\n    let mut prime_digit_counts_len\
    \ = prime_digit_counts.len();\n    let mut prime_digit_counts_len = prime_digit_counts.len();\n\
    \    let mut prime_digit_counts_len = prime_digit_counts.len();\n    let mut prime_digit_counts_len\
    \ = prime_digit_counts.len();\n    let mut prime_digit_counts_len = prime_digit_counts.len();\n\
    \    let mut prime_digit_counts_len = prime_digit_counts.len();\n    let mut prime_digit_counts_len\
    \ = prime_digit_counts.len();\n    let mut prime_digit_counts_len = prime_digit_counts.len();\n\
    \    let mut prime_digit_counts_len = prime_digit_counts.len();\n    let mut prime_digit_counts_len\
    \ = prime_digit_counts.len();\n    let mut prime_digit_counts_len = prime_digit_counts.len();\n\
    \    let mut prime_digit_counts_len = prime_digit_counts.len();\n    let mut prime_digit_counts_len\
    \ = prime_digit_counts.len();\n    let mut prime_digit_counts_len = prime_digit_counts.len();\n\
    \    let mut prime_digit_counts_len = prime_digit_counts.len();\n    let mut prime_digit_counts_len\
    \ = prime_digit_counts.len();\n    let mut prime_digit_counts_len = prime_digit_counts.len();\n\
    \    let mut prime_digit_counts_len = prime_digit_counts.len();\n    let mut prime_digit_counts_len\
    \ = prime_digit_counts.len();\n    let mut prime_digit_counts_len = prime_digit_counts.len();\n\
    \    let mut prime_digit_counts_len = prime_digit_counts.len();\n    let mut prime_digit_counts_len\
    \ = prime_digit_counts.len();\n    let mut prime_digit_counts_len = prime_digit_counts.len();\n\
    \    let mut prime_digit_counts_len = prime_digit_counts.len();\n    let mut prime_digit_counts_len\
    \ = prime_digit_counts.len();\n    let mut prime_digit_counts_len = prime_digit_counts.len();\n\
    \    let mut prime_digit_counts_len = prime_digit_counts.len();\n    let mut prime_digit_counts_len\
    \ = prime_digit_counts.len();\n    let mut prime_digit_counts_len = prime\n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkb0p6ce5.rs:50:43\n   |\n\
    50 |     let mut prime_digit_counts_len = prime\n   |                        \
    \                   ^ help: add `;` here\n51 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `prime` in this scope\n  --> /tmp/tmpkb0p6ce5.rs:50:38\n\
    \   |\n50 |     let mut prime_digit_counts_len = prime\n   |                 \
    \                     ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkb0p6ce5.rs:17:28\n   |\n17 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n    let mut\
    \ prime_digits_set = HashSet::new();\n    let mut prime_digits_set = HashSet::new();\n\
    \    let \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpqaeto9bx.rs:54:1\n  \
    \ |\n54 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmpqaeto9bx.rs:20:32\n   |\n20 |     let\
    \ mut prime_digits_set = HashSet::new();\n   |                               \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpqaeto9bx.rs:21:32\n   |\n21\
    \ |     let mut prime_digits_set = HashSet::new();\n   |                     \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpqaeto9bx.rs:22:32\n\
    \   |\n22 |     let mut prime_digits_set = HashSet::new();\n   |             \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpqaeto9bx.rs:23:32\n\
    \   |\n23 |     let mut prime_digits_set = HashSet::new();\n   |             \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpqaeto9bx.rs:24:32\n\
    \   |\n24 |     let mut prime_digits_set = HashSet::new();\n   |             \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpqaeto9bx.rs:25:32\n\
    \   |\n25 |     let mut prime_digits_set = HashSet::new();\n   |             \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digit = vec![];\n    let mut prime_digit_counter = 0;\n   \
    \ let mut prime_digit_counter2 = 0;\n    let mut prime_digit_counter3 = 0;\n \
    \   let mut prime_digit_counter4 = 0;\n    let mut prime_digit_counter5 = 0;\n\
    \    let mut prime_digit_counter6 = 0;\n    let mut prime_digit_counter7 = 0;\n\
    \    let mut prime_digit_counter8 = 0;\n    let mut prime_digit_counter9 = 0;\n\
    \    let mut prime_digit_counter10 = 0;\n    let mut prime_digit_counter11 = 0;\n\
    \    let mut prime_digit_counter12 = 0;\n    let mut prime_digit_counter13 = 0;\n\
    \    let mut prime_digit_counter14 = 0;\n    let mut prime_digit_counter15 = 0;\n\
    \    let mut prime_digit_counter16 = 0;\n    let mut prime_digit_counter17 = 0;\n\
    \    let mut prime_digit_counter18 = 0;\n    let mut prime_digit_counter19 = 0;\n\
    \    let mut prime_digit_counter20 = 0;\n    let mut prime_digit_counter21 = 0;\n\
    \    let mut prime_digit_counter22 = 0;\n    let mut prime_digit_counter23 = 0;\n\
    \    let mut prime_digit_counter24 = 0;\n    let mut prime_digit_counter25 = 0;\n\
    \    let mut prime_digit_counter26 = 0;\n    let mut prime_digit_counter27 = 0;\n\
    \    let mut prime_digit_counter28 = 0;\n    let mut prime_digit_counter29 = 0;\n\
    \    let mut prime_digit_counter30 = 0;\n    let mut prime_digit_counter31 = 0;\n\
    \    let mut prime_digit_counter32 = 0;\n    let mut prime_digit_counter33 = 0;\n\
    \    let mut prime_digit_counter34 = 0;\n    let mut prime_digit_counter35 = 0;\n\
    \    let mut prime_digit_counter36 = 0;\n    let mut prime_digit_counter37 = 0;\n\
    \    let mut prime_digit_counter38 = 0;\n    let mut prime_digit_counter39 = 0;\n\
    \    let mut prime_digit_counter40 = 0;\n    let mut prime_digit_counter41 = 0;\n\
    \    let mut prime_digit_counter42 = 0;\n    let mut prime_digit_counter43 = 0;\n\
    \    let mut prime_digit_counter44 = 0;\n    let mut prime_digit_counter45 = 0;\n\
    \    let mut prime_digit_counter46 = 0;\n    let mut prime_digit_counter47 = 0;\n\
    \    let mut prime_digit_counter48 = 0;\n    let mut prime_digit_counter49\n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg5ogt_99.rs:69:34\n   |\n\
    69 |     let mut prime_digit_counter49\n   |                                 \
    \ ^ help: add `;` here\n70 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg5ogt_99.rs:17:28\n   |\n17 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut num_digits = num.len();\n\
    \    let mut num_digits_prime = 0;\n    let mut num_digits_prime_pow2 = 0;\n \
    \   let mut num_digits_prime_pow3 = 0;\n    let mut num_digits_prime_pow4 = 0;\n\
    \    let mut num_digits_prime_pow5 = 0;\n    let mut num_digits_prime_pow6 = 0;\n\
    \    let mut num_digits_prime_pow7 = 0;\n    let mut num_digits_prime_pow8 = 0;\n\
    \    let mut num_digits_prime_pow9 = 0;\n    let mut num_digits_prime_pow10 =\
    \ 0;\n    let mut num_digits_prime_pow11 = 0;\n    let mut num_digits_prime_pow12\
    \ = 0;\n    let mut num_digits_prime_pow13 = 0;\n    let mut num_digits_prime_pow14\
    \ = 0;\n    let mut num_digits_prime_pow15 = 0;\n    let mut num_digits_prime_pow16\
    \ = 0;\n    let mut num_digits_prime_pow17 = 0;\n    let mut num_digits_prime_pow18\
    \ = 0;\n    let mut num_digits_prime_pow19 = 0;\n    let mut num_digits_prime_pow20\
    \ = 0;\n    let mut num_digits_prime_pow21 = 0;\n    let mut num_digits_prime_pow22\
    \ = 0;\n    let mut num_digits_prime_pow23 = 0;\n    let mut num_digits_prime_pow24\
    \ = 0;\n    let mut num_digits_prime_pow25 = 0;\n    let mut num_digits_prime_pow26\
    \ = 0;\n    let mut num_digits_prime_pow27 = 0;\n    let mut num_digits_prime_pow28\
    \ = 0;\n    let mut num_digits_prime_pow29 = 0;\n    let mut num_digits_prime_pow30\
    \ = 0;\n    let mut num_digits_prime_pow31 = 0;\n    let mut num_digits_prime_pow32\
    \ = 0;\n    let mut num_digits_prime_pow33 = 0;\n    let mut num_digits_prime_pow34\
    \ = 0;\n    let mut num_digits_prime_pow35 = 0;\n    let mut num_digits_prime_pow36\
    \ = 0;\n    let mut num_digits_prime_pow37 = 0;\n    let mut num_digits_prime_pow38\
    \ = 0;\n    let mut num_digits_prime_pow39 = 0;\n    let mut num_digits_prime_pow40\
    \ = 0;\n    let mut num_digits_prime_pow41 = 0;\n    let mut num_digits_prime_pow\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr9pvr2k_.rs:61:33\n   |\n\
    61 |     let mut num_digits_prime_pow\n   |                                 ^\
    \ help: add `;` here\n62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr9pvr2k_.rs:17:28\n   |\n17 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut digits = num.chars().collect::<Vec<_>>();\n\
    \    let mut primes = vec![2, 3];\n    let mut primes_counter = vec![2, 3];\n\
    \    let mut primes_counter2 = vec![2, 3];\n    let mut primes_counter3 = vec![2,\
    \ 3];\n    let mut primes_counter4 = vec![2, 3];\n    let mut primes_counter5\
    \ = vec![2, 3];\n    let mut primes_counter6 = vec![2, 3];\n    let mut primes_counter7\
    \ = vec![2, 3];\n    let mut primes_counter8 = vec![2, 3];\n    let mut primes_counter9\
    \ = vec![2, 3];\n    let mut primes_counter10 = vec![2, 3];\n    let mut primes_counter11\
    \ = vec![2, 3];\n    let mut primes_counter12 = vec![2, 3];\n    let mut primes_counter13\
    \ = vec![2, 3];\n    let mut primes_counter14 = vec![2, 3];\n    let mut primes_counter15\
    \ = vec![2, 3];\n    let mut primes_counter16 = vec![2, 3];\n    let mut primes_counter17\
    \ = vec![2, 3];\n    let mut primes_counter18 = vec![2, 3];\n    let mut primes_counter19\
    \ = vec![2, 3];\n    let mut primes_counter20 = vec![2, 3];\n    let mut primes_counter21\
    \ = vec![2, 3];\n    let mut primes_counter22 = vec![2, 3];\n    let mut primes_counter23\
    \ = vec![2, 3];\n    let mut primes_counter24 = vec![2, 3];\n    let mut primes_counter25\
    \ = vec![2, 3];\n    let mut primes_counter26 = vec![2, 3];\n    let mut primes_counter27\
    \ = vec![2, 3];\n    let mut primes_counter28 = vec![2, 3];\n    let mut primes_counter29\
    \ = vec![2, 3];\n    let mut primes_counter30 = vec![2, 3];\n    let mut primes_counter31\
    \ = vec![2, 3];\n    let mut primes_counter32 = vec![2, 3];\n    let mut primes_counter33\
    \ = vec![2, 3];\n    let mut primes_counter34 = vec![2, 3];\n    let mut primes_counter35\
    \ = vec![2, 3];\n\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiif4ngsz.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19];\n    let mut digits = num.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.length;\n    while digits_len > 0 {\n       \
    \ let mut digit = digits[digits_len - 1];\n        digits.pop();\n        prime_count\
    \ += prime_digits.iter().position(|&x| x == digit).unwrap_or(0);\n        prime_digits\
    \ = prime_digits.iter().filter(|&x| x != digit).collect();\n        digits_len\
    \ -= 1;\n    }\n    prime_count\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `length` on type `Vec<char>`\n  --> /tmp/tmp14y4npdz.rs:21:33\n\
    \   |\n21 |     let mut digits_len = digits.length;\n   |                    \
    \             ^^^^^^ unknown field\n\nerror[E0277]: a value of type `Vec<{integer}>`\
    \ cannot be built from an iterator over elements of type `&{integer}`\n    -->\
    \ /tmp/tmp14y4npdz.rs:26:68\n     |\n26   |         prime_digits = prime_digits.iter().filter(|&x|\
    \ x != digit).collect();\n     |                                             \
    \                       ^^^^^^^ value of type `Vec<{integer}>` cannot be built\
    \ from `std::iter::Iterator<Item=&{integer}>`\n     |\n     = help: the trait\
    \ `FromIterator<&{integer}>` is not implemented for `Vec<{integer}>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp14y4npdz.rs:29:5\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |                         \
    \   ----- expected `isize` because of return type\n...\n29 |     prime_count\n\
    \   |     ^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    29 |     prime_count.try_into().unwrap()\n   |                ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0609.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97];\n    let mut prime_digits_len = prime_digits.len();\n \
    \   let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let \n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp1rkadndh.rs:54:1\n  \
    \ |\n54 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_index2 = 0;\n    let mut prime_digits_index3 = 0;\n\
    \    let mut prime_digits_index4 = 0;\n    let mut prime_digits_index5 = 0;\n\
    \    let mut prime_digits_index6 = 0;\n    let mut prime_digits_index7 = 0;\n\
    \    let mut prime_digits_index8 = 0;\n    let mut prime_digits_index9 = 0;\n\
    \    let mut prime_digits_index10 = 0;\n    let mut prime_digits_index11 = 0;\n\
    \    let mut prime_digits_index12 = 0;\n    let mut prime_digits_index13 = 0;\n\
    \    let mut prime_digits_index14 = 0;\n    let mut prime_digits_index15 = 0;\n\
    \    let mut prime_digits_index16 = 0;\n    let mut prime_digits_index17 = 0;\n\
    \    let mut prime_digits_index18 = 0;\n    let mut prime_digits_index19 = 0;\n\
    \    let mut prime_digits_index20 = 0;\n    let mut prime_digits_index21 = 0;\n\
    \    let mut prime_digits_index22 = 0;\n    let mut prime_digits_index23 = 0;\n\
    \    let mut prime_digits_index24 = 0;\n    let mut prime_digits_index25 = 0;\n\
    \    let mut prime_digits_index26 = 0;\n    let mut prime_digits_index27 = 0;\n\
    \    let mut prime_digits_index28 = 0;\n    let mut prime_digits_index29 = 0;\n\
    \    let mut prime_digits_index30 = 0;\n    let mut prime_digits_index31 = 0;\n\
    \    let mut prime_digits_index32 = 0;\n    let mut prime_digits_index33 = 0;\n\
    \    let mut prime_digits_index34 = 0;\n    let mut prime_digits_index35 = 0;\n\
    \    let mut prime_digits_index36 = 0;\n    let mut prime_digits_index37 = 0;\n\
    \    let mut prime_digits_index38 = 0;\n    let mut prime_digits_index39 = 0;\n\
    \    let mut prime_digits_index40 = 0;\n    let mut prime_digits_index41 = 0;\n\
    \    let mut prime_digits_index42 = 0;\n    let mut prime_digits_index43 = 0;\n\
    \    let mut prime_digits_index44 = 0;\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb8lqssh5.rs:65:11\n   |\n\
    65 |     let mu\n   |           ^ help: add `;` here\n66 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb8lqssh5.rs:17:28\n \
    \  |\n17 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num_digits = num.chars().filter(|c| c >= '0' && c <=\
    \ '9').count();\n    let mut prime_digits = vec![];\n    let mut prime_counter\
    \ = 0;\n    let mut prime_counter2 = 0;\n    let mut prime_counter3 = 0;\n   \
    \ let mut prime_counter4 = 0;\n    let mut prime_counter5 = 0;\n    let mut prime_counter6\
    \ = 0;\n    let mut prime_counter7 = 0;\n    let mut prime_counter8 = 0;\n   \
    \ let mut prime_counter9 = 0;\n    let mut prime_counter10 = 0;\n    let mut prime_counter11\
    \ = 0;\n    let mut prime_counter12 = 0;\n    let mut prime_counter13 = 0;\n \
    \   let mut prime_counter14 = 0;\n    let mut prime_counter15 = 0;\n    let mut\
    \ prime_counter16 = 0;\n    let mut prime_counter17 = 0;\n    let mut prime_counter18\
    \ = 0;\n    let mut prime_counter19 = 0;\n    let mut prime_counter20 = 0;\n \
    \   let mut prime_counter21 = 0;\n    let mut prime_counter22 = 0;\n    let mut\
    \ prime_counter23 = 0;\n    let mut prime_counter24 = 0;\n    let mut prime_counter25\
    \ = 0;\n    let mut prime_counter26 = 0;\n    let mut prime_counter27 = 0;\n \
    \   let mut prime_counter28 = 0;\n    let mut prime_counter29 = 0;\n    let mut\
    \ prime_counter30 = 0;\n    let mut prime_counter31 = 0;\n    let mut prime_counter32\
    \ = 0;\n    let mut prime_counter33 = 0;\n    let mut prime_counter34 = 0;\n \
    \   let mut prime_counter35 = 0;\n    let mut prime_counter36 = 0;\n    let mut\
    \ prime_counter37 = 0;\n    let mut prime_counter38 = 0;\n    let mut prime_counter39\
    \ = 0;\n    let mut prime_counter40 = 0;\n    let mut prime_counter41 = 0;\n \
    \   let mut prime_counter42 = 0;\n    let mut prime_counter43 = 0;\n    let mut\
    \ prime_counter44 = 0;\n    let mut prime_counter45 = 0;\n    let mut prime_counter46\
    \ = 0;\n    let mut prime_counter47 = 0;\n    let mut prime_counter48 = 0;\n \
    \   let mut prime_counter49 = 0;\n    let mut prime_counter50 = 0;\n    let mut\
    \ prime_counter51 = 0;\n    let mut prime_counter52 = 0;\n    let mut prime_counter53\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpm19mddfn.rs:73:11\n   |\n\
    73 |     let mu\n   |           ^ help: add `;` here\n74 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm19mddfn.rs:18:54\n \
    \  |\n18 |     let mut num_digits = num.chars().filter(|c| c >= '0' && c <= '9').count();\n\
    \   |                                                      ^^^\n   |         \
    \                                             |\n   |                        \
    \                              expected `&char`, found `char`\n   |          \
    \                                            help: consider borrowing here: `&'0'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm19mddfn.rs:18:66\n   |\n18 |\
    \     let mut num_digits = num.chars().filter(|c| c >= '0' && c <= '9').count();\n\
    \   |                                                                  ^^^\n \
    \  |                                                                  |\n   |\
    \                                                                  expected `&char`,\
    \ found `char`\n   |                                                         \
    \         help: consider borrowing here: `&'9'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpm19mddfn.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: isize = 0;\n    let mut num_digits = num.len();\n\
    \    let mut prime_digits = 2;\n    let mut prime_digits_counter = 0;\n    let\
    \ mut prime_digits_counter2 = 0;\n    let mut prime_digits_counter3 = 0;\n   \
    \ let mut prime_digits_counter4 = 0;\n    let mut prime_digits_counter5 = 0;\n\
    \    let mut prime_digits_counter6 = 0;\n    let mut prime_digits_counter7 = 0;\n\
    \    let mut prime_digits_counter8 = 0;\n    let mut prime_digits_counter9 = 0;\n\
    \    let mut prime_digits_counter10 = 0;\n    let mut prime_digits_counter11 =\
    \ 0;\n    let mut prime_digits_counter12 = 0;\n    let mut prime_digits_counter13\
    \ = 0;\n    let mut prime_digits_counter14 = 0;\n    let mut prime_digits_counter15\
    \ = 0;\n    let mut prime_digits_counter16 = 0;\n    let mut prime_digits_counter17\
    \ = 0;\n    let mut prime_digits_counter18 = 0;\n    let mut prime_digits_counter19\
    \ = 0;\n    let mut prime_digits_counter20 = 0;\n    let mut prime_digits_counter21\
    \ = 0;\n    let mut prime_digits_counter22 = 0;\n    let mut prime_digits_counter23\
    \ = 0;\n    let mut prime_digits_counter24 = 0;\n    let mut prime_digits_counter25\
    \ = 0;\n    let mut prime_digits_counter26 = 0;\n    let mut prime_digits_counter27\
    \ = 0;\n    let mut prime_digits_counter28 = 0;\n    let mut prime_digits_counter29\
    \ = 0;\n    let mut prime_digits_counter30 = 0;\n    let mut prime_digits_counter31\
    \ = 0;\n    let mut prime_digits_counter32 = 0;\n    let mut prime_digits_counter33\
    \ = 0;\n    let mut prime_digits_counter34 = 0;\n    let mut prime_digits_counter35\
    \ = 0;\n    let mut prime_digits_counter36 = 0;\n    let mut prime_digits_counter37\
    \ = 0;\n    let mut prime_digits_counter38 = 0;\n    let mut prime_digits_counter39\
    \ = 0;\n    let mut prime_digits_counter40 = 0;\n    let mut prime_digits_counter41\
    \ = 0;\n    let mut prime_digits_counter42 = 0;\n    let mut prime_digits_counter43\
    \ = 0;\n    let mut prime_digits_counter44 = 0;\n    let mut prime\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7rbsd4fd.rs:65:18\n   |\n\
    65 |     let mut prime\n   |                  ^ help: add `;` here\n66 | }\n \
    \  | - unexpected token\n\nerror[E0599]: no method named `len` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmp7rbsd4fd.rs:19:30\n   |\n19 |  \
    \   let mut num_digits = num.len();\n   |                              ^^^ method\
    \ not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7rbsd4fd.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157,\
    \ 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241,\
    \ 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347,\
    \ 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439,\
    \ 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547,\
    \ 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,\
    \ 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751,\
    \ 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,\
    \ 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,\
    \ 983, 991, 997];\n    let mut prime_digits_len = prime_digits.len();\n    let\
    \ mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpebe5kuj4.rs:32:19\n   |\n\
    32 |     let mut prime_\n   |                   ^ help: add `;` here\n33 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpebe5kuj4.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut digits = num.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ digits_iter = digits.iter();\n    let mut digits_iter_next = digits_iter.next();\n\
    \    while digits_iter_next.is_some() {\n        let digit = digits_iter_next.unwrap();\n\
    \        if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit\
    \ == 'E' || digit == 'F' {\n            prime_digits.push_back(digit);\n     \
    \   }\n        digits_iter_next = digits_iter.next();\n    }\n    let mut prime_digits_iter\
    \ = prime_digits.iter();\n    let mut prime_digits_iter_next = prime_digits_iter.next();\n\
    \    while prime_digits_iter_next.is_some() {\n        let prime_digit = prime_digits_iter_next.unwrap();\n\
    \        if prime_digit == '2' || prime_digit == '3' || prime_digit == '5' ||\
    \ prime_digit == '7' || prime_digit == '11' || prime_digit == '13' || prime_digit\
    \ == '17' || prime_digit == '19' || prime_digit == '31' || prime_digit == '37'\
    \ || prime_digit == '41' || prime_digit == '43' || prime_digit == '47' || prime_digit\
    \ == '53' || prime_digit == '59' || prime_digit == '61' || prime_digit == '67'\
    \ || prime_digit == '71' || prime_digit == '73' || prime_digit == '79' || prime_digit\
    \ == '83' || prime_digit == '89' || prime_digit == '97' {\n            prime_count++;\n\
    \        }\n        prime_digits_iter_next = prime_digits_iter.next();\n    }\n\
    \    prime_count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpxh18tifr.rs:34:115\n\
    \   |\n34 | ...   if prime_digit == '2' || prime_digit == '3' || prime_digit ==\
    \ '5' || prime_digit == '7' || prime_digit == '11' || prime_digit == '1...\n \
    \  |                                                                         \
    \                                        ^^^^\n   |\nhelp: if you meant to write\
    \ a `str` literal, use double quotes\n   |\n34 |         if prime_digit == '2'\
    \ || prime_digit == '3' || prime_digit == '5' || prime_digit == '7' || prime_digit\
    \ == \"11\" || prime_digit == '13' || prime_digit == '17' || prime_digit == '19'\
    \ || prime_digit == '31' || prime_digit == '37' || prime_digit == '41' || prime_digit\
    \ == '43' || prime_digit == '47' || prime_digit == '53' || prime_digit == '59'\
    \ || prime_digit == '61' || prime_digit == '67' || prime_digit == '71' || prime_digit\
    \ == '73' || prime_digit == '79' || prime_digit == '83' || prime_digit == '89'\
    \ || prime_digit == '97' {\n   |                                             \
    \                                                                      ~~~~\n\n\
    error: character literal may only contain one codepoint\n  --> /tmp/tmpxh18tifr.rs:34:138\n\
    \   |\n34 | ...' || prime_digit == '7' || prime_digit == '11' || prime_digit ==\
    \ '13' || prime_digit == '17' || prime_digit == '19' || prime_digit == ...\n \
    \  |                                                                     ^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    34 |         if prime_digit == '2' || prime_digit == '3' || prime_digit == '5'\
    \ || prime_digit == '7' || prime_digit == '11' || prime_digit == \"13\" || prime_digit\
    \ == '17' || prime_digit == '19' || prime_digit == '31' || prime_digit == '37'\
    \ || prime_digit == '41' || prime_digit == '43' || prime_digit == '47' || prime_digit\
    \ == '53' || prime_digit == '59' || prime_digit == '61' || prime_digit == '67'\
    \ || prime_digit == '71' || prime_digit == '73' || prime_digit == '79' || prime_digit\
    \ == '83' || prime_digit == '89' || prime_digit == '97' {\n   |             "
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17];\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpngzm6ke9.rs:54:48\n   |\n\
    54 |     let mut prime_digits_len = prime_digits.len\n   |                   \
    \                             ^ help: add `;` here\n55 | }\n   | - unexpected\
    \ token\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpngzm6ke9.rs:54:45\n\
    \   |\n54 |     let mut prime_digits_len = prime_digits.len\n   |            \
    \                                 ^^^ private field\n   |\nhelp: a method `len`\
    \ also exists, call it with parentheses\n   |\n54 |     let mut prime_digits_len\
    \ = prime_digits.len()\n   |                                                ++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpngzm6ke9.rs:17:28\n   |\n17 |\
    \ fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0616.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![];\n    let mut num_prime_counter: usize\
    \ = 0;\n    let mut num_prime_counter2: usize = 0;\n    let mut num_prime_counter3:\
    \ usize = 0;\n    let mut num_prime_counter4: usize = 0;\n    let mut num_prime_counter5:\
    \ usize = 0;\n    let mut num_prime_counter6: usize = 0;\n    let mut num_prime_counter7:\
    \ usize = 0;\n    let mut num_prime_counter8: usize = 0;\n    let mut num_prime_counter9:\
    \ usize = 0;\n    let mut num_prime_counter10: usize = 0;\n    let mut num_prime_counter11:\
    \ usize = 0;\n    let mut num_prime_counter12: usize = 0;\n    let mut num_prime_counter13:\
    \ usize = 0;\n    let mut num_prime_counter14: usize = 0;\n    let mut num_prime_counter15:\
    \ usize = 0;\n    let mut num_prime_counter16: usize = 0;\n    let mut num_prime_counter17:\
    \ usize = 0;\n    let mut num_prime_counter18: usize = 0;\n    let mut num_prime_counter19:\
    \ usize = 0;\n    let mut num_prime_counter20: usize = 0;\n    let mut num_prime_counter21:\
    \ usize = 0;\n    let mut num_prime_counter22: usize = 0;\n    let mut num_prime_counter23:\
    \ usize = 0;\n    let mut num_prime_counter24: usize = 0;\n    let mut num_prime_counter25:\
    \ usize = 0;\n    let mut num_prime_counter26: usize = 0;\n    let mut num_prime_counter27:\
    \ usize = 0;\n    let mut num_prime_counter28: usize = 0;\n    let mut num_prime_counter29:\
    \ usize = 0;\n    let mut num_prime_counter30: usize = 0;\n    let mut num_prime_counter31:\
    \ usize = 0;\n    let mut num_prime_counter32: usize = 0;\n    let mut num_prime_counter33:\
    \ usize = 0;\n    let mut num_prime_counter34: usize = 0;\n    let mut num_prime_counter35:\
    \ usize = 0;\n    let mut num_prime_counter36: usize = 0;\n    let mut num_prime_counter37:\
    \ usize = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcpof8j49.rs:57:11\n   |\n\
    57 |     let mu\n   |           ^ help: add `;` here\n58 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpcpof8j49.rs:18:55\n     |\n18\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcpof8j49.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![];\n    let mut prime_counter: usize = 0;\n\
    \    let mut prime_counter2: usize = 0;\n    let mut prime_counter3: usize = 0;\n\
    \    let mut prime_counter4: usize = 0;\n    let mut prime_counter5: usize = 0;\n\
    \    let mut prime_counter6: usize = 0;\n    let mut prime_counter7: usize = 0;\n\
    \    let mut prime_counter8: usize = 0;\n    let mut prime_counter9: usize = 0;\n\
    \    let mut prime_counter10: usize = 0;\n    let mut prime_counter11: usize =\
    \ 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13: usize\
    \ = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: usize = 0;\n    let mut prime\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr1gyph_6.rs:60:18\n   |\n\
    60 |     let mut prime\n   |                  ^ help: add `;` here\n61 | }\n \
    \  | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmpr1gyph_6.rs:18:55\n\
    \     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr1gyph_6.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97];\n    let mut prime_digits_len = prime_digits.len();\n \
    \   let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n    let mut prime_digits_\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpriep6jnn.rs:38:26\n   |\n\
    38 |     let mut prime_digits_\n   |                          ^ help: add `;`\
    \ here\n39 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around\
    \ method argument\n  --> /tmp/tmpriep6jnn.rs:21:64\n   |\n21 |     let mut prime_digits_len\
    \ = prime_digits_len.saturating_add((prime_digits_len % 2));\n   |           \
    \                                                     ^                    ^\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n21 -     let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n21 +     let mut prime_digits_len = prime_digits_len.saturating_add(prime_digits_len\
    \ % 2);\n   | \n\nwarning: unnecessary parentheses around method argument\n  -->\
    \ /tmp/tmpriep6jnn.rs:22:64\n   |\n22 |     let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n   |                                                               \
    \ ^                    ^\n   |\nhelp: remove these parentheses\n   |\n22 -   \
    \  let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n22 +     let mut prime_digits_len = prime_digits_len.saturating_add(prime_digits_len\
    \ % 2);\n   | \n\nwarning: unnecessary parentheses around method argument\n  -->\
    \ /tmp/tmpriep6jnn.rs:23:64\n   |\n23 |     let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n   |                                                               \
    \ ^                    ^\n   |\nhelp: remove these parentheses\n   |\n23 -   \
    \  let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n23 +     let mut prime_digits_len = prime_digits_len.saturating_add(prime_digits_len\
    \ % 2);\n   | \n\nwarning: unnecessary parentheses around method argument\n  -->\
    \ /tmp/tmpriep6jnn.rs:24:64\n   |\n24 |     let mut prime_digits_len = prime_digits_len.saturating_add((prime_digits_len\
    \ % 2));\n   |                                                               \
    \ ^                    ^\n   |\nhelp: r"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: isize = 0;\n    let mut num_digits = num.len();\n\
    \    let mut prime_digits = false;\n    let mut prime_digit = 0;\n    let mut\
    \ prime_digit_count = 0;\n    let mut prime_digit_count_max = 2;\n    let mut\
    \ prime_digit_count_min = 2;\n    let mut prime_digit_count_max2 = 2;\n    let\
    \ mut prime_digit_count_min2 = 2;\n    let mut prime_digit_count_max3 = 2;\n \
    \   let mut prime_digit_count_min3 = 2;\n    let mut prime_digit_count_max4 =\
    \ 2;\n    let mut prime_digit_count_min4 = 2;\n    let mut prime_digit_count_max5\
    \ = 2;\n    let mut prime_digit_count_min5 = 2;\n    let mut prime_digit_count_max6\
    \ = 3;\n    let mut prime_digit_count_min6 = 3;\n    let mut prime_digit_count_max7\
    \ = 3;\n    let mut prime_digit_count_min7 = 3;\n    let mut prime_digit_count_max8\
    \ = 3;\n    let mut prime_digit_count_min8 = 3;\n    let mut prime_digit_count_max9\
    \ = 3;\n    let mut prime_digit_count_min9 = 3;\n    let mut prime_digit_count_max10\
    \ = 3;\n    let mut prime_digit_count_min10 = 3;\n    let mut prime_digit_count_max11\
    \ = 3;\n    let mut prime_digit_count_min11 = 3;\n    let mut prime_digit_count_max12\
    \ = 3;\n    let mut prime_digit_count_min12 = 3;\n    let mut prime_digit_count_max13\
    \ = 3;\n    let mut prime_digit_count_min13 = 3;\n    let mut prime_digit_count_max14\
    \ = 3;\n    let mut prime_digit_count_min14 = 3;\n    let mut prime_digit_count_max15\
    \ = 3;\n    let mut prime_digit_count_min15 = 3;\n    let mut prime_digit_count_max16\
    \ = 3;\n    let mut prime_digit_count_min16 = 3;\n    let mut prime_digit_count_max17\
    \ = 3;\n    let mut prime_digit_count_min17 = 3;\n    let mut prime_digit_count_max18\
    \ = 3;\n    let mut prime_digit_count_min18 = 3;\n    let mut prime_digit_count_max19\
    \ = 3;\n    let mut prime_digit_count_min19 = 3;\n    let mut prime_digit_count_max20\
    \ = 3;\n    let mut prime_digit_count_min20 = 3;\n    let mut prime_digit_count_max21\
    \ = 4;\n    let mut prime_digit_count_min21 = 4;\n    let mut prime_digit_count_max22\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp81jom5vx.rs:65:36\n   |\n\
    65 |     let mut prime_digit_count_max22\n   |                               \
    \     ^ help: add `;` here\n66 | }\n   | - unexpected token\n\nerror[E0599]: no\
    \ method named `len` found for type `isize` in the current scope\n  --> /tmp/tmp81jom5vx.rs:19:30\n\
    \   |\n19 |     let mut num_digits = num.len();\n   |                        \
    \      ^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp81jom5vx.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize {\n \
    \  |    -------                 ^^^^^ expected `isize`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_set = HashSet::new();\n    let mut prime_digits_set_size\
    \ = prime_digits_set.len();\n    let mut prime_digits_set_iter = prime_digits_set.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter_size = prime_digits_set_iter.len();\n    let\
    \ mut prime_digits_set_iter_iter = prime_digits_set_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter_iter_size = prime_digits_set_iter_iter.len();\n\
    \    let mut prime_digits_set_iter_iter_iter = prime_digits_set_iter_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter_iter_iter_size = prime_digits_set_iter_iter_iter.len();\n\
    \    let mut prime_digits_set_iter_iter_iter_iter = prime_digits_set_iter_iter_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter_iter_iter_iter_size = prime_digits_set_iter_iter_iter_iter.len();\n\
    \    let mut prime_digits_set_iter_iter_iter_iter_iter = prime_digits_set_iter_iter_iter_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter_iter_iter_iter_iter_size = prime_digits_set_iter_iter_iter_iter_iter.len();\n\
    \    let mut prime_digits_set_iter_iter_iter_iter_iter_iter = prime_digits_set_iter_iter_iter_iter_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter_iter_iter_iter_iter_iter_size = prime_digits_set_iter_iter_iter_iter_iter_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter_iter_iter_iter_iter_iter_iter = prime_digits_set_iter_iter_iter_iter_iter_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter_iter_iter_iter_iter_iter_iter_size = prime_digits_set_iter_iter_iter_iter_iter_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digits_set_iter_iter_iter_iter_iter_iter_iter_iter = prime_digits_set_iter_iter_iter_iter_iter_iter.iter().cloned().collect::<Vec<_>>\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: field expressions cannot have generic arguments\n  --> /tmp/tmpk06jsuqu.rs:36:144\n\
    \   |\n36 | ...its_set_iter_iter_iter_iter_iter_iter.iter().cloned().collect::<Vec<_>>\n\
    \   |                                                                   ^^^^^^^^\n\
    \nerror: expected `;`, found `}`\n  --> /tmp/tmpk06jsuqu.rs:36:152\n   |\n36 |\
    \     let mut prime_digits_set_iter_iter_iter_iter_iter_iter_iter_iter = prime_digits_set_iter_iter_iter_iter_iter_iter.iter().cloned().collect::<Vec<_>>\n\
    \   |                                                                        \
    \                                                                            \
    \    ^ help: add `;` here\n37 | }\n   | - unexpected token\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpk06jsuqu.rs:20:32\n\
    \   |\n20 |     let mut prime_digits_set = HashSet::new();\n   |             \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk06jsuqu.rs:17:28\n   |\n17 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97];\n    let mut prime_digits_len = prime_digits.len();\n \
    \   let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let \n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp0upgm2s7.rs:54:1\n  \
    \ |\n54 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_digits = vec![];\n    let mut prime_digit_count\
    \ = 0;\n    let mut prime_digit_count_2 = 0;\n    let mut prime_digit_count_3\
    \ = 0;\n    let mut prime_digit_count_4 = 0;\n    let mut prime_digit_count_5\
    \ = 0;\n    let mut prime_digit_count_6 = 0;\n    let mut prime_digit_count_7\
    \ = 0;\n    let mut prime_digit_count_8 = 0;\n    let mut prime_digit_count_9\
    \ = 0;\n    let mut prime_digit_count_10 = 0;\n    let mut prime_digit_count_11\
    \ = 0;\n    let mut prime_digit_count_12 = 0;\n    let mut prime_digit_count_13\
    \ = 0;\n    let mut prime_digit_count_14 = 0;\n    let mut prime_digit_count_15\
    \ = 0;\n    let mut prime_digit_count_16 = 0;\n    let mut prime_digit_count_17\
    \ = 0;\n    let mut prime_digit_count_18 = 0;\n    let mut prime_digit_count_19\
    \ = 0;\n    let mut prime_digit_count_20 = 0;\n    let mut prime_digit_count_21\
    \ = 0;\n    let mut prime_digit_count_22 = 0;\n    let mut prime_digit_count_23\
    \ = 0;\n    let mut prime_digit_count_24 = 0;\n    let mut prime_digit_count_25\
    \ = 0;\n    let mut prime_digit_count_26 = 0;\n    let mut prime_digit_count_27\
    \ = 0;\n    let mut prime_digit_count_28 = 0;\n    let mut prime_digit_count_29\
    \ = 0;\n    let mut prime_digit_count_30 = 0;\n    let mut prime_digit_count_31\
    \ = 0;\n    let mut prime_digit_count_32 = 0;\n    let mut prime_digit_count_33\
    \ = 0;\n    let mut prime_digit_count_34 = 0;\n    let mut prime_digit_count_35\
    \ = 0;\n    let mut prime_digit_count_36 = 0;\n    let mut prime_digit_count_37\
    \ = 0;\n    let mut prime_digit_count_38 = 0;\n    let mut prime_digit_count_39\
    \ = 0;\n    let mut prime_digit_count_40 = 0;\n    let mut prime_digit_count_41\
    \ = 0;\n    let mut prime_digit_count_42 = 0;\n    let mut prime_digit_count_43\
    \ = 0;\n    let mut prime_digit_count_44 = 0;\n    let mut prime_digit_count_45\
    \ = 0;\n    let mut prime_digit_count_46 = 0;\n    let mut prime_digit_count_47\
    \ = 0;\n    let mut prime_digit_count_48 = 0;\n    let mut prime_digit_count_49\
    \ = 0;\n    let mut prime_digit_count_50 = 0;\n    let mut prime_digit_count_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv4opj8lp.rs:69:31\n   |\n\
    69 |     let mut prime_digit_count_\n   |                               ^ help:\
    \ add `;` here\n70 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv4opj8lp.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_digits = vec![2, 3, 4, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut\
    \ prime_digits_len = prime_digits.len();\n    let mut prime_digits_count = prime_digits_len;\n\
    \    let mut prime_digits_count_2 = prime_digits_count;\n    let mut prime_digits_count_3\
    \ = prime_digits_count;\n    let mut prime_digits_count_4 = prime_digits_count;\n\
    \    let mut prime_digits_count_5 = prime_digits_count;\n    let mut prime_digits_count_6\
    \ = prime_digits_count;\n    let mut prime_digits_count_7 = prime_digits_count;\n\
    \    let mut prime_digits_count_8 = prime_digits_count;\n    let mut prime_digits_count_9\
    \ = prime_digits_count;\n    let mut prime_digits_count_10 = prime_digits_count;\n\
    \    let mut prime_digits_count_11 = prime_digits_count;\n    let mut prime_digits_count_12\
    \ = prime_digits_count;\n    let mut prime_digits_count_13 = prime_digits_count;\n\
    \    let mut prime_digits_count_14 = prime_digits_count;\n    let mut prime_digits_count_15\
    \ = prime_digits_count;\n    let mut prime_digits_count_16 = prime_digits_count;\n\
    \    let mut prime_digits_count_17 = prime_digits_count;\n    let mut prime_digits_count_18\
    \ = prime_digits_count;\n    let mut prime_digits_count_19 = prime_digits_count;\n\
    \    let mut prime_digits_count_20 = prime_digits_count;\n    let mut prime_digits_count_21\
    \ = prime_digits_count;\n    let mut prime_digits_count_22 = prime_digits_count;\n\
    \    let mut prime_digits_count_23 = prime_digits_count;\n    let mut prime_digits_count_24\
    \ = prime_digits_count;\n    let mut prime_digits_count_25 = prime_digits_count;\n\
    \    let mut prime_digits_count_26 = prime_digits_count;\n    let mut prime_digits_count_27\
    \ = prime_digits_count;\n    let mut prime_digits_count_28 = prime_digits_count;\n\
    \    let mut prime_digits_count_29 = prime_digits_count;\n    let mut prime_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1e_sfsct.rs:49:19\n   |\n\
    49 |     let mut prime_\n   |                   ^ help: add `;` here\n50 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1e_sfsct.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut prime_counter = 0;\n    let\
    \ mut prime_digits = vec![];\n    let mut prime_digits_counter = 0;\n    let mut\
    \ prime_digits_counter2 = 0;\n    let mut prime_digits_counter3 = 0;\n    let\
    \ mut prime_digits_counter4 = 0;\n    let mut prime_digits_counter5 = 0;\n   \
    \ let mut prime_digits_counter6 = 0;\n    let mut prime_digits_counter7 = 0;\n\
    \    let mut prime_digits_counter8 = 0;\n    let mut prime_digits_counter9 = 0;\n\
    \    let mut prime_digits_counter10 = 0;\n    let mut prime_digits_counter11 =\
    \ 0;\n    let mut prime_digits_counter12 = 0;\n    let mut prime_digits_counter13\
    \ = 0;\n    let mut prime_digits_counter14 = 0;\n    let mut prime_digits_counter15\
    \ = 0;\n    let mut prime_digits_counter16 = 0;\n    let mut prime_digits_counter17\
    \ = 0;\n    let mut prime_digits_counter18 = 0;\n    let mut prime_digits_counter19\
    \ = 0;\n    let mut prime_digits_counter20 = 0;\n    let mut prime_digits_counter21\
    \ = 0;\n    let mut prime_digits_counter22 = 0;\n    let mut prime_digits_counter23\
    \ = 0;\n    let mut prime_digits_counter24 = 0;\n    let mut prime_digits_counter25\
    \ = 0;\n    let mut prime_digits_counter26 = 0;\n    let mut prime_digits_counter27\
    \ = 0;\n    let mut prime_digits_counter28 = 0;\n    let mut prime_digits_counter29\
    \ = 0;\n    let mut prime_digits_counter30 = 0;\n    let mut prime_digits_counter31\
    \ = 0;\n    let mut prime_digits_counter32 = 0;\n    let mut prime_digits_counter33\
    \ = 0;\n    let mut prime_digits_counter34 = 0;\n    let mut prime_digits_counter35\
    \ = 0;\n    let mut prime_digits_counter36 = 0;\n    let mut prime_digits_counter37\
    \ = 0;\n    let mut prime_digits_counter38 = 0;\n    let mut prime_digits_counter39\
    \ = 0;\n    let mut prime_digits_counter40 = 0;\n    let mut prime_digits_counter41\
    \ = 0;\n    let mut prime_digits_counter42 = 0;\n    let mut prime_digits_counter43\
    \ = 0;\n    let mut prime_digits_counter44 = 0;\n    let mut prime_digits_counter\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp704prvc4.rs:65:33\n   |\n\
    65 |     let mut prime_digits_counter\n   |                                 ^\
    \ help: add `;` here\n66 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp704prvc4.rs:17:28\n   |\n17 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_digits = vec![2, 3, 5, 7, 11, 13, 17];\n    let\
    \ mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_count =\
    \ prime_digits_len;\n    let mut prime_digits_sum = 0;\n    let mut prime_digits_product\
    \ = 1;\n    let mut prime_digits_product2 = 1;\n    let mut prime_digits_product3\
    \ = 1;\n    let mut prime_digits_product4 = 0;\n    let mut prime_digits_product5\
    \ = 0;\n    let mut prime_digits_product6 = 0;\n    let mut prime_digits_product7\
    \ = 0;\n    let mut prime_digits_product8 = 0;\n    let mut prime_digits_product9\
    \ = 0;\n    let mut prime_digits_product10 = 0;\n    let mut prime_digits_product11\
    \ = 0;\n    let mut prime_digits_product12 = 0;\n    let mut prime_digits_product13\
    \ = 0;\n    let mut prime_digits_product14 = 0;\n    let mut prime_digits_product15\
    \ = 0;\n    let mut prime_digits_product16 = 0;\n    let mut prime_digits_product17\
    \ = 0;\n    let mut prime_digits_product18 = 0;\n    let mut prime_digits_product19\
    \ = 0;\n    let mut prime_digits_product20 = 0;\n    let mut prime_digits_product21\
    \ = 0;\n    let mut prime_digits_product22 = 0;\n    let mut prime_digits_product23\
    \ = 0;\n    let mut prime_digits_product24 = 0;\n    let mut prime_digits_product25\
    \ = 0;\n    let mut prime_digits_product26 = 0;\n    let mut prime_digits_product27\
    \ = 0;\n    let mut prime_digits_product28 = 0;\n    let mut prime_digits_product29\
    \ = 0;\n    let mut prime_digits_product30 = 0;\n    let mut prime_digits_product31\
    \ = 0;\n    let mut prime_digits_product32 = 0;\n    let mut prime_digits_product33\
    \ = 0;\n    let mut prime_digits_product34 = 0;\n    let mut prime_digits_product35\
    \ = 0;\n    let mut prime_digits_product36 = 0;\n    let mut prime_digits_product37\
    \ = 0;\n    let mut prime_digits_product38 = 0;\n    let mut prime_digits_product39\
    \ = 0;\n    let mut prime_digits_product40 = 0;\n    let mut prime_digits_product41\
    \ = 0;\n    let mut prime_digits_product42 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkxvj6sm7.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_digits = vec![false; 26];\n    let mut prime_digits_count\
    \ = vec![0; 26];\n    let mut prime_digits_count_max = vec![0; 26];\n    let mut\
    \ prime_digits_count_max_index = vec![0; 26];\n    let mut prime_digits_count_min\
    \ = vec![0; 26];\n    let mut prime_digits_count_min_index = vec![0; 26];\n  \
    \  let mut prime_digits_count_max_index = vec![0; 26];\n    let mut prime_digits_count_min_index\
    \ = vec![0; 26];\n    let mut prime_digits_count_max_index = vec![0; 26];\n  \
    \  let mut prime_digits_count_min_index = vec![0; 26];\n    let mut prime_digits_count_max_index\
    \ = vec![0; 26];\n    let mut prime_digits_count_min_index = vec![0; 26];\n  \
    \  let mut prime_digits_count_max_index = vec![0; 26];\n    let mut prime_digits_count_min_index\
    \ = vec![0; 26];\n    let mut prime_digits_count_max_index = vec![0; 26];\n  \
    \  let mut prime_digits_count_min_index = vec![0; 26];\n    let mut prime_digits_count_max_index\
    \ = vec![0; 26];\n    let mut prime_digits_count_min_index = vec![0; 26];\n  \
    \  let mut prime_digits_count_max_index = vec![0; 26];\n    let mut prime_digits_count_min_index\
    \ = vec![0; 26];\n    let mut prime_digits_count_max_index = vec![0; 26];\n  \
    \  let mut prime_digits_count_min_index = vec![0; 26];\n    let mut prime_digits_count_max_index\
    \ = vec![0; 26];\n    let mut prime_digits_count_min_index = vec![0; 26];\n  \
    \  let mut prime_digits_count_max_index = vec![0; 26];\n    let mut prime_digits_count_min_index\
    \ = vec![0; 26];\n    let mut prime_digits_count_max_index = vec![0; 26];\n  \
    \  let mut prime_digits_count_min_index = vec![0; 26];\n    let mut prime_digits_count_max_index\
    \ = vec![0; 26];\n    let mut prime_digits_count_min_index = vec![0; 26];\n  \
    \  let mut prime_digits_count_max_index = vec![0; 26];\n    let mut prime_digits_count_min_index\
    \ = vec![0; 26];\n    let mut prime_digit\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7jlz81tv.rs:50:24\n   |\n\
    50 |     let mut prime_digit\n   |                        ^ help: add `;` here\n\
    51 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7jlz81tv.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut nums = num.to_lowercase();\n    let mut prime_count\
    \ = 0;\n    let mut prime_digits = vec![];\n    let mut prime_digit = vec![];\n\
    \    let mut prime_digit_count = 1;\n    let mut prime_digit_index = 0;\n    let\
    \ mut prime_digit_index2 = 0;\n    let mut prime_digit_index3 = 0;\n    let mut\
    \ prime_digit_index4 = 0;\n    let mut prime_digit_index5 = 0;\n    let mut prime_digit_index6\
    \ = 0;\n    let mut prime_digit_index7 = 0;\n    let mut prime_digit_index8 =\
    \ 0;\n    let mut prime_digit_index9 = 0;\n    let mut prime_digit_index10 = 0;\n\
    \    let mut prime_digit_index11 = 0;\n    let mut prime_digit_index12 = 0;\n\
    \    let mut prime_digit_index13 = 0;\n    let mut prime_digit_index14 = 0;\n\
    \    let mut prime_digit_index15 = 0;\n    let mut prime_digit_index16 = 0;\n\
    \    let mut prime_digit_index17 = 0;\n    let mut prime_digit_index18 = 0;\n\
    \    let mut prime_digit_index19 = 0;\n    let mut prime_digit_index20 = 0;\n\
    \    let mut prime_digit_index21 = 0;\n    let mut prime_digit_index22 = 0;\n\
    \    let mut prime_digit_index23 = 0;\n    let mut prime_digit_index24 = 0;\n\
    \    let mut prime_digit_index25 = 0;\n    let mut prime_digit_index26 = 0;\n\
    \    let mut prime_digit_index27 = 0;\n    let mut prime_digit_index28 = 0;\n\
    \    let mut prime_digit_index29 = 0;\n    let mut prime_digit_index30 = 0;\n\
    \    let mut prime_digit_index31 = 0;\n    let mut prime_digit_index32 = 0;\n\
    \    let mut prime_digit_index33 = 0;\n    let mut prime_digit_index34 = 0;\n\
    \    let mut prime_digit_index35 = 0;\n    let mut prime_digit_index36 = 0;\n\
    \    let mut prime_digit_index37 = 0;\n    let mut prime_digit_index38 = 0;\n\
    \    let mut prime_digit_index39 = 0;\n    let mut prime_digit_index40 = 0;\n\
    \    let mut prime_digit_index41 = 0;\n    let mut prime_digit_index42 = 0;\n\
    \    let mut prime_digit_index43 = 0;\n    let mut prime_digit_index44 = 0;\n\
    \    let mut prime_digit_index45 = 0;\n    let mut prime_digit_index46 = 0;\n\
    \    let mut prime_digit_index47 = 0;\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxe0c8osl.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut num_digits = num.len();\n\
    \    let mut num_digits_div2 = 0;\n    let mut num_digits_div3 = 0;\n    let mut\
    \ num_digits_div4 = 0;\n    let mut num_digits_div5 = 0;\n    let mut num_digits_div6\
    \ = 0;\n    let mut num_digits_div7 = 0;\n    let mut num_digits_div8 = 0;\n \
    \   let mut num_digits_div9 = 0;\n    let mut num_digits_div10 = 0;\n    let mut\
    \ num_digits_div11 = 0;\n    let mut num_digits_div12 = 0;\n    let mut num_digits_div13\
    \ = 0;\n    let mut num_digits_div14 = 0;\n    let mut num_digits_div15 = 0;\n\
    \    let mut num_digits_div16 = 0;\n    let mut num_digits_div17 = 0;\n    let\
    \ mut num_digits_div18 = 0;\n    let mut num_digits_div19 = 0;\n    let mut num_digits_div20\
    \ = 0;\n    let mut num_digits_div21 = 0;\n    let mut num_digits_div22 = 0;\n\
    \    let mut num_digits_div23 = 0;\n    let mut num_digits_div24 = 0;\n    let\
    \ mut num_digits_div25 = 0;\n    let mut num_digits_div26 = 0;\n    let mut num_digits_div27\
    \ = 0;\n    let mut num_digits_div28 = 0;\n    let mut num_digits_div29 = 0;\n\
    \    let mut num_digits_div30 = 0;\n    let mut num_digits_div31 = 0;\n    let\
    \ mut num_digits_div32 = 0;\n    let mut num_digits_div33 = 0;\n    let mut num_digits_div34\
    \ = 0;\n    let mut num_digits_div35 = 0;\n    let mut num_digits_div36 = 0;\n\
    \    let mut num_digits_div37 = 0;\n    let mut num_digits_div38 = 0;\n    let\
    \ mut num_digits_div39 = 0;\n    let mut num_digits_div40 = 0;\n    let mut num_digits_div41\
    \ = 0;\n    let mut num_digits_div42 = 0;\n    let mut num_digits_div43 = 0;\n\
    \    let mut num_digits_div44 = 0;\n    let mut num_digits_div45 = 0;\n    let\
    \ mut num_digits_div46 = 0;\n    let mut num_digits_div47 = 0;\n    let mut num_digits_div48\
    \ = 0;\n    let mut num_digits_div49 = 0;\n    let mut num_digits_div50 = 0;\n\
    \    let mut num_digits_div51\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpeublkvim.rs:69:29\n   |\n\
    69 |     let mut num_digits_div51\n   |                             ^ help: add\
    \ `;` here\n70 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpeublkvim.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157,\
    \ 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241,\
    \ 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347,\
    \ 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439,\
    \ 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547,\
    \ 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,\
    \ 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751,\
    \ 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,\
    \ 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,\
    \ 983, 991, 997];\n    let mut prime_digits_set = HashSet::new();\n    for digit\
    \ in prime_digits {\n        prime_digits_set.insert(digit);\n    }\n    let mut\
    \ num_digits = num.len();\n    while num_digits > 0 {\n        let mut num_digits_copy\
    \ = num_digits;\n        while num_digits_copy > 0 {\n            let digit =\
    \ num[num_digits_copy - 1];\n            if prime_digits_set.contains(&digit)\
    \ {\n                prime_count++;\n                break;\n            }\n \
    \           num_digits_copy--;\n        }\n        num_digits -= 1;\n    }\n \
    \   prime_count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpf8zciije.rs:30:28\n\
    \   |\n30 |                 prime_count++;\n   |                            ^^\
    \ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n30 |   \
    \              { let tmp = prime_count; prime_count += 1; tmp };\n   |       \
    \          +++++++++++            ~~~~~~~~~~~~~~~~~~~~~~~~~\n30 -            \
    \     prime_count++;\n30 +                 prime_count += 1;\n   | \n\nerror:\
    \ expected expression, found `;`\n  --> /tmp/tmpf8zciije.rs:33:30\n   |\n33 |\
    \             num_digits_copy--;\n   |                              ^ expected\
    \ expression\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmpf8zciije.rs:20:32\n   |\n20 |     let mut prime_digits_set = HashSet::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpf8zciije.rs:28:25\n\
    \   |\n28 |             let digit = num[num_digits_copy - 1];\n   |          \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157,\
    \ 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241,\
    \ 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347,\
    \ 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439,\
    \ 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547,\
    \ 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,\
    \ 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751,\
    \ 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,\
    \ 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,\
    \ 983, 991, 997];\n    let mut prime_digits_len = prime_digits.len();\n    let\
    \ mut prime_digits_count = prime_digits_len;\n    let mut prime_digits_index =\
    \ prime_digits_len;\n    let mut prime_digits_value = prime_digits[prime_digits_index];\n\
    \    let mut prime_digits_value = prime_digits_value;\n    let mut prime_digits_value\
    \ = prime_digits_value;\n    let mut prime_digits_value = prime_digits_value;\n\
    \    let mut prime_digits_value = prime_digits_value;\n    let mut prime_digits_value\
    \ = prime_digits_value;\n    let mut prime_digits_value = prime_digits_value;\n\
    \    let mut prime_digits_value = prime_digits_value;\n    let mut prime_digits_value\
    \ = prime_digits_value;\n\n}\n\nfn main() {\n    let candidate = hex_key;\n  \
    \  assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_rxg3szb.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut digits = num.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.length;\n    let mut primes = vec![false; digits_len];\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let mut primes_len = primes.len();\n    let mut primes_len = primes.len();\n\
    \    let \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmphh_zvit1.rs:65:1\n  \
    \ |\n65 | }\n   | ^ expected pattern\n\nerror[E0609]: no field `length` on type\
    \ `Vec<char>`\n  --> /tmp/tmphh_zvit1.rs:20:33\n   |\n20 |     let mut digits_len\
    \ = digits.length;\n   |                                 ^^^^^^ unknown field\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0609`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_digits = vec![2, 3, 4, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut\
    \ prime_digits_len = prime_digits.len();\n    let mut prime_digits_count = prime_digits_len;\n\
    \    let mut prime_digits_count_copy = prime_digits_count;\n    let mut prime_digits_count_copy\
    \ = prime_digits_count;\n    let mut prime_digits_count_copy = prime_digits_count;\n\
    \    let mut prime_digits_count_copy = prime_digits_count;\n    let mut prime_digits_count_copy\
    \ = prime_digits_count;\n    let mut prime_digits_count_copy = prime_digits_count;\n\
    \    let mut prime_digits_count_copy = prime_digits_count;\n    let mut prime_digits_count_copy\
    \ = prime_digits_count;\n    let mut prime_digits_count_copy = prime_digits_count;\n\
    \    let mut prime_digits_count_copy = prime_digits_count;\n    let mut prime_digits_count_copy\
    \ = prime_digits_count;\n    let mut prime_digits_count_copy = prime_digits_count;\n\
    \    let mut prime_digits_count_copy = prime_digits_count;\n    let mut prime_digits_count_copy\
    \ = prime_digits_count;\n    let mut prime_digits_count_copy = prime_digits_count;\n\
    \    let mut prime_digits_count_copy = prime_digits_count;\n    let mut prime_digits_count_copy\
    \ = prime_digits_count;\n    let mut prime_digits_count_copy = prime_digits_count;\n\
    \    let mut prime_digits_count_copy = prime_digits_count;\n    let mut prime_digits_count_copy\
    \ = prime_digits_count;\n    let mut prime_digits_count_copy = prime_digits_count;\n\
    \    let mut prime_digits_count_copy = prime_digits_count;\n    let mut prime_digits_count_copy\
    \ = prime_digits_count;\n    let mut prime_digits_count_copy = prime_digits_count;\n\
    \    let mut prime_digits_count_copy = prime_digits_count;\n    let mut prime_digits_count_copy\
    \ = prime_digits_count;\n    let mut prime_digits_count_copy = prime_digits_count;\n\
    \    let mut prime_digits_count_copy = prime_digits_count;\n    let mut prime_digits_count_copy\
    \ = prime_digits_count;\n    let mut prime_digits_\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9q36imy_.rs:50:26\n   |\n\
    50 |     let mut prime_digits_\n   |                          ^ help: add `;`\
    \ here\n51 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9q36imy_.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize {\n \
    \  |    -------                 ^^^^^ expected `isize`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut digit_count = 1;\n   \
    \ let mut digit_sum = 0;\n    let mut digit_sum2 = 0;\n    let mut digit_sum3\
    \ = 0;\n    let mut digit_sum4 = 0;\n    let mut digit_sum5 = 0;\n    let mut\
    \ digit_sum6 = 0;\n    let mut digit_sum7 = 0;\n    let mut digit_sum8 = 0;\n\
    \    let mut digit_sum9 = 0;\n    let mut digit_sum10 = 0;\n    let mut digit_sum11\
    \ = 0;\n    let mut digit_sum12 = 0;\n    let mut digit_sum13 = 0;\n    let mut\
    \ digit_sum14 = 0;\n    let mut digit_sum15 = 0;\n    let mut digit_sum16 = 0;\n\
    \    let mut digit_sum17 = 0;\n    let mut digit_sum18 = 0;\n    let mut digit_sum19\
    \ = 0;\n    let mut digit_sum20 = 0;\n    let mut digit_sum21 = 0;\n    let mut\
    \ digit_sum22 = 0;\n    let mut digit_sum23 = 0;\n    let mut digit_sum24 = 0;\n\
    \    let mut digit_sum25 = 0;\n    let mut digit_sum26 = 0;\n    let mut digit_sum27\
    \ = 0;\n    let mut digit_sum28 = 0;\n    let mut digit_sum29 = 0;\n    let mut\
    \ digit_sum30 = 0;\n    let mut digit_sum31 = 0;\n    let mut digit_sum32 = 0;\n\
    \    let mut digit_sum33 = 0;\n    let mut digit_sum34 = 0;\n    let mut digit_sum35\
    \ = 0;\n    let mut digit_sum36 = 0;\n    let mut digit_sum37 = 0;\n    let mut\
    \ digit_sum38 = 0;\n    let mut digit_sum39 = 0;\n    let mut digit_sum40 = 0;\n\
    \    let mut digit_sum41 = 0;\n    let mut digit_sum42 = 0;\n    let mut digit_sum43\
    \ = 0;\n    let mut digit_sum44 = 0;\n    let mut digit_sum45 = 0;\n    let mut\
    \ digit_sum46 = 0;\n    let mut digit_sum47 = 0;\n    let mut digit_sum48 = 0;\n\
    \    let mut digit_sum49 = 0;\n    let mut digit_sum50 = 0;\n    let mut digit_sum51\
    \ = 0;\n    let mut digit_sum52 = 0;\n    let mut digit_sum53 = 0;\n    let mut\
    \ digit_sum54 = 0;\n    let mut digit_sum55 = 0;\n    let mut digit_sum56 = 0;\n\
    \    let mut digit_sum57 = 0;\n    let mut digit_sum58 = 0;\n    let mut digit_sum59\
    \ = 0;\n    let mut digit_sum60 = 0;\n    let mut digit_sum61 = 0;\n    let mut\
    \ digit_sum62 = 0;\n    let mut digit_sum63 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdp8b_kzr.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_digits = vec![false; 26];\n    let mut prime_digit_counts =\
    \ vec![0; 26];\n    let mut prime_digit_counts_index = 0;\n    let mut prime_digit_counts_index2\
    \ = 0;\n    let mut prime_digit_counts_index3 = 0;\n    let mut prime_digit_counts_index4\
    \ = 0;\n    let mut prime_digit_counts_index5 = 0;\n    let mut prime_digit_counts_index6\
    \ = 0;\n    let mut prime_digit_counts_index7 = 0;\n    let mut prime_digit_counts_index8\
    \ = 0;\n    let mut prime_digit_counts_index9 = 0;\n    let mut prime_digit_counts_index10\
    \ = 0;\n    let mut prime_digit_counts_index11 = 0;\n    let mut prime_digit_counts_index12\
    \ = 0;\n    let mut prime_digit_counts_index13 = 0;\n    let mut prime_digit_counts_index14\
    \ = 0;\n    let mut prime_digit_counts_index15 = 0;\n    let mut prime_digit_counts_index16\
    \ = 0;\n    let mut prime_digit_counts_index17 = 0;\n    let mut prime_digit_counts_index18\
    \ = 0;\n    let mut prime_digit_counts_index19 = 0;\n    let mut prime_digit_counts_index20\
    \ = 0;\n    let mut prime_digit_counts_index21 = 0;\n    let mut prime_digit_counts_index22\
    \ = 0;\n    let mut prime_digit_counts_index23 = 0;\n    let mut prime_digit_counts_index24\
    \ = 0;\n    let mut prime_digit_counts_index25 = 0;\n    let mut prime_digit_counts_index26\
    \ = 0;\n    let mut prime_digit_counts_index27 = 0;\n    let mut prime_digit_counts_index28\
    \ = 0;\n    let mut prime_digit_counts_index29 = 0;\n    let mut prime_digit_counts_index30\
    \ = 0;\n    let mut prime_digit_counts_index31 = 0;\n    let mut prime_digit_counts_index32\
    \ = 0;\n    let mut prime_digit_counts_index33 = 0;\n    let mut prime_digit_counts_index34\
    \ = 0;\n    let mut prime_digit_counts_index35 = 0;\n    let mut prime_digit_counts_index36\
    \ = 0;\n    let mut prime_digit_counts_index37 = 0;\n    let mut prime_digit_counts_index38\
    \ = 0;\n    let mut prime_digit_counts_index39 = 0;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptdxb_kfq.rs:60:11\n   |\n\
    60 |     let mu\n   |           ^ help: add `;` here\n61 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmptdxb_kfq.rs:18:55\n     |\n18\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptdxb_kfq.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17];\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpc7spszfu.rs:54:48\n   |\n\
    54 |     let mut prime_digits_len = prime_digits.len\n   |                   \
    \                             ^ help: add `;` here\n55 | }\n   | - unexpected\
    \ token\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpc7spszfu.rs:54:45\n\
    \   |\n54 |     let mut prime_digits_len = prime_digits.len\n   |            \
    \                                 ^^^ private field\n   |\nhelp: a method `len`\
    \ also exists, call it with parentheses\n   |\n54 |     let mut prime_digits_len\
    \ = prime_digits.len()\n   |                                                ++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc7spszfu.rs:17:28\n   |\n17 |\
    \ fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0616.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_count: isize = 0;\n\
    \    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count: isize\
    \ = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_count:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm40nx4ev.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmpm40nx4ev.rs:18:55\n     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num_digits = num.chars().count();\n    let mut num_primes\
    \ = 0;\n    let mut num_primes_digits = 0;\n    let mut num_primes_digits_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes = 0;\n    let mut num_primes_digits_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes = 0;\n    let\
    \ mut num_primes_digits_primes_primes_primes_primes_primes = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl5q0kmm5.rs:38:80\n   |\n\
    38 |     let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_\n\
    \   |                                                                        \
    \        ^ help: add `;` here\n39 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl5q0kmm5.rs:17:28\n   |\n17 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![];\n    let mut prime_counter: usize = 0;\n\
    \    let mut prime_counter2: usize = 0;\n    let mut prime_counter3: usize = 0;\n\
    \    let mut prime_counter4: usize = 0;\n    let mut prime_counter5: usize = 0;\n\
    \    let mut prime_counter6: usize = 0;\n    let mut prime_counter7: usize = 0;\n\
    \    let mut prime_counter8: usize = 0;\n    let mut prime_counter9: usize = 0;\n\
    \    let mut prime_counter10: usize = 0;\n    let mut prime_counter11: usize =\
    \ 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13: usize\
    \ = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: usize = 0;\n    let mut prime\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpthl6kz62.rs:60:18\n   |\n\
    60 |     let mut prime\n   |                  ^ help: add `;` here\n61 | }\n \
    \  | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmpthl6kz62.rs:18:55\n\
    \     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpthl6kz62.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_value = num[prime_digits_index..prime_digits_len];\n\
    \    let mut prime_digits_value_len = prime_digits_value.len();\n    let mut prime_digits_value_len_index\
    \ = 0;\n    let mut prime_digits_value_value = prime_digits_value[prime_digits_value_len_index..prime_digits_value_len];\n\
    \    let mut prime_digits_value_value_len = prime_digits_value_value.len();\n\
    \    let mut prime_digits_value_value_index = 0;\n    let mut prime_digits_value_value_value\
    \ = prime_digits_value_value[prime_digits_value_value_index..prime_digits_value_value_len];\n\
    \    let mut prime_digits_value_value_value_len = prime_digits_value_value_value.len();\n\
    \    let mut prime_digits_value_value_value_index = 0;\n    let mut prime_digits_value_value_value_value\
    \ = prime_digits_value_value_value[prime_digits_value_value_value_index..prime_digits_value_value_value_len];\n\
    \    let mut prime_digits_value_value_value_value_len = prime_digits_value_value_value_value.len();\n\
    \    let mut prime_digits_value_value_value_value_index = 0;\n    let mut prime_digits_value_value_value_value_value\
    \ = prime_digits_value_value_value_value[prime_digits_value_value_value_value_index..prime_digits_value_value_value_len];\n\
    \    let mut prime_digits_value_value_value_value_value_len = prime_digits_value_value_value_value_value.len();\n\
    \    let mut prime_digits_value_value_value_value_value_index = 0;\n    let mut\
    \ prime_digits_value_value_value_value_value_value = prime_digits_value_value_value_value_value[prime_digits_value_value_value_value_value_index..prime_digits_value_value_value_value_len];\n\
    \    let mut prime_digits_value_value_value_value_value_value_len = prime_digits_value_value_value_value_value_value.len();\n\
    \    let mut prime_digits_value_value_value_value_value_value_index = 0;\n   \
    \ let mut prime_digits_value_value_value_value_value_value_value = prime_digits_value_value_value_value_value_value[prime_digits_value_value_value_value_value_value_index..prime_digit\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpv42e215b.rs:41:1\n   |\n41 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpv42e215b.rs:40:118\n   |\n17 | fn hex_key(num: String) -> isize {\n\
    \   |                                  - closing delimiter possibly meant for\
    \ this\n...\n40 |     let mut prime_digits_value_value_value_value_value_value_value\
    \ = prime_digits_value_value_value_value_value_value[prime_digits_value_...\n\
    \   |                                                                        \
    \                                              ^ unclosed delimiter\n41 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n  --> /tmp/tmpv42e215b.rs:22:9\n\
    \   |\n22 |     let mut prime_digits_value = num[prime_digits_index..prime_digits_len];\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\nhelp: consider borrowing here\n   |\n22 |\
    \     let mut prime_digits_value = &num[prime_digits_index..prime_digits_len];\n\
    \   |                                  +\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmpv42e215b.rs:25:9\n\
    \   |\n25 |     let mut prime_digits_value_value = prime_digits_value[prime_digits_value_len_index..prime_digits_value_len];\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\nhelp: consider borrowing here\n   |\n25 |\
    \     let mut prime_digits_value_value = &prime_digits_value[prime_digits_value_len_index..prime_digits_value_len];\n\
    \   |                                        +\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<usize> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime: usize = 2;\n    let mut\
    \ prime_found = false;\n    let mut prime_found2 = false;\n    let mut prime_found3\
    \ = false;\n    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n\
    \    let mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let\
    \ mut prime_found8 = false;\n    let mut prime_found9 = false;\n    let mut prime_found10\
    \ = false;\n    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n\
    \    let mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let\
    \ mut prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut\
    \ prime_found17 = false;\n    let mut prime_found18 = false;\n    let mut prime_found19\
    \ = false;\n    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n\
    \    let mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let\
    \ mut prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut\
    \ prime_found26 = false;\n    let mut prime_found27 = false;\n    let mut prime_found28\
    \ = false;\n    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n\
    \    let mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let\
    \ mut prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut\
    \ prime_found35 = false;\n    let mut prime_found36 = false;\n    let mut prime_found37\
    \ = false;\n    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n\
    \    let mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let\
    \ mut prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut\
    \ prime_found44 = false;\n    let mut prime_found45 = false;\n    let mut prime_found46\
    \ = false;\n    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n\
    \    let mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let\
    \ mut prime_found51 = false;\n    let mut prime_found52 = \n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpr6sc8ylt.rs:73:1\n\
    \   |\n73 | }\n   | ^ expected expression\n\nerror[E0277]: a value of type `Vec<usize>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpr6sc8ylt.rs:18:58\n\
    \     |\n18   |     let mut num: Vec<usize> = num.to_lowercase().chars().collect();\n\
    \     |                                                          ^^^^^^^ value\
    \ of type `Vec<usize>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<usize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = vec![false; 26];\n    let mut prime_digits\
    \ = vec![false; 26];\n    let mut prime_digits_count = vec![0; 26];\n    let mut\
    \ prime_digits_count_index = 0;\n    let mut prime_digits_count_index2 = 0;\n\
    \    let mut prime_digits_count_index3 = 0;\n    let mut prime_digits_count_index4\
    \ = 0;\n    let mut prime_digits_count_index5 = 0;\n    let mut prime_digits_count_index6\
    \ = 0;\n    let mut prime_digits_count_index7 = 0;\n    let mut prime_digits_count_index8\
    \ = 0;\n    let mut prime_digits_count_index9 = 0;\n    let mut prime_digits_count_index10\
    \ = 0;\n    let mut prime_digits_count_index11 = 0;\n    let mut prime_digits_count_index12\
    \ = 0;\n    let mut prime_digits_count_index13 = 0;\n    let mut prime_digits_count_index14\
    \ = 0;\n    let mut prime_digits_count_index15 = 0;\n    let mut prime_digits_count_index16\
    \ = 0;\n    let mut prime_digits_count_index17 = 0;\n    let mut prime_digits_count_index18\
    \ = 0;\n    let mut prime_digits_count_index19 = 0;\n    let mut prime_digits_count_index20\
    \ = 0;\n    let mut prime_digits_count_index21 = 0;\n    let mut prime_digits_count_index22\
    \ = 0;\n    let mut prime_digits_count_index23 = 0;\n    let mut prime_digits_count_index24\
    \ = 0;\n    let mut prime_digits_count_index25 = 0;\n    let mut prime_digits_count_index26\
    \ = 0;\n    let mut prime_digits_count_index27 = 0;\n    let mut prime_digits_count_index28\
    \ = 0;\n    let mut prime_digits_count_index29 = 0;\n    let mut prime_digits_count_index30\
    \ = 0;\n    let mut prime_digits_count_index31 = 0;\n    let mut prime_digits_count_index32\
    \ = 0;\n    let mut prime_digits_count_index33 = 0;\n    let mut prime_digits_count_index34\
    \ = 0;\n    let mut prime_digits_count_index35 = 0;\n    let mut prime_digits_count_index36\
    \ = 0;\n    let mut prime_digits_count_index37 = 0;\n    let mut prime_digits_count_index38\
    \ = 0;\n    let mut prime_digits_count_index39 = 0;\n    let mut prime_digits_count_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpznnrvpfp.rs:60:32\n   |\n\
    60 |     let mut prime_digits_count_\n   |                                ^ help:\
    \ add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpznnrvpfp.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut digit_count = 1;\n   \
    \ let mut digits = num.to_string();\n    let mut primes = vec![false; 26];\n \
    \   let mut primes_count = vec![false; 26];\n    let mut primes_digits = vec![false;\
    \ 26];\n    let mut primes_digits_count = vec![false; 26];\n    let mut primes_digits_count\
    \ = vec![false; 26];\n    let mut primes_digits_count = vec![false; 26];\n   \
    \ let mut primes_digits_count = vec![false; 26];\n    let mut primes_digits_count\
    \ = vec![false; 26];\n    let mut primes_digits_count = vec![false; 26];\n   \
    \ let mut primes_digits_count = vec![false; 26];\n    let mut primes_digits_count\
    \ = vec![false; 26];\n    let mut primes_digits_count = vec![false; 26];\n   \
    \ let mut primes_digits_count = vec![false; 26];\n    let mut primes_digits_count\
    \ = vec![false; 26];\n    let mut primes_digits_count = vec![false; 26];\n   \
    \ let mut primes_digits_count = vec![false; 26];\n    let mut primes_digits_count\
    \ = vec![false; 26];\n    let mut primes_digits_count = vec![false; 26];\n   \
    \ let mut primes_digits_count = vec![false; 26];\n    let mut primes_digits_count\
    \ = vec![false; 26];\n    let mut primes_digits_count = vec![false; 26];\n   \
    \ let mut primes_digits_count = vec![false; 26];\n    let mut primes_digits_count\
    \ = vec![false; 26];\n    let mut primes_digits_count = vec![false; 26];\n   \
    \ let mut primes_digits_count = vec![false; 26];\n    let mut primes_digits_count\
    \ = vec![false; 26];\n    let mut primes_digits_count = vec![false; 26];\n   \
    \ let mut primes_digits_count = vec![false; 26];\n    let mut primes_digits_count\
    \ = vec![false; 26];\n    let mut primes_digits_count = vec![false; 26];\n   \
    \ let mut primes_digits_count = vec![false; 26];\n    let mut primes_digits_count\
    \ = vec![false; 26];\n    let mut primes_digits_count = vec![false; 26];\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi16y75oy.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut digits = num.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut prime_digits = vec![false; 9];\n    let mut prime_digits_index =\
    \ 0;\n    let mut prime_digits_index2 = 0;\n    let mut prime_digits_index3 =\
    \ 0;\n    let mut prime_digits_index4 = 0;\n    let mut prime_digits_index5 =\
    \ 0;\n    let mut prime_digits_index6 = 0;\n    let mut prime_digits_index7 =\
    \ 0;\n    let mut prime_digits_index8 = 0;\n    let mut prime_digits_index9 =\
    \ 0;\n    let mut prime_digits_index10 = 0;\n    let mut prime_digits_index11\
    \ = 0;\n    let mut prime_digits_index12 = 0;\n    let mut prime_digits_index13\
    \ = 0;\n    let mut prime_digits_index14 = 0;\n    let mut prime_digits_index15\
    \ = 0;\n    let mut prime_digits_index16 = 0;\n    let mut prime_digits_index17\
    \ = 0;\n    let mut prime_digits_index18 = 0;\n    let mut prime_digits_index19\
    \ = 0;\n    let mut prime_digits_index20 = 0;\n    let mut prime_digits_index21\
    \ = 0;\n    let mut prime_digits_index22 = 0;\n    let mut prime_digits_index23\
    \ = 0;\n    let mut prime_digits_index24 = 0;\n    let mut prime_digits_index25\
    \ = 0;\n    let mut prime_digits_index26 = 0;\n    let mut prime_digits_index27\
    \ = 0;\n    let mut prime_digits_index28 = 0;\n    let mut prime_digits_index29\
    \ = 0;\n    let mut prime_digits_index30 = 0;\n    let mut prime_digits_index31\
    \ = 0;\n    let mut prime_digits_index32 = 0;\n    let mut prime_digits_index33\
    \ = 0;\n    let mut prime_digits_index34 = 0;\n    let mut prime_digits_index35\
    \ = 0;\n    let mut prime_digits_index36 = 0;\n    let mut prime_digits_index37\
    \ = 0;\n    let mut prime_digits_index38 = 0;\n    let mut prime_digits_index39\
    \ = 0;\n    let mut prime_digits_index40 = 0;\n    let mut prime_digits_index41\
    \ = 0;\n    let mut prime_digits_index42 = 0;\n    let mut prime_digits_index43\
    \ = 0;\n    let mut prime\n}\n\nfn main() {\n    let candidate = hex_key;\n  \
    \  assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprlu4983s.rs:64:18\n   |\n\
    64 |     let mut prime\n   |                  ^ help: add `;` here\n65 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprlu4983s.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut digits = num.chars().collect::<Vec<_>>();\n\
    \    for digit in digits {\n        if digit == 'A' || digit == 'B' || digit ==\
    \ 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n            counter +=\
    \ 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpvyy9mt2x.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut digits = num.chars().collect::<Vec<_>>();\n\
    \    let mut primes = vec![2, 3];\n    let mut primes_counter = vec![2, 3];\n\
    \    let mut primes_counter2 = vec![2, 3];\n    let mut primes_counter3 = vec![2,\
    \ 3];\n    let mut primes_counter4 = vec![2, 3];\n    let mut primes_counter5\
    \ = vec![2, 3];\n    let mut primes_counter6 = vec![2, 3];\n    let mut primes_counter7\
    \ = vec![2, 3];\n    let mut primes_counter8 = vec![2, 3];\n    let mut primes_counter9\
    \ = vec![2, 3];\n    let mut primes_counter10 = vec![2, 3];\n    let mut primes_counter11\
    \ = vec![2, 3];\n    let mut primes_counter12 = vec![2, 3];\n    let mut primes_counter13\
    \ = vec![2, 3];\n    let mut primes_counter14 = vec![2, 3];\n    let mut primes_counter15\
    \ = vec![2, 3];\n    let mut primes_counter16 = vec![2, 3];\n    let mut primes_counter17\
    \ = vec![2, 3];\n    let mut primes_counter18 = vec![2, 3];\n    let mut primes_counter19\
    \ = vec![2, 3];\n    let mut primes_counter20 = vec![2, 3];\n    let mut primes_counter21\
    \ = vec![2, 3];\n    let mut primes_counter22 = vec![2, 3];\n    let mut primes_counter23\
    \ = vec![2, 3];\n    let mut primes_counter24 = vec![2, 3];\n    let mut primes_counter25\
    \ = vec![2, 3];\n    let mut primes_counter26 = vec![2, 3];\n    let mut primes_counter27\
    \ = vec![2, 3];\n    let mut primes_counter28 = vec![2, 3];\n    let mut primes_counter29\
    \ = vec![2, 3];\n    let mut primes_counter30 = vec![2, 3];\n    let mut primes_counter31\
    \ = vec![2, 3];\n    let mut primes_counter32 = vec![2, 3];\n    let mut primes_counter33\
    \ = vec![2, 3];\n    let mut primes_counter34 = vec![2, 3];\n    let mut primes_counter35\
    \ = vec![2, 3];\n\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpocfk99ut.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_digits = vec![false; 26];\n    let mut prime_digits_count =\
    \ vec![0; 26];\n    let mut prime_digits_count_max = vec![0; 26];\n    let mut\
    \ prime_digits_count_min = vec![0; 26];\n    let mut prime_digits_count_max_index\
    \ = vec![0; 26];\n    let mut prime_digits_count_min_index = vec![0; 26];\n  \
    \  let mut prime_digits_count_max_index2 = vec![0; 26];\n    let mut prime_digits_count_min_index2\
    \ = vec![0; 26];\n    let mut prime_digits_count_max_index3 = vec![0; 26];\n \
    \   let mut prime_digits_count_min_index3 = vec![0; 26];\n    let mut prime_digits_count_max_index4\
    \ = vec![0; 26];\n    let mut prime_digits_count_min_index4 = vec![0; 26];\n \
    \   let mut prime_digits_count_max_index5 = vec![0; 26];\n    let mut prime_digits_count_min_index5\
    \ = vec![0; 26];\n    let mut prime_digits_count_max_index6 = vec![0; 26];\n \
    \   let mut prime_digits_count_min_index6 = vec![0; 26];\n    let mut prime_digits_count_max_index7\
    \ = vec![0; 26];\n    let mut prime_digits_count_min_index7 = vec![0; 26];\n \
    \   let mut prime_digits_count_max_index8 = vec![0; 26];\n    let mut prime_digits_count_min_index8\
    \ = vec![0; 26];\n    let mut prime_digits_count_max_index9 = vec![0; 26];\n \
    \   let mut prime_digits_count_min_index9 = vec![0; 26];\n    let mut prime_digits_count_max_index10\
    \ = vec![0; 26];\n    let mut prime_digits_count_min_index10 = vec![0; 26];\n\
    \    let mut prime_digits_count_max_index11 = vec![0; 26];\n    let mut prime_digits_count_min_index11\
    \ = vec![0; 26];\n    let mut prime_digits_count_max_index12 = vec![0; 26];\n\
    \    let mut prime_digits_count_min_index12 = vec![0; 26];\n    let mut prime_digits_count_max_index13\
    \ = vec![0; 26];\n    let mut prime_digits_count_min_index13\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpp5caaweg.rs:48:43\n   |\n\
    48 |     let mut prime_digits_count_min_index13\n   |                        \
    \                   ^ help: add `;` here\n49 | }\n   | - unexpected token\n\n\
    error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmpp5caaweg.rs:18:55\n     |\n18   | \
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |    \
    \                                                   ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp5caaweg.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![];\n    let mut num_prime_counter: usize\
    \ = 0;\n    let mut num_prime_counter2: usize = 0;\n    let mut num_prime_counter3:\
    \ usize = 0;\n    let mut num_prime_counter4: usize = 0;\n    let mut num_prime_counter5:\
    \ usize = 0;\n    let mut num_prime_counter6: usize = 0;\n    let mut num_prime_counter7:\
    \ usize = 0;\n    let mut num_prime_counter8: usize = 0;\n    let mut num_prime_counter9:\
    \ usize = 0;\n    let mut num_prime_counter10: usize = 0;\n    let mut num_prime_counter11:\
    \ usize = 0;\n    let mut num_prime_counter12: usize = 0;\n    let mut num_prime_counter13:\
    \ usize = 0;\n    let mut num_prime_counter14: usize = 0;\n    let mut num_prime_counter15:\
    \ usize = 0;\n    let mut num_prime_counter16: usize = 0;\n    let mut num_prime_counter17:\
    \ usize = 0;\n    let mut num_prime_counter18: usize = 0;\n    let mut num_prime_counter19:\
    \ usize = 0;\n    let mut num_prime_counter20: usize = 0;\n    let mut num_prime_counter21:\
    \ usize = 0;\n    let mut num_prime_counter22: usize = 0;\n    let mut num_prime_counter23:\
    \ usize = 0;\n    let mut num_prime_counter24: usize = 0;\n    let mut num_prime_counter25:\
    \ usize = 0;\n    let mut num_prime_counter26: usize = 0;\n    let mut num_prime_counter27:\
    \ usize = 0;\n    let mut num_prime_counter28: usize = 0;\n    let mut num_prime_counter29:\
    \ usize = 0;\n    let mut num_prime_counter30: usize = 0;\n    let mut num_prime_counter31:\
    \ usize = 0;\n    let mut num_prime_counter32: usize = 0;\n    let mut num_prime_counter33:\
    \ usize = 0;\n    let mut num_prime_counter34: usize = 0;\n    let mut num_prime_counter35:\
    \ usize = 0;\n    let mut num_prime_counter36: usize = 0;\n    let mut num_prime_counter37:\
    \ usize = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyv5sv88l.rs:57:11\n   |\n\
    57 |     let mu\n   |           ^ help: add `;` here\n58 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpyv5sv88l.rs:18:55\n     |\n18\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyv5sv88l.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3];\n    let mut prime_counter: usize =\
    \ 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3: usize\
    \ = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5: usize\
    \ = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7: usize\
    \ = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9: usize\
    \ = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: usize = 0;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpay5s6n6o.rs:60:11\n   |\n\
    60 |     let mu\n   |           ^ help: add `;` here\n61 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpay5s6n6o.rs:18:55\n     |\n18\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpay5s6n6o.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut digits = num.chars().collect::<Vec<_>>();\n\
    \    let mut prime_digits = vec![false; 10];\n    let mut prime_digits_count =\
    \ vec![0; 10];\n    let mut prime_digits_index = vec![0; 10];\n    let mut prime_digits_index_count\
    \ = vec![0; 10];\n    let mut prime_digits_index_value = vec![0; 10];\n    let\
    \ mut prime_digits_index_value2 = vec![0; 10];\n    let mut prime_digits_index_value3\
    \ = vec![0; 10];\n    let mut prime_digits_index_value4 = vec![0; 10];\n    let\
    \ mut prime_digits_index_value5 = vec![0; 10];\n    let mut prime_digits_index_value6\
    \ = vec![0; 10];\n    let mut prime_digits_index_value7 = vec![0; 10];\n    let\
    \ mut prime_digits_index_value8 = vec![0; 10];\n    let mut prime_digits_index_value9\
    \ = vec![0; 10];\n    let mut prime_digits_index_value10 = vec![0; 10];\n    let\
    \ mut prime_digits_index_value11 = vec![0; 10];\n    let mut prime_digits_index_value12\
    \ = vec![0; 10];\n    let mut prime_digits_index_value13 = vec![0; 10];\n    let\
    \ mut prime_digits_index_value14 = vec![0; 10];\n    let mut prime_digits_index_value15\
    \ = vec![0; 10];\n    let mut prime_digits_index_value16 = vec![0; 10];\n    let\
    \ mut prime_digits_index_value17 = vec![0; 10];\n    let mut prime_digits_index_value18\
    \ = vec![0; 10];\n    let mut prime_digits_index_value19 = vec![0; 10];\n    let\
    \ mut prime_digits_index_value20 = vec![0; 10];\n    let mut prime_digits_index_value21\
    \ = vec![0; 10];\n    let mut prime_digits_index_value22 = vec![0; 10];\n    let\
    \ mut prime_digits_index_value23 = vec![0; 10];\n    let mut prime_digits_index_value24\
    \ = vec![0; 10];\n    let mut prime_digits_index_value25 = vec![0; 10];\n    let\
    \ mut prime_digits_index_value26 = vec![0; 10];\n    let mu\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpymaahe2d.rs:50:11\n   |\n\
    50 |     let mu\n   |           ^ help: add `;` here\n51 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpymaahe2d.rs:17:28\n \
    \  |\n17 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17, 19];\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpilxved35.rs:55:1\n   |\n55\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpilxved35.rs:54:45\n\
    \   |\n54 |     let mut prime_digits_len = prime_digits.\n   |               \
    \                              ^ help: add `;` here\n55 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpilxved35.rs:17:28\n \
    \  |\n17 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_index2 = 0;\n    let mut prime_digits_index3 = 0;\n\
    \    let mut prime_digits_index4 = 0;\n    let mut prime_digits_index5 = 0;\n\
    \    let mut prime_digits_index6 = 0;\n    let mut prime_digits_index7 = 0;\n\
    \    let mut prime_digits_index8 = 0;\n    let mut prime_digits_index9 = 0;\n\
    \    let mut prime_digits_index10 = 0;\n    let mut prime_digits_index11 = 0;\n\
    \    let mut prime_digits_index12 = 0;\n    let mut prime_digits_index13 = 0;\n\
    \    let mut prime_digits_index14 = 0;\n    let mut prime_digits_index15 = 0;\n\
    \    let mut prime_digits_index16 = 0;\n    let mut prime_digits_index17 = 0;\n\
    \    let mut prime_digits_index18 = 0;\n    let mut prime_digits_index19 = 0;\n\
    \    let mut prime_digits_index20 = 0;\n    let mut prime_digits_index21 = 0;\n\
    \    let mut prime_digits_index22 = 0;\n    let mut prime_digits_index23 = 0;\n\
    \    let mut prime_digits_index24 = 0;\n    let mut prime_digits_index25 = 0;\n\
    \    let mut prime_digits_index26 = 0;\n    let mut prime_digits_index27 = 0;\n\
    \    let mut prime_digits_index28 = 0;\n    let mut prime_digits_index29 = 0;\n\
    \    let mut prime_digits_index30 = 0;\n    let mut prime_digits_index31 = 0;\n\
    \    let mut prime_digits_index32 = 0;\n    let mut prime_digits_index33 = 0;\n\
    \    let mut prime_digits_index34 = 0;\n    let mut prime_digits_index35 = 0;\n\
    \    let mut prime_digits_index36 = 0;\n    let mut prime_digits_index37 = 0;\n\
    \    let mut prime_digits_index38 = 0;\n    let mut prime_digits_index39 = 0;\n\
    \    let mut prime_digits_index40 = 0;\n    let mut prime_digits_index41 = 0;\n\
    \    let mut prime_digits_index42 = 0;\n    let mut prime_digits_index43 = 0;\n\
    \    let mut prime_digits_index44 = 0;\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwp0uivo0.rs:65:11\n   |\n\
    65 |     let mu\n   |           ^ help: add `;` here\n66 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwp0uivo0.rs:17:28\n \
    \  |\n17 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![];\n    let mut prime_count: usize = 0;\n \
    \   let mut prime_digit: u8 = 0;\n    let mut prime_digit_count: usize = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index: usize\
    \ = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_value: \n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpj3njjrfb.rs:66:1\n   |\n\
    65 |     let mut prime_digit_value: \n   |         --------------------- while\
    \ parsing the type for `mut prime_digit_value`\n66 | }\n   | ^ expected type\n\
    \nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmpj3njjrfb.rs:18:55\n     |\n18   | \
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |    \
    \                                                   ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime: isize = 2;\n    let mut\
    \ prime_found = false;\n    let mut prime_found2 = false;\n    let mut prime_found3\
    \ = false;\n    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n\
    \    let mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let\
    \ mut prime_found8 = false;\n    let mut prime_found9 = false;\n    let mut prime_found10\
    \ = false;\n    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n\
    \    let mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let\
    \ mut prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut\
    \ prime_found17 = false;\n    let mut prime_found18 = false;\n    let mut prime_found19\
    \ = false;\n    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n\
    \    let mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let\
    \ mut prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut\
    \ prime_found26 = false;\n    let mut prime_found27 = false;\n    let mut prime_found28\
    \ = false;\n    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n\
    \    let mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let\
    \ mut prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut\
    \ prime_found35 = false;\n    let mut prime_found36 = false;\n    let mut prime_found37\
    \ = false;\n    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n\
    \    let mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let\
    \ mut prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut\
    \ prime_found44 = false;\n    let mut prime_found45 = false;\n    let mut prime_found46\
    \ = false;\n    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n\
    \    let mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let\
    \ mut prime_found51 = false;\n    let mut prime_found52 = false;\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpkg6a7ps4.rs:18:55\n     |\n18\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkg6a7ps4.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num_digits = num.chars().count();\n    let mut num_primes\
    \ = 0;\n    let mut num_primes_digits = 0;\n    let mut num_primes_digits_pow2\
    \ = 0;\n    let mut num_primes_digits_pow3 = 0;\n    let mut num_primes_digits_pow4\
    \ = 0;\n    let mut num_primes_digits_pow5 = 0;\n    let mut num_primes_digits_pow6\
    \ = 0;\n    let mut num_primes_digits_pow7 = 0;\n    let mut num_primes_digits_pow8\
    \ = 0;\n    let mut num_primes_digits_pow9 = 0;\n    let mut num_primes_digits_pow10\
    \ = 0;\n    let mut num_primes_digits_pow11 = 0;\n    let mut num_primes_digits_pow12\
    \ = 0;\n    let mut num_primes_digits_pow13 = 0;\n    let mut num_primes_digits_pow14\
    \ = 0;\n    let mut num_primes_digits_pow15 = 0;\n    let mut num_primes_digits_pow16\
    \ = 0;\n    let mut num_primes_digits_pow17 = 0;\n    let mut num_primes_digits_pow18\
    \ = 0;\n    let mut num_primes_digits_pow19 = 0;\n    let mut num_primes_digits_pow20\
    \ = 0;\n    let mut num_primes_digits_pow21 = 0;\n    let mut num_primes_digits_pow22\
    \ = 0;\n    let mut num_primes_digits_pow23 = 0;\n    let mut num_primes_digits_pow24\
    \ = 0;\n    let mut num_primes_digits_pow25 = 0;\n    let mut num_primes_digits_pow26\
    \ = 0;\n    let mut num_primes_digits_pow27 = 0;\n    let mut num_primes_digits_pow28\
    \ = 0;\n    let mut num_primes_digits_pow29 = 0;\n    let mut num_primes_digits_pow30\
    \ = 0;\n    let mut num_primes_digits_pow31 = 0;\n    let mut num_primes_digits_pow32\
    \ = 0;\n    let mut num_primes_digits_pow33 = 0;\n    let mut num_primes_digits_pow34\
    \ = 0;\n    let mut num_primes_digits_pow35 = 0;\n    let mut num_primes_digits_pow36\
    \ = 0;\n    let mut num_primes_digits_pow37 = 0;\n    let mut num_primes_digits_pow38\
    \ = 0;\n    let mut num_primes_digits_pow39 = 0;\n    let mut num_primes_digits_pow40\
    \ = 0;\n    let mut num_primes_digits_pow41 = 0;\n    let mut num_primes_digit\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp86s1cako.rs:61:29\n   |\n\
    61 |     let mut num_primes_digit\n   |                             ^ help: add\
    \ `;` here\n62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp86s1cako.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut num_digits = num.len();\n\
    \    let mut num_digits_div2 = 0;\n    let mut num_digits_div3 = 0;\n    let mut\
    \ num_digits_div4 = 0;\n    let mut num_digits_div5 = 0;\n    let mut num_digits_div6\
    \ = 0;\n    let mut num_digits_div7 = 0;\n    let mut num_digits_div8 = 0;\n \
    \   let mut num_digits_div9 = 0;\n    let mut num_digits_div10 = 0;\n    let mut\
    \ num_digits_div11 = 0;\n    let mut num_digits_div12 = 0;\n    let mut num_digits_div13\
    \ = 0;\n    let mut num_digits_div14 = 0;\n    let mut num_digits_div15 = 0;\n\
    \    let mut num_digits_div16 = 0;\n    let mut num_digits_div17 = 0;\n    let\
    \ mut num_digits_div18 = 0;\n    let mut num_digits_div19 = 0;\n    let mut num_digits_div20\
    \ = 0;\n    let mut num_digits_div21 = 0;\n    let mut num_digits_div22 = 0;\n\
    \    let mut num_digits_div23 = 0;\n    let mut num_digits_div24 = 0;\n    let\
    \ mut num_digits_div25 = 0;\n    let mut num_digits_div26 = 0;\n    let mut num_digits_div27\
    \ = 0;\n    let mut num_digits_div28 = 0;\n    let mut num_digits_div29 = 0;\n\
    \    let mut num_digits_div30 = 0;\n    let mut num_digits_div31 = 0;\n    let\
    \ mut num_digits_div32 = 0;\n    let mut num_digits_div33 = 0;\n    let mut num_digits_div34\
    \ = 0;\n    let mut num_digits_div35 = 0;\n    let mut num_digits_div36 = 0;\n\
    \    let mut num_digits_div37 = 0;\n    let mut num_digits_div38 = 0;\n    let\
    \ mut num_digits_div39 = 0;\n    let mut num_digits_div40 = 0;\n    let mut num_digits_div41\
    \ = 0;\n    let mut num_digits_div42 = 0;\n    let mut num_digits_div43 = 0;\n\
    \    let mut num_digits_div44 = 0;\n    let mut num_digits_div45 = 0;\n    let\
    \ mut num_digits_div46 = 0;\n    let mut num_digits_div47 = 0;\n    let mut num_digits_div48\
    \ = 0;\n    let mut num_digits_div49 = 0;\n    let mut num_digits_div50 = 0;\n\
    \    let mut num_digits_div51\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxn2h1zze.rs:69:29\n   |\n\
    69 |     let mut num_digits_div51\n   |                             ^ help: add\
    \ `;` here\n70 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxn2h1zze.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num_str = num.to_string();\n    let mut num_str2 = num_str.to_owned();\n\
    \    let mut num_str3 = num_str2.to_owned();\n    let mut num_str4 = num_str3.to_owned();\n\
    \    let mut num_str5 = num_str4.to_owned();\n    let mut num_str6 = num_str5.to_owned();\n\
    \    let mut num_str7 = num_str6.to_owned();\n    let mut num_str8 = num_str7.to_owned();\n\
    \    let mut num_str9 = num_str8.to_owned();\n    let mut num_str10 = num_str9.to_owned();\n\
    \    let mut num_str11 = num_str10.to_owned();\n    let mut num_str12 = num_str11.to_owned();\n\
    \    let mut num_str13 = num_str12.to_owned();\n    let mut num_str14 = num_str13.to_owned();\n\
    \    let mut num_str15 = num_str14.to_owned();\n    let mut num_str16 = num_str15.to_owned();\n\
    \    let mut num_str17 = num_str16.to_owned();\n    let mut num_str18 = num_str17.to_owned();\n\
    \    let mut num_str19 = num_str18.to_owned();\n    let mut num_str20 = num_str19.to_owned();\n\
    \    let mut num_str21 = num_str20.to_owned();\n    let mut num_str22 = num_str21.to_owned();\n\
    \    let mut num_str23 = num_str22.to_owned();\n    let mut num_str24 = num_str23.to_owned();\n\
    \    let mut num_str25 = num_str24.to_owned();\n    let mut num_str26 = num_str25.to_owned();\n\
    \    let mut num_str27 = num_str26.to_owned();\n    let mut num_str28 = num_str27.to_owned();\n\
    \    let mut num_str29 = num_str28.to_owned();\n    let mut num_str30 = num_str29.to_owned();\n\
    \    let mut num_str31 = num_str30.to_owned();\n    let mut num_str32 = num_str31.to_owned();\n\
    \    let mut num_str33 = num_str32.to_owned();\n    let mut num_str34 = num_str33.to_owned();\n\
    \    let mut num_str35 = num_str34.to_owned();\n    let mut num_str\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps9ngyye3.rs:53:20\n   |\n\
    53 |     let mut num_str\n   |                    ^ help: add `;` here\n54 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps9ngyye3.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_count = vec![];\n    let mut prime_digits_count_max\
    \ = vec![];\n    let mut prime_digits_count_min = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_max_index\
    \ = vec![];\n    let mut prime_digits_count_min_index = vec![];\n    let mut prime_digits_count_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzchxb66_.rs:55:32\n   |\n\
    55 |     let mut prime_digits_count_\n   |                                ^ help:\
    \ add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzchxb66_.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![2,\
    \ 3, 4, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97];\n    let mut prime_digits_len = prime_digits.len();\n \
    \   let mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3g4oipg5.rs:47:26\n   |\n\
    47 |     let mut prime_digits_\n   |                          ^ help: add `;`\
    \ here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3g4oipg5.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize {\n \
    \  |    -------                 ^^^^^ expected `isize`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut num_digits = num.len();\n\
    \    let mut num_digits_squared = num_digits * num_digits;\n    let mut prime_digits\
    \ = vec![0; num_digits_squared];\n    let mut prime_digits_squared = vec![0; num_digits_squared];\n\
    \    let mut prime_digits_square_root = vec![0; num_digits_squared];\n    let\
    \ mut prime_digits_square_root_squared = vec![0; num_digits_squared];\n    let\
    \ mut prime_digits_square_root_square_root = vec![0; num_digits_squared];\n  \
    \  let mut prime_digits_square_root_square_root_squared = vec![0; num_digits_squared];\n\
    \    let mut prime_digits_square_root_square_root_square_root = vec![0; num_digits_squared];\n\
    \    let mut prime_digits_square_root_square_root_square_root_squared = vec![0;\
    \ num_digits_squared];\n    let mut prime_digits_square_root_square_root_square_root_square_root\
    \ = vec![0; num_digits_squared];\n    let mut prime_digits_square_root_square_root_square_root_square_root_squared\
    \ = vec![0; num_digits_squared];\n    let mut prime_digits_square_root_square_root_square_root_square_root_square_root\
    \ = vec![0; num_digits_squared];\n    let mut prime_digits_square_root_square_root_square_root_square_root_square_root_squared\
    \ = vec![0; num_digits_squared];\n    let mut prime_digits_square_root_square_root_square_root_square_root_square_root_square_root\
    \ = vec![0; num_digits_squared];\n    let mut prime_digits_square_root_square_root_square_root_square_root_square_root_square_root_squared\
    \ = vec![0; num_digits_squared];\n    let mut prime_digits_square_root_square_root_square_root_square_root_square_root_square_root_square_root\
    \ = vec![0; num_digits_squared];\n    let mut prime_digits_square_root_square_root_square_root_square_root_square_root_square_root_square_root_squared\
    \ = vec![0; num_digits_squared];\n    let mut prime_digits_square_root_square_root_square\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfy6gwdr0.rs:37:56\n   |\n\
    37 |     let mut prime_digits_square_root_square_root_square\n   |           \
    \                                             ^ help: add `;` here\n38 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfy6gwdr0.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_sum: isize = 0;\n\
    \    let mut prime_digit_product: isize = 1;\n    let mut prime_digit_product2:\
    \ isize = 1;\n    let mut prime_digit_product3: isize = 1;\n    let mut prime_digit_product4:\
    \ isize = 1;\n    let mut prime_digit_product5: isize = 1;\n    let mut prime_digit_product6:\
    \ isize = 1;\n    let mut prime_digit_product7: isize = 1;\n    let mut prime_digit_product8:\
    \ isize = 1;\n    let mut prime_digit_product9: isize = 1;\n    let mut prime_digit_product10:\
    \ isize = 1;\n    let mut prime_digit_product11: isize = 1;\n    let mut prime_digit_product12:\
    \ isize = 1;\n    let mut prime_digit_product13: isize = 1;\n    let mut prime_digit_product14:\
    \ isize = 1;\n    let mut prime_digit_product15: isize = 1;\n    let mut prime_digit_product16:\
    \ isize = 1;\n    let mut prime_digit_product17: isize = 1;\n    let mut prime_digit_product18:\
    \ isize = 1;\n    let mut prime_digit_product19: isize = 1;\n    let mut prime_digit_product20:\
    \ isize = 1;\n    let mut prime_digit_product21: isize = 1;\n    let mut prime_digit_product22:\
    \ isize = 1;\n    let mut prime_digit_product23: isize = 1;\n    let mut prime_digit_product24:\
    \ isize = 1;\n    let mut prime_digit_product25: isize = 1;\n    let mut prime_digit_product26:\
    \ isize = 1;\n    let mut prime_digit_product27: isize = 1;\n    let mut prime_digit_product28:\
    \ isize = 1;\n    let mut prime_digit_product29: isize = 1;\n    let mut prime_digit_product30:\
    \ isize = 1;\n    let mut prime_digit_product31: isize = 1;\n    let mut prime_digit_product32:\
    \ isize = 1;\n    let mut prime_digit_product33: isize = 1;\n    let mut prime_digit_product34:\
    \ isize = 1;\n    let mut prime_digit_product35: isize = 1;\n\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxv8gf75_.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmpxv8gf75_.rs:18:55\n     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: usize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: usize = 0;\n    let mut prime_digit_count: usize = 0;\n\
    \    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count: usize\
    \ = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9akkt03n.rs:17:28\n   |\n\
    17 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmp9akkt03n.rs:18:55\n     |\n18   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num_str = num.to_string();\n    let mut num_str2 = num_str.to_owned();\n\
    \    let mut num_str3 = num_str2.to_owned();\n    let mut num_str4 = num_str3.to_owned();\n\
    \    let mut num_str5 = num_str4.to_owned();\n    let mut num_str6 = num_str5.to_owned();\n\
    \    let mut num_str7 = num_str6.to_owned();\n    let mut num_str8 = num_str7.to_owned();\n\
    \    let mut num_str9 = num_str8.to_owned();\n    let mut num_str10 = num_str9.to_owned();\n\
    \    let mut num_str11 = num_str10.to_owned();\n    let mut num_str12 = num_str11.to_owned();\n\
    \    let mut num_str13 = num_str12.to_owned();\n    let mut num_str14 = num_str13.to_owned();\n\
    \    let mut num_str15 = num_str14.to_owned();\n    let mut num_str16 = num_str15.to_owned();\n\
    \    let mut num_str17 = num_str16.to_owned();\n    let mut num_str18 = num_str17.to_owned();\n\
    \    let mut num_str19 = num_str18.to_owned();\n    let mut num_str20 = num_str19.to_owned();\n\
    \    let mut num_str21 = num_str20.to_owned();\n    let mut num_str22 = num_str21.to_owned();\n\
    \    let mut num_str23 = num_str22.to_owned();\n    let mut num_str24 = num_str23.to_owned();\n\
    \    let mut num_str25 = num_str24.to_owned();\n    let mut num_str26 = num_str25.to_owned();\n\
    \    let mut num_str27 = num_str26.to_owned();\n    let mut num_str28 = num_str27.to_owned();\n\
    \    let mut num_str29 = num_str28.to_owned();\n    let mut num_str30 = num_str29.to_owned();\n\
    \    let mut num_str31 = num_str30.to_owned();\n    let mut num_str32 = num_str31.to_owned();\n\
    \    let mut num_str33 = num_str32.to_owned();\n    let mut num_str34 = num_str33.to_owned();\n\
    \    let mut num_str35 = num_str34.to_owned();\n    let mut num_str\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd7zjs_s5.rs:53:20\n   |\n\
    53 |     let mut num_str\n   |                    ^ help: add `;` here\n54 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd7zjs_s5.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut digits = num.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ digits_len = digits.length;\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.length;\n    let mut digits_index = 0;\n    let mut digits_len = digits.length;\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.length;\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.length;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = digits.length;\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.length;\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.length;\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.length;\n    let mut digits_index = 0;\n    let mut\
    \ digits_len = digits.length;\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.length;\n    let mut digits_index = 0;\n    let mut digits_len = digits.length;\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.length;\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.length;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = digits.length;\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.length;\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.length;\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.length;\n    let mut digits_index = 0;\n    let mut\
    \ digits_len = digits.length;\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.length;\n    let mut digits_index = 0;\n    let mut digits_len = digits.length;\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.length;\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.length;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = digits.length;\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.length;\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.length;\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.length;\n    let mut digits_index = 0;\n    let mut\
    \ digits_len = digits.length;\n    let mut digits_index = 0;\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `length` on type `Vec<char>`\n  --> /tmp/tmp77kf3imz.rs:21:33\n\
    \   |\n21 |     let mut digits_len = digits.length;\n   |                    \
    \             ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type\
    \ `Vec<char>`\n  --> /tmp/tmp77kf3imz.rs:23:33\n   |\n23 |     let mut digits_len\
    \ = digits.length;\n   |                                 ^^^^^^ unknown field\n\
    \nerror[E0609]: no field `length` on type `Vec<char>`\n  --> /tmp/tmp77kf3imz.rs:25:33\n\
    \   |\n25 |     let mut digits_len = digits.length;\n   |                    \
    \             ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type\
    \ `Vec<char>`\n  --> /tmp/tmp77kf3imz.rs:27:33\n   |\n27 |     let mut digits_len\
    \ = digits.length;\n   |                                 ^^^^^^ unknown field\n\
    \nerror[E0609]: no field `length` on type `Vec<char>`\n  --> /tmp/tmp77kf3imz.rs:29:33\n\
    \   |\n29 |     let mut digits_len = digits.length;\n   |                    \
    \             ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type\
    \ `Vec<char>`\n  --> /tmp/tmp77kf3imz.rs:31:33\n   |\n31 |     let mut digits_len\
    \ = digits.length;\n   |                                 ^^^^^^ unknown field\n\
    \nerror[E0609]: no field `length` on type `Vec<char>`\n  --> /tmp/tmp77kf3imz.rs:33:33\n\
    \   |\n33 |     let mut digits_len = digits.length;\n   |                    \
    \             ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type\
    \ `Vec<char>`\n  --> /tmp/tmp77kf3imz.rs:35:33\n   |\n35 |     let mut digits_len\
    \ = digits.length;\n   |                                 ^^^^^^ unknown field\n\
    \nerror[E0609]: no field `length` on type `Vec<char>`\n  --> /tmp/tmp77kf3imz.rs:37:33\n\
    \   |\n37 |     let mut digits_len = digits.length;\n   |                    \
    \             ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type\
    \ `Vec<char>`\n  --> /tmp/tmp77kf3imz.rs:39:33\n   |\n39 |     let mut digits_len\
    \ = digits.length;\n   |                                 ^^^^^^ unknown field\n\
    \nerror[E0609]: no field `length` on type `Vec<char>`\n  --> /tmp/tmp77kf3imz.rs:41:33\n\
    \   |\n41 |     let mut digits_len ="
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n\
    \    let mut prime_digits_len = num.len();\n    let mut prime_digits_index = 0;\n\
    \    let mut prime_digits_value = num[prime_digits_index..].to_digits();\n   \
    \ let mut prime_digits_value_len = prime_digits_value.len();\n    let mut prime_digits_value_len_index\
    \ = 0;\n    let mut prime_digits_value_len_value = prime_digits_value[prime_digits_value_len_index..].to_digits();\n\
    \    let mut prime_digits_value_len_value_len = prime_digits_value_len_value.len();\n\
    \    let mut prime_digits_value_len_value_len_index = 0;\n    let mut prime_digits_value_len_value_len_value\
    \ = prime_digits_value_len_value[prime_digits_value_len_value_len_index..].to_digits();\n\
    \    let mut prime_digits_value_len_value_len_value_len = 0;\n    let mut prime_digits_value_len_value_len_value_len_index\
    \ = 0;\n    let mut prime_digits_value_len_value_len_value_len_value = 0;\n  \
    \  let mut prime_digits_value_len_value_len_value_len_value_len = 0;\n    let\
    \ mut prime_digits_value_len_value_len_value_len_value_len = 0;\n    let mut prime_digits_value_len_value_len_value_len_value_len\
    \ = 0;\n    let mut prime_digits_value_len_value_len_value_len_value_len = 0;\n\
    \    let mut prime_digits_value_len_value_len_value_len_value_len = 0;\n    let\
    \ mut prime_digits_value_len_value_len_value_len_value_len = 0;\n    let mut prime_digits_value_len_value_len_value_len_value_len\
    \ = 0;\n    let mut prime_digits_value_len_value_len_value_len_value_len = 0;\n\
    \    let mut prime_digits_value_len_value_len_value_len_value_len = 0;\n    let\
    \ mut prime_digits_value_len_value_len_value_len_value_len = 0;\n    let mut prime_digits_value_len_value_len_value_len_value_len\
    \ = 0;\n    let mut prime_digits_value_len_value_len_value_len_value_len = 0;\n\
    \    let mut prime_digits_value_len_value_len_value_len_value_len = 0;\n    let\
    \ mut prime_digits_value_len_value_len_value_len_value_len = 0;\n    let mut prime_digits_value_len_value_len_value_len_value_len\
    \ = 0;\n    let mut prime_digits_value_len_value_len_value_len_value_len = 0;\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqstj92wa.rs:48:11\n   |\n\
    48 |     let mu\n   |           ^ help: add `;` here\n49 | }\n   | - unexpected\
    \ token\n\nerror[E0599]: no method named `to_digits` found for type `str` in the\
    \ current scope\n  --> /tmp/tmpqstj92wa.rs:22:60\n   |\n22 |     let mut prime_digits_value\
    \ = num[prime_digits_index..].to_digits();\n   |                             \
    \                               ^^^^^^^^^ method not found in `str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqstj92wa.rs:17:28\n   |\n17 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let mut num_digits = num.len();\n\
    \    let mut num_digits_prime = 0;\n    let mut num_digits_not_prime = 0;\n  \
    \  let mut num_digits_not_prime_prime = 0;\n    let mut num_digits_not_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime = 0;\n\
    \    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime = 0;\n \
    \   let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n\
    \    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpn8uwxq8t.rs:39:76\n   |\n\
    39 |     let mut num_digits_not_prime_prime_prime_prime_prime_prime_prime_prime_\n\
    \   |                                                                        \
    \    ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn8uwxq8t.rs:17:28\n   |\n17 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut digits\
    \ = num.chars().collect::<Vec<_>>();\n    let mut prime_digits = primes.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime_digit_count = primes.iter().cloned().count();\n    let mut\
    \ digit_count = digits.len();\n    let mut prime_digit_count = prime_digits.iter().cloned().count();\n\
    \    let mut digit_count = digits.len();\n    let mut prime_digit_count = prime_digits.iter().cloned().count();\n\
    \    let mut digit_count = digits.len();\n    let mut prime_digit_count = prime_digits.iter().cloned().count();\n\
    \    let mut digit_count = digits.len();\n    let mut prime_digit_count = prime_digits.iter().cloned().count();\n\
    \    let mut digit_count = digits.len();\n    let mut prime_digit_count = prime_digits.iter().cloned().count();\n\
    \    let mut digit_count = digits.len();\n    let mut prime_digit_count = prime_digits.iter().cloned().count();\n\
    \    let mut digit_count = digits.len();\n    let mut prime_digit_count = prime_digits.iter().cloned().count();\n\
    \    let mut digit_count = digits.len();\n    let mut prime_digit_count = prime_digits.iter().cloned().count();\n\
    \    let mut digit_count = digits.len();\n    let mut prime_digit_count = prime_digits.iter().cloned().count();\n\
    \    let mut digit_count = digits.len();\n    let mut prime_digit_count = prime_digits.iter().cloned().count();\n\
    \    let mut digit_count = digits.len();\n    let mut prime_digit_count = prime_digits.iter().cloned().count();\n\
    \    let mut digit_count = digits.len();\n    let mut prime_digit_count = prime_digits.iter().cloned().count();\n\
    \    let mut digit_count = digits.len();\n    let mut prime_digit_count = prime_digits.iter().cloned().count();\n\
    \    let mut digit_count = digits.len();\n    let mut prime_digit_count = prime_digits.iter().cloned().count();\n\
    \    let mut digit_count = digits.len();\n    let mut prime_digit_count = prime_digits.iter().cloned().count();\n\
    \    let mut digit_count = digits.len();\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl3_ngr7s.rs:53:11\n   |\n\
    53 |     let mu\n   |           ^ help: add `;` here\n54 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl3_ngr7s.rs:17:28\n \
    \  |\n17 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<usize> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<usize> = vec![2, 3];\n    let mut counter: usize = 0;\n\
    \    let mut digit: usize = 0;\n    let mut prime_counter: usize = 0;\n    let\
    \ mut prime_digit: usize = 0;\n    let mut prime_prime_counter: usize = 0;\n \
    \   let mut prime_prime_digit: usize = 0;\n    let mut prime_prime_prime_counter:\
    \ usize = 0;\n    let mut prime_prime_prime_digit: usize = 0;\n    let mut prime_prime_prime_prime_counter:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_digit: usize = 0;\n    let mut\
    \ prime_prime_prime_prime_prime_counter: usize = 0;\n    let mut prime_prime_prime_prime_prime_digit:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_counter: usize =\
    \ 0;\n    let mut prime_prime_prime_prime_prime_prime_digit: usize = 0;\n    let\
    \ mut prime_prime_prime_prime_prime_prime_prime_counter: usize = 0;\n    let mut\
    \ prime_prime_prime_prime_prime_prime_prime_digit: usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_counter:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_digit: usize\
    \ = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_counter: usize\
    \ = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_digit: usize\
    \ = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_counter:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_digit:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_counter:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_digit:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbskre_ic.rs:44:49\n   |\n\
    44 |     let mut prime_prime_prime_prime_prime_prime_\n   |                  \
    \                               ^ help: add `;` here\n45 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<usize>` cannot be built from an\
    \ iterator over elements of type `char`\n    --> /tmp/tmpbskre_ic.rs:18:58\n \
    \    |\n18   |     let mut num: Vec<usize> = num.to_lowercase().chars().collect();\n\
    \     |                                                          ^^^^^^^ value\
    \ of type `Vec<usize>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<usize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbskre_ic.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3];\n    let mut counter: usize = 0;\n \
    \   let mut digit: u8 = 0;\n    let mut prime_counter: usize = 0;\n    let mut\
    \ prime_digit: u8 = 0;\n    let mut prime_prime: usize = 0;\n    let mut prime_prime_prime:\
    \ usize = 0;\n    let mut prime_prime_prime_prime: usize = 0;\n    let mut prime_prime_prime_prime_prime:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime: usize = 0;\n  \
    \  let mut prime_prime_prime_prime_prime_prime_prime: usize = 0;\n    let mut\
    \ prime_prime_prime_prime_prime_prime_prime_prime: usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ usize = 0;\n    let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpm4wq57dz.rs:40:109\n   |\n\
    40 |     let mut prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_\n\
    \   |                                                                        \
    \                                     ^ help: add `;` here\n41 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpm4wq57dz.rs:18:55\n     |\n18\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm4wq57dz.rs:17:28\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_vec();\n    let mut cnt: isize\
    \ = 0;\n    let mut prime: isize = 2;\n    let mut prime_found = false;\n    let\
    \ mut prime_found2 = false;\n    let mut prime_found3 = false;\n    let mut prime_found4\
    \ = false;\n    let mut prime_found5 = false;\n    let mut prime_found6 = false;\n\
    \    let mut prime_found7 = false;\n    let mut prime_found8 = false;\n    let\
    \ mut prime_found9 = false;\n    let mut prime_found10 = false;\n    let mut prime_found11\
    \ = false;\n    let mut prime_found12 = false;\n    let mut prime_found13 = false;\n\
    \    let mut prime_found14 = false;\n    let mut prime_found15 = false;\n    let\
    \ mut prime_found16 = false;\n    let mut prime_found17 = false;\n    let mut\
    \ prime_found18 = false;\n    let mut prime_found19 = false;\n    let mut prime_found20\
    \ = false;\n    let mut prime_found21 = false;\n    let mut prime_found22 = false;\n\
    \    let mut prime_found23 = false;\n    let mut prime_found24 = false;\n    let\
    \ mut prime_found25 = false;\n    let mut prime_found26 = false;\n    let mut\
    \ prime_found27 = false;\n    let mut prime_found28 = false;\n    let mut prime_found29\
    \ = false;\n    let mut prime_found30 = false;\n    let mut prime_found31 = false;\n\
    \    let mut prime_found32 = false;\n    let mut prime_found33 = false;\n    let\
    \ mut prime_found34 = false;\n    let mut prime_found35 = false;\n    let mut\
    \ prime_found36 = false;\n    let mut prime_found37 = false;\n    let mut prime_found38\
    \ = false;\n    let mut prime_found39 = false;\n    let mut prime_found40 = false;\n\
    \    let mut prime_found41 = false;\n    let mut prime_found42 = false;\n    let\
    \ mut prime_found43 = false;\n    let mut prime_found44 = false;\n    let mut\
    \ prime_found45 = false;\n    let mut prime_found46 = false;\n    let mut prime_found47\
    \ = false;\n    let mut prime_found48 = false;\n    let mut prime_found49 = false;\n\
    \    let mut prime_found50 = false;\n    let mut prime_found51 = false;\n    let\
    \ mut prime_found52 = false;\n    let mut prime\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcbyn3b7w.rs:73:18\n   |\n\
    73 |     let mut prime\n   |                  ^ help: add `;` here\n74 | }\n \
    \  | - unexpected token\n\nerror[E0599]: no method named `to_vec` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpcbyn3b7w.rs:18:32\n   |\n18 | \
    \    let mut num: Vec<u8> = num.to_vec();\n   |                              \
    \  ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcbyn3b7w.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize {\n \
    \  |    -------                 ^^^^^ expected `isize`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_vec();\n    let mut prime_count:\
    \ usize = 0;\n    let mut prime_digit: u8 = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value:\
    \ u8 = 0;\n    let mut prime_\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppfv__qvx.rs:68:19\n   |\n\
    68 |     let mut prime_\n   |                   ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0599]: no method named `to_vec` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmppfv__qvx.rs:18:32\n   |\n18 | \
    \    let mut num: Vec<u8> = num.to_vec();\n   |                              \
    \  ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmppfv__qvx.rs:17:28\n   |\n17 | fn hex_key(num: String) -> isize {\n \
    \  |    -------                 ^^^^^ expected `isize`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num: Vec<u8> = num.to_vec();\n    let mut prime_digit:\
    \ Vec<u8> = vec![0; 16];\n    let mut prime_digit_count: usize = 0;\n    let mut\
    \ prime_digit_index: usize = 0;\n    let mut prime_digit_count: usize = 0;\n \
    \   let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count: usize\
    \ = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_index: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_\n}\n\nfn main() {\n    let candidate =\
    \ hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9z_afjgn.rs:63:25\n   |\n\
    63 |     let mut prime_digit_\n   |                         ^ help: add `;` here\n\
    64 | }\n   | - unexpected token\n\nerror[E0599]: no method named `to_vec` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp9z_afjgn.rs:18:32\n\
    \   |\n18 |     let mut num: Vec<u8> = num.to_vec();\n   |                   \
    \             ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9z_afjgn.rs:17:28\n   |\n17 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut nums = num.to_chars().collect::<Vec<_>>();\n    let\
    \ mut primes = vec![false; 26];\n    let mut primes_counter = 0;\n    let mut\
    \ primes_counter2 = 0;\n    let mut primes_counter3 = 0;\n    let mut primes_counter4\
    \ = 0;\n    let mut primes_counter5 = 0;\n    let mut primes_counter6 = 0;\n \
    \   let mut primes_counter7 = 0;\n    let mut primes_counter8 = 0;\n    let mut\
    \ primes_counter9 = 0;\n    let mut primes_counter10 = 0;\n    let mut primes_counter11\
    \ = 0;\n    let mut primes_counter12 = 0;\n    let mut primes_counter13 = 0;\n\
    \    let mut primes_counter14 = 0;\n    let mut primes_counter15 = 0;\n    let\
    \ mut primes_counter16 = 0;\n    let mut primes_counter17 = 0;\n    let mut primes_counter18\
    \ = 0;\n    let mut primes_counter19 = 0;\n    let mut primes_counter20 = 0;\n\
    \    let mut primes_counter21 = 0;\n    let mut primes_counter22 = 0;\n    let\
    \ mut primes_counter23 = 0;\n    let mut primes_counter24 = 0;\n    let mut primes_counter25\
    \ = 0;\n    let mut primes_counter26 = 0;\n    let mut primes_counter27 = 0;\n\
    \    let mut primes_counter28 = 0;\n    let mut primes_counter29 = 0;\n    let\
    \ mut primes_counter30 = 0;\n    let mut primes_counter31 = 0;\n    let mut primes_counter32\
    \ = 0;\n    let mut primes_counter33 = 0;\n    let mut primes_counter34 = 0;\n\
    \    let mut primes_counter35 = 0;\n    let mut primes_counter36 = 0;\n    let\
    \ mut primes_counter37 = 0;\n    let mut primes_counter38 = 0;\n    let mut primes_counter39\
    \ = 0;\n    let mut primes_counter40 = 0;\n    let mut primes_counter41 = 0;\n\
    \    let mut primes_counter42 = 0;\n    let mut primes_counter43 = 0;\n    let\
    \ mut primes_counter44 = 0;\n    let mut primes_counter45 = 0;\n    let mut primes_counter46\
    \ = 0;\n    let mut primes_counter47 = 0;\n    let mut primes_counter48 = 0;\n\
    \    let mut primes_counter49 = 0;\n    let mut primes_counter50 = 0;\n    let\
    \ mut primes_counter51 = 0;\n    let mut primes_counter52 = 0;\n    let mut primes_counter53\
    \ = 0;\n    let mut primes_counter54 = 0;\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_odv3xmt.rs:74:11\n   |\n\
    74 |     let mu\n   |           ^ help: add `;` here\n75 | }\n   | - unexpected\
    \ token\n\nerror[E0599]: no method named `to_chars` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp_odv3xmt.rs:18:24\n   |\n18 |     let mut\
    \ nums = num.to_chars().collect::<Vec<_>>();\n   |                        ^^^^^^^^\
    \ help: there is an associated function with a similar name: `chars`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_odv3xmt.rs:17:28\n   |\n17 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
