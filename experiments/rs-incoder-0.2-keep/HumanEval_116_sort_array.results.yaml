name: HumanEval_116_sort_array
language: rust
results:
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = 0;\n    let mut decimal = 0;\n\
    \    for &i in arr {\n        if i & 1 != 0 {\n            ones += 1;\n      \
    \  } else {\n            decimal += i;\n        }\n    }\n    if ones > 0 {\n\
    \        result.sort_by_key(|&i| i / decimal);\n    } else {\n        result.sort_by_key(|&i|\
    \ i);\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnqe1fy49.rs:12:9\n   |\n\
    12 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for x in arr {\n\
    \        if x % 2 == 0 {\n            ones.push(x);\n        } else {\n      \
    \      result.push(x);\n        }\n    }\n    let mut i = 0;\n    while i < ones.len()\
    \ {\n        let mut j = i;\n        while j < ones.len() && ones[j] == ones[j\
    \ + 1] {\n            j += 1\n        }\n        result.push(ones[j]);\n     \
    \   i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counter = vec![0; arr.len()];\n    let mut result = vec![0; arr.len()];\n\
    \    for i in 0..arr.len() {\n        if arr[i] == 0 {\n            counter[i]\
    \ = 0;\n        } else {\n            counter[i] = counter[i] + 1;\n        }\n\
    \    }\n    for i in 0..arr.len() {\n        if counter[i] > 1 {\n           \
    \ result[i] = i;\n            counter[i] = 0;\n        }\n    }\n    for i in\
    \ 0..arr.len() {\n        if counter[i] == 1 {\n            result[i] = arr[i];\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpite_p79e.rs:26:25\n   |\n\
    26 |             result[i] = arr[i];\n   |             ---------   ^^^^^^ expected\
    \ `usize`, found `isize`\n   |             |\n   |             expected due to\
    \ the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpite_p79e.rs:29:5\n\
    \   |\n8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |             \
    \                      ---------- expected `Vec<isize>` because of return type\n\
    ...\n29 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    let mut decimal\
    \ = vec![];\n    for i in arr {\n        if i & 1 == 1 {\n            ones.push(i);\n\
    \        } else {\n            decimal.push(i);\n        }\n    }\n    for i in\
    \ ones {\n        result.push(i);\n    }\n    for i in decimal {\n        result.push(i);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 3, 2, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpe1rwvye3.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counter = HashMap::new();\n    for e in arr {\n        if let Some(count)\
    \ = counter.entry(e).or_insert(0) {\n            *count += 1;\n        } else\
    \ {\n            counter.insert(e, 1);\n        }\n    }\n    let mut sorted_arr\
    \ = Vec::new();\n    for e in counter.keys() {\n        sorted_arr.push(e);\n\
    \    }\n    sorted_arr.sort();\n    sorted_arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmprp1g6v9c.rs:9:23\n  |\n9 |     let mut counter = HashMap::new();\n \
    \ |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = 0;\n    let mut decimal = 0;\n\
    \    for &i in arr {\n        if i & 1 != 0 {\n            ones += 1;\n      \
    \  } else {\n            decimal += i;\n        }\n    }\n    if ones > 0 {\n\
    \        result.sort_by_key(|&i| i as isize);\n        result.sort_by_key(|&i|\
    \ decimal as isize);\n    } else {\n        result.sort_by_key(|&i| i as isize);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvl55ut8t.rs:12:9\n   |\n\
    12 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < arr.len() {\n        if arr[i] == 1 {\n            i += 1;\n        } else\
    \ {\n            result[j] = arr[i];\n            j += 1;\n        }\n    }\n\
    \    result[j..] = arr[i..];\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `[isize]` cannot be known at\
    \ compilation time\n  --> /tmp/tmp5okubob9.rs:20:5\n   |\n20 |     result[j..]\
    \ = arr[i..];\n   |     ^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `[isize]`\n   = note:\
    \ the left-hand-side of an assignment must have a statically known size\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n  \
    \  while i < arr.len() {\n        let mut k = i;\n        while k < arr.len()\
    \ {\n            if arr[k] == 1 {\n                result.push(k);\n         \
    \       k += 1;\n            } else {\n                break;\n            }\n\
    \        }\n        while j < arr.len() {\n            if arr[j] == 1 {\n    \
    \            result.push(j);\n                j += 1;\n            } else {\n\
    \                break;\n            }\n        }\n        i += 1;\n        j\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmparbddxbf.rs:33:5\n   |\n\
    8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \               ---------- expected `Vec<isize>` because of return type\n...\n\
    33 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counter = HashMap::new();\n    for &i in arr {\n        if let Some(count)\
    \ = counter.entry(i).or_insert(0) {\n            *count += 1;\n        } else\
    \ {\n            counter.insert(i, 1);\n        }\n    }\n    arr.iter().cloned().sort_by_key(|&i|\
    \ counter.entry(i).or_insert(0));\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpg51h0nl3.rs:9:23\n  |\n9 |     let mut counter = HashMap::new();\n \
    \ |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg51h0nl3.rs:10:9\n   |\n10 |     for &i in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `Cloned` in the current scope\n  --> /tmp/tmpg51h0nl3.rs:17:25\n\
    \   |\n17 |     arr.iter().cloned().sort_by_key(|&i| counter.entry(i).or_insert(0));\n\
    \   |                         ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpg51h0nl3.rs:8:35\n\
    \  |\n8 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n  |    ----------  \
    \                   ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for i in arr.iter() {\n        if i & 1 !=\
    \ 0 {\n            result.push(i);\n        }\n    }\n    result.sort_unstable_by(|a,\
    \ b| {\n        let mut a = a as usize;\n        let mut b = b as usize;\n   \
    \     if a > b {\n            (a, b)\n        } else {\n            (b, a)\n \
    \       }\n    });\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4h6hbnt7.rs:19:13\n   |\n\
    19 |             (a, b)\n   |             ^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found tuple\n   |\n   = note: expected enum `std::cmp::Ordering`\n         \
    \    found tuple `(usize, usize)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4h6hbnt7.rs:21:13\n\
    \   |\n21 |             (b, a)\n   |             ^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found tuple\n   |\n   = note: expected enum `std::cmp::Ordering`\n         \
    \    found tuple `(usize, usize)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4h6hbnt7.rs:24:5\n\
    \   |\n8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |             \
    \                      ---------- expected `Vec<isize>` because of return type\n\
    ...\n24 |     result\n   |     ^^^^^^ expected `isize`, found `&isize`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror[E0606]: casting `&&isize` as `usize` is invalid\n  --> /tmp/tmp4h6hbnt7.rs:16:21\n\
    \   |\n16 |         let mut a = a as usize;\n   |                     ^^^^^^^^^^\n\
    \   |\n   = help: cast through a raw pointer first\n\nerror[E0606]: casting `&&isize`\
    \ as `usize` is invalid\n  --> /tmp/tmp4h6hbnt7.rs:17:21\n   |\n17 |         let\
    \ mut b = b as usize;\n   |                     ^^^^^^^^^^\n   |\n   = help: cast\
    \ through a raw pointer first\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0606.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = arr.clone();\n    let mut cnt = 0;\n    for i in res {\n  \
    \      if cnt > 1 {\n            cnt -= 1;\n            continue;\n        }\n\
    \        if i != 0 {\n            cnt += 1;\n            continue;\n        }\n\
    \    }\n    for i in res {\n        if i != 0 {\n            cnt += 1;\n     \
    \       continue;\n        }\n        if cnt > 1 {\n            cnt -= 1;\n  \
    \          continue;\n        }\n        res.swap(i, res.iter().cloned().count());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpewoyvjyw.rs:30:18\n   |\n\
    30 |         res.swap(i, res.iter().cloned().count());\n   |                 \
    \ ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n30 |         res.swap(i.try_into().unwrap(),\
    \ res.iter().cloned().count());\n   |                   ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut ones = Vec::new();\n    let mut\
    \ zeros = Vec::new();\n    for ele in arr {\n        if ele == 0 {\n         \
    \   zeros.push(ele);\n        } else {\n            ones.push(ele);\n        }\n\
    \    }\n    let mut ones_count = ones.length;\n    let mut zeros_count = zeros.length;\n\
    \    while ones_count > 0 && zeros_count > 0 {\n        if ones[ones_count - 1]\
    \ == 1 {\n            ones_count -= 1;\n        } else {\n            zeros_count\
    \ -= 1;\n        }\n    }\n    while ones_count > 0 {\n        result.push(ones[ones_count\
    \ - 1]);\n        ones_count -= 1;\n    }\n    while zeros_count > 0 {\n     \
    \   result.push(zeros[zeros_count - 1]);\n        zeros_count -= 1;\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `length` on type `Vec<isize>`\n  --> /tmp/tmpi_05vxk5.rs:19:31\n\
    \   |\n19 |     let mut ones_count = ones.length;\n   |                      \
    \         ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type `Vec<isize>`\n\
    \  --> /tmp/tmpi_05vxk5.rs:20:33\n   |\n20 |     let mut zeros_count = zeros.length;\n\
    \   |                                 ^^^^^^ unknown field\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0609`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by_key(|x| {\n   \
    \     if x == 1 {\n            0\n        } else {\n            1\n        }\n\
    \    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpsk3nnfka.rs:11:14\n\
    \   |\n11 |         if x == 1 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut cnt = 0;\n    for x in arr {\n       \
    \ if cnt > 0 {\n            cnt += 1;\n            res.push(x);\n        } else\
    \ {\n            cnt += x.checked_mul(2).unwrap();\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 2, 3, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmph3ewx9ht.rs:24:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_unstable_by_key(|x|\
    \ {\n        let mut bin = x.to_bin();\n        bin.truncate(bin.len() - 1);\n\
    \        bin\n    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_bin` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmplq0c8ykt.rs:11:25\n   |\n11 |         let mut\
    \ bin = x.to_bin();\n   |                         ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 != 0 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    result.sort_by_key(|i| {\n     \
    \   if ones.len() == 0 {\n            ones.push(i);\n            0\n        }\
    \ else {\n            let mut j = 0;\n            while j < ones.len() && i <\
    \ ones[j] {\n                j += 1;\n            }\n            if j == ones.len()\
    \ {\n                ones.push(i);\n                0\n            } else {\n\
    \                ones[j];\n            }\n        }\n    });\n    result\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp37cpsu2n.rs:20:23\n   |\n\
    20 |             ones.push(i);\n   |                       ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |  \
    \           ones.push(*i);\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp37cpsu2n.rs:24:41\n   |\n24 |             while j < ones.len()\
    \ && i < ones[j] {\n   |                                         ^^^^^^^\n   |\
    \                                         |\n   |                            \
    \             expected `&isize`, found `isize`\n   |                         \
    \                help: consider borrowing here: `&ones[j]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp37cpsu2n.rs:28:27\n   |\n28 |                 ones.push(i);\n\
    \   |                           ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n28 |                 ones.push(*i);\n\
    \   |                           +\n\nerror[E0308]: `if` and `else` have incompatible\
    \ types\n  --> /tmp/tmp37cpsu2n.rs:31:17\n   |\n27 | /             if j == ones.len()\
    \ {\n28 | |                 ones.push(i);\n29 | |                 0\n   | |  \
    \               - expected because of this\n30 | |             } else {\n31 |\
    \ |                 ones[j];\n   | |                 ^^^^^^^-\n   | |        \
    \         |      |\n   | |                 |      help: consider removing this\
    \ semicolon\n   | |                 expected integer, found `()`\n32 | |     \
    \        }\n   | |_____________- `if` and `else` have incompatible types\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        for i in ones {\n            result.push(i);\n        }\n    }\n    if\
    \ result.len() > 0 {\n        result.sort();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpi7qtqbi6.rs:31:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.to_vec();\n    sorted_arr.sort_by_key(|x| {\n  \
    \      let mut bin = String::new();\n        for i in 0..32 {\n            if\
    \ x & (1 << i) != 0 {\n                bin.push(\"1\");\n            } else {\n\
    \                bin.push(\"0\");\n            }\n        }\n        bin\n   \
    \ });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx837s62_.rs:14:26\n   |\n\
    14 |                 bin.push(\"1\");\n   |                          ^^^ expected\
    \ `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal, use\
    \ single quotes\n   |\n14 |                 bin.push('1');\n   |             \
    \             ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx837s62_.rs:16:26\n\
    \   |\n16 |                 bin.push(\"0\");\n   |                          ^^^\
    \ expected `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal,\
    \ use single quotes\n   |\n16 |                 bin.push('0');\n   |         \
    \                 ~~~\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut xs = x.to_string();\n        xs.reverse();\n\
    \        xs.chars().filter(|c| c == '1').count() as isize\n    })\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpz76tjrwg.rs:11:12\n   |\n11 |         xs.reverse();\n\
    \   |            ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpz76tjrwg.rs:12:33\n\
    \   |\n12 |         xs.chars().filter(|c| c == '1').count() as isize\n   |   \
    \                              ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz76tjrwg.rs:9:5\n   |\n8  |   fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                     ---------- expected\
    \ `Vec<isize>` because of return type\n9  | /     arr.sort_by_key(|x| {\n10 |\
    \ |         let mut xs = x.to_string();\n11 | |         xs.reverse();\n12 | |\
    \         xs.chars().filter(|c| c == '1').count() as isize\n13 | |     })\n  \
    \ | |______^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut counter = vec![];\n    for ele in arr\
    \ {\n        if ele == 1 {\n            counter.push(1);\n        } else {\n \
    \           counter.push(counter.last().unwrap() + 1);\n        }\n    }\n   \
    \ for i in 0..counter.len() {\n        result.push(counter.iter().skip(i).sum());\n\
    \    }\n    result.sort_unstable();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 9, 12, 14, 15]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpv_2jwubb.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a > b {\n            1\n        } else {\n\
    \            -1\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuojq6_1h.rs:11:13\n   |\n\
    11 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuojq6_1h.rs:13:13\n\
    \   |\n13 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut bin = String::new();\n        bin.push_str(&format!(\"\
    {:b}\", x));\n        bin.chars().filter(|c| c == '1').count()\n    });\n    arr.sort_by_key(|x|\
    \ x.to_dec());\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpop4208q5.rs:12:34\n\
    \   |\n12 |         bin.chars().filter(|c| c == '1').count()\n   |           \
    \                       ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0599]: no method named `to_dec`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmpop4208q5.rs:14:27\n\
    \   |\n14 |     arr.sort_by_key(|x| x.to_dec());\n   |                       \
    \    ^^^^^^ help: there is an associated function with a similar name: `to_be`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut num_ones = 0;\n    for x in arr {\n\
    \        if x != 0 {\n            num_ones += 1;\n        }\n    }\n    if num_ones\
    \ == 0 {\n        result.sort_unstable();\n    } else {\n        result.sort_by_key(|x|\
    \ {\n            let mut num_ones = 0;\n            for x in arr {\n         \
    \       if x != 0 {\n                    num_ones += 1;\n                }\n \
    \           }\n            num_ones\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp1fwpz2vs.rs:19:29\n   |\n\
    19 |         result.sort_by_key(|x| {\n   |                             ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `arr`, a captured variable in an `FnMut` closure\n   --> /tmp/tmp1fwpz2vs.rs:21:22\n\
    \    |\n8   |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    |        \
    \         --- captured outer variable\n...\n19  |           result.sort_by_key(|x|\
    \ {\n    |  ____________________________-\n20  | |             let mut num_ones\
    \ = 0;\n21  | |             for x in arr {\n    | |                      ^^^\n\
    \    | |                      |\n    | |                      `arr` moved due\
    \ to this implicit call to `.into_iter()`\n    | |                      move occurs\
    \ because `arr` has type `Vec<isize>`, which does not implement the `Copy` trait\n\
    22  | |                 if x != 0 {\n...   |\n26  | |             num_ones\n27\
    \  | |         });\n    | |_________- captured by this `FnMut` closure\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `arr`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |             for x in &arr {\n    |       \
    \               +\n\nerror[E0382]: use of moved value: `arr`\n   --> /tmp/tmp1fwpz2vs.rs:19:28\n\
    \    |\n8   | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    |          \
    \     --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n11  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n19  |         result.sort_by_key(|x|\
    \ {\n    |                            ^^^ value used here after move\n20  |  \
    \           let mut num_ones = 0;\n21  |             for x in arr {\n    |   \
    \                   --- use occurs due to use in closure\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the "
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > 0 {\n        result.sort_by_key(|x|\
    \ ones[x as usize]);\n    } else {\n        result.sort_by_key(|x| x.to_dec());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_dec` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpn334hw0t.rs:21:34\n   |\n21 |         result.sort_by_key(|x|\
    \ x.to_dec());\n   |                                  ^^^^^^ help: there is an\
    \ associated function with a similar name: `to_be`\n\nerror[E0606]: casting `&isize`\
    \ as `usize` is invalid\n  --> /tmp/tmpn334hw0t.rs:19:37\n   |\n19 |         result.sort_by_key(|x|\
    \ ones[x as usize]);\n   |                                     -^^^^^^^^^\n  \
    \ |                                     |\n   |                              \
    \       cannot cast `&isize` as `usize`\n   |                                \
    \     help: dereference the expression: `*x`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0606.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut bin = x.to_bin();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8exl486m.rs:106:3\n\
    \    |\n8   | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    |          \
    \                                    - unclosed delimiter\n9   |     arr.sort_by_key(|x|\
    \ {\n    |                    - unclosed delimiter\n...\n106 | }\n    |   ^\n\n\
    error: expected one of `)`, `,`, `.`, `?`, or an operator, found keyword `fn`\n\
    \  --> /tmp/tmp8exl486m.rs:96:1\n   |\n94 | }\n   |  - expected one of `)`, `,`,\
    \ `.`, `?`, or an operator\n95 | \n96 | fn main() {\n   | ^^ unexpected token\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = 0;\n    for &i in arr {\n  \
    \      if *i & 1 == 1 {\n            ones += 1;\n        } else {\n          \
    \  result.push(*i / ones);\n            ones = 1;\n        }\n    }\n    result.push(*ones);\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnaprsi3e.rs:11:9\n   |\n\
    11 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0614]: type `{integer}`\
    \ cannot be dereferenced\n  --> /tmp/tmpnaprsi3e.rs:19:17\n   |\n19 |     result.push(*ones);\n\
    \   |                 ^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for i in arr.iter() {\n        if i & 1 ==\
    \ 1 {\n            result.push(i);\n        }\n    }\n    result.sort_by_key(|x|\
    \ x.to_dec());\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_dec` found for reference `&&isize` in\
    \ the current scope\n  --> /tmp/tmpdis9dowq.rs:15:30\n   |\n15 |     result.sort_by_key(|x|\
    \ x.to_dec());\n   |                              ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdis9dowq.rs:16:5\n   |\n8  | fn sort_array(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                                   ---------- expected `Vec<isize>` because\
    \ of return type\n...\n16 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        result.extend(ones);\n    } else {\n        result.extend(result.iter().cloned());\n\
    \    }\n    result.sort_unstable();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `result` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpai47owco.rs:21:9\n   |\n21 |         result.extend(result.iter().cloned());\n\
    \   |         ^^^^^^^------^-------------^^^^^^^^^^\n   |         |      |   \
    \   |\n   |         |      |      immutable borrow occurs here\n   |         |\
    \      immutable borrow later used by call\n   |         mutable borrow occurs\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut bin = String::new();\n        bin.push_str(&format!(\"\
    {:b}\", x));\n        bin.chars().filter(|c| c == '1').count()\n    });\n    arr.sort_by_key(|x|\
    \ {\n        let mut bin = String::new();\n        bin.push_str(&format!(\"{:b}\"\
    , x));\n        bin.chars().filter(|c| c == '0').count()\n    });\n    arr\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp7ddc63j3.rs:12:34\n\
    \   |\n12 |         bin.chars().filter(|c| c == '1').count()\n   |           \
    \                       ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp7ddc63j3.rs:17:34\n   |\n17 |         bin.chars().filter(|c|\
    \ c == '0').count()\n   |                                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counter = HashMap::new();\n    for x in arr {\n        counter.entry(x).or_insert(0)\
    \ += 1;\n    }\n    let mut sorted_arr = Vec::new();\n    for x in counter.iter()\
    \ {\n        if *x != 0 {\n            sorted_arr.push(x);\n        }\n    }\n\
    \    sorted_arr.sort_unstable_by_key(|x| {\n        counter[x].cmp(&counter[x\
    \ - 1])\n    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpbjy_7rpe.rs:9:23\n  |\n9 |     let mut counter = HashMap::new();\n \
    \ |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpbjy_7rpe.rs:11:39\n   |\n\
    11 |         counter.entry(x).or_insert(0) += 1;\n   |         -----------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut ones = vec![];\n    for i in arr {\n \
    \       if i & 1 != 0 {\n            ones.push(i);\n        } else {\n       \
    \     res.push(i);\n        }\n    }\n    if ones.len() > 0 {\n        res.sort_by(|a,\
    \ b| ones[a] - ones[b]);\n    } else {\n        res.sort_by(|a, b| a - b);\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpwik8buph.rs:19:28\n\
    \   |\n19 |         res.sort_by(|a, b| ones[a] - ones[b]);\n   |             \
    \               ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpwik8buph.rs:19:38\n\
    \   |\n19 |         res.sort_by(|a, b| ones[a] - ones[b]);\n   |             \
    \                         ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwik8buph.rs:21:28\n\
    \   |\n21 |         res.sort_by(|a, b| a - b);\n   |                         \
    \   ^^^^^ expected enum `std::cmp::Ordering`, found `isize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for ele in arr\
    \ {\n        if ele == 1 {\n            ones.push(ele);\n        } else {\n  \
    \          result.push(ele);\n        }\n    }\n    ones = sort_array(ones);\n\
    \    let mut i = 0;\n    for ele in ones {\n        result.push(ele);\n      \
    \  i += ele;\n    }\n    for i in 0..result.len() {\n        result[i] = result[i]\
    \ / i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc_qpbuqe.rs:25:33\n   |\n\
    25 |         result[i] = result[i] / i;\n   |                                \
    \ ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot divide `isize` by\
    \ `usize`\n  --> /tmp/tmpc_qpbuqe.rs:25:31\n   |\n25 |         result[i] = result[i]\
    \ / i;\n   |                               ^ no implementation for `isize / usize`\n\
    \   |\n   = help: the trait `Div<usize>` is not implemented for `isize`\n   =\
    \ help: the following other types implement trait `Div<Rhs>`:\n             <&'a\
    \ f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128\
    \ as Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32 as\
    \ Div<i32>>\n             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n\
    \             <&'a isize as Div<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < arr.len() {\n        if arr[i] > 0 {\n            result.push(arr[i]);\n\
    \            i += 1;\n        } else {\n            while j < arr.len() && arr[j]\
    \ == 0 {\n                j += 1;\n            }\n            if j > i {\n   \
    \             result.push(arr[j]);\n                j += 1;\n            }\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 2, 3, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp_gwqj3_7.rs:31:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_unstable_by(|a, b|\
    \ {\n        if a > b {\n            1\n        } else {\n            -1\n   \
    \     }\n    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptdufc9xs.rs:12:13\n   |\n\
    12 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptdufc9xs.rs:14:13\n\
    \   |\n14 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 != 0 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(ones[ones.len() - 1]);\n            ones.pop();\n        }\n\
    \    }\n    result.push(ones[ones.len() - 1]);\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, 1]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmptnbb7ndx.rs:25:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = 0;\n    for &i in arr {\n  \
    \      if *i & 1 != 0 {\n            ones += 1;\n        }\n        result.push(*i\
    \ + (ones * 10));\n    }\n    result.sort_unstable();\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprweo8b7y.rs:11:9\n   |\n\
    11 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut counter = vec![];\n    for i in arr\
    \ {\n        if i.is_zero() {\n            continue;\n        }\n        let mut\
    \ counter = counter.clone();\n        let mut count = 0;\n        while let Some(k)\
    \ = counter.iter().position(|&x| x == 1) {\n            count += 1;\n        \
    \    counter[k] = 0;\n        }\n        result.push(i);\n        counter.push(count);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp07whjvk_.rs:12:14\n   |\n12 |         if i.is_zero() {\n\
    \   |              ^^^^^^^ method not found in `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        match a {\n            0 => b.cmp(&b),\n  \
    \          _ => a.cmp(&b),\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcvq9djhx.rs:9:5\n   |\n8\
    \  |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    9  | /     arr.sort_by(|a, b| {\n10 | |         match a {\n11 | |            \
    \ 0 => b.cmp(&b),\n12 | |             _ => a.cmp(&b),\n13 | |         }\n14 |\
    \ |     })\n   | |______^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        result.extend(ones);\n    } else {\n        result.extend(result.into_iter().rev());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0505]: cannot move out of `result` because it is borrowed\n  -->\
    \ /tmp/tmptog14_pp.rs:21:23\n   |\n21 |         result.extend(result.into_iter().rev());\n\
    \   |         --------------^^^^^^-------------------\n   |         |        \
    \     |\n   |         |             move out of `result` occurs here\n   |   \
    \      borrow of `result` occurs here\n\nerror[E0382]: use of moved value: `result`\n\
    \   --> /tmp/tmptog14_pp.rs:23:5\n    |\n9   |     let mut result = vec![];\n\
    \    |         ---------- move occurs because `result` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n...\n21  |         result.extend(result.into_iter().rev());\n\
    \    |                              ----------- `result` moved due to this method\
    \ call\n22  |     }\n23  |     result\n    |     ^^^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `result`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0382, E0505.\nFor more information about an error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_unstable();\n    sorted_arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpegvtu86h.rs:16:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by(|a, b| {\n    \
    \    match a {\n            0 => b.cmp(&b).unwrap(),\n            _ => a.cmp(&b).unwrap(),\n\
    \        }\n    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmpdkox0xhl.rs:12:28\n   |\n12 |          \
    \   0 => b.cmp(&b).unwrap(),\n   |                            ^^^^^^ method not\
    \ found in `std::cmp::Ordering`\n\nerror[E0599]: no method named `unwrap` found\
    \ for enum `std::cmp::Ordering` in the current scope\n  --> /tmp/tmpdkox0xhl.rs:13:28\n\
    \   |\n13 |             _ => a.cmp(&b).unwrap(),\n   |                       \
    \     ^^^^^^ method not found in `std::cmp::Ordering`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    let mut\
    \ k = arr.len() - 1;\n    while i < k {\n        if arr[i] == 1 {\n          \
    \  i += 1;\n        } else {\n            if arr[j] == 1 {\n                j\
    \ += 1;\n            } else {\n                if arr[k] == 1 {\n            \
    \        k -= 1;\n                } else {\n                    res.push(arr[i]);\n\
    \                    i += 1;\n                    j += 1;\n                  \
    \  k -= 1;\n                }\n            }\n        }\n    }\n    res.push(arr[k]);\n\
    \    res\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 2, 2]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp5mvpxz7f.rs:37:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut ones = 0;\n    let mut decimal\
    \ = 0;\n    for ele in arr {\n        if ele == 1 {\n            ones += 1;\n\
    \        } else {\n            decimal += ele as isize;\n        }\n    }\n  \
    \  if ones > 0 {\n        result.push(-decimal as isize);\n        result.push(-ones\
    \ as isize);\n    } else {\n        result.push(-decimal as isize);\n    }\n \
    \   result.sort_unstable();\n    result\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3,\
    \ 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5,\
    \ -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-14, -1]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp4b7swscs.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    for i in ones {\n        result.push(i);\n\
    \    }\n    result.sort_by_key(|x| x.to_dec());\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_dec` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpsov09uj_.rs:21:30\n   |\n21 |     result.sort_by_key(|x|\
    \ x.to_dec());\n   |                              ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() == 0 {\n        result.sort();\n\
    \    } else {\n        let mut i = 0;\n        let mut j = 0;\n        let mut\
    \ k = 0;\n        while i < ones.len() && j < result.len() {\n            if ones[i]\
    \ == result[j] {\n                i += 1;\n                j += 1;\n         \
    \   } else {\n                let tmp = result[j];\n                result[j]\
    \ = result[k];\n                result[k] = tmp;\n                i += 1;\n  \
    \              j += 1;\n                k += 1;\n            }\n        }\n  \
    \      result.sort();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp51s8ms67.rs:44:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() == 0 {\n        result.sort();\n\
    \    } else {\n        let mut i = 0;\n        let mut j = 0;\n        while i\
    \ < ones.len() && j < result.len() {\n            if ones[i] == result[j] {\n\
    \                i += 1;\n                j += 1;\n            } else {\n    \
    \            let tmp = result[j];\n                result[j] = ones[i];\n    \
    \            ones[i] = tmp;\n                i += 1;\n                j += 1;\n\
    \            }\n        }\n        result.sort();\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpvoz691cw.rs:42:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        let mut ones = 0.0;\n        let mut zeros\
    \ = 0.0;\n        while a != 0 {\n            ones += 1;\n            a >>= 1;\n\
    \        }\n        while b != 0 {\n            zeros += 1;\n            b >>=\
    \ 1;\n        }\n        ones - zeros\n    })\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpypx99m0j.rs:12:17\n\
    \   |\n12 |         while a != 0 {\n   |                 ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: cannot add-assign `{integer}`\
    \ to `{float}`\n  --> /tmp/tmpypx99m0j.rs:13:18\n   |\n13 |             ones +=\
    \ 1;\n   |                  ^^ no implementation for `{float} += {integer}`\n\
    \   |\n   = help: the trait `AddAssign<{integer}>` is not implemented for `{float}`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror[E0368]: binary assignment operation `>>=` cannot be applied to type `&isize`\n\
    \  --> /tmp/tmpypx99m0j.rs:14:13\n   |\n14 |             a >>= 1;\n   |      \
    \       -^^^^^^\n   |             |\n   |             cannot use `>>=` on type\
    \ `&isize`\n   |\nhelp: `>>=` can be used on `isize`, you can dereference `a`\n\
    \   |\n14 |             *a >>= 1;\n   |             +\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpypx99m0j.rs:16:17\n   |\n16 |     \
    \    while b != 0 {\n   |                 ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: cannot add-assign "
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for &i in arr {\n\
    \        if i & 1 != 0 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(ones.pop().unwrap());\n        }\n    }\n    result.push(ones.pop().unwrap());\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnwtrdeff.rs:11:9\n   |\n\
    11 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        let mut j = i;\n        while j < arr.len() && arr[j] == 1 {\n      \
    \      j += 1\n        }\n        result.push(arr[i]);\n        result.push(arr[j]);\n\
    \        i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for x in arr {\n\
    \        if x == 0 {\n            ones.push(x);\n        } else {\n          \
    \  result.push(x);\n        }\n    }\n    let mut i = 0;\n    while i < ones.size()\
    \ {\n        let mut j = i;\n        while j < ones.size() && ones[j] == 0 {\n\
    \            j += 1\n        }\n        if j > i {\n            result.swap(i,\
    \ j);\n            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpepp4gohp.rs:19:20\n   |\n19 |     while i < ones.size()\
    \ {\n   |                    ^^^^ help: there is an associated function with a\
    \ similar name: `resize`\n\nerror[E0599]: no method named `size` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpepp4gohp.rs:21:24\n   |\n21\
    \ |         while j < ones.size() && ones[j] == 0 {\n   |                    \
    \    ^^^^ help: there is an associated function with a similar name: `resize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 != 0 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    result.sort_by_key(|x| ones[x as\
    \ usize]);\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0606]: casting `&isize` as `usize` is invalid\n  --> /tmp/tmp0rv55r7m.rs:18:33\n\
    \   |\n18 |     result.sort_by_key(|x| ones[x as usize]);\n   |              \
    \                   -^^^^^^^^^\n   |                                 |\n   | \
    \                                cannot cast `&isize` as `usize`\n   |       \
    \                          help: dereference the expression: `*x`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0606`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        ones = sort_array(ones);\n    }\n    for i in ones {\n        result.push(i);\n\
    \    }\n    if result.len() == 0 {\n        result\n    } else {\n        sort_array(result)\n\
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counter = HashMap::new();\n    for &i in arr {\n        if let Some(count)\
    \ = counter.entry(i).or_insert(0) {\n            *count += 1;\n        } else\
    \ {\n            counter.insert(i, 1);\n        }\n    }\n    arr.iter().cloned().sort_by_key(|&i|\
    \ {\n        if let Some(count) = counter.entry(i).or_insert(0) {\n          \
    \  *count as isize\n        } else {\n            counter.insert(i, 1);\n    \
    \        0\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3,\
    \ 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5,\
    \ -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpaugfet6y.rs:9:23\n  |\n9 |     let mut counter = HashMap::new();\n \
    \ |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaugfet6y.rs:10:9\n   |\n10 |     for &i in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `Cloned` in the current scope\n  --> /tmp/tmpaugfet6y.rs:17:25\n\
    \   |\n17 |     arr.iter().cloned().sort_by_key(|&i| {\n   |                 \
    \        ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut ones = vec![];\n    for i in arr {\n \
    \       if i & 1 == 1 {\n            ones.push(i);\n        } else {\n       \
    \     res.push(i);\n        }\n    }\n    if ones.len() > 0 {\n        res.sort_by(|a,\
    \ b| ones[a] - ones[b]);\n    } else {\n        res.sort_by(|a, b| a - b);\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpponvlf8b.rs:19:28\n\
    \   |\n19 |         res.sort_by(|a, b| ones[a] - ones[b]);\n   |             \
    \               ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpponvlf8b.rs:19:38\n\
    \   |\n19 |         res.sort_by(|a, b| ones[a] - ones[b]);\n   |             \
    \                         ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpponvlf8b.rs:21:28\n\
    \   |\n21 |         res.sort_by(|a, b| a - b);\n   |                         \
    \   ^^^^^ expected enum `std::cmp::Ordering`, found `isize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut ones = Vec::new();\n    let mut\
    \ zeros = Vec::new();\n    let mut max_ones = 0;\n    let mut max_zeros = 0;\n\
    \    let mut max_ones_idx = 0;\n    let mut max_zeros_idx = 0;\n    let mut idx\
    \ = 0;\n    let mut idx2 = 0;\n    let mut idx3 = 0;\n    let mut idx4 = 0;\n\
    \    let mut idx5 = 0;\n    let mut idx6 = 0;\n    let mut idx7 = 0;\n    let\
    \ mut idx8 = 0;\n    let mut idx9 = 0;\n    let mut idx10 = 0;\n    let mut idx11\
    \ = 0;\n    let mut idx12 = 0;\n    let mut idx13 = 0;\n    let mut idx14 = 0;\n\
    \    let mut idx15 = 0;\n    let mut idx16 = 0;\n    let mut idx17 = 0;\n    let\
    \ mut idx18 = 0;\n    let mut idx19 = 0;\n    let mut idx20 = 0;\n    let mut\
    \ idx21 = 0;\n    let mut idx22 = 0;\n    let mut idx23 = 0;\n    let mut idx24\
    \ = 0;\n    let mut idx25 = 0;\n    let mut idx26 = 0;\n    let mut idx27 = 0;\n\
    \    let mut idx28 = 0;\n    let mut idx29 = 0;\n    let mut idx30 = 0;\n    let\
    \ mut idx31 = 0;\n    let mut idx32 = 0;\n    let mut idx33 = 0;\n    let mut\
    \ idx34 = 0;\n    let mut idx35 = 0;\n    let mut idx36 = 0;\n    let mut idx37\
    \ = 0;\n    let mut idx38 = 0;\n    let mut idx39 = 0;\n    let mut idx40 = 0;\n\
    \    let mut idx41 = 0;\n    let mut idx42 = 0;\n    let mut idx43 = 0;\n    let\
    \ mut idx44 = 0;\n    let mut idx45 = 0;\n    let mut idx46 = 0;\n    let mut\
    \ idx47 = 0;\n    let mut idx48 = 0;\n    let mut idx49 = 0;\n    let mut idx50\
    \ = 0;\n    let mut idx51 = 0;\n    let mut idx52 = 0;\n    let mut idx53 = 0;\n\
    \    let mut idx54 = 0;\n    let mut idx55 = 0;\n    let mut idx56 = 0;\n    let\
    \ mut idx57 = 0;\n    let mut idx58 = 0;\n    let mut idx59 = 0;\n    let mut\
    \ idx60 = 0;\n    let mut idx61 = 0;\n    let mut idx62 = 0;\n    let mut idx63\
    \ = 0;\n    let mut idx64 = 0;\n    let mut idx65 = 0;\n    let \n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpo818jk6d.rs:82:1\n  \
    \ |\n82 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr.iter()\
    \ {\n        if i & 1 != 0 {\n            ones.push(i);\n        } else {\n  \
    \          result.push(i);\n        }\n    }\n    if ones.len() == 0 {\n     \
    \   result.sort();\n    } else {\n        let mut i = 0;\n        let mut j =\
    \ 0;\n        let mut k = result.len() - 1;\n        while i < k {\n         \
    \   while i < k && (result[i] & 1) == 0 {\n                i += 1;\n         \
    \   }\n            while j < k && (result[j] & 1) == 0 {\n                j +=\
    \ 1;\n            }\n            if i < j {\n                let tmp = result[i];\n\
    \                result[i] = result[j];\n                result[j] = tmp;\n  \
    \          }\n            i += 1;\n            j -= 1;\n        }\n        result.sort();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8r5c14sw.rs:41:5\n   |\n\
    8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \               ---------- expected `Vec<isize>` because of return type\n...\n\
    41 |     result\n   |     ^^^^^^ expected `isize`, found `&isize`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by_key(|x| {\n   \
    \     let mut count = 0;\n        for &i in &mut sorted_arr {\n            if\
    \ i & 1 == 1 {\n                count += 1;\n            }\n        }\n      \
    \  count as isize\n    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps2v3lb_j.rs:12:13\n   |\n\
    12 |         for &i in &mut sorted_arr {\n   |             ^^    ---------------\
    \ this expression has type `Option<&mut isize>`\n   |             |\n   |    \
    \         types differ in mutability\n   |             help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note: expected mutable reference\
    \ `&mut isize`\n                      found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by(|a, b| {\n    \
    \    if a > b {\n            1\n        } else {\n            -1\n        }\n\
    \    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmr2oggco.rs:12:13\n   |\n\
    12 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmr2oggco.rs:14:13\n\
    \   |\n14 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for x in arr {\n\
    \        if x % 2 == 0 {\n            ones.push(x);\n        } else {\n      \
    \      result.push(x - ones[0]);\n            ones = vec![];\n        }\n    }\n\
    \    if ones.len() > 0 {\n        result.push(x - ones[0]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `x` in this scope\n  --> /tmp/tmpkftdpayo.rs:20:21\n\
    \   |\n20 |         result.push(x - ones[0]);\n   |                     ^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut counter = vec![];\n    for i in arr\
    \ {\n        if i.is_zero() {\n            continue;\n        }\n        let mut\
    \ counter = counter.clone();\n        counter.push(i);\n        let mut max_counter\
    \ = counter.iter().max().unwrap();\n        let mut max_counter_index = counter.iter().position(|x|\
    \ x == max_counter).unwrap();\n        let mut max_counter_value = counter[max_counter_index];\n\
    \        let mut max_counter_index = max_counter_index.wrapping_add(1);\n    \
    \    for i in 0..max_counter_index {\n            if counter[i] == max_counter_value\
    \ {\n                counter[i] = 0;\n            } else {\n                break;\n\
    \            }\n        }\n        let mut max_counter_value = max_counter_value.wrapping_add(1);\n\
    \        for i in 0..max_counter_index {\n            if counter[i] == max_counter_value\
    \ {\n                counter[i] = 0;\n            } else {\n                break;\n\
    \            }\n        }\n        result.push(max_counter_value);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpqxep8chn.rs:12:14\n   |\n12 |         if i.is_zero() {\n\
    \   |              ^^^^^^^ method not found in `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.to_vec();\n    sorted_arr.sort_by_key(|x| {\n  \
    \      if x == 1 {\n            0\n        } else {\n            1\n        }\n\
    \    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpnr_yjlg9.rs:11:14\n\
    \   |\n11 |         if x == 1 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i as isize);\n        }\n    }\n    if ones.len() > result.len()\
    \ {\n        result.extend_from_slice(&ones[..]);\n    } else {\n        result.extend_from_slice(&ones[..result.len()]);\n\
    \    }\n    if result.len() == 0 {\n        result.push(0);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 1, 5, 3]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpb1pa8n79.rs:31:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() == 0 {\n        result.sort();\n\
    \    } else {\n        let mut i = 0;\n        let mut j = 0;\n        let mut\
    \ k = ones[0];\n        while i < result.len() && j < ones.size() {\n        \
    \    if result[i] < k {\n                result.swap(i, j);\n                i\
    \ += 1;\n            } else {\n                k += ones[j];\n               \
    \ j += 1;\n            }\n        }\n        result.swap(i, result.len());\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmplexq_7fu.rs:24:44\n   |\n24 |         while i <\
    \ result.len() && j < ones.size() {\n   |                                    \
    \        ^^^^ help: there is an associated function with a similar name: `resize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = arr.clone();\n    let mut cnt = 0;\n    for i in arr.iter()\
    \ {\n        if cnt > 0 {\n            cnt += 1;\n            res[i] = cnt;\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp9sp1qmeo.rs:14:13\n\
    \   |\n14 |             res[i] = cnt;\n   |             ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<isize>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut num_ones = 0;\n    for x in arr {\n\
    \        if x % 2 == 0 {\n            result.push(x);\n            num_ones +=\
    \ 1;\n        } else {\n            if num_ones == 0 {\n                result.push(x);\n\
    \            } else {\n                if num_ones < x {\n                   \
    \ result.push(x);\n                } else {\n                    result.push(num_ones);\n\
    \                }\n            }\n            num_ones = 0;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 2, 3, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpw8i2h9bs.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for x in arr {\n\
    \        if x % 2 == 0 {\n            ones.push(x);\n        } else {\n      \
    \      result.push(x);\n        }\n    }\n    let mut i = 0;\n    while i < ones.len()\
    \ {\n        let mut j = i;\n        while j < ones.len() && ones[j] == ones[i]\
    \ {\n            j += 1\n        }\n        if j == i {\n            break;\n\
    \        }\n        result.swap(i, j);\n        i += 1;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, 1]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmphagdlueq.rs:35:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        result.extend(ones);\n    } else {\n        result.extend(result.into_iter().rev().take(ones.len()).collect());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmprerb0dxg.rs:21:16\n\
    \   |\n21 |         result.extend(result.into_iter().rev().take(ones.len()).collect());\n\
    \   |                ^^^^^^ cannot infer type for type parameter `A` declared\
    \ on the trait `Extend`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < arr.len() {\n        if arr[i] == 1 {\n            result.push(j);\n   \
    \         i += 1;\n        } else {\n            i += 1;\n        }\n    }\n \
    \   while j < arr.len() {\n        if arr[j] == 1 {\n            result.push(j);\n\
    \            j += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5yye3xg9.rs:28:5\n   |\n\
    8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \               ---------- expected `Vec<isize>` because of return type\n...\n\
    28 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a > b {\n            1\n        } else {\n\
    \            -1\n        }\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgp80n63q.rs:11:13\n   |\n\
    11 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgp80n63q.rs:13:13\n\
    \   |\n13 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgp80n63q.rs:9:5\n\
    \   |\n8  |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n9  | /     arr.sort_by(|a, b| {\n10 | |         if a > b {\n11 | |   \
    \          1\n12 | |         } else {\n13 | |             -1\n14 | |         }\n\
    15 | |     })\n   | |______^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr.iter()\
    \ {\n        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n  \
    \          result.push(ones.pop().unwrap());\n            result.push(i);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpupffd7d8.rs:19:5\n   |\n\
    8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \               ---------- expected `Vec<isize>` because of return type\n...\n\
    19 |     result\n   |     ^^^^^^ expected `isize`, found `&isize`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_unstable();\n    sorted_arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpd4qben3g.rs:16:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a > b {\n            1\n        } else {\n\
    \            -1\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx5zuhca0.rs:11:13\n   |\n\
    11 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx5zuhca0.rs:13:13\n\
    \   |\n13 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut ones = vec![];\n    for i in arr {\n \
    \       if i & 1 != 0 {\n            ones.push(i);\n        } else {\n       \
    \     res.push(i);\n        }\n    }\n    if ones.len() > 0 {\n        res.sort_by(|a,\
    \ b| {\n            ones[a].cmp(&ones[b])\n        });\n    }\n    if res.len()\
    \ > 0 {\n        res.iter().cloned().collect()\n    } else {\n        vec![]\n\
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp675r7xyu.rs:20:13\n\
    \   |\n20 |             ones[a].cmp(&ones[b])\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp675r7xyu.rs:20:26\n\
    \   |\n20 |             ones[a].cmp(&ones[b])\n   |                          ^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by_key(|x| {\n   \
    \     let mut num_ones = 0;\n        for &i in &x {\n            if i == 1 {\n\
    \                num_ones += 1;\n            }\n        }\n        num_ones\n\
    \    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&&isize` is not an iterator\n  --> /tmp/tmp936so9yi.rs:12:19\n\
    \   |\n12 |         for &i in &x {\n   |                   ^^ `&&isize` is not\
    \ an iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&&isize`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut ones = Vec::new();\n    let mut\
    \ zeros = Vec::new();\n    let mut max_ones = 0;\n    let mut max_zeros = 0;\n\
    \    let mut max_value = 0;\n    for x in arr {\n        if x == 1 {\n       \
    \     ones.push(x);\n            max_ones = std::cmp::max(max_ones, x);\n    \
    \    } else {\n            zeros.push(x);\n            max_zeros = std::cmp::max(max_zeros,\
    \ x);\n        }\n    }\n    for i in 0..max_ones {\n        result.push(ones[i]);\n\
    \    }\n    for i in 0..max_zeros {\n        result.push(zeros[i]);\n    }\n \
    \   for i in 0..max_ones {\n        result.push(ones[i]);\n    }\n    for i in\
    \ 0..max_zeros {\n        result.push(zeros[i]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpyorl6_x4.rs:25:21\n\
    \   |\n25 |         result.push(ones[i]);\n   |                     ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpyorl6_x4.rs:28:21\n   |\n28 |  \
    \       result.push(zeros[i]);\n   |                     ^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpyorl6_x4.rs:31:21\n   |\n31 |         result.push(ones[i]);\n\
    \   |                     ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpyorl6_x4.rs:34:21\n   |\n34 |         result.push(zeros[i]);\n\
    \   |                     ^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr.iter()\
    \ {\n        if i & 1 != 0 {\n            ones.push(i);\n        } else {\n  \
    \          result.push(ones.pop().unwrap());\n        }\n    }\n    result.push(ones.pop().unwrap());\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppr17eva8.rs:19:5\n   |\n\
    8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \               ---------- expected `Vec<isize>` because of return type\n...\n\
    19 |     result\n   |     ^^^^^^ expected `isize`, found `&isize`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        result.extend(ones);\n    } else {\n        result.extend(result.into_iter().rev().take(ones.len()).cloned());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::iter::Take<Rev<std::vec::IntoIter<isize>>>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmp5sk33tzj.rs:21:65\n     |\n21   |\
    \         result.extend(result.into_iter().rev().take(ones.len()).cloned());\n\
    \     |                                                                 ^^^^^^\
    \ expected reference, found `isize`\n     |\n     = note: expected reference `&_`\n\
    \                     found type `isize`\nnote: required by a bound in `cloned`\n\
    \nerror[E0271]: type mismatch resolving `<std::iter::Take<Rev<std::vec::IntoIter<isize>>>\
    \ as Iterator>::Item == &_`\n   --> /tmp/tmp5sk33tzj.rs:21:23\n    |\n21  |  \
    \       result.extend(result.into_iter().rev().take(ones.len()).cloned());\n \
    \   |                ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected reference, found `isize`\n    |                |\n    |           \
    \     required by a bound introduced by this call\n    |\n    = note: expected\
    \ reference `&_`\n                    found type `isize`\n    = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<std::iter::Take<Rev<std::vec::IntoIter<isize>>>>`\n\
    note: required by a bound in `extend`\n\nerror[E0271]: type mismatch resolving\
    \ `<std::iter::Take<Rev<std::vec::IntoIter<isize>>> as Iterator>::Item == &_`\n\
    \   --> /tmp/tmp5sk33tzj.rs:21:23\n    |\n21  |         result.extend(result.into_iter().rev().take(ones.len()).cloned());\n\
    \    |                ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected reference, found `isize`\n    |                |\n    |           \
    \     required by a bound introduced by this call\n    |\n    = note: expected\
    \ reference `&_`\n                    found type `isize`\n    = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<std::iter::Take<Rev<std::vec::IntoIter<isize>>>>`\n\
    \    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Cloned<std::iter::Take<Rev<std::vec::IntoIter<isize>>>>`\nnote: required\
    \ by a bound in `extend`\n\nerror: aborting due to 3 previous errors\n\nFor more "
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by_key(|x| {\n   \
    \     let mut cnt = 0;\n        for &i in &mut sorted_arr {\n            if i\
    \ & 1 != 0 {\n                cnt += 1;\n            }\n        }\n        cnt\n\
    \    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkkhbwbq5.rs:12:13\n   |\n\
    12 |         for &i in &mut sorted_arr {\n   |             ^^    ---------------\
    \ this expression has type `Option<&mut isize>`\n   |             |\n   |    \
    \         types differ in mutability\n   |             help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note: expected mutable reference\
    \ `&mut isize`\n                      found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut counter = vec![];\n    for i in arr\
    \ {\n        if i.is_zero() {\n            continue;\n        }\n        let mut\
    \ counter = counter.clone();\n        let mut count = 0;\n        while let Some(k)\
    \ = counter.pop() {\n            if k == 0 {\n                count += 1;\n  \
    \          } else {\n                break;\n            }\n        }\n      \
    \  result.push(i);\n        counter.push(count);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpsc9xzib1.rs:12:14\n   |\n12 |         if i.is_zero() {\n\
    \   |              ^^^^^^^ method not found in `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        a.checked_mul(2).is_zero() || b.checked_mul(2).is_zero()\n\
    \            ? a.checked_mul(2).is_zero()\n                ? b.checked_mul(2).is_zero()\n\
    \                    ? a.checked_mul(2).is_zero()\n                        ? a.checked_mul(2).is_zero()\n\
    \                            ? a.checked_mul(2).is_zero()\n                  \
    \              ? a.checked_mul(2).is_zero()\n                                \
    \    ? a.checked_mul(2).is_zero()\n                                        ? a.checked_mul(2).is_zero()\n\
    \                                            ? a.checked_mul(2).is_zero()\n  \
    \                                              ? a.checked_mul(2).is_zero()\n\
    \                                                    ? a.checked_mul(2).is_zero()\n\
    \                                                        ? a.checked_mul(2).is_zero()\n\
    \                                                            : a.checked_mul(2).is_zero()\n\
    \                                                : b.checked_mul(2).is_zero()\n\
    \                            : b.checked_mul(2).is_zero()\n                  \
    \  : a.checked_mul(2).is_zero()\n                : b.checked_mul(2).is_zero()\n\
    \            : a.checked_mul(2).is_zero()\n    });\n    arr\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `a`\n\
    \  --> /tmp/tmpl78_9g0r.rs:11:15\n   |\n11 |             ? a.checked_mul(2).is_zero()\n\
    \   |               ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror:\
    \ aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 != 0 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(ones);\n            ones = vec![];\n        }\n    }\n    result.push(ones);\n\
    \    result.sort_by_key(|x| x.iter().map(|x| x.clone()).collect::<Vec<_>>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9r5vtikw.rs:21:5\n   |\n\
    8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \               ---------- expected `Vec<isize>` because of return type\n...\n\
    21 |     result\n   |     ^^^^^^ expected `isize`, found struct `Vec`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<Vec<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut ones = Vec::new();\n    let mut\
    \ zeros = Vec::new();\n    let mut max_ones = 0;\n    let mut max_zeros = 0;\n\
    \    let mut max_value = 0;\n    let mut max_index = 0;\n    let mut index = 0;\n\
    \    for &i in arr {\n        if i == 1 {\n            ones.push(i);\n       \
    \ } else {\n            zeros.push(i);\n        }\n        if i == 0 {\n     \
    \       max_ones = i;\n        } else {\n            max_zeros = i;\n        }\n\
    \        if i > max_value {\n            max_value = i;\n        }\n        if\
    \ i > max_index {\n            max_index = i;\n        }\n    }\n    let mut i\
    \ = 0;\n    while i < ones.size() {\n        if ones[i] > max_ones {\n       \
    \     result.push(max_index);\n            i += 1;\n        } else {\n       \
    \     result.push(ones[i]);\n            i += 1;\n        }\n    }\n    while\
    \ i < zeros.size() {\n        if zeros[i] > max_zeros {\n            result.push(max_index);\n\
    \            i += 1;\n        } else {\n            result.push(zeros[i]);\n \
    \           i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8ugiftak.rs:17:9\n   |\n\
    17 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0599]: no method named\
    \ `size` found for struct `Vec<{integer}>` in the current scope\n  --> /tmp/tmp8ugiftak.rs:36:20\n\
    \   |\n36 |     while i < ones.size() {\n   |                    ^^^^ help: there\
    \ is an associated function with a similar name: `resize`\n\nerror[E0599]: no\
    \ method named `size` found for struct `Vec<{integer}>` in the current scope\n\
    \  --> /tmp/tmp8ugiftak.rs:45:21\n   |\n45 |     while i < zeros.size() {\n  \
    \ |                     ^^^^ help: there is an associated function with a similar\
    \ name: `resize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut ones = 0;\n    let mut decimal = 0;\n\
    \    for &i in arr {\n        if i & 1 != 0 {\n            ones += 1;\n      \
    \  } else {\n            decimal += i;\n        }\n    }\n    if ones == 0 {\n\
    \        for &i in arr {\n            res.push(i);\n        }\n    } else {\n\
    \        for &i in arr {\n            if i & 1 != 0 {\n                res.push(i);\n\
    \            } else {\n                res.push(decimal + i);\n            }\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc0pwnsdd.rs:12:9\n   |\n\
    12 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc0pwnsdd.rs:20:13\n   |\n20 |         for &i in arr {\n   |   \
    \          ^^    --- this expression has type `Option<isize>`\n   |          \
    \   |\n   |             expected `isize`, found reference\n   |             help:\
    \ you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc0pwnsdd.rs:24:13\n   |\n24 |         for &i in arr {\n   |   \
    \          ^^    --- this expression has type `Option<isize>`\n   |          \
    \   |\n   |             expected `isize`, found reference\n   |             help:\
    \ you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    let mut decimal\
    \ = vec![];\n    for i in arr {\n        if i & 1 != 0 {\n            ones.push(i);\n\
    \        } else {\n            decimal.push(i);\n        }\n    }\n    for i in\
    \ ones {\n        result.push(i);\n    }\n    for i in decimal {\n        result.push(i);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 3, 2, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp62fbk6lo.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut ones = Vec::new();\n    let mut\
    \ zeros = Vec::new();\n    for &i in arr {\n        if i & 1 == 1 {\n        \
    \    ones.push(i);\n        } else {\n            zeros.push(i);\n        }\n\
    \    }\n    ones = sort_array(ones);\n    zeros = sort_array(zeros);\n    for\
    \ i in ones {\n        result.push(i);\n    }\n    for i in zeros {\n        result.push(-i);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbq4aqfu7.rs:12:9\n   |\n\
    12 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a > b {\n            1\n        } else {\n\
    \            -1\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp17wjxwil.rs:11:13\n   |\n\
    11 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp17wjxwil.rs:13:13\n\
    \   |\n13 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut ones = Vec::new();\n    for &i\
    \ in arr {\n        if i == 1 {\n            ones.push(i);\n        } else {\n\
    \            result.push(i);\n        }\n    }\n    let mut i = 0;\n    while\
    \ i < ones.len() {\n        let mut j = i;\n        while j < ones.len() && ones[j]\
    \ == 0 {\n            j += 1\n        }\n        let mut k = j;\n        while\
    \ k < ones.len() && ones[k] == 1 {\n            k += 1\n        }\n        if\
    \ k > i {\n            result.swap(i, k);\n            i += 1;\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp12wg8_6q.rs:11:9\n   |\n\
    11 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.to_vec();\n    sorted_arr.sort_by_key(|x| {\n  \
    \      if x == 1 {\n            0\n        } else {\n            1\n        }\n\
    \    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpa0skb84d.rs:11:14\n\
    \   |\n11 |         if x == 1 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for x in arr {\n\
    \        if x % 2 == 1 {\n            ones.push(x);\n        } else {\n      \
    \      result.push(x);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        result.extend(ones);\n    } else {\n        result.extend(result.iter().cloned().rev());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `result` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmp9csa336d.rs:21:9\n   |\n21 |         result.extend(result.iter().cloned().rev());\n\
    \   |         ^^^^^^^------^-------------^^^^^^^^^^^^^^^^\n   |         |    \
    \  |      |\n   |         |      |      immutable borrow occurs here\n   |   \
    \      |      immutable borrow later used by call\n   |         mutable borrow\
    \ occurs here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut bin = String::new();\n        bin.push_str(&format!(\"\
    {:b}\", x));\n        bin.len()\n    });\n    arr.sort_by_key(|x| {\n        let\
    \ mut dec = String::new();\n        dec.push_str(&format!(\"{:d}\", x));\n   \
    \     dec.len()\n    });\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: unknown format trait `d`\n  --> /tmp/tmp3es3u1nl.rs:16:34\n   |\n\
    16 |         dec.push_str(&format!(\"{:d}\", x));\n   |                      \
    \            ^\n   |\n   = note: the only appropriate formatting traits are:\n\
    \           - ``, which uses the `Display` trait\n           - `?`, which uses\
    \ the `Debug` trait\n           - `e`, which uses the `LowerExp` trait\n     \
    \      - `E`, which uses the `UpperExp` trait\n           - `o`, which uses the\
    \ `Octal` trait\n           - `p`, which uses the `Pointer` trait\n          \
    \ - `b`, which uses the `Binary` trait\n           - `x`, which uses the `LowerHex`\
    \ trait\n           - `X`, which uses the `UpperHex` trait\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut count = 0;\n        let mut bits =\
    \ x.to_bin();\n        while !bits.is_empty() {\n            count += bits.len()\
    \ - 1;\n            bits = bits.split_off(1);\n        }\n        count / 2\n\
    \    });\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_bin` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpst58nv13.rs:11:26\n   |\n11 |         let mut\
    \ bits = x.to_bin();\n   |                          ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by_key(|x| {\n   \
    \     let mut num_ones = 0;\n        for &i in &x {\n            if i == 1 {\n\
    \                num_ones += 1;\n            }\n        }\n        num_ones\n\
    \    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&&isize` is not an iterator\n  --> /tmp/tmpfyfogubf.rs:12:19\n\
    \   |\n12 |         for &i in &x {\n   |                   ^^ `&&isize` is not\
    \ an iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&&isize`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        let mut a = a.to_bin();\n        let mut b\
    \ = b.to_bin();\n        if a > b {\n            1\n        } else {\n       \
    \     -1\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_bin` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpd2egaabc.rs:10:23\n   |\n10 |         let mut\
    \ a = a.to_bin();\n   |                       ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror[E0599]: no method named `to_bin`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmpd2egaabc.rs:11:23\n\
    \   |\n11 |         let mut b = b.to_bin();\n   |                       ^^^^^^\
    \ help: there is an associated function with a similar name: `to_be`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd2egaabc.rs:13:13\n   |\n13 |             1\n\
    \   |             ^ expected enum `std::cmp::Ordering`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd2egaabc.rs:15:13\n   |\n15 |             -1\n\
    \   |             ^^ expected enum `std::cmp::Ordering`, found integer\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_unstable();\n    sorted_arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpzn5c3qyo.rs:16:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut ones = 0;\n    let mut decimal\
    \ = 0;\n    for ele in arr {\n        if ele == 1 {\n            ones += 1;\n\
    \        } else {\n            decimal += ele as isize;\n        }\n    }\n  \
    \  if ones > 0 {\n        result.push(decimal);\n    }\n    for ele in arr {\n\
    \        if ele == 1 {\n            ones += 1;\n        } else {\n           \
    \ decimal -= ele as isize;\n        }\n        if ones == 0 {\n            result.push(decimal);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpyrek8rjx.rs:22:16\n\
    \    |\n8   | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    |          \
    \     --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n12  |     for ele in arr {\n    |                ---\
    \ `arr` moved due to this implicit call to `.into_iter()`\n...\n22  |     for\
    \ ele in arr {\n    |                ^^^ value used here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |     for ele in &arr {\n    |             \
    \   +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        let mut a = a.to_bin();\n        let mut b\
    \ = b.to_bin();\n        if a < b {\n            1\n        } else {\n       \
    \     -1\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_bin` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmp0m5lrah9.rs:10:23\n   |\n10 |         let mut\
    \ a = a.to_bin();\n   |                       ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror[E0599]: no method named `to_bin`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmp0m5lrah9.rs:11:23\n\
    \   |\n11 |         let mut b = b.to_bin();\n   |                       ^^^^^^\
    \ help: there is an associated function with a similar name: `to_be`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0m5lrah9.rs:13:13\n   |\n13 |             1\n\
    \   |             ^ expected enum `std::cmp::Ordering`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0m5lrah9.rs:15:13\n   |\n15 |             -1\n\
    \   |             ^^ expected enum `std::cmp::Ordering`, found integer\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for i in arr.iter() {\n        let mut count\
    \ = 0;\n        let mut j = 0;\n        while j < i {\n            if arr[j] ==\
    \ 1 {\n                count += 1;\n                j += 1;\n            } else\
    \ {\n                break;\n            }\n        }\n        result.push((count\
    \ as isize).cmp(&i as isize));\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp5o3b1czv.rs:13:17\n\
    \   |\n13 |         while j < i {\n   |                 ^ no implementation for\
    \ `isize < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp5o3b1czv.rs:14:16\n   |\n14 |         \
    \    if arr[j] == 1 {\n   |                ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5o3b1czv.rs:21:42\n\
    \   |\n21 |         result.push((count as isize).cmp(&i as isize));\n   |    \
    \                                      ^^^^^^^^^^^\n   |                     \
    \                     |\n   |                                          expected\
    \ `&isize`, found `isize`\n   |                                          help:\
    \ consider borrowing here: `&(&i as isize)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5o3b1czv.rs:23:5\n   |\n8  | fn sort_array(arr: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                   ---------- expected `Vec<isize>`\
    \ because of return type\n...\n23 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `std::cmp::Ordering`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<std::cmp::Ordering>`\n\nerror[E0606]: casting\
    \ `&&isize` as `isize` is invalid\n  --> /tmp/tmp5o3b1czv.rs:21:42\n   |\n21 |\
    \         result.push((count as isize).cmp(&i as isize));\n   |              \
    \                            ^^^^^^^^^^^\n   |\n   = help: cast through a raw\
    \ pointer first\n\nerror: abortin"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        let mut j = i;\n        while j < arr.len() {\n            if arr[j]\
    \ == 1 {\n                result.push(j);\n                j += 1;\n         \
    \   } else {\n                break;\n            }\n        }\n        if j ==\
    \ arr.len() {\n            result.push(i);\n            i += 1;\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptha9til2.rs:26:5\n   |\n\
    8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \               ---------- expected `Vec<isize>` because of return type\n...\n\
    26 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for i in arr.iter() {\n        let mut count\
    \ = 0;\n        for j in 0..i {\n            if i & (1 << j) != 0 {\n        \
    \        count += 1;\n            }\n        }\n        result.push((count as\
    \ isize).cmp(&i));\n    }\n    result.sort_unstable();\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4cldt082.rs:12:21\n   |\n\
    12 |         for j in 0..i {\n   |                     ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |        \
    \ for j in 0..*i {\n   |                     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4cldt082.rs:20:5\n   |\n8  | fn sort_array(arr: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                   ---------- expected `Vec<isize>`\
    \ because of return type\n...\n20 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `std::cmp::Ordering`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<std::cmp::Ordering>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut bin = x.to_bin();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmplucrysev.rs:106:3\n\
    \    |\n8   | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    |          \
    \                                    - unclosed delimiter\n9   |     arr.sort_by_key(|x|\
    \ {\n    |                    - unclosed delimiter\n...\n106 | }\n    |   ^\n\n\
    error: expected one of `)`, `,`, `.`, `?`, or an operator, found keyword `fn`\n\
    \  --> /tmp/tmplucrysev.rs:96:1\n   |\n94 | }\n   |  - expected one of `)`, `,`,\
    \ `.`, `?`, or an operator\n95 | \n96 | fn main() {\n   | ^^ unexpected token\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_unstable_by(|a, b|\
    \ {\n        match a {\n            0 => Some(b),\n            _ => None,\n  \
    \      }\n    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw44kv4u4.rs:12:18\n   |\n\
    12 |             0 => Some(b),\n   |                  ^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found enum `Option`\n   |\n   = note: expected enum `std::cmp::Ordering`\n \
    \             found enum `Option<&isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut res = 0;\n        for b in x.to_binary()\
    \ {\n            res += (b as usize).checked_add((res as usize).wrapping_add(1));\n\
    \        }\n        res\n    });\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_binary` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmplp_nfbry.rs:11:20\n   |\n11 |         for\
    \ b in x.to_binary() {\n   |                    ^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror[E0277]: cannot add-assign `Option<usize>`\
    \ to `{integer}`\n  --> /tmp/tmplp_nfbry.rs:12:17\n   |\n12 |             res\
    \ += (b as usize).checked_add((res as usize).wrapping_add(1));\n   |         \
    \        ^^ no implementation for `{integer} += Option<usize>`\n   |\n   = help:\
    \ the trait `AddAssign<Option<usize>>` is not implemented for `{integer}`\n  \
    \ = help: the following other types implement trait `AddAssign<Rhs>`:\n      \
    \       <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n          \
    \   <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16 as\
    \ AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 != 0 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        result.extend(ones);\n    } else {\n        result.extend(result.into_iter().rev());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0505]: cannot move out of `result` because it is borrowed\n  -->\
    \ /tmp/tmp3m2k_oga.rs:21:23\n   |\n21 |         result.extend(result.into_iter().rev());\n\
    \   |         --------------^^^^^^-------------------\n   |         |        \
    \     |\n   |         |             move out of `result` occurs here\n   |   \
    \      borrow of `result` occurs here\n\nerror[E0382]: use of moved value: `result`\n\
    \   --> /tmp/tmp3m2k_oga.rs:23:5\n    |\n9   |     let mut result = vec![];\n\
    \    |         ---------- move occurs because `result` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n...\n21  |         result.extend(result.into_iter().rev());\n\
    \    |                              ----------- `result` moved due to this method\
    \ call\n22  |     }\n23  |     result\n    |     ^^^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `result`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0382, E0505.\nFor more information about an error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_unstable_by(|a, b|\
    \ {\n        if a > b {\n            1\n        } else {\n            -1\n   \
    \     }\n    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm5yp2qr7.rs:12:13\n   |\n\
    12 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm5yp2qr7.rs:14:13\n\
    \   |\n14 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for i in arr.iter() {\n        if i & 1 ==\
    \ 1 {\n            result.push(i);\n        }\n    }\n    result.sort_unstable_by_key(|x|\
    \ x.to_dec());\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_dec` found for reference `&&isize` in\
    \ the current scope\n  --> /tmp/tmphmxur9w8.rs:15:39\n   |\n15 |     result.sort_unstable_by_key(|x|\
    \ x.to_dec());\n   |                                       ^^^^^^ help: there\
    \ is an associated function with a similar name: `to_be`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphmxur9w8.rs:16:5\n   |\n8  | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                   ---------- expected\
    \ `Vec<isize>` because of return type\n...\n16 |     result\n   |     ^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n   \
    \           found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    let mut decimal\
    \ = vec![];\n    for i in arr {\n        if i & 1 == 1 {\n            ones.push(i);\n\
    \        } else {\n            decimal.push(i);\n        }\n    }\n    for i in\
    \ ones {\n        result.push(i);\n    }\n    for i in decimal {\n        result.push(i);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 3, 2, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpn9jv23ex.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a > b {\n            1\n        } else {\n\
    \            -1\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpctq89as6.rs:11:13\n   |\n\
    11 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpctq89as6.rs:13:13\n\
    \   |\n13 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr.iter()\
    \ {\n        if i & 1 != 0 {\n            ones.push(i);\n        } else {\n  \
    \          result.push(ones);\n            ones = vec![];\n        }\n    }\n\
    \    result.push(ones);\n    result.sort_by_key(|x| x.iter().count());\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpayk5oym2.rs:21:5\n   |\n\
    8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \               ---------- expected `Vec<isize>` because of return type\n...\n\
    21 |     result\n   |     ^^^^^^ expected `isize`, found struct `Vec`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<Vec<&isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_unstable_by(|a, b|\
    \ {\n        if a > b {\n            1\n        } else {\n            -1\n   \
    \     }\n    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl5v8odu7.rs:12:13\n   |\n\
    12 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl5v8odu7.rs:14:13\n\
    \   |\n14 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a > b {\n            1\n        } else {\n\
    \            -1\n        }\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt73as8k4.rs:11:13\n   |\n\
    11 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt73as8k4.rs:13:13\n\
    \   |\n13 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt73as8k4.rs:9:5\n\
    \   |\n8  |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n9  | /     arr.sort_by(|a, b| {\n10 | |         if a > b {\n11 | |   \
    \          1\n12 | |         } else {\n13 | |             -1\n14 | |         }\n\
    15 | |     })\n   | |______^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut counter = vec![];\n    for i in arr\
    \ {\n        if i.is_zero() {\n            continue;\n        }\n        if let\
    \ Some(mut counter) = counter.iter_mut() {\n            counter.push(i);\n   \
    \     } else {\n            counter = vec![i];\n            result.push(i);\n\
    \        }\n    }\n    if let Some(mut counter) = counter.iter_mut() {\n     \
    \   counter.sort();\n        result.extend(counter);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp0vw26yz7.rs:12:14\n   |\n12 |         if i.is_zero() {\n\
    \   |              ^^^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0vw26yz7.rs:15:16\n   |\n15 |         if let Some(mut counter)\
    \ = counter.iter_mut() {\n   |                ^^^^^^^^^^^^^^^^^   ------------------\
    \ this expression has type `std::slice::IterMut<'_, _>`\n   |                |\n\
    \   |                expected struct `std::slice::IterMut`, found enum `Option`\n\
    \   |\n   = note: expected struct `std::slice::IterMut<'_, _>`\n             \
    \   found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0vw26yz7.rs:22:12\n\
    \   |\n22 |     if let Some(mut counter) = counter.iter_mut() {\n   |        \
    \    ^^^^^^^^^^^^^^^^^   ------------------ this expression has type `std::slice::IterMut<'_,\
    \ isize>`\n   |            |\n   |            expected struct `std::slice::IterMut`,\
    \ found enum `Option`\n   |\n   = note: expected struct `std::slice::IterMut<'_,\
    \ isize>`\n                found enum `Option<_>`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for i in arr.iter() {\n        let mut count\
    \ = 0;\n        for j in 0..i.isize {\n            if arr[j] == i {\n        \
    \        count += 1;\n            }\n        }\n        result.push((count as\
    \ isize).cmp(&i));\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `isize` on type `&isize`\n  --> /tmp/tmpiay6uzik.rs:12:23\n\
    \   |\n12 |         for j in 0..i.isize {\n   |                       ^^^^^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpiay6uzik.rs:13:26\n   |\n13 |  \
    \           if arr[j] == i {\n   |                          ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |  \
    \           if arr[j] == *i {\n   |                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiay6uzik.rs:19:5\n   |\n8  | fn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                   ----------\
    \ expected `Vec<isize>` because of return type\n...\n19 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found enum `std::cmp::Ordering`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<std::cmp::Ordering>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut counter = vec![];\n    for i in arr\
    \ {\n        if i.is_zero() {\n            continue;\n        }\n        if let\
    \ Some(mut v) = counter.iter().position(|&x| x == 1) {\n            counter[v.unwrap()]\
    \ += 1;\n        } else {\n            counter.push(i);\n        }\n    }\n  \
    \  for i in counter.iter() {\n        result.push(i);\n    }\n    result.sort_unstable_by(|a,\
    \ b| a.cmp(b));\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpuweksvby.rs:12:14\n   |\n12 |         if i.is_zero() {\n\
    \   |              ^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmpuweksvby.rs:16:23\n\
    \   |\n16 |             counter[v.unwrap()] += 1;\n   |                      \
    \ ^^^^^^ method not found in `usize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpuweksvby.rs:25:5\n   |\n8  | fn sort_array(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                                   ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut ones = vec![];\n    for i in arr {\n \
    \       if i & 1 == 1 {\n            ones.push(i);\n        } else {\n       \
    \     res.push(i);\n        }\n    }\n    if ones.len() > 0 {\n        res.sort_unstable_by(|a,\
    \ b| ones[a] - ones[b]);\n    } else {\n        res.sort_unstable();\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpswnyqv7t.rs:19:37\n\
    \   |\n19 |         res.sort_unstable_by(|a, b| ones[a] - ones[b]);\n   |    \
    \                                 ^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmpswnyqv7t.rs:19:47\n   |\n19 |         res.sort_unstable_by(|a,\
    \ b| ones[a] - ones[b]);\n   |                                               ^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 != 0 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(ones[ones.len() - 1]);\n            ones.pop();\n        }\n\
    \    }\n    result.push(ones[ones.len() - 1]);\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, 1]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmprva2rzws.rs:25:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    let mut i = 0;\n    while i < ones.len()\
    \ {\n        let mut j = i;\n        while j < ones.len() && ones[j] == 0 {\n\
    \            j += 1\n        }\n        result.push(ones[j]);\n        i = j;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    let mut decimal\
    \ = vec![];\n    for i in arr {\n        if i & 1 == 1 {\n            ones.push(i);\n\
    \        } else {\n            decimal.push(i);\n        }\n    }\n    for i in\
    \ ones {\n        result.push(i);\n    }\n    for i in decimal {\n        result.push(i);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 3, 2, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp5_t7adz_.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for i in arr.iter() {\n        if *i as usize\
    \ == 1 {\n            result.push(i);\n        } else {\n            result.push(*i\
    \ as isize);\n        }\n    }\n    result.sort_by_key(|x| x.to_dec());\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5usov5c6.rs:14:25\n   |\n\
    14 |             result.push(*i as isize);\n   |                         ^^^^^^^^^^^\n\
    \   |                         |\n   |                         expected `&isize`,\
    \ found `isize`\n   |                         help: consider borrowing here: `&(*i\
    \ as isize)`\n\nerror[E0599]: no method named `to_dec` found for reference `&&isize`\
    \ in the current scope\n  --> /tmp/tmp5usov5c6.rs:17:30\n   |\n17 |     result.sort_by_key(|x|\
    \ x.to_dec());\n   |                              ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5usov5c6.rs:18:5\n   |\n8  | fn sort_array(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                                   ---------- expected `Vec<isize>` because\
    \ of return type\n...\n18 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < arr.len() {\n        if arr[i] == 1 {\n            result.push(j);\n   \
    \         i += 1;\n            j += 1;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    result.push(j);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp0ob8ehxz.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a > b {\n            1\n        } else {\n\
    \            -1\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph2em3o1r.rs:11:13\n   |\n\
    11 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph2em3o1r.rs:13:13\n\
    \   |\n13 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() == 0 {\n        result.sort();\n\
    \    } else {\n        let mut ones_len = ones.len();\n        let mut i = 0;\n\
    \        let mut j = 0;\n        let mut k = result.len();\n        while i <\
    \ k {\n            if ones_len > j {\n                let tmp = result[j];\n \
    \               result[j] = result[i];\n                result[i] = tmp;\n   \
    \             i += 1;\n                j += 1;\n            } else {\n       \
    \         i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpr8jg67w_.rs:42:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n    sorted_arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp3qp5ai3l.rs:16:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        result.extend(ones);\n    } else {\n        result.extend(result);\n\
    \    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3,\
    \ 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5,\
    \ -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0505]: cannot move out of `result` because it is borrowed\n  -->\
    \ /tmp/tmpqxcv6orp.rs:21:23\n   |\n21 |         result.extend(result);\n   | \
    \        --------------^^^^^^-\n   |         |             |\n   |         | \
    \            move out of `result` occurs here\n   |         borrow of `result`\
    \ occurs here\n\nerror[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpqxcv6orp.rs:23:5\n\
    \   |\n9  |     let mut result = vec![];\n   |         ---------- move occurs\
    \ because `result` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n...\n21 |         result.extend(result);\n   |                      \
    \ ------ value moved here\n22 |     }\n23 |     result.sort();\n   |     ^^^^^^^^^^^^^\
    \ value borrowed here after move\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0382, E0505.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    let mut i = 0;\n    while i < result.len()\
    \ {\n        let mut j = i;\n        while j < result.len() {\n            if\
    \ ones[j] < ones[j + 1] {\n                let tmp = result[j];\n            \
    \    result[j] = result[j + 1];\n                result[j + 1] = tmp;\n      \
    \      }\n            j += 1\n        }\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmphrlzmkyd.rs:36:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        match a {\n            0 => b.cmp(&b),\n  \
    \          a => b.cmp(&a),\n            _ => a.cmp(&b),\n        }\n    })\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoj4jq36g.rs:9:5\n   |\n8\
    \  |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    9  | /     arr.sort_by(|a, b| {\n10 | |         match a {\n11 | |            \
    \ 0 => b.cmp(&b),\n12 | |             a => b.cmp(&a),\n13 | |             _ =>\
    \ a.cmp(&b),\n14 | |         }\n15 | |     })\n   | |______^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by_key(|x| {\n   \
    \     let mut bits = 0;\n        for &b in x.iter() {\n            bits <<= 1;\n\
    \            if b == 1 {\n                bits += 1;\n            }\n        }\n\
    \        bits\n    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3,\
    \ 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5,\
    \ -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmp1mu9_vhw.rs:12:21\n   |\n12 |         for &b in\
    \ x.iter() {\n   |                     ^^^^ method not found in `&isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 != 0 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(ones.pop().unwrap());\n        }\n    }\n    result.push(ones.pop().unwrap());\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, 1]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpbdr33eoh.rs:24:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for i in arr.iter() {\n        let mut count\
    \ = 0;\n        for j in 0..i {\n            if arr[j] == 1 {\n              \
    \  count += 1;\n            }\n        }\n        result.push((count as isize).cmp(&i));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzaojp6pe.rs:12:21\n   |\n\
    12 |         for j in 0..i {\n   |                     ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |        \
    \ for j in 0..*i {\n   |                     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzaojp6pe.rs:19:5\n   |\n8  | fn sort_array(arr: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                   ---------- expected `Vec<isize>`\
    \ because of return type\n...\n19 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `std::cmp::Ordering`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<std::cmp::Ordering>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a > b {\n            1\n        } else {\n\
    \            -1\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_q1mg9qc.rs:11:13\n   |\n\
    11 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_q1mg9qc.rs:13:13\n\
    \   |\n13 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for i in arr.iter() {\n        let mut count\
    \ = 0;\n        for j in 0..i {\n            if i & (1 << j) != 0 {\n        \
    \        count += 1;\n            }\n        }\n        if count > result.len()\
    \ {\n            result.push(i);\n        }\n    }\n    result.sort_unstable_by_key(|x|\
    \ x.to_dec());\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpai6jwxfx.rs:12:21\n   |\n\
    12 |         for j in 0..i {\n   |                     ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |        \
    \ for j in 0..*i {\n   |                     +\n\nerror[E0599]: no method named\
    \ `to_dec` found for reference `&&isize` in the current scope\n  --> /tmp/tmpai6jwxfx.rs:21:39\n\
    \   |\n21 |     result.sort_unstable_by_key(|x| x.to_dec());\n   |           \
    \                            ^^^^^^ help: there is an associated function with\
    \ a similar name: `to_be`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpai6jwxfx.rs:22:5\n\
    \   |\n8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |             \
    \                      ---------- expected `Vec<isize>` because of return type\n\
    ...\n22 |     result\n   |     ^^^^^^ expected `isize`, found `&isize`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a == 0 {\n            b.cmp(a)\n       \
    \ } else {\n            a.cmp(b)\n        }\n    })\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpzbz67oh1.rs:10:14\n\
    \   |\n10 |         if a == 0 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzbz67oh1.rs:9:5\n\
    \   |\n8  |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n9  | /     arr.sort_by(|a, b| {\n10 | |         if a == 0 {\n11 | |  \
    \           b.cmp(a)\n12 | |         } else {\n13 | |             a.cmp(b)\n14\
    \ | |         }\n15 | |     })\n   | |______^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut ones = 0;\n    let mut decimal = 0;\n\
    \    for ele in arr {\n        if ele == 1 {\n            ones += 1;\n       \
    \ } else {\n            decimal += ele as isize;\n        }\n    }\n    if ones\
    \ > 0 {\n        res.sort_unstable_by(|a, b| {\n            ones - a.cmp(b) as\
    \ isize\n        });\n    } else {\n        res.sort_unstable_by(|a, b| {\n  \
    \          decimal - a.cmp(b) as isize\n        });\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmpal7w1z3o.rs:20:31\n\
    \   |\n20 |         res.sort_unstable_by(|a, b| {\n   |                      \
    \         ^ consider giving this closure parameter the explicit type `&T`, where\
    \ the type parameter `T` is specified\n   |\n   = note: type must be known at\
    \ this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpal7w1z3o.rs:21:13\n\
    \   |\n21 |             ones - a.cmp(b) as isize\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found integer\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0282, E0308.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a > b {\n            1\n        } else {\n\
    \            -1\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0b46g4_w.rs:11:13\n   |\n\
    11 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0b46g4_w.rs:13:13\n\
    \   |\n13 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        a.iter().zip(b.iter()).fold(0, |acc, (a, b)|\
    \ {\n            acc + a.checked_mul(2).checked_add(b.checked_mul(2).unwrap()).unwrap()\n\
    \        })\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmpr4tv3cvp.rs:10:11\n   |\n10 |         a.iter().zip(b.iter()).fold(0,\
    \ |acc, (a, b)| {\n   |           ^^^^ method not found in `&isize`\n\nerror[E0599]:\
    \ no method named `iter` found for reference `&isize` in the current scope\n \
    \ --> /tmp/tmpr4tv3cvp.rs:10:24\n   |\n10 |         a.iter().zip(b.iter()).fold(0,\
    \ |acc, (a, b)| {\n   |                        ^^^^ method not found in `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpr4tv3cvp.rs:9:5\n   |\n8  |  \
    \ fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                       \
    \              ---------- expected `Vec<isize>` because of return type\n9  | /\
    \     arr.sort_by(|a, b| {\n10 | |         a.iter().zip(b.iter()).fold(0, |acc,\
    \ (a, b)| {\n11 | |             acc + a.checked_mul(2).checked_add(b.checked_mul(2).unwrap()).unwrap()\n\
    12 | |         })\n13 | |     })\n   | |______^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 != 0 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        result.extend(ones);\n    } else {\n        result.extend(result.iter().cloned());\n\
    \    }\n    result.sort_by(|a, b| a.cmp(b));\n    result\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `result` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpkr14o66o.rs:21:9\n   |\n21 |         result.extend(result.iter().cloned());\n\
    \   |         ^^^^^^^------^-------------^^^^^^^^^^\n   |         |      |   \
    \   |\n   |         |      |      immutable borrow occurs here\n   |         |\
    \      immutable borrow later used by call\n   |         mutable borrow occurs\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for i in arr.iter() {\n        let mut count\
    \ = 0;\n        for j in 0..i {\n            if i & (1 << j) != 0 {\n        \
    \        count += 1;\n            }\n        }\n        if count > result.len()\
    \ {\n            result.push(count);\n        }\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] as isize;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] / 2;\n    }\n    for i in 0..result.len() {\n\
    \        result[i] = result[i] % 10;\n    }\n    for i in 0..result.len() {\n\
    \        result[i] = result[i] * 2;\n    }\n    for i in 0..result.len() {\n \
    \       result[i] = result[i] as isize;\n    }\n    for i in 0..result.len() {\n\
    \        result[i] = result[i] / 10;\n    }\n    for i in 0..result.len() {\n\
    \        result[i] = result[i] % 10;\n    }\n    for i in 0..result.len() {\n\
    \        result[i] = result[i] * 100;\n    }\n    for i in 0..result.len() {\n\
    \        result[i] = result[i] as isize;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] / 100;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] % 10;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] * 1000;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] as isize;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] / 1000;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] % 10;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] * 1000000;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] as isize;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] / 1000000;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] % 10;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] * 10000000;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] as isize;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] / 10000000;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] % 10;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] * 1000000000;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] as isize;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] / 1000000000;\n    }\n    for i in 0..result.len()\
    \ {\n        result[i] = result[i] % 10;\n    }\n    for i in 0..result.len()\
    \ {\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpcynigvdp.rs:115:3\n\
    \    |\n8   | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    |          \
    \                                    - unclosed delimiter\n...\n102 |     for\
    \ i in 0..result.len() {\n    |                              - this delimiter\
    \ might not be properly closed...\n103 | }\n    | - ...as it matches this but\
    \ it has different indentation\n...\n115 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcynigvdp.rs:12:21\n   |\n12 |         for j in 0..i {\n\
    \   |                     ^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n12 |         for j in 0..*i {\n   |        \
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcynigvdp.rs:22:21\n\
    \   |\n22 |         result[i] = result[i] as isize;\n   |         ---------  \
    \ ^^^^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n   |         |\n   |   \
    \      expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcynigvdp.rs:34:21\n   |\n34 |         result[i] = result[i] as\
    \ isize;\n   |         ---------   ^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `isize`\n   |         |\n   |         expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcynigvdp.rs:46:21\n   |\n46 |\
    \         result[i] = result[i] as isize;\n   |         ---------   ^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |         |\n   |         expected due to\
    \ the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcynigvdp.rs:58:21\n\
    \   |\n58 |         result[i] = result[i] as isize;\n   |         ---------  \
    \ ^^^^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n   |         |\n   |   \
    \      expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcynigvdp.rs:70:21\n   |\n70 |         result[i] = result[i] as\
    \ isize;\n   |         ---------   ^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `isize`\n   |         |\n   |         expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcynigvdp.rs:"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    let mut i = 0;\n    while i < ones.size()\
    \ {\n        let mut j = i;\n        while j < ones.size() && ones[j] & 1 == 1\
    \ {\n            j += 1\n        }\n        result.push(ones[j]);\n        i =\
    \ j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmp06gr_yzw.rs:19:20\n   |\n19 |     while i < ones.size()\
    \ {\n   |                    ^^^^ help: there is an associated function with a\
    \ similar name: `resize`\n\nerror[E0599]: no method named `size` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp06gr_yzw.rs:21:24\n   |\n21\
    \ |         while j < ones.size() && ones[j] & 1 == 1 {\n   |                \
    \        ^^^^ help: there is an associated function with a similar name: `resize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        match a {\n            0 => 1,\n          \
    \  1 => 1,\n            2 => 2,\n            3 => 3,\n            4 => 4,\n  \
    \          _ => a - b,\n        }\n    });\n    arr\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpisw_r8w1.rs:11:18\n   |\n\
    11 |             0 => 1,\n   |                  ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by_key(|x| {\n   \
    \     match x {\n            0 => 0,\n            1 => 1,\n            2 => 2,\n\
    \            _ => 3,\n        }\n    });\n    sorted_arr\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 5, 3, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpmxjq5l6g.rs:23:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by_key(|x| {\n   \
    \     let mut counter = 0;\n        for &i in &mut sorted_arr {\n            if\
    \ i & 1 != 0 {\n                counter += 1;\n            }\n        }\n    \
    \    counter\n    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoyqrzs_r.rs:12:13\n   |\n\
    12 |         for &i in &mut sorted_arr {\n   |             ^^    ---------------\
    \ this expression has type `Option<&mut isize>`\n   |             |\n   |    \
    \         types differ in mutability\n   |             help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note: expected mutable reference\
    \ `&mut isize`\n                      found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        match a {\n            0 => 1,\n          \
    \  1 => 2,\n            2 => 3,\n            3 => 4,\n            4 => 5,\n  \
    \          _ => a - b,\n        }\n    });\n    arr\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg6q814tb.rs:11:18\n   |\n\
    11 |             0 => 1,\n   |                  ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut ones = vec![];\n    for i in arr.iter()\
    \ {\n        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n  \
    \          res.push(i);\n        }\n    }\n    for i in ones.iter() {\n      \
    \  res.push(i);\n    }\n    res.sort_unstable_by_key(|x| x.to_dec());\n    res\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_dec` found for reference `&&isize` in\
    \ the current scope\n  --> /tmp/tmpi6h_8j2j.rs:21:36\n   |\n21 |     res.sort_unstable_by_key(|x|\
    \ x.to_dec());\n   |                                    ^^^^^^ help: there is\
    \ an associated function with a similar name: `to_be`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi6h_8j2j.rs:22:5\n   |\n8  | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                   ---------- expected\
    \ `Vec<isize>` because of return type\n...\n22 |     res\n   |     ^^^ expected\
    \ `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n   \
    \           found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    let mut zeros =\
    \ vec![];\n    let mut max_ones = 0;\n    let mut max_zeros = 0;\n    for x in\
    \ arr {\n        if x != 0 {\n            ones.push(x);\n            max_ones\
    \ = std::cmp::max(max_ones, x);\n        } else {\n            zeros.push(x);\n\
    \            max_zeros = std::cmp::max(max_zeros, x);\n        }\n    }\n    let\
    \ mut i = 0;\n    while i < ones.size() {\n        let mut j = i;\n        while\
    \ j < ones.size() && ones[j] == 1 {\n            j += 1\n        }\n        let\
    \ mut k = i;\n        while k < ones.size() && ones[k] == 0 {\n            k +=\
    \ 1\n        }\n        let mut tmp = ones[k];\n        ones[k] = ones[j];\n \
    \       ones[j] = tmp;\n        tmp = zeros[k];\n        zeros[k] = zeros[j];\n\
    \        zeros[j] = tmp;\n        result.push(ones[i]);\n        result.push(zeros[i]);\n\
    \        i += 1;\n    }\n    if max_ones > max_zeros {\n        result.sort_unstable();\n\
    \    } else {\n        result.sort_unstable_by_key(|x| x.to_dec());\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpchx30x68.rs:24:20\n   |\n24 |     while i < ones.size()\
    \ {\n   |                    ^^^^ help: there is an associated function with a\
    \ similar name: `resize`\n\nerror[E0599]: no method named `size` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpchx30x68.rs:26:24\n   |\n26\
    \ |         while j < ones.size() && ones[j] == 1 {\n   |                    \
    \    ^^^^ help: there is an associated function with a similar name: `resize`\n\
    \nerror[E0599]: no method named `size` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpchx30x68.rs:30:24\n   |\n30 |         while k < ones.size()\
    \ && ones[k] == 0 {\n   |                        ^^^^ help: there is an associated\
    \ function with a similar name: `resize`\n\nerror[E0599]: no method named `to_dec`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmpchx30x68.rs:46:43\n\
    \   |\n46 |         result.sort_unstable_by_key(|x| x.to_dec());\n   |       \
    \                                    ^^^^^^ help: there is an associated function\
    \ with a similar name: `to_be`\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut bin = String::new();\n        bin.push_str(&format!(\"\
    {:b}\", x));\n        bin.chars().filter(|c| c == '1').count()\n    });\n    arr.sort_by_key(|x|\
    \ x.to_dec());\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpojzifrp5.rs:12:34\n\
    \   |\n12 |         bin.chars().filter(|c| c == '1').count()\n   |           \
    \                       ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0599]: no method named `to_dec`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmpojzifrp5.rs:14:27\n\
    \   |\n14 |     arr.sort_by_key(|x| x.to_dec());\n   |                       \
    \    ^^^^^^ help: there is an associated function with a similar name: `to_be`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut bin = x.to_bin();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmphr3yzbqf.rs:106:3\n\
    \    |\n8   | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    |          \
    \                                    - unclosed delimiter\n9   |     arr.sort_by_key(|x|\
    \ {\n    |                    - unclosed delimiter\n...\n106 | }\n    |   ^\n\n\
    error: expected one of `)`, `,`, `.`, `?`, or an operator, found keyword `fn`\n\
    \  --> /tmp/tmphr3yzbqf.rs:96:1\n   |\n94 | }\n   |  - expected one of `)`, `,`,\
    \ `.`, `?`, or an operator\n95 | \n96 | fn main() {\n   | ^^ unexpected token\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for x in arr {\n\
    \        if x == 0 {\n            ones.push(x);\n        } else {\n          \
    \  let mut i = 0;\n            while i < ones.size() && ones[i] == x {\n     \
    \           i += 1;\n            }\n            result.push(ones[i as usize]);\n\
    \            ones.push(x);\n        }\n    }\n    result.push(ones[ones.len()\
    \ - 1]);\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpkr7bc4q_.rs:16:28\n   |\n16 |             while\
    \ i < ones.size() && ones[i] == x {\n   |                            ^^^^ help:\
    \ there is an associated function with a similar name: `resize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for &i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() == 0 {\n        result.sort_unstable();\n\
    \    } else {\n        result.sort_by_key(|&i| ones[i as usize]);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxqe1wkly.rs:11:9\n   |\n\
    11 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = 0;\n    let mut decimal = 0;\n\
    \    for &i in arr {\n        if i & 1 == 1 {\n            ones += 1;\n      \
    \  } else {\n            decimal += i;\n        }\n    }\n    if ones < arr.len()\
    \ {\n        result.push(decimal);\n        result.push(ones);\n    } else {\n\
    \        result.push(decimal);\n        result.push(arr.len());\n    }\n    result.sort_unstable();\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9_3drgqe.rs:12:9\n   |\n\
    12 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9_3drgqe.rs:27:5\n   |\n8  | fn sort_array(arr: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                   ---------- expected `Vec<isize>`\
    \ because of return type\n...\n27 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for i in arr.iter() {\n        let mut count\
    \ = 0;\n        for j in 0..i {\n            if i & (1 << j) != 0 {\n        \
    \        count += 1;\n            }\n        }\n        result.push((count as\
    \ isize).cmp(&i));\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdo4dpsyp.rs:12:21\n   |\n\
    12 |         for j in 0..i {\n   |                     ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |        \
    \ for j in 0..*i {\n   |                     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdo4dpsyp.rs:19:5\n   |\n8  | fn sort_array(arr: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                   ---------- expected `Vec<isize>`\
    \ because of return type\n...\n19 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `std::cmp::Ordering`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<std::cmp::Ordering>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut ones = 0;\n    let mut decimal\
    \ = 0;\n    for x in arr {\n        if x == 1 {\n            ones += 1;\n    \
    \    } else {\n            decimal += x;\n        }\n    }\n    if ones > 0 {\n\
    \        result.sort_by_key(|x| {\n            ones - x.leading_zeros()\n    \
    \    });\n    }\n    if decimal > 0 {\n        result.sort_by_key(|x| {\n    \
    \        decimal - x.leading_zeros()\n        });\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmps3_glacx.rs:20:29\n\
    \   |\n20 |         result.sort_by_key(|x| {\n   |                           \
    \  ^ consider giving this closure parameter the explicit type `&T`, where the\
    \ type parameter `T` is specified\n   |\n   = note: type must be known at this\
    \ point\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut ones = x;\n        while ones > 0\
    \ {\n            ones >>= 1;\n        }\n        ones\n    });\n    arr\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpya9mvbzv.rs:11:22\n   |\n\
    11 |         while ones > 0 {\n   |                      ^\n   |             \
    \         |\n   |                      expected `&isize`, found integer\n   |\
    \                      help: consider borrowing here: `&0`\n\nerror[E0368]: binary\
    \ assignment operation `>>=` cannot be applied to type `&isize`\n  --> /tmp/tmpya9mvbzv.rs:12:13\n\
    \   |\n12 |             ones >>= 1;\n   |             ----^^^^^^\n   |       \
    \      |\n   |             cannot use `>>=` on type `&isize`\n   |\nhelp: `>>=`\
    \ can be used on `isize`, you can dereference `ones`\n   |\n12 |             *ones\
    \ >>= 1;\n   |             +\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 != 0 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        result.extend(ones);\n    } else {\n        result.extend(result.into_iter().rev().take(ones.len()).collect());\n\
    \    }\n    result.sort_unstable();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpkppvfgin.rs:21:16\n\
    \   |\n21 |         result.extend(result.into_iter().rev().take(ones.len()).collect());\n\
    \   |                ^^^^^^ cannot infer type for type parameter `A` declared\
    \ on the trait `Extend`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by_key(|x| {\n   \
    \     let mut count = 0;\n        for &i in &mut sorted_arr {\n            if\
    \ i == 1 {\n                count += 1;\n            }\n        }\n        count\n\
    \    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplvpklbjt.rs:12:13\n   |\n\
    12 |         for &i in &mut sorted_arr {\n   |             ^^    ---------------\
    \ this expression has type `Option<&mut isize>`\n   |             |\n   |    \
    \         types differ in mutability\n   |             help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note: expected mutable reference\
    \ `&mut isize`\n                      found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(ones[ones.len() - 1]);\n            ones.pop();\n        }\n\
    \    }\n    result.push(ones[ones.len() - 1]);\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, 1]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmphftofyfw.rs:25:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        a.checked_mul(2).is_zero() || b.checked_mul(2).is_zero()\n\
    \            || a.checked_mul(2).is_zero() || b.checked_mul(2).is_zero()\n   \
    \         || (a.checked_mul(2).is_zero() && b.checked_mul(2).is_zero())\n    \
    \        || (a.checked_mul(2).is_zero() && !b.checked_mul(2).is_zero())\n    \
    \        || (!a.checked_mul(2).is_zero() && b.checked_mul(2).is_zero())\n    \
    \        || (!a.checked_mul(2).is_zero() && !b.checked_mul(2).is_zero())\n   \
    \ })\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmpoa9wx0d5.rs:10:26\n   |\n10 |         a.checked_mul(2).is_zero()\
    \ || b.checked_mul(2).is_zero()\n   |                          ^^^^^^^ method\
    \ not found in `Option<isize>`\n\nerror[E0599]: no method named `is_zero` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpoa9wx0d5.rs:10:56\n  \
    \ |\n10 |         a.checked_mul(2).is_zero() || b.checked_mul(2).is_zero()\n \
    \  |                                                        ^^^^^^^ method not\
    \ found in `Option<isize>`\n\nerror[E0599]: no method named `is_zero` found for\
    \ enum `Option` in the current scope\n  --> /tmp/tmpoa9wx0d5.rs:11:33\n   |\n\
    11 |             || a.checked_mul(2).is_zero() || b.checked_mul(2).is_zero()\n\
    \   |                                 ^^^^^^^ method not found in `Option<isize>`\n\
    \nerror[E0599]: no method named `is_zero` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpoa9wx0d5.rs:11:63\n   |\n11 |             || a.checked_mul(2).is_zero()\
    \ || b.checked_mul(2).is_zero()\n   |                                        \
    \                       ^^^^^^^ method not found in `Option<isize>`\n\nerror[E0599]:\
    \ no method named `is_zero` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpoa9wx0d5.rs:12:34\n   |\n12 |             || (a.checked_mul(2).is_zero()\
    \ && b.checked_mul(2).is_zero())\n   |                                  ^^^^^^^\
    \ method not found in `Option<isize>`\n\nerror[E0599]: no method named `is_zero`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpoa9wx0d5.rs:12:64\n\
    \   |\n12 |             || (a.checked_mul(2).is_zero() && b.checked_mul(2).is_zero())\n\
    \   |                                                                ^^^^^^^ method\
    \ not found in `Option<isize>`\n\nerror[E0599]: no method named `is_zero` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpoa9wx0d5.rs:13:34\n  \
    \ |\n13 |             || (a.checked_mul(2).is_zero() && !b.checked_mul(2).is_zero())\n\
    \   |                                  ^^^^^^^ method not found in `Option<isize>`\n\
    \nerror[E05"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr.iter()\
    \ {\n        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n  \
    \          result.push(ones[ones.len() - 1]);\n            ones.pop();\n     \
    \   }\n    }\n    result.push(ones[ones.len() - 1]);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpms7sffqr.rs:20:5\n   |\n\
    8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \               ---------- expected `Vec<isize>` because of return type\n...\n\
    20 |     result\n   |     ^^^^^^ expected `isize`, found `&isize`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        result.extend(ones);\n    } else {\n        result.extend(result);\n\
    \    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3,\
    \ 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5,\
    \ -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0505]: cannot move out of `result` because it is borrowed\n  -->\
    \ /tmp/tmpu4_w_2r7.rs:21:23\n   |\n21 |         result.extend(result);\n   | \
    \        --------------^^^^^^-\n   |         |             |\n   |         | \
    \            move out of `result` occurs here\n   |         borrow of `result`\
    \ occurs here\n\nerror[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpu4_w_2r7.rs:23:5\n\
    \   |\n9  |     let mut result = vec![];\n   |         ---------- move occurs\
    \ because `result` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n...\n21 |         result.extend(result);\n   |                      \
    \ ------ value moved here\n22 |     }\n23 |     result.sort();\n   |     ^^^^^^^^^^^^^\
    \ value borrowed here after move\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0382, E0505.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    for i in ones {\n        result.push(i);\n\
    \    }\n    result.sort_by_key(|x| x.to_dec());\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_dec` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmph_4zb4g4.rs:21:30\n   |\n21 |     result.sort_by_key(|x|\
    \ x.to_dec());\n   |                              ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        a.checked_mul(2).is_zero() || b.checked_mul(2).is_zero()\n\
    \            ? a.checked_add(b).unwrap()\n            : a.checked_mul(2).unwrap().cmp(&b.checked_mul(2).unwrap())\n\
    \    })\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `a`\n\
    \  --> /tmp/tmpe5srbrnv.rs:11:15\n   |\n11 |             ? a.checked_add(b).unwrap()\n\
    \   |               ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe5srbrnv.rs:9:5\n   |\n8  |   fn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                     ----------\
    \ expected `Vec<isize>` because of return type\n9  | /     arr.sort_by(|a, b|\
    \ {\n10 | |         a.checked_mul(2).is_zero() || b.checked_mul(2).is_zero()\n\
    11 | |             ? a.checked_add(b).unwrap()\n12 | |             : a.checked_mul(2).unwrap().cmp(&b.checked_mul(2).unwrap())\n\
    13 | |     })\n   | |______^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by_key(|x| {\n   \
    \     let mut count = 0;\n        for &i in &x {\n            if i == 1 {\n  \
    \              count += 1;\n            }\n        }\n        count as isize\n\
    \    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&&isize` is not an iterator\n  --> /tmp/tmpvmb9g6bp.rs:12:19\n\
    \   |\n12 |         for &i in &x {\n   |                   ^^ `&&isize` is not\
    \ an iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&&isize`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.to_vec();\n    sorted_arr.sort_by_key(|x| {\n  \
    \      let mut i = 0;\n        let mut j = 0;\n        while i < arr.len() &&\
    \ j < sorted_arr.len() {\n            if arr[i] == sorted_arr[j] {\n         \
    \       i += 1;\n                j += 1;\n            } else {\n             \
    \   let mut k = i;\n                while k > 0 && sorted_arr[k - 1] > sorted_arr[k]\
    \ {\n                    k -= 1;\n                }\n                sorted_arr[k]\
    \ = sorted_arr[j];\n                sorted_arr[j] = arr[i];\n                i\
    \ += 1;\n                j += 1;\n            }\n        }\n        j\n    });\n\
    \    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp7baj690r.rs:10:29\n   |\n\
    10 |     sorted_arr.sort_by_key(|x| {\n   |                             ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0499]: cannot borrow `sorted_arr`\
    \ as mutable more than once at a time\n  --> /tmp/tmp7baj690r.rs:10:28\n   |\n\
    10 |       sorted_arr.sort_by_key(|x| {\n   |       -          ----------- ^^^\
    \ second mutable borrow occurs here\n   |       |          |\n   |  _____|   \
    \       first borrow later used by call\n   | |\n11 | |         let mut i = 0;\n\
    12 | |         let mut j = 0;\n13 | |         while i < arr.len() && j < sorted_arr.len()\
    \ {\n...  |\n22 | |                 sorted_arr[k] = sorted_arr[j];\n   | |   \
    \              ---------- second borrow occurs due to use of `sorted_arr` in closure\n\
    ...  |\n28 | |         j\n29 | |     });\n   | |______- first mutable borrow occurs\
    \ here\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0499`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a > b {\n            1\n        } else {\n\
    \            -1\n        }\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpirw0stkl.rs:11:13\n   |\n\
    11 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpirw0stkl.rs:13:13\n\
    \   |\n13 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpirw0stkl.rs:9:5\n\
    \   |\n8  |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n9  | /     arr.sort_by(|a, b| {\n10 | |         if a > b {\n11 | |   \
    \          1\n12 | |         } else {\n13 | |             -1\n14 | |         }\n\
    15 | |     })\n   | |______^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counter = vec![0; arr.len()];\n    for x in arr {\n        counter[x]\
    \ += 1;\n    }\n    arr.sort_by_key(|x| counter[x]);\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpq051jr1u.rs:11:9\n   |\n11 |         counter[x] += 1;\n   |        \
    \ ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n  \
    \ = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n  --> /tmp/tmpq051jr1u.rs:13:25\n\
    \   |\n13 |     arr.sort_by_key(|x| counter[x]);\n   |                       \
    \  ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n \
    \  = help: the trait `SliceIndex<[{integer}]>` is not implemented for `&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        match b {\n            0 => a.cmp(b),\n   \
    \         1 => a.cmp(b).reverse(),\n            _ => a.cmp(b).reverse().unwrap(),\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmp4bfb_8p7.rs:13:37\n   |\n13 |          \
    \   _ => a.cmp(b).reverse().unwrap(),\n   |                                  \
    \   ^^^^^^ method not found in `std::cmp::Ordering`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4bfb_8p7.rs:9:5\n   |\n8  |   fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                     ---------- expected\
    \ `Vec<isize>` because of return type\n9  | /     arr.sort_by(|a, b| {\n10 | |\
    \         match b {\n11 | |             0 => a.cmp(b),\n12 | |             1 =>\
    \ a.cmp(b).reverse(),\n13 | |             _ => a.cmp(b).reverse().unwrap(),\n\
    14 | |         }\n15 | |     })\n   | |______^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut ones = Vec::new();\n    let mut\
    \ zeros = Vec::new();\n    let mut max_ones = 0;\n    let mut max_zeros = 0;\n\
    \    let mut max_value = 0;\n    for &i in arr {\n        if i & 1 == 1 {\n  \
    \          ones.push(i);\n            max_ones = i;\n        } else {\n      \
    \      zeros.push(i);\n            max_zeros = i;\n        }\n    }\n    for i\
    \ in ones {\n        if max_ones > max_zeros {\n            result.push(i);\n\
    \            max_ones = i;\n        } else {\n            result.push(max_zeros);\n\
    \            max_zeros = i;\n        }\n    }\n    for i in zeros {\n        if\
    \ max_zeros > max_ones {\n            result.push(i);\n            max_zeros =\
    \ i;\n        } else {\n            result.push(max_ones);\n            max_ones\
    \ = i;\n        }\n    }\n    for i in result {\n        if i > max_value {\n\
    \            max_value = i;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdf4xfhh1.rs:15:9\n   |\n\
    15 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut res = 0;\n        for b in x.to_binary()\
    \ {\n            res += *b as usize;\n        }\n        res\n    });\n    arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_binary` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpodc485lx.rs:11:20\n   |\n11 |         for\
    \ b in x.to_binary() {\n   |                    ^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a > b {\n            1\n        } else {\n\
    \            -1\n        }\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx23w65l3.rs:11:13\n   |\n\
    11 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx23w65l3.rs:13:13\n\
    \   |\n13 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx23w65l3.rs:9:5\n\
    \   |\n8  |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n9  | /     arr.sort_by(|a, b| {\n10 | |         if a > b {\n11 | |   \
    \          1\n12 | |         } else {\n13 | |             -1\n14 | |         }\n\
    15 | |     })\n   | |______^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut bin = String::new();\n        bin.push_str(&format!(\"\
    {:b}\", x));\n        bin.chars().filter(|c| c == '1').count()\n    });\n    arr.sort_by_key(|x|\
    \ {\n        let mut dec = x.to_dec();\n        dec.cmp(&dec.one())\n    });\n\
    \    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp63jf_4vr.rs:12:34\n\
    \   |\n12 |         bin.chars().filter(|c| c == '1').count()\n   |           \
    \                       ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0599]: no method named `to_dec`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmp63jf_4vr.rs:15:25\n\
    \   |\n15 |         let mut dec = x.to_dec();\n   |                         ^^^^^^\
    \ help: there is an associated function with a similar name: `to_be`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        result.extend(ones);\n    } else {\n        result.extend(result.into_iter().rev());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0505]: cannot move out of `result` because it is borrowed\n  -->\
    \ /tmp/tmpvpi8feaj.rs:21:23\n   |\n21 |         result.extend(result.into_iter().rev());\n\
    \   |         --------------^^^^^^-------------------\n   |         |        \
    \     |\n   |         |             move out of `result` occurs here\n   |   \
    \      borrow of `result` occurs here\n\nerror[E0382]: use of moved value: `result`\n\
    \   --> /tmp/tmpvpi8feaj.rs:23:5\n    |\n9   |     let mut result = vec![];\n\
    \    |         ---------- move occurs because `result` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n...\n21  |         result.extend(result.into_iter().rev());\n\
    \    |                              ----------- `result` moved due to this method\
    \ call\n22  |     }\n23  |     result\n    |     ^^^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `result`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0382, E0505.\nFor more information about an error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut ones = Vec::new();\n    let mut\
    \ zeros = Vec::new();\n    for x in arr {\n        if x == 1 {\n            ones.push(x);\n\
    \        } else {\n            zeros.push(x);\n        }\n    }\n    let mut i\
    \ = 0;\n    while i < zeros.len() {\n        result.push(zeros.remove(i));\n \
    \       i += 1;\n    }\n    while i < ones.len() {\n        result.push(ones.remove(i));\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp3ldk_wu_.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        let mut j = i;\n        while j < arr.len() && arr[j] == 1 {\n      \
    \      j += 1\n        }\n        result.push(*arr.subslice(i, j));\n        i\
    \ = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `subslice` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpy4hf1gwr.rs:16:26\n   |\n16 |         result.push(*arr.subslice(i,\
    \ j));\n   |                          ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `splice`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n  \
    \  let mut k = arr.len() - 1;\n    while i < k {\n        while j >= i && arr[j]\
    \ == 1 {\n            j -= 1;\n        }\n        result.push(arr[i]);\n     \
    \   if j >= i {\n            result.push(arr[j]);\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmprwf1ggde.rs:15:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for x in arr {\n\
    \        if x == 1 {\n            ones.push(x);\n        } else {\n          \
    \  result.push(x);\n        }\n    }\n    let mut i = 0;\n    while i < ones.size()\
    \ {\n        let mut j = 0;\n        while j < result.len() {\n            if\
    \ ones[i] == result[j] {\n                result.swap(j, j + 1);\n           \
    \     i += 1;\n                break;\n            }\n            j += 1\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmp0m39_492.rs:19:20\n   |\n19 |     while i < ones.size()\
    \ {\n   |                    ^^^^ help: there is an associated function with a\
    \ similar name: `resize`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() == 0 {\n        result.sort();\n\
    \    } else {\n        let mut i = 0;\n        let mut j = 0;\n        let mut\
    \ k = result.len();\n        while i < k {\n            if ones[j] < ones[i] {\n\
    \                result.swap(i, j);\n                i += 1;\n            } else\
    \ {\n                j += 1;\n            }\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmp45iqb19r.rs:25:16\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a < b {\n            1\n        } else {\n\
    \            -1\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8bm8jwma.rs:11:13\n   |\n\
    11 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8bm8jwma.rs:13:13\n\
    \   |\n13 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        result.extend(ones);\n    } else {\n        result.extend(result.into_iter().rev().take(ones.len()).cloned());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::iter::Take<Rev<std::vec::IntoIter<isize>>>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmp5feza1we.rs:21:65\n     |\n21   |\
    \         result.extend(result.into_iter().rev().take(ones.len()).cloned());\n\
    \     |                                                                 ^^^^^^\
    \ expected reference, found `isize`\n     |\n     = note: expected reference `&_`\n\
    \                     found type `isize`\nnote: required by a bound in `cloned`\n\
    \nerror[E0271]: type mismatch resolving `<std::iter::Take<Rev<std::vec::IntoIter<isize>>>\
    \ as Iterator>::Item == &_`\n   --> /tmp/tmp5feza1we.rs:21:23\n    |\n21  |  \
    \       result.extend(result.into_iter().rev().take(ones.len()).cloned());\n \
    \   |                ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected reference, found `isize`\n    |                |\n    |           \
    \     required by a bound introduced by this call\n    |\n    = note: expected\
    \ reference `&_`\n                    found type `isize`\n    = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<std::iter::Take<Rev<std::vec::IntoIter<isize>>>>`\n\
    note: required by a bound in `extend`\n\nerror[E0271]: type mismatch resolving\
    \ `<std::iter::Take<Rev<std::vec::IntoIter<isize>>> as Iterator>::Item == &_`\n\
    \   --> /tmp/tmp5feza1we.rs:21:23\n    |\n21  |         result.extend(result.into_iter().rev().take(ones.len()).cloned());\n\
    \    |                ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected reference, found `isize`\n    |                |\n    |           \
    \     required by a bound introduced by this call\n    |\n    = note: expected\
    \ reference `&_`\n                    found type `isize`\n    = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<std::iter::Take<Rev<std::vec::IntoIter<isize>>>>`\n\
    \    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Cloned<std::iter::Take<Rev<std::vec::IntoIter<isize>>>>`\nnote: required\
    \ by a bound in `extend`\n\nerror: aborting due to 3 previous errors\n\nFor more "
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a > b {\n            1\n        } else {\n\
    \            -1\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcf061v41.rs:11:13\n   |\n\
    11 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcf061v41.rs:13:13\n\
    \   |\n13 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        for i in ones {\n            result.push(i);\n        }\n    }\n    if\
    \ result.len() > 0 {\n        result.sort();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpvfl7nlfx.rs:31:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut ones = vec![];\n    for i in arr {\n \
    \       if i & 1 == 1 {\n            ones.push(i);\n        } else {\n       \
    \     res.push(i);\n        }\n    }\n    ones = sort_array(ones);\n    res =\
    \ sort_array(res);\n    for i in 0..ones.len() {\n        res.push(ones[i]);\n\
    \    }\n    for i in 0..res.len() {\n        res.push(res.last() + 1);\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `{integer}` to `Option<&isize>`\n  --> /tmp/tmptlo3ek3j.rs:24:29\n\
    \   |\n24 |         res.push(res.last() + 1);\n   |                  ----------\
    \ ^ - {integer}\n   |                  |\n   |                  Option<&isize>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < arr.len() {\n        if arr[i] > 0 {\n            result.push(arr[j]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n     \
    \   if i == arr.len() {\n            break;\n        }\n        if arr[i] > 0\
    \ {\n            i += 1;\n        } else {\n            i += 1;\n        }\n \
    \       if i == arr.len() {\n            break;\n        }\n        if arr[i]\
    \ > 0 {\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            break;\n        }\n        if arr[i]\
    \ > 0 {\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            break;\n        }\n        if arr[i]\
    \ > 0 {\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            break;\n        }\n        if arr[i]\
    \ > 0 {\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            break;\n        }\n        if arr[i]\
    \ > 0 {\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            break;\n        }\n        if arr[i]\
    \ > 0 {\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            break;\n        }\n        if arr[i]\
    \ > 0 {\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            break;\n        }\n        if arr[i]\
    \ > 0 {\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            break;\n        }\n        if arr[i]\
    \ > 0 {\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            break;\n        }\n        if arr[i]\
    \ > 0 {\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            break;\n        }\n        if arr[i]\
    \ > 0 {\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            break;\n        }\n        if arr[i]\
    \ > 0 {\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            break;\n        }\n        if arr[i]\
    \ > 0 {\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            break;\n        }\n        if arr[i]\
    \ > 0 {\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            break;\n        }\n        if arr[i]\
    \ > 0 {\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            break;\n        }\n        if arr[i]\
    \ > 0 {\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpmgryf9y9.rs:163:3\n\
    \    |\n8   | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    |          \
    \                                    - unclosed delimiter\n...\n12  |     while\
    \ i < arr.len() {\n    |                         - unclosed delimiter\n...\n150\
    \ |         if arr[i] > 0 {\n    |                       - this delimiter might\
    \ not be properly closed...\n151 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n163 | }\n    |   ^\n\nerror[E0308]: mismatched types\n\
    \   --> /tmp/tmpmgryf9y9.rs:12:5\n    |\n8   |   fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    |                                     ---------- expected\
    \ `Vec<isize>` because of return type\n...\n12  | /     while i < arr.len() {\n\
    13  | |         if arr[i] > 0 {\n14  | |             result.push(arr[j]);\n15\
    \  | |             i += 1;\n...   |\n162 | |     assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n163 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = arr.clone();\n    let mut cnt = 0;\n    for i in res.iter()\
    \ {\n        if *i & 1 == 1 {\n            cnt += 1;\n        }\n    }\n    if\
    \ cnt == res.len() {\n        res\n    } else {\n        res.sort();\n       \
    \ res\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpv4skwoyv.rs:26:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut xs = x.to_string().chars().collect::<Vec<_>>();\n\
    \        xs.reverse();\n        xs.iter().filter(|c| c == '1').count()\n    })\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&&char` with `char`\n  --> /tmp/tmp_ppb9dua.rs:12:32\n\
    \   |\n12 |         xs.iter().filter(|c| c == '1').count()\n   |             \
    \                   ^^ no implementation for `&&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&&char`\n   = help: the\
    \ trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_ppb9dua.rs:9:5\n   |\n8  |   fn sort_array(arr: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                     ---------- expected `Vec<isize>`\
    \ because of return type\n9  | /     arr.sort_by_key(|x| {\n10 | |         let\
    \ mut xs = x.to_string().chars().collect::<Vec<_>>();\n11 | |         xs.reverse();\n\
    12 | |         xs.iter().filter(|c| c == '1').count()\n13 | |     })\n   | |______^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        let mut j = i;\n        while j < arr.len() && arr[j] == 1 {\n      \
    \      j += 1\n        }\n        result.push(arr[i]);\n        result.push(arr[j]);\n\
    \        i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        let mut j = i;\n        while j < arr.len() && arr[j] == 1 {\n      \
    \      j += 1\n        }\n        result.push(arr[i]);\n        result.push(arr[j]);\n\
    \        i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut ones = vec![];\n    for ele in arr {\n\
    \        if ele == 1 {\n            ones.push(ele);\n        } else {\n      \
    \      res.push(ele);\n        }\n    }\n    ones = sort_array(ones);\n    let\
    \ mut i = 0;\n    for ele in ones {\n        res.push(ele);\n        i += 1;\n\
    \        while i < ones.size() {\n            if ones[i] == 0 {\n            \
    \    i += 1;\n            } else {\n                break;\n            }\n  \
    \      }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmppf26rltu.rs:23:24\n   |\n23 |         while i <\
    \ ones.size() {\n   |                        ^^^^ help: there is an associated\
    \ function with a similar name: `resize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 != 0 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(ones.pop().unwrap());\n        }\n    }\n    result.push(ones.pop().unwrap());\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, 1]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpv23bc6xm.rs:24:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by(|a, b| {\n    \
    \    if a > b {\n            1\n        } else {\n            -1\n        }\n\
    \    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjrlmoe8i.rs:12:13\n   |\n\
    12 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjrlmoe8i.rs:14:13\n\
    \   |\n14 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for i in arr.iter() {\n        let mut count\
    \ = 0;\n        for j in i {\n            if j == 1 {\n                count +=\
    \ 1;\n            }\n        }\n        if count > result.len() {\n          \
    \  result.push(i);\n        }\n    }\n    result.sort_by_key(|x| x.to_dec());\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&isize` is not an iterator\n  --> /tmp/tmptijky67j.rs:12:18\n\
    \   |\n12 |         for j in i {\n   |                  ^ `&isize` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&isize`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&isize`\n\
    \nerror[E0599]: no method named `to_dec` found for reference `&&isize` in the\
    \ current scope\n  --> /tmp/tmptijky67j.rs:21:30\n   |\n21 |     result.sort_by_key(|x|\
    \ x.to_dec());\n   |                              ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmptijky67j.rs:22:5\n   |\n8  | fn sort_array(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                                   ---------- expected `Vec<isize>` because\
    \ of return type\n...\n22 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 != 0 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    result.sort_by(|a, b| {\n      \
    \  if a > b {\n            ones[a]\n        } else {\n            ones[b]\n  \
    \      }\n    });\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpli_elkb5.rs:20:13\n\
    \   |\n20 |             ones[a]\n   |             ^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `&isize`\n  --> /tmp/tmpli_elkb5.rs:22:13\n   |\n22 |        \
    \     ones[b]\n   |             ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        result.extend(ones);\n    } else {\n        result.extend(result);\n\
    \    }\n    result.sort_by_key(|x| x.to_dec());\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_dec` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpnr2r2g37.rs:23:30\n   |\n23 |     result.sort_by_key(|x|\
    \ x.to_dec());\n   |                              ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for i in arr.iter() {\n        if i & 1 ==\
    \ 1 {\n            result.push(i);\n        }\n    }\n    result.sort();\n   \
    \ result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkp9_o6j0.rs:16:5\n   |\n\
    8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \               ---------- expected `Vec<isize>` because of return type\n...\n\
    16 |     result\n   |     ^^^^^^ expected `isize`, found `&isize`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for i in arr.iter() {\n        let mut count\
    \ = 0;\n        for j in 0..i.isize {\n            if arr[j] == 1 {\n        \
    \        count += 1;\n            }\n        }\n        result.push((count as\
    \ isize).cmp(&i));\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `isize` on type `&isize`\n  --> /tmp/tmp6ehwcgsl.rs:12:23\n\
    \   |\n12 |         for j in 0..i.isize {\n   |                       ^^^^^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp6ehwcgsl.rs:19:5\n   |\n8  | fn\
    \ sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                          \
    \         ---------- expected `Vec<isize>` because of return type\n...\n19 | \
    \    result\n   |     ^^^^^^ expected `isize`, found enum `std::cmp::Ordering`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<std::cmp::Ordering>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        result.extend(ones);\n    } else {\n        result.extend(result.into_iter().rev());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0505]: cannot move out of `result` because it is borrowed\n  -->\
    \ /tmp/tmpe3c6r8cq.rs:21:23\n   |\n21 |         result.extend(result.into_iter().rev());\n\
    \   |         --------------^^^^^^-------------------\n   |         |        \
    \     |\n   |         |             move out of `result` occurs here\n   |   \
    \      borrow of `result` occurs here\n\nerror[E0382]: use of moved value: `result`\n\
    \   --> /tmp/tmpe3c6r8cq.rs:23:5\n    |\n9   |     let mut result = vec![];\n\
    \    |         ---------- move occurs because `result` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n...\n21  |         result.extend(result.into_iter().rev());\n\
    \    |                              ----------- `result` moved due to this method\
    \ call\n22  |     }\n23  |     result\n    |     ^^^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `result`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0382, E0505.\nFor more information about an error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by_key(|x| {\n   \
    \     let mut res = 0;\n        for i in 0..32 {\n            if x & (1 << i)\
    \ != 0 {\n                res += 1;\n            }\n        }\n        res\n \
    \   });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 4, 5, 3]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp79gcljf5.rs:24:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counter = vec![0; arr.len()];\n    for &i in arr {\n        counter[i\
    \ as usize] += 1;\n    }\n    let mut res = vec![0; arr.len()];\n    for i in\
    \ 0..arr.len() {\n        let mut j = i;\n        while j > 0 && counter[j as\
    \ usize] == 0 {\n            j -= 1;\n        }\n        res.swap(i, j);\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5m4ex38o.rs:10:9\n   |\n\
    10 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut bin = x.to_bin();\n        let mut\
    \ count = 0;\n        while !bin.is_empty() {\n            count += 1;\n     \
    \       bin = bin.split_off(1);\n        }\n        count / 2\n    });\n    arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_bin` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmp9o58fd65.rs:10:25\n   |\n10 |         let mut\
    \ bin = x.to_bin();\n   |                         ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut ones = vec![];\n    for ele in arr {\n\
    \        if ele == 0 {\n            ones.push(ele);\n        } else {\n      \
    \      res.push(ele);\n        }\n    }\n    let mut i = 0;\n    while i < ones.len()\
    \ {\n        let mut j = i;\n        while j < ones.len() && ones[j] == ones[j\
    \ - 1] {\n            j += 1\n        }\n        if j == i {\n            break;\n\
    \        }\n        res.swap(i, j);\n        i = j;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 2, 3, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp5ptnmu54.rs:35:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut bin = x.to_bin();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n        bin.trim();\n        bin.trim();\n        bin.trim();\n\
    \        bin.trim();\n\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp1xd46oru.rs:106:3\n\
    \    |\n8   | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    |          \
    \                                    - unclosed delimiter\n9   |     arr.sort_by_key(|x|\
    \ {\n    |                    - unclosed delimiter\n...\n106 | }\n    |   ^\n\n\
    error: expected one of `)`, `,`, `.`, `?`, or an operator, found keyword `fn`\n\
    \  --> /tmp/tmp1xd46oru.rs:96:1\n   |\n94 | }\n   |  - expected one of `)`, `,`,\
    \ `.`, `?`, or an operator\n95 | \n96 | fn main() {\n   | ^^ unexpected token\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut ones = vec![];\n    for i in arr {\n\
    \        if i & 1 == 1 {\n            ones.push(i);\n        } else {\n      \
    \      result.push(i);\n        }\n    }\n    if ones.len() > result.len() {\n\
    \        for i in ones {\n            result.push(i);\n        }\n    }\n    if\
    \ result.len() > ones.len() {\n        for i in result {\n            ones.push(i);\n\
    \        }\n    }\n    if ones.len() == result.len() {\n        for i in ones\
    \ {\n            result.push(i);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `ones`\n   --> /tmp/tmpf1958_0_.rs:23:23\n\
    \    |\n10  |     let mut ones = vec![];\n    |         -------- move occurs because\
    \ `ones` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n\
    19  |         for i in ones {\n    |                  ---- `ones` moved due to\
    \ this implicit call to `.into_iter()`\n...\n23  |     if result.len() > ones.len()\
    \ {\n    |                       ^^^^^^^^^^ value borrowed here after move\n \
    \   |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `ones`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |         for i in &ones {\n\
    \    |                  +\n\nerror[E0382]: borrow of moved value: `result`\n \
    \ --> /tmp/tmpf1958_0_.rs:28:22\n   |\n9  |     let mut result = vec![];\n   |\
    \         ---------- move occurs because `result` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n24 |         for i in result {\n \
    \  |                  ------ `result` moved due to this implicit call to `.into_iter()`\n\
    ...\n28 |     if ones.len() == result.len() {\n   |                      ^^^^^^^^^^^^\
    \ value borrowed here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n24\
    \ |         for i in &result {\n   |                  +\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        let mut res = 0;\n        while x != 0 {\n\
    \            res += x % 10;\n            x /= 10;\n        }\n        res\n  \
    \  })\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpvlnb2ytj.rs:11:17\n\
    \   |\n11 |         while x != 0 {\n   |                 ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0368]: binary assignment operation\
    \ `/=` cannot be applied to type `&isize`\n  --> /tmp/tmpvlnb2ytj.rs:13:13\n \
    \  |\n13 |             x /= 10;\n   |             -^^^^^^\n   |             |\n\
    \   |             cannot use `/=` on type `&isize`\n   |\nhelp: `/=` can be used\
    \ on `isize`, you can dereference `x`\n   |\n13 |             *x /= 10;\n   |\
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvlnb2ytj.rs:9:5\n\
    \   |\n8  |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n9  | /     arr.sort_by_key(|x| {\n10 | |         let mut res = 0;\n11\
    \ | |         while x != 0 {\n12 | |             res += x % 10;\n...  |\n15 |\
    \ |         res\n16 | |     })\n   | |______^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
